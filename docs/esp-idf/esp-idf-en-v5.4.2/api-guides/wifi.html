<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wi-Fi Driver - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/wifi.html" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-guides/wifi';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Espressif Wireshark User Guide" href="wireshark-user-guide.html" />
    <link rel="prev" title="Running ESP-IDF Applications on Host" href="host-apps.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../get-started/index.html">Get Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="app_trace.html">Application Level Tracing Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="startup.html">Application Startup Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="classic-bt/index.html">Bluetooth<sup>®</sup> Classic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ble/index.html">Bluetooth<sup>®</sup> Low Energy</a></li>
<li class="toctree-l2"><a class="reference internal" href="esp-ble-mesh/ble-mesh-index.html">ESP-BLE-MESH</a></li>
<li class="toctree-l2"><a class="reference internal" href="bootloader.html">Bootloader</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-system.html">Build System</a></li>
<li class="toctree-l2"><a class="reference internal" href="coexist.html">RF Coexistence</a></li>
<li class="toctree-l2"><a class="reference internal" href="c.html">C Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="cplusplus.html">C++ Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="code-quality/index.html">Code Quality</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_dump.html">Core Dump</a></li>
<li class="toctree-l2"><a class="reference internal" href="current-consumption-measurement-modules.html">Current Consumption Measurement of Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="deep-sleep-stub.html">Deep-sleep Wake Stubs</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="esp-wifi-mesh.html">ESP-WIFI-MESH</a></li>
<li class="toctree-l2"><a class="reference internal" href="external-ram.html">Support for External RAM</a></li>
<li class="toctree-l2"><a class="reference internal" href="fatal-errors.html">Fatal Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="file-system-considerations.html">File System Considerations</a></li>
<li class="toctree-l2"><a class="reference internal" href="hardware-abstraction.html">Hardware Abstraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="hlinterrupts.html">High Priority Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="jtag-debugging/index.html">JTAG Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="linker-script-generation.html">Linker Script Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="low-power-mode/index.html">Low Power Modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lwip.html">lwIP</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-types.html">Memory Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="openthread.html">OpenThread</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition-tables.html">Partition Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance/index.html">Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="reproducible-builds.html">Reproducible Builds</a></li>
<li class="toctree-l2"><a class="reference internal" href="RF_calibration.html">RF Calibration</a></li>
<li class="toctree-l2"><a class="reference internal" href="stdio.html">Standard I/O and Console Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="thread-local-storage.html">Thread Local Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools/index.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="unit-tests.html">Unit Testing in ESP32</a></li>
<li class="toctree-l2"><a class="reference internal" href="host-apps.html">Running ESP-IDF Applications on Host</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Wi-Fi Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-feature-list">ESP32 Wi-Fi Feature List</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-to-write-a-wi-fi-application">How To Write a Wi-Fi Application</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#preparation">Preparation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-wi-fi-compile-time-options">Setting Wi-Fi Compile-time Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#init-wi-fi">Init Wi-Fi</a></li>
<li class="toctree-l4"><a class="reference internal" href="#start-connect-wi-fi">Start/Connect Wi-Fi</a></li>
<li class="toctree-l4"><a class="reference internal" href="#event-handling">Event-Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#write-error-recovery-routines-correctly-at-all-times">Write Error-Recovery Routines Correctly at All Times</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-api-error-code">ESP32 Wi-Fi API Error Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-api-parameter-initialization">ESP32 Wi-Fi API Parameter Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-programming-model">ESP32 Wi-Fi Programming Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-event-description">ESP32 Wi-Fi Event Description</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-wifi-ready">WIFI_EVENT_WIFI_READY</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-scan-done">WIFI_EVENT_SCAN_DONE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-sta-start">WIFI_EVENT_STA_START</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-sta-stop">WIFI_EVENT_STA_STOP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-sta-connected">WIFI_EVENT_STA_CONNECTED</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ip-event-sta-got-ip">IP_EVENT_STA_GOT_IP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ip-event-got-ip6">IP_EVENT_GOT_IP6</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ip-event-sta-lost-ip">IP_EVENT_STA_LOST_IP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-ap-start">WIFI_EVENT_AP_START</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-ap-stop">WIFI_EVENT_AP_STOP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-ap-staconnected">WIFI_EVENT_AP_STACONNECTED</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-ap-stadisconnected">WIFI_EVENT_AP_STADISCONNECTED</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-ap-probereqrecved">WIFI_EVENT_AP_PROBEREQRECVED</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-sta-beacon-timeout">WIFI_EVENT_STA_BEACON_TIMEOUT</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wifi-event-connectionless-module-wake-interval-start">WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-station-general-scenario">ESP32 Wi-Fi Station General Scenario</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-lwip-init-phase">1. Wi-Fi/LwIP Init Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-configuration-phase">2. Wi-Fi Configuration Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-start-phase">3. Wi-Fi Start Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-connect-phase">4. Wi-Fi Connect Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-got-ip-phase">5. Wi-Fi 'Got IP' Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-disconnect-phase">6. Wi-Fi Disconnect Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-ip-change-phase">7. Wi-Fi IP Change Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-deinit-phase">8. Wi-Fi Deinit Phase</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-ap-general-scenario">ESP32 Wi-Fi AP General Scenario</a></li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-scan">ESP32 Wi-Fi Scan</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#scan-type">Scan Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scan-configuration">Scan Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scan-all-aps-on-all-channels-foreground">Scan All APs on All Channels (Foreground)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scan-all-aps-on-all-channels-background">Scan All APs on All Channels (Background)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scan-for-specific-ap-on-all-channels">Scan for Specific AP on All Channels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scan-in-wi-fi-connect">Scan in Wi-Fi Connect</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scan-in-blocked-mode">Scan in Blocked Mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parallel-scan">Parallel Scan</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scan-when-wi-fi-is-connecting">Scan When Wi-Fi Is Connecting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-station-connecting-scenario">ESP32 Wi-Fi Station Connecting Scenario</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#scan-phase">Scan Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#auth-phase">Auth Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#association-phase">Association Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#four-way-handshake-phase">Four-way Handshake Phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-reason-code">Wi-Fi Reason Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-reason-code-related-to-wrong-password">Wi-Fi Reason code related to wrong password</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-reason-code-related-to-low-rssi">Wi-Fi Reason code related to low RSSI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-station-connecting-when-multiple-aps-are-found">ESP32 Wi-Fi Station Connecting When Multiple APs Are Found</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-reconnect">Wi-Fi Reconnect</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-beacon-timeout">Wi-Fi Beacon Timeout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-configuration">ESP32 Wi-Fi Configuration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-mode">Wi-Fi Mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#station-basic-configuration">Station Basic Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ap-basic-configuration">AP Basic Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-protocol-mode">Wi-Fi Protocol Mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#long-range-lr">Long Range (LR)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-country-code">Wi-Fi Country Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-vendor-ie-configuration">Wi-Fi Vendor IE Configuration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-easy-connect-dpp">Wi-Fi Easy Connect™ (DPP)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wpa2-enterprise">WPA2-Enterprise</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-awaretm-nan">Wi-Fi Aware<sup>TM</sup> (NAN)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wireless-network-management">Wireless Network Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#radio-resource-measurement">Radio Resource Measurement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fast-bss-transition">Fast BSS Transition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-power-saving-mode">ESP32 Wi-Fi Power-saving Mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#station-sleep">Station Sleep</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ap-sleep">AP Sleep</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disconnected-state-sleep">Disconnected State Sleep</a></li>
<li class="toctree-l4"><a class="reference internal" href="#connectionless-modules-power-saving">Connectionless Modules Power-saving</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#esp32-wi-fi-throughput">ESP32 Wi-Fi Throughput</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-80211-packet-send">Wi-Fi 80211 Packet Send</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#preconditions-of-using-esp-wifi-80211-tx">Preconditions of Using <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-rate">Data Rate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#side-effects-to-avoid-in-different-scenarios">Side-Effects to Avoid in Different Scenarios</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-sniffer-mode">Wi-Fi Sniffer Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-multiple-antennas">Wi-Fi Multiple Antennas</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-channel-state-information">Wi-Fi Channel State Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-channel-state-information-configure">Wi-Fi Channel State Information Configure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-ht20-40">Wi-Fi HT20/40</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-qos">Wi-Fi QoS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-amsdu">Wi-Fi AMSDU</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-fragment">Wi-Fi Fragment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wps-enrollee">WPS Enrollee</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-buffer-usage">Wi-Fi Buffer Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#why-buffer-configuration-is-important">Why Buffer Configuration Is Important</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-vs-static-buffer">Dynamic vs. Static Buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#peak-wi-fi-dynamic-buffer">Peak Wi-Fi Dynamic Buffer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#how-to-improve-wi-fi-performance">How to Improve Wi-Fi Performance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#protocol-stack-operation-mode">Protocol Stack Operation Mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-to-configure-parameters">How to Configure Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-psram">Using PSRAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#wi-fi-menuconfig">Wi-Fi Menuconfig</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-buffer-configure">Wi-Fi Buffer Configure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-nvs-flash">Wi-Fi NVS Flash</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wi-fi-aggregate-mac-protocol-data-unit-ampdu">Wi-Fi Aggregate MAC Protocol Data Unit (AMPDU)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#troubleshooting">Troubleshooting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="wireshark-user-guide.html">Espressif Wireshark User Guide</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="wifi-security.html">Wi-Fi Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="wifi-expansion.html">Wi-Fi Expansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy.html">PHY</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">API Guides</a></li>
      <li class="breadcrumb-item active">Wi-Fi Driver</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-guides/wifi.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="wi-fi-driver">
<h1>Wi-Fi Driver<a class="headerlink" href="#wi-fi-driver" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../zh_CN/v5.4.2/esp32/api-guides/wifi.html">[中文]</a></p>
<section id="esp32-wi-fi-feature-list">
<h2>ESP32 Wi-Fi Feature List<a class="headerlink" href="#esp32-wi-fi-feature-list" title="Permalink to this heading"></a></h2>
<p>The following features are supported:</p>
<ul class="simple">
<li><p>4 virtual Wi-Fi interfaces, which are STA, AP, Sniffer and reserved.</p></li>
<li><p>Station-only mode, AP-only mode, station/AP-coexistence mode</p></li>
<li><p>IEEE 802.11b, IEEE 802.11g, IEEE 802.11n, and APIs to configure the protocol mode</p></li>
<li><p>WPA/WPA2/WPA3/WPA2-Enterprise/WPA3-Enterprise/WAPI/WPS and DPP</p></li>
<li><p>AMSDU, AMPDU, HT40, QoS, and other key features</p></li>
<li><p>Modem-sleep</p></li>
<li><p>The Espressif-specific ESP-NOW protocol and Long Range mode, which supports up to <strong>1 km</strong> of data traffic</p></li>
<li><p>Up to 20 MBit/s TCP throughput and 30 MBit/s UDP throughput over the air</p></li>
<li><p>Sniffer</p></li>
<li><p>Both fast scan and all-channel scan</p></li>
<li><p>Multiple antennas</p></li>
<li><p>Channel state information</p></li>
</ul>
<ul class="simple">
<li><p>Wi-Fi Aware (NAN)</p></li>
</ul>
</section>
<section id="how-to-write-a-wi-fi-application">
<h2>How To Write a Wi-Fi Application<a class="headerlink" href="#how-to-write-a-wi-fi-application" title="Permalink to this heading"></a></h2>
<section id="preparation">
<h3>Preparation<a class="headerlink" href="#preparation" title="Permalink to this heading"></a></h3>
<p>Generally, the most effective way to begin your own Wi-Fi application is to select an example which is similar to your own application, and port the useful part into your project. It is not a MUST, but it is strongly recommended that you take some time to read this article first, especially if you want to program a robust Wi-Fi application.</p>
<p>This article is supplementary to the Wi-Fi APIs/Examples. It describes the principles of using the Wi-Fi APIs, the limitations of the current Wi-Fi API implementation, and the most common pitfalls in using Wi-Fi. This article also reveals some design details of the Wi-Fi driver. We recommend you to select an <a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi">example </a>.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/getting_started/station">wifi/getting_started/station</a> demonstrates how to use the station functionality to connect to an AP.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/getting_started/softAP">wifi/getting_started/softAP</a> demonstrates how to use the SoftAP functionality to configure ESP32 as an AP.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/scan">wifi/scan</a> demonstrates how to scan for available APs, configure the scan settings, and display the scan results.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/fast_scan">wifi/fast_scan</a> demonstrates how to perform fast and all channel scans for nearby APs, set thresholds for signal strength and authentication modes, and connect to the best fitting AP based on signal strength and authentication mode.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/wps">wifi/wps</a> demonstrates how to use the WPS enrollee feature to simplify the process of connecting to a Wi-Fi router, with options for PIN or PBC modes.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/wps_softap_registrar">wifi/wps_softap_registrar</a> demonstrates how to use the WPS registrar feature on SoftAP mode, simplifying the process of connecting to a Wi-Fi SoftAP from a station.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/smart_config">wifi/smart_config</a> demonstrates how to use the smartconfig feature to connect to a target AP using the ESPTOUCH app.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/power_save">wifi/power_save</a> demonstrates how to use the power save mode in station mode.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/softap_sta">wifi/softap_sta</a> demonstrates how to configure ESP32 to function as both an AP and a station simultaneously, effectively enabling it to act as a Wi-Fi NAT router.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/iperf">wifi/iperf</a> demonstrates how to implement the protocol used by the iPerf performance measurement tool, allowing for performance measurement between two chips or between a single chip and a computer running the iPerf tool, with specific instructions for testing station/soft-AP TCP/UDP RX/TX throughput.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/roaming/roaming_app">wifi/roaming/roaming_app</a> demonstrates how to use the Wi-Fi Roaming App functionality to efficiently roam between compatible APs.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/roaming/roaming_11kvr">wifi/roaming/roaming_11kvr</a> demonstrates how to implement roaming using 11k and 11v APIs.</p></li>
</ul>
</section>
<section id="setting-wi-fi-compile-time-options">
<h3>Setting Wi-Fi Compile-time Options<a class="headerlink" href="#setting-wi-fi-compile-time-options" title="Permalink to this heading"></a></h3>
<p>Refer to <a class="reference internal" href="#wi-fi-menuconfig">Wi-Fi Menuconfig</a>.</p>
</section>
<section id="init-wi-fi">
<h3>Init Wi-Fi<a class="headerlink" href="#init-wi-fi" title="Permalink to this heading"></a></h3>
<p>Refer to <a class="reference internal" href="#esp32-wi-fi-station-general-scenario">ESP32 Wi-Fi station General Scenario</a> and <a class="reference internal" href="#esp32-wi-fi-ap-general-scenario">ESP32 Wi-Fi AP General Scenario</a>.</p>
</section>
<section id="start-connect-wi-fi">
<h3>Start/Connect Wi-Fi<a class="headerlink" href="#start-connect-wi-fi" title="Permalink to this heading"></a></h3>
<p>Refer to <a class="reference internal" href="#esp32-wi-fi-station-general-scenario">ESP32 Wi-Fi station General Scenario</a> and <a class="reference internal" href="#esp32-wi-fi-ap-general-scenario">ESP32 Wi-Fi AP General Scenario</a>.</p>
</section>
<section id="event-handling">
<h3>Event-Handling<a class="headerlink" href="#event-handling" title="Permalink to this heading"></a></h3>
<p>Generally, it is easy to write code in &quot;sunny-day&quot; scenarios, such as <a class="reference internal" href="#wifi-event-sta-start">WIFI_EVENT_STA_START</a> and <a class="reference internal" href="#wifi-event-sta-connected">WIFI_EVENT_STA_CONNECTED</a>. The hard part is to write routines in &quot;rainy-day&quot; scenarios, such as <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a>. Good handling of &quot;rainy-day&quot; scenarios is fundamental to robust Wi-Fi applications. Refer to <a class="reference internal" href="#esp32-wi-fi-event-description">ESP32 Wi-Fi Event Description</a>, <a class="reference internal" href="#esp32-wi-fi-station-general-scenario">ESP32 Wi-Fi station General Scenario</a>, and <a class="reference internal" href="#esp32-wi-fi-ap-general-scenario">ESP32 Wi-Fi AP General Scenario</a>. See also the <a class="reference internal" href="../api-reference/system/esp_event.html"><span class="doc">overview of the Event Loop Library in ESP-IDF</span></a>.</p>
</section>
<section id="write-error-recovery-routines-correctly-at-all-times">
<h3>Write Error-Recovery Routines Correctly at All Times<a class="headerlink" href="#write-error-recovery-routines-correctly-at-all-times" title="Permalink to this heading"></a></h3>
<p>Just like the handling of &quot;rainy-day&quot; scenarios, a good error-recovery routine is also fundamental to robust Wi-Fi applications. Refer to <a class="reference internal" href="#esp32-wi-fi-api-error-code">ESP32 Wi-Fi API Error Code</a>.</p>
</section>
</section>
<section id="esp32-wi-fi-api-error-code">
<h2>ESP32 Wi-Fi API Error Code<a class="headerlink" href="#esp32-wi-fi-api-error-code" title="Permalink to this heading"></a></h2>
<p>All of the ESP32 Wi-Fi APIs have well-defined return values, namely, the error code. The error code can be categorized into:</p>
<blockquote>
<div><ul class="simple">
<li><p>No errors, e.g., <a class="reference internal" href="../api-reference/system/esp_err.html#c.ESP_OK" title="ESP_OK"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_OK</span></code></a> means that the API returns successfully.</p></li>
<li><p>Recoverable errors, such as <a class="reference internal" href="../api-reference/system/esp_err.html#c.ESP_ERR_NO_MEM" title="ESP_ERR_NO_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NO_MEM</span></code></a>.</p></li>
<li><p>Non-recoverable, non-critical errors.</p></li>
<li><p>Non-recoverable, critical errors.</p></li>
</ul>
</div></blockquote>
<p>Whether the error is critical or not depends on the API and the application scenario, and it is defined by the API user.</p>
<p><strong>The primary principle to write a robust application with Wi-Fi API is to always check the error code and write the error-handling code.</strong> Generally, the error-handling code can be used:</p>
<blockquote>
<div><ul class="simple">
<li><p>For recoverable errors, in which case you can write a recoverable-error code. For example, when <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a> returns <a class="reference internal" href="../api-reference/system/esp_err.html#c.ESP_ERR_NO_MEM" title="ESP_ERR_NO_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NO_MEM</span></code></a>, the recoverable-error code vTaskDelay can be called in order to get a microseconds' delay for another try.</p></li>
<li><p>For non-recoverable, yet non-critical errors, in which case printing the error code is a good method for error handling.</p></li>
<li><p>For non-recoverable and also critical errors, in which case &quot;assert&quot; may be a good method for error handling. For example, if <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_set_mode11wifi_mode_t" title="esp_wifi_set_mode"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_mode()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">ESP_ERR_WIFI_NOT_INIT</span></code>, it means that the Wi-Fi driver is not initialized by <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_initPK18wifi_init_config_t" title="esp_wifi_init"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_init()</span></code></a> successfully. You can detect this kind of error very quickly in the application development phase.</p></li>
</ul>
</div></blockquote>
<p>In <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_common/include/esp_err.h">esp_common/include/esp_err.h</a>, <code class="docutils literal notranslate"><span class="pre">ESP_ERROR_CHECK</span></code> checks the return values. It is a rather commonplace error-handling code and can be used as the default error-handling code in the application development phase. However, it is strongly recommended that API users write their own error-handling code.</p>
</section>
<section id="esp32-wi-fi-api-parameter-initialization">
<h2>ESP32 Wi-Fi API Parameter Initialization<a class="headerlink" href="#esp32-wi-fi-api-parameter-initialization" title="Permalink to this heading"></a></h2>
<p>When initializing struct parameters for the API, one of two approaches should be followed:</p>
<ul class="simple">
<li><p>Explicitly set all fields of the parameter.</p></li>
<li><p>Use get API to get current configuration first, then set application specific fields.</p></li>
</ul>
<p>Initializing or getting the entire structure is very important, because most of the time the value 0 indicates that the default value is used. More fields may be added to the struct in the future and initializing these to zero ensures the application will still work correctly after ESP-IDF is updated to a new release.</p>
</section>
<section id="esp32-wi-fi-programming-model">
<span id="wifi-programming-model"></span><h2>ESP32 Wi-Fi Programming Model<a class="headerlink" href="#esp32-wi-fi-programming-model" title="Permalink to this heading"></a></h2>
<p>The ESP32 Wi-Fi programming model is depicted as follows:</p>
<figure class="align-center" id="id2">
<div class="align-default"><img height="300" src="../_images/blockdiag-e84890e7d031323182382a1b1773ff4b3e4894aa.png" width="740" /></div>
<figcaption>
<p><span class="caption-text">Wi-Fi Programming Model</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The Wi-Fi driver can be considered a black box that knows nothing about high-layer code, such as the TCP/IP stack, application task, and event task. The application task (code) generally calls <a class="reference internal" href="../api-reference/network/esp_wifi.html"><span class="doc">Wi-Fi driver APIs</span></a> to initialize Wi-Fi and handles Wi-Fi events when necessary. Wi-Fi driver receives API calls, handles them, and posts events to the application.</p>
<p>Wi-Fi event handling is based on the <a class="reference internal" href="../api-reference/system/esp_event.html"><span class="doc">esp_event library</span></a>. Events are sent by the Wi-Fi driver to the <a class="reference internal" href="../api-reference/system/esp_event.html#esp-event-default-loops"><span class="std std-ref">default event loop</span></a>. Application may handle these events in callbacks registered using <a class="reference internal" href="../api-reference/system/esp_event.html#_CPPv426esp_event_handler_register16esp_event_base_t7int32_t19esp_event_handler_tPv" title="esp_event_handler_register"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_event_handler_register()</span></code></a>. Wi-Fi events are also handled by <a class="reference internal" href="../api-reference/network/esp_netif.html"><span class="doc">esp_netif component</span></a> to provide a set of default behaviors. For example, when Wi-Fi station connects to an AP, esp_netif will automatically start the DHCP client by default.</p>
</section>
<section id="esp32-wi-fi-event-description">
<h2>ESP32 Wi-Fi Event Description<a class="headerlink" href="#esp32-wi-fi-event-description" title="Permalink to this heading"></a></h2>
<section id="wifi-event-wifi-ready">
<h3>WIFI_EVENT_WIFI_READY<a class="headerlink" href="#wifi-event-wifi-ready" title="Permalink to this heading"></a></h3>
<p>The Wi-Fi driver will never generate this event, which, as a result, can be ignored by the application event callback. This event may be removed in future releases.</p>
</section>
<section id="wifi-event-scan-done">
<h3>WIFI_EVENT_SCAN_DONE<a class="headerlink" href="#wifi-event-scan-done" title="Permalink to this heading"></a></h3>
<p>The scan-done event is triggered by <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> and will arise in the following scenarios:</p>
<blockquote>
<div><ul class="simple">
<li><p>The scan is completed, e.g., the target AP is found successfully, or all channels have been scanned.</p></li>
<li><p>The scan is stopped by <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv418esp_wifi_scan_stopv" title="esp_wifi_scan_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_stop()</span></code></a>.</p></li>
<li><p>The <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> is called before the scan is completed. A new scan will override the current scan and a scan-done event will be generated.</p></li>
</ul>
</div></blockquote>
<p>The scan-done event will not arise in the following scenarios:</p>
<blockquote>
<div><ul class="simple">
<li><p>It is a blocked scan.</p></li>
<li><p>The scan is caused by <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a>.</p></li>
</ul>
</div></blockquote>
<p>Upon receiving this event, the event task does nothing. The application event callback needs to call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv424esp_wifi_scan_get_ap_numP8uint16_t" title="esp_wifi_scan_get_ap_num"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_get_ap_num()</span></code></a> and <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv428esp_wifi_scan_get_ap_recordsP8uint16_tP16wifi_ap_record_t" title="esp_wifi_scan_get_ap_records"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_get_ap_records()</span></code></a> to fetch the scanned AP list and trigger the Wi-Fi driver to free the internal memory which is allocated during the scan <strong>(do not forget to do this!)</strong>.
Refer to <a class="reference internal" href="#esp32-wi-fi-scan">ESP32 Wi-Fi Scan</a> for a more detailed description.</p>
</section>
<section id="wifi-event-sta-start">
<h3>WIFI_EVENT_STA_START<a class="headerlink" href="#wifi-event-sta-start" title="Permalink to this heading"></a></h3>
<p>If <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a> returns <a class="reference internal" href="../api-reference/system/esp_err.html#c.ESP_OK" title="ESP_OK"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_OK</span></code></a> and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will initialize the LwIP network interface (netif). Generally, the application event callback needs to call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> to connect to the configured AP.</p>
</section>
<section id="wifi-event-sta-stop">
<h3>WIFI_EVENT_STA_STOP<a class="headerlink" href="#wifi-event-sta-stop" title="Permalink to this heading"></a></h3>
<p>If <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_stopv" title="esp_wifi_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_stop()</span></code></a> returns <a class="reference internal" href="../api-reference/system/esp_err.html#c.ESP_OK" title="ESP_OK"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_OK</span></code></a> and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will release the station's IP address, stop the DHCP client, remove TCP/UDP-related connections, and clear the LwIP station netif, etc. The application event callback generally does not need to do anything.</p>
</section>
<section id="wifi-event-sta-connected">
<h3>WIFI_EVENT_STA_CONNECTED<a class="headerlink" href="#wifi-event-sta-connected" title="Permalink to this heading"></a></h3>
<p>If <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> returns <a class="reference internal" href="../api-reference/system/esp_err.html#c.ESP_OK" title="ESP_OK"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_OK</span></code></a> and the station successfully connects to the target AP, the connection event will arise. Upon receiving this event, the event task starts the DHCP client and begins the DHCP process of getting the IP address. Then, the Wi-Fi driver is ready for sending and receiving data. This moment is good for beginning the application work, provided that the application does not depend on LwIP, namely the IP address. However, if the application is LwIP-based, then you need to wait until the <em>got ip</em> event comes in.</p>
</section>
<section id="wifi-event-sta-disconnected">
<h3>WIFI_EVENT_STA_DISCONNECTED<a class="headerlink" href="#wifi-event-sta-disconnected" title="Permalink to this heading"></a></h3>
<p>This event can be generated in the following scenarios:</p>
<blockquote>
<div><ul class="simple">
<li><p>When <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_disconnectv" title="esp_wifi_disconnect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_disconnect()</span></code></a> or <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_stopv" title="esp_wifi_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_stop()</span></code></a> is called and the station is already connected to the AP.</p></li>
<li><p>When <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> is called, but the Wi-Fi driver fails to set up a connection with the AP due to certain reasons, e.g., the scan fails to find the target AP or the authentication times out. If there are more than one AP with the same SSID, the disconnected event will be raised after the station fails to connect all of the found APs.</p></li>
<li><p>When the Wi-Fi connection is disrupted because of specific reasons, e.g., the station continuously loses N beacons, the AP kicks off the station, or the AP's authentication mode is changed.</p></li>
</ul>
</div></blockquote>
<p>Upon receiving this event, the default behaviors of the event task are:</p>
<ul class="simple">
<li><p>Shutting down the station's LwIP netif.</p></li>
<li><p>Notifying the LwIP task to clear the UDP/TCP connections which cause the wrong status to all sockets. For socket-based applications, the application callback can choose to close all sockets and re-create them, if necessary, upon receiving this event.</p></li>
</ul>
<p>The most common event handle code for this event in application is to call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> to reconnect the Wi-Fi. However, if the event is raised because <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_disconnectv" title="esp_wifi_disconnect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_disconnect()</span></code></a> is called, the application should not call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> to reconnect. It is the application's responsibility to distinguish whether the event is caused by <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_disconnectv" title="esp_wifi_disconnect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_disconnect()</span></code></a> or other reasons. Sometimes a better reconnection strategy is required. Refer to <a class="reference internal" href="#wi-fi-reconnect">Wi-Fi Reconnect</a> and <a class="reference internal" href="#scan-when-wi-fi-is-connecting">Scan When Wi-Fi Is Connecting</a>.</p>
<p>Another thing that deserves attention is that the default behavior of LwIP is to abort all TCP socket connections on receiving the disconnect. In most cases, it is not a problem. However, for some special applications, this may not be what they want. Consider the following scenarios:</p>
<ul class="simple">
<li><p>The application creates a TCP connection to maintain the application-level keep-alive data that is sent out every 60 seconds.</p></li>
<li><p>Due to certain reasons, the Wi-Fi connection is cut off, and the <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> is raised. According to the current implementation, all TCP connections will be removed and the keep-alive socket will be in a wrong status. However, since the application designer believes that the network layer should <strong>ignore</strong> this error at the Wi-Fi layer, the application does not close the socket.</p></li>
<li><p>Five seconds later, the Wi-Fi connection is restored because <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> is called in the application event callback function. <strong>Moreover, the station connects to the same AP and gets the same IPV4 address as before</strong>.</p></li>
<li><p>Sixty seconds later, when the application sends out data with the keep-alive socket, the socket returns an error and the application closes the socket and re-creates it when necessary.</p></li>
</ul>
<p>In above scenarios, ideally, the application sockets and the network layer should not be affected, since the Wi-Fi connection only fails temporarily and recovers very quickly. The application can enable &quot;Keep TCP connections when IP changed&quot; via LwIP menuconfig.</p>
</section>
<section id="ip-event-sta-got-ip">
<h3>IP_EVENT_STA_GOT_IP<a class="headerlink" href="#ip-event-sta-got-ip" title="Permalink to this heading"></a></h3>
<p>This event arises when the DHCP client successfully gets the IPV4 address from the DHCP server, or when the IPV4 address is changed. The event means that everything is ready and the application can begin its tasks (e.g., creating sockets).</p>
<p>The IPV4 may be changed because of the following reasons:</p>
<blockquote>
<div><ul class="simple">
<li><p>The DHCP client fails to renew/rebind the IPV4 address, and the station's IPV4 is reset to 0.</p></li>
<li><p>The DHCP client rebinds to a different address.</p></li>
<li><p>The static-configured IPV4 address is changed.</p></li>
</ul>
</div></blockquote>
<p>Whether the IPV4 address is changed or not is indicated by the field <code class="docutils literal notranslate"><span class="pre">ip_change</span></code> of <code class="docutils literal notranslate"><span class="pre">ip_event_got_ip_t</span></code>.</p>
<p>The socket is based on the IPV4 address, which means that, if the IPV4 changes, all sockets relating to this IPV4 will become abnormal. Upon receiving this event, the application needs to close all sockets and recreate the application when the IPV4 changes to a valid one.</p>
</section>
<section id="ip-event-got-ip6">
<h3>IP_EVENT_GOT_IP6<a class="headerlink" href="#ip-event-got-ip6" title="Permalink to this heading"></a></h3>
<p>This event arises when the IPV6 SLAAC support auto-configures an address for the ESP32, or when this address changes. The event means that everything is ready and the application can begin its tasks, e.g., creating sockets.</p>
</section>
<section id="ip-event-sta-lost-ip">
<h3>IP_EVENT_STA_LOST_IP<a class="headerlink" href="#ip-event-sta-lost-ip" title="Permalink to this heading"></a></h3>
<p>This event arises when the IPV4 address becomes invalid.</p>
<p>IP_EVENT_STA_LOST_IP does not arise immediately after the Wi-Fi disconnects. Instead, it starts an IPV4 address lost timer. If the IPV4 address is got before ip lost timer expires, IP_EVENT_STA_LOST_IP does not happen. Otherwise, the event arises when the IPV4 address lost timer expires.</p>
<p>Generally, the application can ignore this event, because it is just a debug event to inform that the IPV4 address is lost.</p>
</section>
<section id="wifi-event-ap-start">
<h3>WIFI_EVENT_AP_START<a class="headerlink" href="#wifi-event-ap-start" title="Permalink to this heading"></a></h3>
<p>Similar to <a class="reference internal" href="#wifi-event-sta-start">WIFI_EVENT_STA_START</a>.</p>
</section>
<section id="wifi-event-ap-stop">
<h3>WIFI_EVENT_AP_STOP<a class="headerlink" href="#wifi-event-ap-stop" title="Permalink to this heading"></a></h3>
<p>Similar to <a class="reference internal" href="#wifi-event-sta-stop">WIFI_EVENT_STA_STOP</a>.</p>
</section>
<section id="wifi-event-ap-staconnected">
<h3>WIFI_EVENT_AP_STACONNECTED<a class="headerlink" href="#wifi-event-ap-staconnected" title="Permalink to this heading"></a></h3>
<p>Every time a station is connected to ESP32 AP, the <a class="reference internal" href="#wifi-event-ap-staconnected">WIFI_EVENT_AP_STACONNECTED</a> will arise. Upon receiving this event, the event task will do nothing, and the application callback can also ignore it. However, you may want to do something, for example, to get the info of the connected STA.</p>
</section>
<section id="wifi-event-ap-stadisconnected">
<h3>WIFI_EVENT_AP_STADISCONNECTED<a class="headerlink" href="#wifi-event-ap-stadisconnected" title="Permalink to this heading"></a></h3>
<p>This event can happen in the following scenarios:</p>
<blockquote>
<div><ul class="simple">
<li><p>The application calls <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_disconnectv" title="esp_wifi_disconnect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_disconnect()</span></code></a>, or <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_deauth_sta8uint16_t" title="esp_wifi_deauth_sta"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_deauth_sta()</span></code></a>, to manually disconnect the station.</p></li>
<li><p>The Wi-Fi driver kicks off the station, e.g., because the AP has not received any packets in the past five minutes. The time can be modified by <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv426esp_wifi_set_inactive_time16wifi_interface_t8uint16_t" title="esp_wifi_set_inactive_time"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_inactive_time()</span></code></a>.</p></li>
<li><p>The station kicks off the AP.</p></li>
</ul>
</div></blockquote>
<p>When this event happens, the event task will do nothing, but the application event callback needs to do something, e.g., close the socket which is related to this station.</p>
</section>
<section id="wifi-event-ap-probereqrecved">
<h3>WIFI_EVENT_AP_PROBEREQRECVED<a class="headerlink" href="#wifi-event-ap-probereqrecved" title="Permalink to this heading"></a></h3>
<p>This event is disabled by default. The application can enable it via API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv423esp_wifi_set_event_mask8uint32_t" title="esp_wifi_set_event_mask"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_event_mask()</span></code></a>.
When this event is enabled, it will be raised each time the AP receives a probe request.</p>
</section>
<section id="wifi-event-sta-beacon-timeout">
<h3>WIFI_EVENT_STA_BEACON_TIMEOUT<a class="headerlink" href="#wifi-event-sta-beacon-timeout" title="Permalink to this heading"></a></h3>
<p>If the station does not receive the beacon of the connected AP within the inactive time, the beacon timeout happens, the <a class="reference internal" href="#wifi-event-sta-beacon-timeout">WIFI_EVENT_STA_BEACON_TIMEOUT</a> will arise. The application can set inactive time via API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv426esp_wifi_set_inactive_time16wifi_interface_t8uint16_t" title="esp_wifi_set_inactive_time"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_inactive_time()</span></code></a>.</p>
</section>
<section id="wifi-event-connectionless-module-wake-interval-start">
<h3>WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START<a class="headerlink" href="#wifi-event-connectionless-module-wake-interval-start" title="Permalink to this heading"></a></h3>
<p>The <a class="reference internal" href="#wifi-event-connectionless-module-wake-interval-start">WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START</a> will arise at the start of connectionless module <cite>Interval</cite>. See <a class="reference internal" href="#connectionless-module-power-save"><span class="std std-ref">connectionless module power save</span></a>.</p>
</section>
</section>
<section id="esp32-wi-fi-station-general-scenario">
<h2>ESP32 Wi-Fi Station General Scenario<a class="headerlink" href="#esp32-wi-fi-station-general-scenario" title="Permalink to this heading"></a></h2>
<p>Below is a &quot;big scenario&quot; which describes some small scenarios in station mode:</p>
<figure class="align-center" id="id3">
<div class="align-default"><img height="1713" src="../_images/seqdiag-a7b38267e6f38bbdb2719c2828bd53a30a9d7d52.png" width="768" /></div>
<figcaption>
<p><span class="caption-text">Sample Wi-Fi Event Scenarios in Station Mode</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<section id="wi-fi-lwip-init-phase">
<h3>1. Wi-Fi/LwIP Init Phase<a class="headerlink" href="#wi-fi-lwip-init-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s1.1: The main task calls <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_netif_init()</span></code> to create an LwIP core task and initialize LwIP-related work.</p></li>
<li><p>s1.2: The main task calls <a class="reference internal" href="../api-reference/system/esp_event.html#_CPPv421esp_event_loop_createPK21esp_event_loop_args_tP23esp_event_loop_handle_t" title="esp_event_loop_create"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_event_loop_create()</span></code></a> to create a system Event task and initialize an application event's callback function. In the scenario above, the application event's callback function does nothing but relaying the event to the application task.</p></li>
<li><p>s1.3: The main task calls <a class="reference internal" href="../api-reference/network/esp_netif_programming.html#_CPPv432esp_netif_create_default_wifi_apv" title="esp_netif_create_default_wifi_ap"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_netif_create_default_wifi_ap()</span></code></a> or <a class="reference internal" href="../api-reference/network/esp_netif_programming.html#_CPPv433esp_netif_create_default_wifi_stav" title="esp_netif_create_default_wifi_sta"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_netif_create_default_wifi_sta()</span></code></a> to create default network interface instance binding station or AP with TCP/IP stack.</p></li>
<li><p>s1.4: The main task calls <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_initPK18wifi_init_config_t" title="esp_wifi_init"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_init()</span></code></a> to create the Wi-Fi driver task and initialize the Wi-Fi driver.</p></li>
<li><p>s1.5: The main task calls OS API to create the application task.</p></li>
</ul>
</div></blockquote>
<p>Step 1.1 ~ 1.5 is a recommended sequence that initializes a Wi-Fi-/LwIP-based application. However, it is <strong>NOT</strong> a must-follow sequence, which means that you can create the application task in step 1.1 and put all other initialization in the application task. Moreover, you may not want to create the application task in the initialization phase if the application task depends on the sockets. Rather, you can defer the task creation until the IP is obtained.</p>
</section>
<section id="wi-fi-configuration-phase">
<h3>2. Wi-Fi Configuration Phase<a class="headerlink" href="#wi-fi-configuration-phase" title="Permalink to this heading"></a></h3>
<p>Once the Wi-Fi driver is initialized, you can start configuring the Wi-Fi driver. In this scenario, the mode is station, so you may need to call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_set_mode11wifi_mode_t" title="esp_wifi_set_mode"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_mode()</span></code></a> (WIFI_MODE_STA) to configure the Wi-Fi mode as station. You can call other <cite>esp_wifi_set_xxx</cite> APIs to configure more settings, such as the protocol mode, the country code, and the bandwidth. Refer to <a class="reference internal" href="#esp32-wi-fi-configuration">ESP32 Wi-Fi Configuration</a>.</p>
<p>Generally, the Wi-Fi driver should be configured before the Wi-Fi connection is set up. But this is <strong>NOT</strong> mandatory, which means that you can configure the Wi-Fi connection anytime, provided that the Wi-Fi driver is initialized successfully. However, if the configuration does not need to change after the Wi-Fi connection is set up, you should configure the Wi-Fi driver at this stage, because the configuration APIs (such as <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv421esp_wifi_set_protocol16wifi_interface_t7uint8_t" title="esp_wifi_set_protocol"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_protocol()</span></code></a>) will cause the Wi-Fi to reconnect, which may not be desirable.</p>
<p>If the Wi-Fi NVS flash is enabled by menuconfig, all Wi-Fi configuration in this phase, or later phases, will be stored into flash. When the board powers on/reboots, you do not need to configure the Wi-Fi driver from scratch. You only need to call <code class="docutils literal notranslate"><span class="pre">esp_wifi_get_xxx</span></code> APIs to fetch the configuration stored in flash previously. You can also configure the Wi-Fi driver if the previous configuration is not what you want.</p>
</section>
<section id="wi-fi-start-phase">
<h3>3. Wi-Fi Start Phase<a class="headerlink" href="#wi-fi-start-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s3.1: Call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a> to start the Wi-Fi driver.</p></li>
<li><p>s3.2: The Wi-Fi driver posts <a class="reference internal" href="#wifi-event-sta-start">WIFI_EVENT_STA_START</a> to the event task; then, the event task will do some common things and will call the application event callback function.</p></li>
<li><p>s3.3: The application event callback function relays the <a class="reference internal" href="#wifi-event-sta-start">WIFI_EVENT_STA_START</a> to the application task. We recommend that you call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a>. However, you can also call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> in other phrases after the <a class="reference internal" href="#wifi-event-sta-start">WIFI_EVENT_STA_START</a> arises.</p></li>
</ul>
</div></blockquote>
</section>
<section id="wi-fi-connect-phase">
<h3>4. Wi-Fi Connect Phase<a class="headerlink" href="#wi-fi-connect-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s4.1: Once <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> is called, the Wi-Fi driver will start the internal scan/connection process.</p></li>
<li><p>s4.2: If the internal scan/connection process is successful, the <a class="reference internal" href="#wifi-event-sta-connected">WIFI_EVENT_STA_CONNECTED</a> will be generated. In the event task, it starts the DHCP client, which will finally trigger the DHCP process.</p></li>
<li><p>s4.3: In the above-mentioned scenario, the application event callback will relay the event to the application task. Generally, the application needs to do nothing, and you can do whatever you want, e.g., print a log.</p></li>
</ul>
</div></blockquote>
<p>In step 4.2, the Wi-Fi connection may fail because, for example, the password is wrong, or the AP is not found. In a case like this, <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> will arise and the reason for such a failure will be provided. For handling events that disrupt Wi-Fi connection, please refer to phase 6.</p>
</section>
<section id="wi-fi-got-ip-phase">
<h3>5. Wi-Fi 'Got IP' Phase<a class="headerlink" href="#wi-fi-got-ip-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s5.1: Once the DHCP client is initialized in step 4.2, the <em>got IP</em> phase will begin.</p></li>
<li><p>s5.2: If the IP address is successfully received from the DHCP server, then <a class="reference internal" href="#ip-event-sta-got-ip">IP_EVENT_STA_GOT_IP</a> will arise and the event task will perform common handling.</p></li>
<li><p>s5.3: In the application event callback, <a class="reference internal" href="#ip-event-sta-got-ip">IP_EVENT_STA_GOT_IP</a> is relayed to the application task. For LwIP-based applications, this event is very special and means that everything is ready for the application to begin its tasks, e.g., creating the TCP/UDP socket. A very common mistake is to initialize the socket before <a class="reference internal" href="#ip-event-sta-got-ip">IP_EVENT_STA_GOT_IP</a> is received. <strong>DO NOT start the socket-related work before the IP is received.</strong></p></li>
</ul>
</div></blockquote>
</section>
<section id="wi-fi-disconnect-phase">
<h3>6. Wi-Fi Disconnect Phase<a class="headerlink" href="#wi-fi-disconnect-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s6.1: When the Wi-Fi connection is disrupted, e.g., the AP is powered off or the RSSI is poor, <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> will arise. This event may also arise in phase 3. Here, the event task will notify the LwIP task to clear/remove all UDP/TCP connections. Then, all application sockets will be in a wrong status. In other words, no socket can work properly when this event happens.</p></li>
<li><p>s6.2: In the scenario described above, the application event callback function relays <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> to the application task. The recommended actions are: 1) call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> to reconnect the Wi-Fi, 2) close all sockets, and 3) re-create them if necessary. For details, please refer to <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a>.</p></li>
</ul>
</div></blockquote>
</section>
<section id="wi-fi-ip-change-phase">
<h3>7. Wi-Fi IP Change Phase<a class="headerlink" href="#wi-fi-ip-change-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s7.1: If the IP address is changed, the <a class="reference internal" href="#ip-event-sta-got-ip">IP_EVENT_STA_GOT_IP</a> will arise with &quot;ip_change&quot; set to true.</p></li>
<li><p>s7.2: <strong>This event is important to the application. When it occurs, the timing is good for closing all created sockets and recreating them.</strong></p></li>
</ul>
</div></blockquote>
</section>
<section id="wi-fi-deinit-phase">
<h3>8. Wi-Fi Deinit Phase<a class="headerlink" href="#wi-fi-deinit-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s8.1: Call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_disconnectv" title="esp_wifi_disconnect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_disconnect()</span></code></a> to disconnect the Wi-Fi connectivity.</p></li>
<li><p>s8.2: Call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_stopv" title="esp_wifi_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_stop()</span></code></a> to stop the Wi-Fi driver.</p></li>
<li><p>s8.3: Call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv415esp_wifi_deinitv" title="esp_wifi_deinit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_deinit()</span></code></a> to unload the Wi-Fi driver.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="esp32-wi-fi-ap-general-scenario">
<h2>ESP32 Wi-Fi AP General Scenario<a class="headerlink" href="#esp32-wi-fi-ap-general-scenario" title="Permalink to this heading"></a></h2>
<p>Below is a &quot;big scenario&quot; which describes some small scenarios in AP mode:</p>
<blockquote>
<div><figure class="align-center" id="id4">
<div class="align-default"><img height="1164" src="../_images/seqdiag-54e7896d2a7f4297cf7ec2ee1ef53144ea16b692.png" width="768" /></div>
<figcaption>
<p><span class="caption-text">Sample Wi-Fi Event Scenarios in AP Mode</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div></blockquote>
</section>
<section id="esp32-wi-fi-scan">
<h2>ESP32 Wi-Fi Scan<a class="headerlink" href="#esp32-wi-fi-scan" title="Permalink to this heading"></a></h2>
<p>Currently, the <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> API is supported only in station or station/AP mode.</p>
<section id="scan-type">
<h3>Scan Type<a class="headerlink" href="#scan-type" title="Permalink to this heading"></a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 23.1%" />
<col style="width: 76.9%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Mode</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Active Scan</p></td>
<td><p>Scan by sending a probe request. The default scan is an active scan.</p></td>
</tr>
<tr class="row-odd"><td><p>Passive Scan</p></td>
<td><p>No probe request is sent out. Just switch to the specific channel and wait for a beacon. Application can enable it via the scan_type field of <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv418wifi_scan_config_t" title="wifi_scan_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wifi_scan_config_t</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p>Foreground Scan</p></td>
<td><p>This scan is applicable when there is no Wi-Fi connection in station mode. Foreground or background scanning is controlled by the Wi-Fi driver and cannot be configured by the application.</p></td>
</tr>
<tr class="row-odd"><td><p>Background Scan</p></td>
<td><p>This scan is applicable when there is a Wi-Fi connection in station mode or in station/AP mode. Whether it is a foreground scan or background scan depends on the Wi-Fi driver and cannot be configured by the application.</p></td>
</tr>
<tr class="row-even"><td><p>All-Channel Scan</p></td>
<td><p>It scans all of the channels. If the channel field of <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv418wifi_scan_config_t" title="wifi_scan_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wifi_scan_config_t</span></code></a> is set to 0, it is an all-channel scan.</p></td>
</tr>
<tr class="row-odd"><td><p>Specific Channel Scan</p></td>
<td><p>It scans specific channels only. If the channel field of <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv418wifi_scan_config_t" title="wifi_scan_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wifi_scan_config_t</span></code></a> set to 1-14, it is a specific-channel scan.</p></td>
</tr>
</tbody>
</table>
<p>The scan modes in above table can be combined arbitrarily, so there are in total 8 different scans:</p>
<blockquote>
<div><ul class="simple">
<li><p>All-Channel Background Active Scan</p></li>
<li><p>All-Channel Background Passive Scan</p></li>
<li><p>All-Channel Foreground Active Scan</p></li>
<li><p>All-Channel Foreground Passive Scan</p></li>
<li><p>Specific-Channel Background Active Scan</p></li>
<li><p>Specific-Channel Background Passive Scan</p></li>
<li><p>Specific-Channel Foreground Active Scan</p></li>
<li><p>Specific-Channel Foreground Passive Scan</p></li>
</ul>
</div></blockquote>
</section>
<section id="scan-configuration">
<h3>Scan Configuration<a class="headerlink" href="#scan-configuration" title="Permalink to this heading"></a></h3>
<p>The scan type and other per-scan attributes are configured by <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a>. The table below provides a detailed description of <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv418wifi_scan_config_t" title="wifi_scan_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wifi_scan_config_t</span></code></a>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23.1%" />
<col style="width: 76.9%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ssid</p></td>
<td><p>If the SSID is not NULL, it is only the AP with the same SSID that can be scanned.</p></td>
</tr>
<tr class="row-odd"><td><p>bssid</p></td>
<td><p>If the BSSID is not NULL, it is only the AP with the same BSSID that can be scanned.</p></td>
</tr>
<tr class="row-even"><td><p>channel</p></td>
<td><p>If “channel” is 0, there will be an all-channel scan; otherwise, there will be a specific-channel scan.</p></td>
</tr>
<tr class="row-odd"><td><p>show_hidden</p></td>
<td><p>If “show_hidden” is 0, the scan ignores the AP with a hidden SSID; otherwise, the scan considers the hidden AP a normal one.</p></td>
</tr>
<tr class="row-even"><td><p>scan_type</p></td>
<td><p>If “scan_type” is WIFI_SCAN_TYPE_ACTIVE, the scan is “active”; otherwise, it is a “passive” one.</p></td>
</tr>
<tr class="row-odd"><td><p>scan_time</p></td>
<td><p>This field is used to control how long the scan dwells on each channel.</p>
<p>For passive scans, scan_time.passive designates the dwell time for each channel.</p>
<p>For active scans, dwell times for each channel are listed in the table below. Here, min is short for scan time.active.min and max is short for scan_time.active.max.</p>
<ul class="simple">
<li><p>min=0, max=0: scan dwells on each channel for 120 ms.</p></li>
<li><p>min&gt;0, max=0: scan dwells on each channel for 120 ms.</p></li>
<li><p>min=0, max&gt;0: scan dwells on each channel for <code class="docutils literal notranslate"><span class="pre">max</span></code> ms.</p></li>
<li><p>min&gt;0, max&gt;0: the minimum time the scan dwells on each channel is <code class="docutils literal notranslate"><span class="pre">min</span></code> ms. If no AP is found during this time frame, the scan switches to the next channel. Otherwise, the scan dwells on the channel for <code class="docutils literal notranslate"><span class="pre">max</span></code> ms.</p></li>
</ul>
<p>If you want to improve the performance of the scan, you can try to modify these two parameters.</p>
</td>
</tr>
</tbody>
</table>
<p>There are also some global scan attributes which are configured by API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_set_config16wifi_interface_tP13wifi_config_t" title="esp_wifi_set_config"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_config()</span></code></a>, refer to <a class="reference internal" href="#station-basic-configuration">Station Basic Configuration</a></p>
</section>
<section id="scan-all-aps-on-all-channels-foreground">
<h3>Scan All APs on All Channels (Foreground)<a class="headerlink" href="#scan-all-aps-on-all-channels-foreground" title="Permalink to this heading"></a></h3>
<p>Scenario:</p>
<figure class="align-center" id="id5">
<div class="align-default"><img height="536" src="../_images/seqdiag-5a2d49dc16b2369af28dea48a4944cbcaaf83761.png" width="528" /></div>
<figcaption>
<p><span class="caption-text">Foreground Scan of all Wi-Fi Channels</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The scenario above describes an all-channel, foreground scan. The foreground scan can only occur in station mode where the station does not connect to any AP. Whether it is a foreground or background scan is totally determined by the Wi-Fi driver, and cannot be configured by the application.</p>
<p>Detailed scenario description:</p>
<section id="scan-configuration-phase">
<h4>Scan Configuration Phase<a class="headerlink" href="#scan-configuration-phase" title="Permalink to this heading"></a></h4>
<blockquote>
<div><ul class="simple">
<li><p>s1.1: Call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv420esp_wifi_set_countryPK14wifi_country_t" title="esp_wifi_set_country"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_country()</span></code></a> to set the country info if the default country info is not what you want. Refer to <a class="reference internal" href="#wi-fi-country-code">Wi-Fi Country Code</a>.</p></li>
<li><p>s1.2: Call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> to configure the scan. To do so, you can refer to <a class="reference internal" href="#scan-configuration">Scan Configuration</a>. Since this is an all-channel scan, just set the SSID/BSSID/channel to 0.</p></li>
</ul>
</div></blockquote>
</section>
<section id="wi-fi-driver-s-internal-scan-phase">
<h4>Wi-Fi Driver's Internal Scan Phase<a class="headerlink" href="#wi-fi-driver-s-internal-scan-phase" title="Permalink to this heading"></a></h4>
<blockquote>
<div><ul class="simple">
<li><p>s2.1: The Wi-Fi driver switches to channel 1. In this case, the scan type is WIFI_SCAN_TYPE_ACTIVE, and a probe request is broadcasted. Otherwise, the Wi-Fi will wait for a beacon from the APs. The Wi-Fi driver will stay in channel 1 for some time. The dwell time is configured in min/max time, with the default value being 120 ms.</p></li>
<li><p>s2.2: The Wi-Fi driver switches to channel 2 and performs the same operation as in step 2.1.</p></li>
<li><p>s2.3: The Wi-Fi driver scans the last channel N, where N is determined by the country code which is configured in step 1.1.</p></li>
</ul>
</div></blockquote>
</section>
<section id="scan-done-event-handling-phase">
<h4>Scan-Done Event Handling Phase<a class="headerlink" href="#scan-done-event-handling-phase" title="Permalink to this heading"></a></h4>
<blockquote>
<div><ul class="simple">
<li><p>s3.1: When all channels are scanned, <a class="reference internal" href="#wifi-event-scan-done">WIFI_EVENT_SCAN_DONE</a> will arise.</p></li>
<li><p>s3.2: The application's event callback function notifies the application task that <a class="reference internal" href="#wifi-event-scan-done">WIFI_EVENT_SCAN_DONE</a> is received. <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv424esp_wifi_scan_get_ap_numP8uint16_t" title="esp_wifi_scan_get_ap_num"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_get_ap_num()</span></code></a> is called to get the number of APs that have been found in this scan. Then, it allocates enough entries and calls <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv428esp_wifi_scan_get_ap_recordsP8uint16_tP16wifi_ap_record_t" title="esp_wifi_scan_get_ap_records"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_get_ap_records()</span></code></a> to get the AP records. Please note that the AP records in the Wi-Fi driver will be freed once <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv428esp_wifi_scan_get_ap_recordsP8uint16_tP16wifi_ap_record_t" title="esp_wifi_scan_get_ap_records"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_get_ap_records()</span></code></a> is called. Do not call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv428esp_wifi_scan_get_ap_recordsP8uint16_tP16wifi_ap_record_t" title="esp_wifi_scan_get_ap_records"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_get_ap_records()</span></code></a> twice for a single scan-done event. If <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv428esp_wifi_scan_get_ap_recordsP8uint16_tP16wifi_ap_record_t" title="esp_wifi_scan_get_ap_records"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_get_ap_records()</span></code></a> is not called when the scan-done event occurs, the AP records allocated by the Wi-Fi driver will not be freed. So, make sure you call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv428esp_wifi_scan_get_ap_recordsP8uint16_tP16wifi_ap_record_t" title="esp_wifi_scan_get_ap_records"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_get_ap_records()</span></code></a>, yet only once.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="scan-all-aps-on-all-channels-background">
<h3>Scan All APs on All Channels (Background)<a class="headerlink" href="#scan-all-aps-on-all-channels-background" title="Permalink to this heading"></a></h3>
<p>Scenario:</p>
<figure class="align-center" id="id6">
<div class="align-default"><img height="803" src="../_images/seqdiag-f99fced3498fd24f6d5726d6d0e20792538a0a04.png" width="528" /></div>
<figcaption>
<p><span class="caption-text">Background Scan of all Wi-Fi Channels</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The scenario above is an all-channel background scan. Compared to <a class="reference internal" href="#scan-all-aps-on-all-channels-foreground">Scan All APs on All Channels (Foreground)</a> , the difference in the all-channel background scan is that the Wi-Fi driver will scan the back-to-home channel for 30 ms before it switches to the next channel to give the Wi-Fi connection a chance to transmit/receive data.</p>
</section>
<section id="scan-for-specific-ap-on-all-channels">
<h3>Scan for Specific AP on All Channels<a class="headerlink" href="#scan-for-specific-ap-on-all-channels" title="Permalink to this heading"></a></h3>
<p>Scenario:</p>
<figure class="align-center" id="id7">
<div class="align-default"><img height="565" src="../_images/seqdiag-a5627488c6b2c21a0343b76825da5feb07a9026c.png" width="528" /></div>
<figcaption>
<p><span class="caption-text">Scan of specific Wi-Fi Channels</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>This scan is similar to <a class="reference internal" href="#scan-all-aps-on-all-channels-foreground">Scan All APs on All Channels (Foreground)</a>. The differences are:</p>
<blockquote>
<div><ul class="simple">
<li><p>s1.1: In step 1.2, the target AP will be configured to SSID/BSSID.</p></li>
<li><p>s2.1 ~ s2.N: Each time the Wi-Fi driver scans an AP, it will check whether it is a target AP or not. If the scan is <code class="docutils literal notranslate"><span class="pre">WIFI_FAST_SCAN</span></code> scan and the target AP is found, then the scan-done event will arise and scanning will end; otherwise, the scan will continue. Please note that the first scanned channel may not be channel 1, because the Wi-Fi driver optimizes the scanning sequence.</p></li>
</ul>
</div></blockquote>
<p>It is a possible situation that there are multiple APs that match the target AP info, e.g., two APs with the SSID of &quot;ap&quot; are scanned. In this case, if the scan is <code class="docutils literal notranslate"><span class="pre">WIFI_FAST_SCAN</span></code>, then only the first scanned &quot;ap&quot; will be found. If the scan is <code class="docutils literal notranslate"><span class="pre">WIFI_ALL_CHANNEL_SCAN</span></code>, both &quot;ap&quot; will be found and the station will connect the &quot;ap&quot; according to the configured strategy. Refer to <a class="reference internal" href="#station-basic-configuration">Station Basic Configuration</a>.</p>
<p>You can scan a specific AP, or all of them, in any given channel. These two scenarios are very similar.</p>
</section>
<section id="scan-in-wi-fi-connect">
<h3>Scan in Wi-Fi Connect<a class="headerlink" href="#scan-in-wi-fi-connect" title="Permalink to this heading"></a></h3>
<p>When <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> is called, the Wi-Fi driver will try to scan the configured AP first. The scan in &quot;Wi-Fi Connect&quot; is the same as <a class="reference internal" href="#scan-for-specific-ap-on-all-channels">Scan for Specific AP On All Channels</a>, except that no scan-done event will be generated when the scan is completed. If the target AP is found, the Wi-Fi driver will start the Wi-Fi connection; otherwise, <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> will be generated. Refer to <a class="reference internal" href="#scan-for-specific-ap-on-all-channels">Scan for Specific AP On All Channels</a>.</p>
</section>
<section id="scan-in-blocked-mode">
<h3>Scan in Blocked Mode<a class="headerlink" href="#scan-in-blocked-mode" title="Permalink to this heading"></a></h3>
<p>If the block parameter of <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> is true, then the scan is a blocked one, and the application task will be blocked until the scan is done. The blocked scan is similar to an unblocked one, except that no scan-done event will arise when the blocked scan is completed.</p>
</section>
<section id="parallel-scan">
<h3>Parallel Scan<a class="headerlink" href="#parallel-scan" title="Permalink to this heading"></a></h3>
<p>Two application tasks may call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> at the same time, or the same application task calls <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> before it gets a scan-done event. Both scenarios can happen. <strong>However, the Wi-Fi driver does not support multiple concurrent scans adequately. As a result, concurrent scans should be avoided.</strong> Support for concurrent scan will be enhanced in future releases, as the ESP32's Wi-Fi functionality improves continuously.</p>
</section>
<section id="scan-when-wi-fi-is-connecting">
<h3>Scan When Wi-Fi Is Connecting<a class="headerlink" href="#scan-when-wi-fi-is-connecting" title="Permalink to this heading"></a></h3>
<p>The <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> fails immediately if the Wi-Fi is connecting, because the connecting has higher priority than the scan. If scan fails because of connecting, the recommended strategy is to delay for some time and retry scan again. The scan will succeed once the connecting is completed.</p>
<p>However, the retry/delay strategy may not work all the time. Considering the following scenarios:</p>
<ul class="simple">
<li><p>The station is connecting a non-existing AP or it connects the existing AP with a wrong password, it always raises the event <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a>.</p></li>
<li><p>The application calls <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> to reconnect on receiving the disconnect event.</p></li>
<li><p>Another application task, e.g., the console task, calls <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> to do scan, the scan always fails immediately because the station keeps connecting.</p></li>
<li><p>When scan fails, the application simply delays for some time and retries the scan.</p></li>
</ul>
<p>In the above scenarios, the scan will never succeed because the connecting is in process. So if the application supports similar scenario, it needs to implement a better reconnection strategy. For example:</p>
<ul class="simple">
<li><p>The application can choose to define a maximum continuous reconnection counter and stop reconnecting once the counter reaches the maximum.</p></li>
<li><p>The application can choose to reconnect immediately in the first N continuous reconnection, then give a delay sometime and reconnect again.</p></li>
</ul>
<p>The application can define its own reconnection strategy to avoid the scan starve to death. Refer to &lt;<a class="reference internal" href="#wi-fi-reconnect">Wi-Fi Reconnect</a>&gt;.</p>
</section>
</section>
<section id="esp32-wi-fi-station-connecting-scenario">
<h2>ESP32 Wi-Fi Station Connecting Scenario<a class="headerlink" href="#esp32-wi-fi-station-connecting-scenario" title="Permalink to this heading"></a></h2>
<p>This scenario depicts the case if only one target AP is found in the scan phase. For scenarios where more than one AP with the same SSID is found, refer to <a class="reference internal" href="#esp32-wi-fi-station-connecting-when-multiple-aps-are-found">ESP32 Wi-Fi Station Connecting When Multiple APs Are Found</a>.</p>
<p>Generally, the application can ignore the connecting process. Below is a brief introduction to the process for those who are really interested.</p>
<p>Scenario:</p>
<figure class="align-center" id="id8">
<div class="align-default"><img height="1199" src="../_images/seqdiag-8f972839ce9a21766346badffb8e8f7e063352c5.png" width="528" /></div>
<figcaption>
<p><span class="caption-text">Wi-Fi Station Connecting Process</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<section id="scan-phase">
<h3>Scan Phase<a class="headerlink" href="#scan-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s1.1: The Wi-Fi driver begins scanning in &quot;Wi-Fi Connect&quot;. Refer to <a class="reference internal" href="#scan-in-wi-fi-connect">Scan in Wi-Fi Connect</a> for more details.</p></li>
<li><p>s1.2: If the scan fails to find the target AP, <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> will arise and the reason code could either be <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_NO_AP_FOUND</span></code> or <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_NO_AP_FOUND_W_COMPATIBLE_SECURITY</span></code> or <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_NO_AP_FOUND_IN_AUTHMODE_THRESHOLD</span></code> or <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_NO_AP_FOUND_IN_RSSI_THRESHOLD</span></code> depending of the Station's configuration. Refer to <a class="reference internal" href="#wi-fi-reason-code">Wi-Fi Reason Code</a>.</p></li>
</ul>
</div></blockquote>
</section>
<section id="auth-phase">
<h3>Auth Phase<a class="headerlink" href="#auth-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s2.1: The authentication request packet is sent and the auth timer is enabled.</p></li>
<li><p>s2.2: If the authentication response packet is not received before the authentication timer times out, <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> will arise and the reason code will be <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_AUTH_EXPIRE</span></code>. Refer to <a class="reference internal" href="#wi-fi-reason-code">Wi-Fi Reason Code</a>.</p></li>
<li><p>s2.3: The auth-response packet is received and the auth-timer is stopped.</p></li>
<li><p>s2.4: The AP rejects authentication in the response and <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> arises, while the reason code is <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_AUTH_FAIL</span></code> or the reasons specified by the AP. Refer to <a class="reference internal" href="#wi-fi-reason-code">Wi-Fi Reason Code</a>.</p></li>
</ul>
</div></blockquote>
</section>
<section id="association-phase">
<h3>Association Phase<a class="headerlink" href="#association-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s3.1: The association request is sent and the association timer is enabled.</p></li>
<li><p>s3.2: If the association response is not received before the association timer times out, <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> will arise and the reason code will be <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_DISASSOC_DUE_TO_INACTIVITY</span></code>. Refer to <a class="reference internal" href="#wi-fi-reason-code">Wi-Fi Reason Code</a>.</p></li>
<li><p>s3.3: The association response is received and the association timer is stopped.</p></li>
<li><p>s3.4: The AP rejects the association in the response and <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> arises, while the reason code is the one specified in the association response. Refer to <a class="reference internal" href="#wi-fi-reason-code">Wi-Fi Reason Code</a>.</p></li>
</ul>
</div></blockquote>
</section>
<section id="four-way-handshake-phase">
<h3>Four-way Handshake Phase<a class="headerlink" href="#four-way-handshake-phase" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>s4.1: The handshake timer is enabled, and the 1/4 EAPOL is not received before the handshake timer expires. <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> will arise and the reason code will be <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_HANDSHAKE_TIMEOUT</span></code>. Refer to <a class="reference internal" href="#wi-fi-reason-code">Wi-Fi Reason Code</a>.</p></li>
<li><p>s4.2: The 1/4 EAPOL is received.</p></li>
<li><p>s4.3: The station replies 2/4 EAPOL.</p></li>
<li><p>s4.4: If the 3/4 EAPOL is not received before the handshake timer expires, <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> will arise and the reason code will be <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_HANDSHAKE_TIMEOUT</span></code>. Refer to <a class="reference internal" href="#wi-fi-reason-code">Wi-Fi Reason Code</a>.</p></li>
<li><p>s4.5: The 3/4 EAPOL is received.</p></li>
<li><p>s4.6: The station replies 4/4 EAPOL.</p></li>
<li><p>s4.7: The station raises <a class="reference internal" href="#wifi-event-sta-connected">WIFI_EVENT_STA_CONNECTED</a>.</p></li>
</ul>
</div></blockquote>
</section>
<section id="wi-fi-reason-code">
<span id="esp-wifi-reason-code"></span><h3>Wi-Fi Reason Code<a class="headerlink" href="#wi-fi-reason-code" title="Permalink to this heading"></a></h3>
<p>The table below shows the reason-code defined in ESP32. The first column is the macro name defined in <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_wifi/include/esp_wifi_types.h">esp_wifi/include/esp_wifi_types.h</a>. The common prefix <code class="docutils literal notranslate"><span class="pre">WIFI_REASON</span></code> is removed, which means that <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code> actually stands for <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_UNSPECIFIED</span></code> and so on. The second column is the value of the reason. This reason value is same as defined in section 9.4.1.7 of IEEE 802.11-2020. (For more information, refer to the standard mentioned above.) The last column describes the reason. Reason-codes starting from 200 are Espressif defined reason-codes and are not part of IEEE 802.11-2020.</p>
<p>Also note that REASON_NO_AP_FOUND_XXX codes are mentioned in increasing order of importance. So if a single AP has a combination of the above reasons for failure, the more important one will be reported. Additionally, if there are multiple APs that satisfy the identifying criteria and connecting to all of them fails for different reasons mentioned above, then the reason code reported is for the AP that failed connection due to the least important reason code, as it was the one closest to a successful connection.</p>
<p>Following reason codes are renamed to their shorter form to wrap the table in page width.</p>
<ul class="simple">
<li><p>TRANSMISSION_LINK_ESTABLISHMENT_FAILED : TX_LINK_EST_FAILED</p></li>
<li><p>NO_AP_FOUND_W_COMPATIBLE_SECURITY : NO_AP_FOUND_SECURITY</p></li>
<li><p>NO_AP_FOUND_IN_AUTHMODE_THRESHOLD : NO_AP_FOUND_AUTHMODE</p></li>
<li><p>NO_AP_FOUND_IN_RSSI_THRESHOLD : NO_AP_FOUND_RSSI</p></li>
</ul>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 41.0%" />
<col style="width: 10.0%" />
<col style="width: 49.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Reason code</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>UNSPECIFIED</p></td>
<td><p>1</p></td>
<td><p>Generally, it means an internal failure, e.g., the memory runs out, the internal TX fails, or the reason is received from the remote side.</p></td>
</tr>
<tr class="row-odd"><td><p>AUTH_EXPIRE</p></td>
<td><p>2</p></td>
<td><p>The previous authentication is no longer valid.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>auth is timed out.</p></li>
<li><p>the reason is received from the AP.</p></li>
</ul>
<p>For the ESP AP, this reason is reported when:</p>
<ul class="simple">
<li><p>the AP has not received any packets from the station in the past five minutes.</p></li>
<li><p>the AP is stopped by calling <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_stopv" title="esp_wifi_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_stop()</span></code></a>.</p></li>
<li><p>the station is de-authed by calling <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_deauth_sta8uint16_t" title="esp_wifi_deauth_sta"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_deauth_sta()</span></code></a>.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>AUTH_LEAVE</p></td>
<td><p>3</p></td>
<td><p>De-authenticated, because the sending station is leaving (or has left).</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>DISASSOC_DUE_TO_INACTIVITY</p></td>
<td><p>4</p></td>
<td><p>Disassociated due to inactivity.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>assoc is timed out.</p></li>
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>ASSOC_TOOMANY</p></td>
<td><p>5</p></td>
<td><p>Disassociated, because the AP is unable to handle all currently associated STAs at the same time.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
<p>For the ESP AP, this reason is reported when:</p>
<ul class="simple">
<li><p>the stations associated with the AP reach the maximum number that the AP can support.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>CLASS2_FRAME_FROM_NONAUTH_STA</p></td>
<td><p>6</p></td>
<td><p>Class-2 frame received from a non-authenticated STA.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
<p>For the ESP AP, this reason is reported when:</p>
<ul class="simple">
<li><p>the AP receives a packet with data from a non-authenticated station.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>CLASS3_FRAME_FROM_NONASSOC_STA</p></td>
<td><p>7</p></td>
<td><p>Class-3 frame received from a non-associated STA.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
<p>For the ESP AP, this reason is reported when:</p>
<ul class="simple">
<li><p>the AP receives a packet with data from a non-associated station.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>ASSOC_LEAVE</p></td>
<td><p>8</p></td>
<td><p>Disassociated, because the sending station is leaving (or has left) BSS.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
<li><p>the station is disconnected by <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_disconnectv" title="esp_wifi_disconnect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_disconnect()</span></code></a> and other APIs.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>ASSOC_NOT_AUTHED</p></td>
<td><p>9</p></td>
<td><p>station requesting (re)association is not authenticated by the responding STA.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
<p>For the ESP AP, this reason is reported when:</p>
<ul class="simple">
<li><p>the AP receives packets with data from an associated, yet not authenticated, station.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>DISASSOC_PWRCAP_BAD</p></td>
<td><p>10</p></td>
<td><p>Disassociated, because the information in the Power Capability element is unacceptable.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>DISASSOC_SUPCHAN_BAD</p></td>
<td><p>11</p></td>
<td><p>Disassociated, because the information in the Supported Channels element is unacceptable.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>BSS_TRANSITION_DISASSOC</p></td>
<td><p>12</p></td>
<td><p>AP wants us to move to another AP, sent as a part of BTM procedure. Please note that when station is sending BTM request and moving to another AP, ROAMING reason code will be reported instead of this.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>IE_INVALID</p></td>
<td><p>13</p></td>
<td><p>Invalid element, i.e., an element whose content does not meet the specifications of the Standard in frame formats clause.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
<p>For the ESP AP, this reason is reported when:</p>
<ul class="simple">
<li><p>the AP parses a wrong WPA or RSN IE.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>MIC_FAILURE</p></td>
<td><p>14</p></td>
<td><p>Message integrity code (MIC) failure.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>4WAY_HANDSHAKE_TIMEOUT</p></td>
<td><p>15</p></td>
<td><p>Four-way handshake times out. For legacy reasons, in ESP this reason code is replaced with <code class="docutils literal notranslate"><span class="pre">WIFI_REASON_HANDSHAKE_TIMEOUT</span></code>.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>the handshake times out.</p></li>
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>GROUP_KEY_UPDATE_TIMEOUT</p></td>
<td><p>16</p></td>
<td><p>Group-Key Handshake times out.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>IE_IN_4WAY_DIFFERS</p></td>
<td><p>17</p></td>
<td><p>The element in the four-way handshake is different from the (Re-)Association Request/Probe and Response/Beacon frame.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
<li><p>the station finds that the four-way handshake IE differs from the IE in the (Re-)Association Request/Probe and Response/Beacon frame.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>GROUP_CIPHER_INVALID</p></td>
<td><p>18</p></td>
<td><p>Invalid group cipher.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>PAIRWISE_CIPHER_INVALID</p></td>
<td><p>19</p></td>
<td><p>Invalid pairwise cipher.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>AKMP_INVALID</p></td>
<td><p>20</p></td>
<td><p>Invalid AKMP.</p>
<p>For the ESP station, this reason is reported when:
- it is received from the AP.</p>
</td>
</tr>
<tr class="row-even"><td><p>UNSUPP_RSN_IE_VERSION</p></td>
<td><p>21</p></td>
<td><p>Unsupported RSNE version.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>INVALID_RSN_IE_CAP</p></td>
<td><p>22</p></td>
<td><p>Invalid RSNE capabilities.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>802_1X_AUTH_FAILED</p></td>
<td><p>23</p></td>
<td><p>IEEE 802.1X. authentication failed.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
<p>For the ESP AP, this reason is reported when:</p>
<ul class="simple">
<li><p>IEEE 802.1X. authentication fails.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>CIPHER_SUITE_REJECTED</p></td>
<td><p>24</p></td>
<td><p>Cipher suite rejected due to security policies.</p>
<p>For the ESP station, this reason is reported when:</p>
<ul class="simple">
<li><p>it is received from the AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>TDLS_PEER_UNREACHABLE</p></td>
<td><p>25</p></td>
<td><p>TDLS direct-link teardown due to TDLS peer STA unreachable via the TDLS direct link.</p></td>
</tr>
<tr class="row-odd"><td><p>TDLS_UNSPECIFIED</p></td>
<td><p>26</p></td>
<td><p>TDLS direct-link teardown for unspecified reason.</p></td>
</tr>
<tr class="row-even"><td><p>SSP_REQUESTED_DISASSOC</p></td>
<td><p>27</p></td>
<td><p>Disassociated because session terminated by SSP request.</p></td>
</tr>
<tr class="row-odd"><td><p>NO_SSP_ROAMING_AGREEMENT</p></td>
<td><p>28</p></td>
<td><p>Disassociated because of lack of SSP roaming agreement.</p></td>
</tr>
<tr class="row-even"><td><p>BAD_CIPHER_OR_AKM</p></td>
<td><p>29</p></td>
<td><p>Requested service rejected because of SSP cipher suite or AKM requirement.</p></td>
</tr>
<tr class="row-odd"><td><p>NOT_AUTHORIZED_THIS_LOCATION</p></td>
<td><p>30</p></td>
<td><p>Requested service not authorized in this location.</p></td>
</tr>
<tr class="row-even"><td><p>SERVICE_CHANGE_PRECLUDES_TS</p></td>
<td><p>31</p></td>
<td><p>TS deleted because QoS AP lacks sufficient bandwidth for this QoS STA due to a change in BSS service characteristics or operational mode (e.g., an HT BSS change from 40 MHz channel to 20 MHz channel).</p></td>
</tr>
<tr class="row-odd"><td><p>UNSPECIFIED_QOS</p></td>
<td><p>32</p></td>
<td><p>Disassociated for unspecified, QoS-related reason.</p></td>
</tr>
<tr class="row-even"><td><p>NOT_ENOUGH_BANDWIDTH</p></td>
<td><p>33</p></td>
<td><p>Disassociated because QoS AP lacks sufficient bandwidth for this QoS STA.</p></td>
</tr>
<tr class="row-odd"><td><p>MISSING_ACKS</p></td>
<td><p>34</p></td>
<td><p>Disassociated because excessive number of frames need to be acknowledged, but are not acknowledged due to AP transmissions and/or poor channel conditions.</p></td>
</tr>
<tr class="row-even"><td><p>EXCEEDED_TXOP</p></td>
<td><p>35</p></td>
<td><p>Disassociated because STA is transmitting outside the limits of its TXOPs.</p></td>
</tr>
<tr class="row-odd"><td><p>STA_LEAVING</p></td>
<td><p>36</p></td>
<td><p>Requesting STA is leaving the BSS (or resetting).</p></td>
</tr>
<tr class="row-even"><td><p>END_BA</p></td>
<td><p>37</p></td>
<td><p>Requesting STA is no longer using the stream or session.</p></td>
</tr>
<tr class="row-odd"><td><p>UNKNOWN_BA</p></td>
<td><p>38</p></td>
<td><p>Requesting STA received frames using a mechanism for which a setup has not been completed.</p></td>
</tr>
<tr class="row-even"><td><p>TIMEOUT</p></td>
<td><p>39</p></td>
<td><p>Requested from peer STA due to timeout</p></td>
</tr>
<tr class="row-odd"><td><p>Reserved</p></td>
<td><p>40 ~ 45</p></td>
<td><p>Reserved as per IEEE80211-2020 specifications.</p></td>
</tr>
<tr class="row-even"><td><p>PEER_INITIATED</p></td>
<td><p>46</p></td>
<td><p>In a Disassociation frame: Disassociated because authorized access limit reached.</p></td>
</tr>
<tr class="row-odd"><td><p>AP_INITIATED</p></td>
<td><p>47</p></td>
<td><p>In a Disassociation frame: Disassociated due to external service requirements.</p></td>
</tr>
<tr class="row-even"><td><p>INVALID_FT_ACTION_FRAME_COUNT</p></td>
<td><p>48</p></td>
<td><p>Invalid FT Action frame count.</p></td>
</tr>
<tr class="row-odd"><td><p>INVALID_PMKID</p></td>
<td><p>49</p></td>
<td><p>Invalid pairwise master key identifier (PMKID).</p></td>
</tr>
<tr class="row-even"><td><p>INVALID_MDE</p></td>
<td><p>50</p></td>
<td><p>Invalid MDE.</p></td>
</tr>
<tr class="row-odd"><td><p>INVALID_FTE</p></td>
<td><p>51</p></td>
<td><p>Invalid FTE</p></td>
</tr>
<tr class="row-even"><td><p>TX_LINK_EST_FAILED</p></td>
<td><p>67</p></td>
<td><p>TRANSMISSION_LINK_ESTABLISHMENT_FAILED will be reported when Transmission link establishment in alternative channel failed.</p></td>
</tr>
<tr class="row-odd"><td><p>ALTERATIVE_CHANNEL_OCCUPIED</p></td>
<td><p>68</p></td>
<td><p>The alternative channel is occupied.</p></td>
</tr>
<tr class="row-even"><td><p>BEACON_TIMEOUT</p></td>
<td><p>200</p></td>
<td><p>Espressif-specific Wi-Fi reason code: when the station loses N beacons continuously, it will disrupt the connection and report this reason.</p></td>
</tr>
<tr class="row-odd"><td><p>NO_AP_FOUND</p></td>
<td><p>201</p></td>
<td><p>Espressif-specific Wi-Fi reason code: when the station fails to scan the target AP, this reason code will be reported. In case of security mismatch or station's configuration mismatch, new reason codes NO_AP_FOUND_XXX will be reported.</p></td>
</tr>
<tr class="row-even"><td><p>AUTH_FAIL</p></td>
<td><p>202</p></td>
<td><p>Espressif-specific Wi-Fi reason code: the authentication fails, but not because of a timeout.</p></td>
</tr>
<tr class="row-odd"><td><p>ASSOC_FAIL</p></td>
<td><p>203</p></td>
<td><p>Espressif-specific Wi-Fi reason code: the association fails, but not because of DISASSOC_DUE_TO_INACTIVITY or ASSOC_TOOMANY.</p></td>
</tr>
<tr class="row-even"><td><p>HANDSHAKE_TIMEOUT</p></td>
<td><p>204</p></td>
<td><p>Espressif-specific Wi-Fi reason code: the handshake fails for the same reason as that in WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT.</p></td>
</tr>
<tr class="row-odd"><td><p>CONNECTION_FAIL</p></td>
<td><p>205</p></td>
<td><p>Espressif-specific Wi-Fi reason code: the connection to the AP has failed.</p></td>
</tr>
<tr class="row-even"><td><p>AP_TSF_RESET</p></td>
<td><p>206</p></td>
<td><p>Espressif-specific Wi-Fi reason code: the disconnection happened due to AP's TSF reset.</p></td>
</tr>
<tr class="row-odd"><td><p>ROAMING</p></td>
<td><p>207</p></td>
<td><p>Espressif-specific Wi-Fi reason code: the station is roaming to another AP, this reason code is just for info, station will automatically move to another AP.</p></td>
</tr>
<tr class="row-even"><td><p>ASSOC_COMEBACK_TIME_TOO_LONG</p></td>
<td><p>208</p></td>
<td><p>Espressif-specific Wi-Fi reason code: This reason code will be reported when Assoc comeback time in association response is too high.</p></td>
</tr>
<tr class="row-odd"><td><p>SA_QUERY_TIMEOUT</p></td>
<td><p>209</p></td>
<td><p>Espressif-specific Wi-Fi reason code: This reason code will be reported when AP did not reply of SA query sent by ESP station.</p></td>
</tr>
<tr class="row-even"><td><p>NO_AP_FOUND_SECURITY</p></td>
<td><p>210</p></td>
<td><p>Espressif-specific Wi-Fi reason code: NO_AP_FOUND_W_COMPATIBLE_SECURITY will be reported if an AP that fits identifying criteria (e.g. ssid) is found but the connection is rejected due to incompatible security configuration. These situations could be:</p>
<ul class="simple">
<li><p>The Access Point is offering WEP security, but our station's password is not WEP-compliant.</p></li>
<li><p>The station is configured in Open mode; however, the Access Point is broadcasting in secure mode.</p></li>
<li><p>The Access Point uses Enterprise security, but we haven't set up the corresponding enterprise configuration, and vice versa.</p></li>
<li><p>SAE-PK is configured in the station configuration, but the Access Point does not support SAE-PK.</p></li>
<li><p>SAE-H2E is configured in the station configuration; however, the AP only supports WPA3-PSK or WPA3-WPA2-PSK.</p></li>
<li><p>The station is configured in secure mode (Password or Enterprise mode); however, an Open AP is found during the scan.</p></li>
<li><p>SAE HnP is configured in the station configuration; however, the AP supports H2E only.</p></li>
<li><p>H2E is disabled in the station configuration; however, the AP is WPA3-EXT-PSK, which requires H2E support.</p></li>
<li><p>The Access Point requires PMF, but the station is not configured for PMF capable/required.</p></li>
<li><p>The station configuration requires PMF, but the AP is not configured for PMF capable/required.</p></li>
<li><p>The Access Point is using unsupported group management/pairwise ciphers.</p></li>
<li><p>OWE is not enabled in the station configuration, but the discovered AP is using OWE only mode.</p></li>
<li><p>The Access Point is broadcasting an invalid RSNXE in its beacons.</p></li>
<li><p>The Access Point is in Independent BSS mode.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>NO_AP_FOUND_AUTHMODE</p></td>
<td><p>211</p></td>
<td><p>Espressif-specific Wi-Fi reason code: NO_AP_FOUND_IN_AUTHMODE_THRESHOLD will be reported if an AP that fit identifying criteria (e.g. ssid) is found but the authmode threhsold set in the wifi_config_t is not met.</p></td>
</tr>
<tr class="row-even"><td><p>NO_AP_FOUND_RSSI</p></td>
<td><p>212</p></td>
<td><p>Espressif-specific Wi-Fi reason code: NO_AP_FOUND_IN_RSSI_THRESHOLD will be reported if an AP that fits identifying criteria (e.g. ssid) is found but the RSSI threhsold set in the wifi_config_t is not met.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="wi-fi-reason-code-related-to-wrong-password">
<h3>Wi-Fi Reason code related to wrong password<a class="headerlink" href="#wi-fi-reason-code-related-to-wrong-password" title="Permalink to this heading"></a></h3>
<p>The table below shows the Wi-Fi reason-code may related to wrong password.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 9.1%" />
<col style="width: 18.2%" />
<col style="width: 72.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Reason code</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>4WAY_HANDSHAKE_TIMEOUT</p></td>
<td><p>15</p></td>
<td><p>Four-way handshake times out. Setting wrong password when STA connecting to an encrypted AP.</p></td>
</tr>
<tr class="row-odd"><td><p>NO_AP_FOUND</p></td>
<td><p>201</p></td>
<td><p>This may related to wrong password in the two scenarios:</p>
<ul class="simple">
<li><p>Setting password when STA connecting to an unencrypted AP.</p></li>
<li><p>Does not set password when STA connecting to an encrypted AP.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>HANDSHAKE_TIMEOUT</p></td>
<td><p>204</p></td>
<td><p>Four-way handshake fails.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="wi-fi-reason-code-related-to-low-rssi">
<h3>Wi-Fi Reason code related to low RSSI<a class="headerlink" href="#wi-fi-reason-code-related-to-low-rssi" title="Permalink to this heading"></a></h3>
<p>The table below shows the Wi-Fi reason-code may related to low RSSI.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 9.1%" />
<col style="width: 18.2%" />
<col style="width: 72.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Reason code</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NO_AP_FOUND_IN_RSSI_THRESHOLD</p></td>
<td><p>212</p></td>
<td><p>The station fails to scan the target AP due to low RSSI</p></td>
</tr>
<tr class="row-odd"><td><p>HANDSHAKE_TIMEOUT</p></td>
<td><p>204</p></td>
<td><p>Four-way handshake fails.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="esp32-wi-fi-station-connecting-when-multiple-aps-are-found">
<h2>ESP32 Wi-Fi Station Connecting When Multiple APs Are Found<a class="headerlink" href="#esp32-wi-fi-station-connecting-when-multiple-aps-are-found" title="Permalink to this heading"></a></h2>
<p>This scenario is similar as <a class="reference internal" href="#esp32-wi-fi-station-connecting-scenario">ESP32 Wi-Fi Station Connecting Scenario</a>. The difference is that the station will not raise the event <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a> unless it fails to connect all of the found APs.</p>
</section>
<section id="wi-fi-reconnect">
<h2>Wi-Fi Reconnect<a class="headerlink" href="#wi-fi-reconnect" title="Permalink to this heading"></a></h2>
<p>The station may disconnect due to many reasons, e.g., the connected AP is restarted. It is the application's responsibility to reconnect. The recommended reconnection strategy is to call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a> on receiving event <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a>.</p>
<p>Sometimes the application needs more complex reconnection strategy:</p>
<ul class="simple">
<li><p>If the disconnect event is raised because the <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_disconnectv" title="esp_wifi_disconnect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_disconnect()</span></code></a> is called, the application may not want to do the reconnection.</p></li>
<li><p>If the <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_scan_startPK18wifi_scan_config_tb" title="esp_wifi_scan_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_scan_start()</span></code></a> may be called at anytime, a better reconnection strategy is necessary. Refer to <a class="reference internal" href="#scan-when-wi-fi-is-connecting">Scan When Wi-Fi Is Connecting</a>.</p></li>
</ul>
<p>Another thing that need to be considered is that the reconnection may not connect the same AP if there are more than one APs with the same SSID. The reconnection always select current best APs to connect.</p>
</section>
<section id="wi-fi-beacon-timeout">
<h2>Wi-Fi Beacon Timeout<a class="headerlink" href="#wi-fi-beacon-timeout" title="Permalink to this heading"></a></h2>
<p>The beacon timeout mechanism is used by ESP32 station to detect whether the AP is alive or not. If the station does not receive the beacon of the connected AP within the inactive time, the beacon timeout happens. The application can set inactive time via API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv426esp_wifi_set_inactive_time16wifi_interface_t8uint16_t" title="esp_wifi_set_inactive_time"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_inactive_time()</span></code></a>.</p>
<p>After the beacon times out, the station sends 5 probe requests to the AP. If still no probe response or beacon is received from AP, the station disconnects from the AP and raises the event <a class="reference internal" href="#wifi-event-sta-disconnected">WIFI_EVENT_STA_DISCONNECTED</a>.</p>
<p>It should be considered that the timer used for beacon timeout will be reset during the scanning process. It means that the scan process will affect the triggering of the event <a class="reference internal" href="#wifi-event-sta-beacon-timeout">WIFI_EVENT_STA_BEACON_TIMEOUT</a>.</p>
</section>
<section id="esp32-wi-fi-configuration">
<h2>ESP32 Wi-Fi Configuration<a class="headerlink" href="#esp32-wi-fi-configuration" title="Permalink to this heading"></a></h2>
<p>All configurations will be stored into flash when the Wi-Fi NVS is enabled; otherwise, refer to <a class="reference internal" href="#wi-fi-nvs-flash">Wi-Fi NVS Flash</a>.</p>
<section id="wi-fi-mode">
<h3>Wi-Fi Mode<a class="headerlink" href="#wi-fi-mode" title="Permalink to this heading"></a></h3>
<p>Call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_set_mode11wifi_mode_t" title="esp_wifi_set_mode"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_mode()</span></code></a> to set the Wi-Fi mode.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23.1%" />
<col style="width: 76.9%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Mode</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">WIFI_MODE_NULL</span></code></p></td>
<td><p>NULL mode: in this mode, the internal data struct is not allocated to the station and the AP, while both the station and AP interfaces are not initialized for RX/TX Wi-Fi data. Generally, this mode is used for Sniffer, or when you only want to stop both the station and the AP without calling <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv415esp_wifi_deinitv" title="esp_wifi_deinit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_deinit()</span></code></a> to unload the whole Wi-Fi driver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">WIFI_MODE_STA</span></code></p></td>
<td><p>Station mode: in this mode, <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a> will init the internal station data, while the station’s interface is ready for the RX and TX Wi-Fi data. After <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_connectv" title="esp_wifi_connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_connect()</span></code></a>, the station will connect to the target AP.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">WIFI_MODE_AP</span></code></p></td>
<td><p>AP mode: in this mode, <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a> will init the internal AP data, while the AP’s interface is ready for RX/TX Wi-Fi data. Then, the Wi-Fi driver starts broad-casting beacons, and the AP is ready to get connected to other stations.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">WIFI_MODE_APSTA</span></code></p></td>
<td><p>Station/AP coexistence mode: in this mode, <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a> will simultaneously initialize both the station and the AP. This is done in station mode and AP mode. Please note that the channel of the external AP, which the ESP station is connected to, has higher priority over the ESP AP channel.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="station-basic-configuration">
<h3>Station Basic Configuration<a class="headerlink" href="#station-basic-configuration" title="Permalink to this heading"></a></h3>
<p>API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_set_config16wifi_interface_tP13wifi_config_t" title="esp_wifi_set_config"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_config()</span></code></a> can be used to configure the station. And the configuration will be stored in NVS. The table below describes the fields in detail.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23.1%" />
<col style="width: 76.9%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ssid</p></td>
<td><p>This is the SSID of the target AP, to which the station wants to connect.</p></td>
</tr>
<tr class="row-odd"><td><p>password</p></td>
<td><p>Password of the target AP.</p></td>
</tr>
<tr class="row-even"><td><p>scan_method</p></td>
<td><p>For <code class="docutils literal notranslate"><span class="pre">WIFI_FAST_SCAN</span></code> scan, the scan ends when the first matched AP is found. For <code class="docutils literal notranslate"><span class="pre">WIFI_ALL_CHANNEL_SCAN</span></code>, the scan finds all matched APs on all channels. The default scan is <code class="docutils literal notranslate"><span class="pre">WIFI_FAST_SCAN</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>bssid_set</p></td>
<td><p>If bssid_set is 0, the station connects to the AP whose SSID is the same as the field “ssid”, while the field “bssid” is ignored. In all other cases, the station connects to the AP whose SSID is the same as the “ssid” field, while its BSSID is the same the “bssid” field .</p></td>
</tr>
<tr class="row-even"><td><p>bssid</p></td>
<td><p>This is valid only when bssid_set is 1; see field “bssid_set”.</p></td>
</tr>
<tr class="row-odd"><td><p>channel</p></td>
<td><p>If the channel is 0, the station scans the channel 1 ~ N to search for the target AP; otherwise, the station starts by scanning the channel whose value is the same as that of the “channel” field, and then scans the channel 1 ~ N but skip the specific channel to find the target AP. For example, if the channel is 3, the scan order will be 3, 1, 2, 4,..., N. If you do not know which channel the target AP is running on, set it to 0.</p></td>
</tr>
<tr class="row-even"><td><p>sort_method</p></td>
<td><p>This field is only for <code class="docutils literal notranslate"><span class="pre">WIFI_ALL_CHANNEL_SCAN</span></code>.</p>
<p>If the sort_method is <code class="docutils literal notranslate"><span class="pre">WIFI_CONNECT_AP_BY_SIGNAL</span></code>, all matched APs are sorted by signal, and the AP with the best signal will be connected firstly. For example, the station wants to connect an AP whose SSID is “apxx”. If the scan finds two APs whose SSID equals to “apxx”, and the first AP’s signal is -90 dBm while the second AP’s signal is -30 dBm, the station connects the second AP firstly, and it would not connect the first one unless it fails to connect the second one.</p>
<p>If the sort_method is <code class="docutils literal notranslate"><span class="pre">WIFI_CONNECT_AP_BY_SECURITY</span></code>, all matched APs are sorted by security. For example, the station wants to connect an AP whose SSID is “apxx”. If the scan finds two APs whose SSID is “apxx”, and the security of the first found AP is open while the second one is WPA2, the station connects to the second AP firstly, and it would not connect the first one unless it fails to connect the second one.</p>
</td>
</tr>
<tr class="row-odd"><td><p>threshold</p></td>
<td><p>The threshold is used to filter the found AP. If the RSSI or security mode is less than the configured threshold, the AP will be discarded.</p>
<p>If the RSSI is set to 0, it means the default threshold and the default RSSI threshold are -127 dBm. If the authmode threshold is set to 0, it means the default threshold and the default authmode threshold are open.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>WEP/WPA security modes are deprecated in IEEE 802.11-2016 specifications and are recommended not to be used. These modes can be rejected using authmode threshold by setting threshold as WPA2 by threshold.authmode as <code class="docutils literal notranslate"><span class="pre">WIFI_AUTH_WPA2_PSK</span></code>.</p>
</div>
</section>
<section id="ap-basic-configuration">
<h3>AP Basic Configuration<a class="headerlink" href="#ap-basic-configuration" title="Permalink to this heading"></a></h3>
<p>API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_set_config16wifi_interface_tP13wifi_config_t" title="esp_wifi_set_config"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_config()</span></code></a> can be used to configure the AP. And the configuration will be stored in NVS. The table below describes the fields in detail.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21.4%" />
<col style="width: 78.6%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ssid</p></td>
<td><p>SSID of AP; if the ssid[0] is 0xFF and ssid[1] is 0xFF, the AP defaults the SSID to <code class="docutils literal notranslate"><span class="pre">ESP_aabbcc</span></code>, where “aabbcc” is the last three bytes of the AP MAC.</p></td>
</tr>
<tr class="row-odd"><td><p>password</p></td>
<td><p>Password of AP; if the auth mode is <code class="docutils literal notranslate"><span class="pre">WIFI_AUTH_OPEN</span></code>, this field will be ignored.</p></td>
</tr>
<tr class="row-even"><td><p>ssid_len</p></td>
<td><p>Length of SSID; if ssid_len is 0, check the SSID until there is a termination character. If ssid_len &gt; 32, change it to 32; otherwise, set the SSID length according to ssid_len.</p></td>
</tr>
<tr class="row-odd"><td><p>channel</p></td>
<td><p>Channel of AP; if the channel is out of range, the Wi-Fi driver defaults to channel 1. So, please make sure the channel is within the required range. For more details, refer to <a class="reference internal" href="#wi-fi-country-code">Wi-Fi Country Code</a>.</p></td>
</tr>
<tr class="row-even"><td><p>authmode</p></td>
<td><p>Auth mode of ESP AP; currently, ESP AP does not support AUTH_WEP. If the authmode is an invalid value, AP defaults the value to <code class="docutils literal notranslate"><span class="pre">WIFI_AUTH_OPEN</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>ssid_hidden</p></td>
<td><p>If ssid_hidden is 1, AP does not broadcast the SSID; otherwise, it does broadcast the SSID.</p></td>
</tr>
<tr class="row-even"><td><p>max_connection</p></td>
<td><p>The max number of stations allowed to connect in, the default value is 10. ESP Wi-Fi supports up to 15 (<code class="docutils literal notranslate"><span class="pre">ESP_WIFI_MAX_CONN_NUM</span></code>) Wi-Fi connections. Please note that ESP AP and ESP-NOW share the same encryption hardware keys, so the max_connection parameter will be affected by the <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-espnow-max-encrypt-num"><span class="std std-ref">CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM</span></a>. The total number of encryption hardware keys is 17, if <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-espnow-max-encrypt-num"><span class="std std-ref">CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM</span></a> &lt;= 2, the max_connection can be set up to 15, otherwise the max_connection can be set up to (17 - <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-espnow-max-encrypt-num"><span class="std std-ref">CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM</span></a>).</p></td>
</tr>
<tr class="row-odd"><td><p>beacon_interval</p></td>
<td><p>Beacon interval; the value is 100 ~ 60000 ms, with default value being 100 ms. If the value is out of range, AP defaults it to 100 ms.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="wi-fi-protocol-mode">
<h3>Wi-Fi Protocol Mode<a class="headerlink" href="#wi-fi-protocol-mode" title="Permalink to this heading"></a></h3>
<p>Currently, the ESP-IDF supports the following protocol modes:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21.4%" />
<col style="width: 78.6%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Protocol Mode</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>802.11b</p></td>
<td><p>Call <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_protocol(ifx,</span> <span class="pre">WIFI_PROTOCOL_11B)</span></code> to set the station/AP to 802.11b-only mode.</p></td>
</tr>
<tr class="row-odd"><td><p>802.11bg</p></td>
<td><p>Call <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_protocol(ifx,</span> <span class="pre">WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G)</span></code> to set the station/AP to 802.11bg mode.</p></td>
</tr>
<tr class="row-even"><td><p>802.11g</p></td>
<td><p>Call <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_protocol(ifx,</span> <span class="pre">WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G)</span></code> and esp_wifi_config_11b_rate(ifx, true) to set the station/AP to 802.11g mode.</p></td>
</tr>
<tr class="row-odd"><td><p>802.11bgn</p></td>
<td><p>Call <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_protocol(ifx,</span> <span class="pre">WIFI_PROTOCOL_11B|</span> <span class="pre">WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)</span></code> to set the station/ AP to BGN mode.</p></td>
</tr>
<tr class="row-even"><td><p>802.11gn</p></td>
<td><p>Call <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_protocol(ifx,</span> <span class="pre">WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)</span></code> and esp_wifi_config_11b_rate(ifx, true) to set the station/AP to 802.11gn mode.</p></td>
</tr>
<tr class="row-odd"><td><p>802.11 BGNLR</p></td>
<td><p>Call <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_protocol(ifx,</span> <span class="pre">WIFI_PROTOCOL_11B|</span> <span class="pre">WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_LR)</span></code> to set the station/AP to BGN and the LR mode.</p></td>
</tr>
<tr class="row-even"><td><p>802.11 LR</p></td>
<td><p>Call <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_protocol(ifx,</span> <span class="pre">WIFI_PROTOCOL_LR)</span></code> to set the station/AP only to the LR mode.</p>
<p><strong>This mode is an Espressif-patented mode which can achieve a one-kilometer line of sight range. Please make sure both the station and the AP are connected to an ESP device.</strong></p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="long-range-lr">
<h3>Long Range (LR)<a class="headerlink" href="#long-range-lr" title="Permalink to this heading"></a></h3>
<p>Long Range (LR) mode is an Espressif-patented Wi-Fi mode which can achieve a one-kilometer line of sight range. Compared to the traditional 802.11b mode, it has better reception sensitivity, stronger anti-interference ability, and longer transmission distance.</p>
<section id="lr-compatibility">
<h4>LR Compatibility<a class="headerlink" href="#lr-compatibility" title="Permalink to this heading"></a></h4>
<p>Since LR is Espressif-unique Wi-Fi mode, only ESP32 chip series devices (except ESP32-C2) can transmit and receive the LR data. In other words, the ESP32 chip series devices (except ESP32-C2) should NOT transmit the data in LR data rate if the connected device does not support LR. The application can achieve this by configuring a suitable Wi-Fi mode. If the negotiated mode supports LR, the ESP32 chip series devices (except ESP32-C2) may transmit data in LR rate. Otherwise, ESP32 chip series devices (except ESP32-C2) will transmit all data in the traditional Wi-Fi data rate.</p>
<p>The following table depicts the Wi-Fi mode negotiation:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>APSTA</p></th>
<th class="head"><p>BGN</p></th>
<th class="head"><p>BG</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>BGNLR</p></th>
<th class="head"><p>BGLR</p></th>
<th class="head"><p>BLR</p></th>
<th class="head"><p>LR</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BGN</p></td>
<td><p>BGN</p></td>
<td><p>BG</p></td>
<td><p>B</p></td>
<td><p>BGN</p></td>
<td><p>BG</p></td>
<td><p>B</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>BG</p></td>
<td><p>BG</p></td>
<td><p>BG</p></td>
<td><p>B</p></td>
<td><p>BG</p></td>
<td><p>BG</p></td>
<td><p>B</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>B</p></td>
<td><p>B</p></td>
<td><p>B</p></td>
<td><p>B</p></td>
<td><p>B</p></td>
<td><p>B</p></td>
<td><p>B</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>BGNLR</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>BGNLR</p></td>
<td><p>BGLR</p></td>
<td><p>BLR</p></td>
<td><p>LR</p></td>
</tr>
<tr class="row-even"><td><p>BGLR</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>BGLR</p></td>
<td><p>BGLR</p></td>
<td><p>BLR</p></td>
<td><p>LR</p></td>
</tr>
<tr class="row-odd"><td><p>BLR</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>BLR</p></td>
<td><p>BLR</p></td>
<td><p>BLR</p></td>
<td><p>LR</p></td>
</tr>
<tr class="row-even"><td><p>LR</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>LR</p></td>
<td><p>LR</p></td>
<td><p>LR</p></td>
<td><p>LR</p></td>
</tr>
</tbody>
</table>
<p>In the above table, the row is the Wi-Fi mode of AP and the column is the Wi-Fi mode of station. The &quot;-&quot; indicates Wi-Fi mode of the AP and station are not compatible.</p>
<p>According to the table, the following conclusions can be drawn:</p>
<ul class="simple">
<li><p>For LR-enabled AP of ESP32, it is incompatible with traditional 802.11 mode, because the beacon is sent in LR mode.</p></li>
<li><p>For LR-enabled station of ESP32 whose mode is NOT LR-only mode, it is compatible with traditional 802.11 mode.</p></li>
<li><p>If both station and AP are ESP32 series chips devices (except ESP32-C2) and both of them have enabled LR mode, the negotiated mode supports LR.</p></li>
</ul>
<p>If the negotiated Wi-Fi mode supports both traditional 802.11 mode and LR mode, it is the Wi-Fi driver's responsibility to automatically select the best data rate in different Wi-Fi modes and the application can ignore it.</p>
</section>
<section id="lr-impacts-to-traditional-wi-fi-device">
<h4>LR Impacts to Traditional Wi-Fi Device<a class="headerlink" href="#lr-impacts-to-traditional-wi-fi-device" title="Permalink to this heading"></a></h4>
<p>The data transmission in LR rate has no impacts on the traditional Wi-Fi device because:</p>
<ul class="simple">
<li><p>The CCA and backoff process in LR mode are consistent with 802.11 specification.</p></li>
<li><p>The traditional Wi-Fi device can detect the LR signal via CCA and do backoff.</p></li>
</ul>
<p>In other words, the transmission impact in LR mode is similar to that in 802.11b mode.</p>
</section>
<section id="lr-transmission-distance">
<h4>LR Transmission Distance<a class="headerlink" href="#lr-transmission-distance" title="Permalink to this heading"></a></h4>
<p>The reception sensitivity gain of LR is about 4 dB larger than that of the traditional 802.11b mode. Theoretically, the transmission distance is about 2 to 2.5 times the distance of 11B.</p>
</section>
<section id="lr-throughput">
<h4>LR Throughput<a class="headerlink" href="#lr-throughput" title="Permalink to this heading"></a></h4>
<p>The LR rate has very limited throughput, because the raw PHY data rate LR is 1/2 Mbps and 1/4 Mbps.</p>
</section>
<section id="when-to-use-lr">
<h4>When to Use LR<a class="headerlink" href="#when-to-use-lr" title="Permalink to this heading"></a></h4>
<p>The general conditions for using LR are:</p>
<ul class="simple">
<li><p>Both the AP and station are Espressif devices.</p></li>
<li><p>Long distance Wi-Fi connection and data transmission is required.</p></li>
<li><p>Data throughput requirements are very small, such as remote device control.</p></li>
</ul>
</section>
</section>
<section id="wi-fi-country-code">
<h3>Wi-Fi Country Code<a class="headerlink" href="#wi-fi-country-code" title="Permalink to this heading"></a></h3>
<p>Call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv420esp_wifi_set_countryPK14wifi_country_t" title="esp_wifi_set_country"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_country()</span></code></a> to set the country info. The table below describes the fields in detail. Please consult local 2.4 GHz RF operating regulations before configuring these fields.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21.4%" />
<col style="width: 78.6%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cc[3]</p></td>
<td><p>Country code string. This attribute identifies the country or noncountry entity in which the station/AP is operating. If it is a country, the first two octets of this string is the two-character country info as described in the document ISO/IEC3166-1. The third octet is one of the following:</p>
<ul class="simple">
<li><p>an ASCII space character, which means the regulations under which the station/AP is operating encompass all environments for the current frequency band in the country.</p></li>
<li><p>an ASCII ‘O’ character, which means the regulations under which the station/AP is operating are for an outdoor environment only.</p></li>
<li><p>an ASCII ‘I’ character, which means the regulations under which the station/AP is operating are for an indoor environment only.</p></li>
<li><p>an ASCII ‘X’ character, which means the station/AP is operating under a noncountry entity. The first two octets of the noncountry entity is two ASCII ‘XX’ characters.</p></li>
<li><p>the binary representation of the Operating Class table number currently in use. Refer to Annex E of IEEE Std 802.11-2020.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>schan</p></td>
<td><p>Start channel. It is the minimum channel number of the regulations under which the station/AP can operate.</p></td>
</tr>
<tr class="row-even"><td><p>nchan</p></td>
<td><p>Total number of channels as per the regulations. For example, if the schan=1, nchan=13, then the station/AP can send data from channel 1 to 13.</p></td>
</tr>
<tr class="row-odd"><td><p>policy</p></td>
<td><p>Country policy. This field controls which country info will be used if the configured country info is in conflict with the connected AP’s. For more details on related policies, see the following section.</p></td>
</tr>
</tbody>
</table>
<p>The default country info is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wifi_country_t</span> <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">.</span><span class="n">cc</span> <span class="o">=</span> <span class="s2">&quot;01&quot;</span><span class="p">,</span>
    <span class="o">.</span><span class="n">schan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">nchan</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
    <span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">WIFI_COUNTRY_POLICY_AUTO</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If the Wi-Fi Mode is station/AP coexist mode, they share the same configured country info. Sometimes, the country info of AP, to which the station is connected, is different from the country info of configured. For example, the configured station has country info:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wifi_country_t</span> <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">.</span><span class="n">cc</span> <span class="o">=</span> <span class="s2">&quot;JP&quot;</span><span class="p">,</span>
    <span class="o">.</span><span class="n">schan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">nchan</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
    <span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">WIFI_COUNTRY_POLICY_AUTO</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>but the connected AP has country info:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wifi_country_t</span> <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">.</span><span class="n">cc</span> <span class="o">=</span> <span class="s2">&quot;CN&quot;</span><span class="p">,</span>
    <span class="o">.</span><span class="n">schan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">.</span><span class="n">nchan</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>then country info of connected AP's is used.</p>
<p>The following table depicts which country info is used in different Wi-Fi modes and different country policies, and it also describes the impact on active scan.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23.1%" />
<col style="width: 23.1%" />
<col style="width: 53.8%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Wi-Fi Mode</p></th>
<th class="head"><p>Policy</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Station</p></td>
<td><p>WIFI_COUNTRY_POLICY_AUTO</p></td>
<td><p>If the connected AP has country IE in its beacon, the country info equals to the country info in beacon. Otherwise, use the default country info.</p>
<p>For scan:</p>
<blockquote>
<div><p>Use active scan from 1 to 11 and use passive scan from 12 to 14.</p>
</div></blockquote>
<p>Always keep in mind that if an AP with hidden SSID and station is set to a passive scan channel, the passive scan will not find it. In other words, if the application hopes to find the AP with hidden SSID in every channel, the policy of country info should be configured to WIFI_COUNTRY_POLICY_MANUAL.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Station</p></td>
<td><p>WIFI_COUNTRY_POLICY_MANUAL</p></td>
<td><p>Always use the configured country info.</p>
<p>For scan:</p>
<blockquote>
<div><p>Use active scan from schan to schan+nchan-1.</p>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>AP</p></td>
<td><p>WIFI_COUNTRY_POLICY_AUTO</p></td>
<td><p>Always use the configured country info.</p></td>
</tr>
<tr class="row-odd"><td><p>AP</p></td>
<td><p>WIFI_COUNTRY_POLICY_MANUAL</p></td>
<td><p>Always use the configured country info.</p></td>
</tr>
<tr class="row-even"><td><p>Station/AP-coexistence</p></td>
<td><p>WIFI_COUNTRY_POLICY_AUTO</p></td>
<td><p>Station: Same as station mode with policy WIFI_COUNTRY_POLICY_AUTO.
AP: If the station does not connect to any external AP, the AP uses the configured country info. If the station connects to an external AP, the AP has the same country info as the station.</p></td>
</tr>
<tr class="row-odd"><td><p>Station/AP-coexistence</p></td>
<td><p>WIFI_COUNTRY_POLICY_MANUAL</p></td>
<td><p>Station: Same as station mode with policy WIFI_COUNTRY_POLICY_MANUAL.
AP: Same as AP mode with policy WIFI_COUNTRY_POLICY_MANUAL.</p></td>
</tr>
</tbody>
</table>
<section id="home-channel">
<h4>Home Channel<a class="headerlink" href="#home-channel" title="Permalink to this heading"></a></h4>
<p>In AP mode, the home channel is defined as the AP channel. In station mode, home channel is defined as the channel of AP which the station is connected to. In station/AP-coexistence mode, the home channel of AP and station must be the same, and if they are different, the station's home channel is always in priority. For example, assume that the AP is on channel 6, and the station connects to an AP whose channel is 9. Since the station's home channel has higher priority, the AP needs to switch its channel from 6 to 9 to make sure that it has the same home channel as the station. While switching channel, the ESP32 in AP mode will notify the connected stations about the channel migration using a Channel Switch Announcement (CSA). Station that supports channel switching will transit without disconnecting and reconnecting to the AP.</p>
</section>
</section>
<section id="wi-fi-vendor-ie-configuration">
<h3>Wi-Fi Vendor IE Configuration<a class="headerlink" href="#wi-fi-vendor-ie-configuration" title="Permalink to this heading"></a></h3>
<p>By default, all Wi-Fi management frames are processed by the Wi-Fi driver, and the application can ignore them. However, some applications may have to handle the beacon, probe request, probe response, and other management frames. For example, if you insert some vendor-specific IE into the management frames, it is only the management frames which contain this vendor-specific IE that will be processed. In ESP32, <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv422esp_wifi_set_vendor_ieb21wifi_vendor_ie_type_t19wifi_vendor_ie_id_tPKv" title="esp_wifi_set_vendor_ie"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_vendor_ie()</span></code></a> and <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv425esp_wifi_set_vendor_ie_cb18esp_vendor_ie_cb_tPv" title="esp_wifi_set_vendor_ie_cb"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_vendor_ie_cb()</span></code></a> are responsible for this kind of tasks.</p>
</section>
</section>
<section id="wi-fi-easy-connect-dpp">
<h2>Wi-Fi Easy Connect™ (DPP)<a class="headerlink" href="#wi-fi-easy-connect-dpp" title="Permalink to this heading"></a></h2>
<p>Wi-Fi Easy Connect<sup>TM</sup> (or Device Provisioning Protocol) is a secure and standardized provisioning protocol for configuring Wi-Fi devices. More information can be found in <a class="reference internal" href="../api-reference/network/esp_dpp.html"><span class="doc">esp_dpp</span></a>.</p>
</section>
<section id="wpa2-enterprise">
<h2>WPA2-Enterprise<a class="headerlink" href="#wpa2-enterprise" title="Permalink to this heading"></a></h2>
<p>WPA2-Enterprise is the secure authentication mechanism for enterprise wireless networks. It uses RADIUS server for authentication of network users before connecting to the Access Point. The authentication process is based on 802.1X policy and comes with different Extended Authentication Protocol (EAP) methods such as TLS, TTLS, and PEAP. RADIUS server authenticates the users based on their credentials (username and password), digital certificates, or both. When ESP32 in station mode tries to connect an AP in enterprise mode, it sends authentication request to AP which is sent to RADIUS server by AP for authenticating the station. Based on different EAP methods, the parameters can be set in configuration which can be opened using <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">menuconfig</span></code>. WPA2_Enterprise is supported by ESP32 only in station mode.</p>
<p>For establishing a secure connection, AP and station negotiate and agree on the best possible cipher suite to be used. ESP32 supports 802.1X/EAP (WPA) method of AKM and Advanced encryption standard with Counter Mode Cipher Block Chaining Message Authentication protocol (AES-CCM) cipher suite. It also supports the cipher suites supported by mbedtls if <cite>USE_MBEDTLS_CRYPTO</cite> flag is set.</p>
<dl class="simple">
<dt>ESP32 currently supports the following EAP methods:</dt><dd><ul class="simple">
<li><p>EAP-TLS: This is a certificate-based method and only requires SSID and EAP-IDF.</p></li>
<li><p>PEAP: This is a Protected EAP method. Username and Password are mandatory.</p></li>
<li><dl class="simple">
<dt>EAP-TTLS: This is a credential-based method. Only server authentication is mandatory while user authentication is optional. Username and Password are mandatory. It supports different Phase2 methods, such as:</dt><dd><ul>
<li><p>PAP: Password Authentication Protocol.</p></li>
<li><p>CHAP: Challenge Handshake Authentication Protocol.</p></li>
<li><p>MSCHAP and MSCHAP-V2.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>EAP-FAST: This is an authentication method based on Protected Access Credentials (PAC) which also uses identity and password. Currently, USE_MBEDTLS_CRYPTO flag should be disabled to use this feature.</p></li>
</ul>
</dd>
</dl>
<p>Detailed information on creating certificates and how to run wpa2_enterprise example on ESP32 can be found in <a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/wifi/wifi_enterprise">wifi/wifi_enterprise</a>.</p>
</section>
<section id="wi-fi-awaretm-nan">
<h2>Wi-Fi Aware<sup>TM</sup> (NAN)<a class="headerlink" href="#wi-fi-awaretm-nan" title="Permalink to this heading"></a></h2>
<p>Wi-Fi Aware<sup>TM</sup> or NAN (Neighbor Awareness Networking) is a protocol that allows Wi-Fi devices to discover services in their proximity. NAN uses direct device-to-device communication and does not require any Internet or AP connection.</p>
<p>Multiple NAN devices in the vicinity will form a NAN cluster which allows them to communicate with each other. NAN devices in a cluster synchronise their clocks and listen to each other periodically on Channel 6. Devices can advertise (Publish) or seek for (Subscribe) services within their NAN Cluster using Service Discovery protocols. Matching of services is done by service name and optionally matching filters. Once a Subscriber gets a match with a Publisher, it can either send a message (Follow-up) or establish a datapath (NDP) with the Publisher. After NDP is setup both devices will obtain an IPv6 address and can use it for communication.</p>
<p>Please note that NAN Datapath security is not supported i.e., the data packets will go out unencrypted. NAN uses a separate interface for Discovery and Datapath, which is other than that used for STA and AP. NAN operates in standalone mode, which means co-existence with STA or AP interface is not supported.</p>
<p>Refer to ESP-IDF examples <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/examples/wifi/wifi_aware/nan_publisher/README.md">examples/wifi/wifi_aware/nan_publisher/README.md</a> and <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/examples/wifi/wifi_aware/nan_subscriber/README.md">examples/wifi/wifi_aware/nan_subscriber/README.md</a> to setup a NAN Publisher and Subscriber.</p>
</section>
<section id="wireless-network-management">
<h2>Wireless Network Management<a class="headerlink" href="#wireless-network-management" title="Permalink to this heading"></a></h2>
<p>Wireless Network Management allows client devices to exchange information about the network topology, including information related to RF environment. This makes each client network-aware, facilitating overall improvement in the performance of the wireless network. It is part of 802.11v specification. It also enables the client to support Network assisted Roaming.
- Network assisted Roaming: Enables WLAN to send messages to associated clients, resulting clients to associate with APs with better link metrics. This is useful for both load balancing and in directing poorly connected clients.</p>
<p>Current implementation of 802.11v includes support for BSS transition management frames.</p>
</section>
<section id="radio-resource-measurement">
<h2>Radio Resource Measurement<a class="headerlink" href="#radio-resource-measurement" title="Permalink to this heading"></a></h2>
<p>Radio Resource Measurement (802.11k) is intended to improve the way traffic is distributed within a network. In a WLAN, each device normally connects to the access point (AP) that provides the strongest signal. Depending on the number and geographic locations of the subscribers, this arrangement can sometimes lead to excessive demand on one AP and underutilization of others, resulting in degradation of overall network performance. In a network conforming to 802.11k, if the AP having the strongest signal is loaded to its full capacity, a wireless device can be moved to one of the underutilized APs. Even though the signal may be weaker, the overall throughput is greater because more efficient use is made of the network resources.</p>
<p>Current implementation of 802.11k includes support for beacon measurement report, link measurement report, and neighbor request.</p>
<p>Refer ESP-IDF example <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/examples/wifi/roaming/README.md">examples/wifi/roaming/README.md</a> to set up and use these APIs. Example code only demonstrates how these APIs can be used, and the application should define its own algorithm and cases as required.</p>
</section>
<section id="fast-bss-transition">
<h2>Fast BSS Transition<a class="headerlink" href="#fast-bss-transition" title="Permalink to this heading"></a></h2>
<p>Fast BSS transition (802.11R FT), is a standard to permit continuous connectivity aboard wireless devices in motion, with fast and secure client transitions from one Basic Service Set (abbreviated BSS, and also known as a base station or more colloquially, an access point) to another performed in a nearly seamless manner <strong>avoiding 802.1i 4 way handshake</strong> . 802.11R specifies transitions between access points by redefining the security key negotiation protocol, allowing both the negotiation and requests for wireless resources to occur in parallel. The key derived from the server to be cached in the wireless network, so that a reasonable number of future connections can be based on the cached key, avoiding the 802.1X process</p>
<p>ESP32 station supports FT for WPA2-PSK networks. Do note that ESP32 station only support FT over the air protocol only.</p>
<p>A config option <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-11r-support"><span class="std std-ref">CONFIG_ESP_WIFI_11R_SUPPORT</span></a> and configuration parameter <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">ft_enabled</span></code> in <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417wifi_sta_config_t" title="wifi_sta_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wifi_sta_config_t</span></code></a> is provided to enable 802.11R support for station. Refer ESP-IDF example <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/examples/wifi/roaming/README.md">examples/wifi/roaming/README.md</a> for further details.</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>Distance measurement using RTT is not accurate, and factors such as RF interference, multi-path travel, antenna orientation, and lack of calibration increase these inaccuracies. For better results, it is suggested to perform FTM between two ESP32 chip series devices as station and AP.</p>
<p>Refer to ESP-IDF example <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/examples/wifi/ftm/README.md">examples/wifi/ftm/README.md</a> for steps on how to set up and perform FTM.</p>
</div>
</section>
<section id="esp32-wi-fi-power-saving-mode">
<h2>ESP32 Wi-Fi Power-saving Mode<a class="headerlink" href="#esp32-wi-fi-power-saving-mode" title="Permalink to this heading"></a></h2>
<p>This subsection will briefly introduce the concepts and usage related to Wi-Fi Power Saving Mode, for a more detailed introduction please refer to the <a class="reference internal" href="low-power-mode/index.html"><span class="doc">Low Power Mode User Guide</span></a></p>
<section id="station-sleep">
<h3>Station Sleep<a class="headerlink" href="#station-sleep" title="Permalink to this heading"></a></h3>
<p>Currently, ESP32 Wi-Fi supports the Modem-sleep mode which refers to the legacy power-saving mode in the IEEE 802.11 protocol. Modem-sleep mode works in station-only mode and the station must connect to the AP first. If the Modem-sleep mode is enabled, station will switch between active and sleep state periodically. In sleep state, RF, PHY and BB are turned off in order to reduce power consumption. Station can keep connection with AP in modem-sleep mode.</p>
<p>Modem-sleep mode includes minimum and maximum power-saving modes. In minimum power-saving mode, station wakes up every DTIM to receive beacon. Broadcast data will not be lost because it is transmitted after DTIM. However, it cannot save much more power if DTIM is short for DTIM is determined by AP.</p>
<p>In maximum power-saving mode, station wakes up in every listen interval to receive beacon. This listen interval can be set to be longer than the AP DTIM period. Broadcast data may be lost because station may be in sleep state at DTIM time. If listen interval is longer, more power is saved, but broadcast data is more easy to lose. Listen interval can be configured by calling API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv419esp_wifi_set_config16wifi_interface_tP13wifi_config_t" title="esp_wifi_set_config"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_config()</span></code></a> before connecting to AP.</p>
<p>Call <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_ps(WIFI_PS_MIN_MODEM)</span></code> to enable Modem-sleep minimum power-saving mode or <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_ps(WIFI_PS_MAX_MODEM)</span></code> to enable Modem-sleep maximum power-saving mode after calling <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_initPK18wifi_init_config_t" title="esp_wifi_init"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_init()</span></code></a>. When station connects to AP, Modem-sleep will start. When station disconnects from AP, Modem-sleep will stop.</p>
<p>Call <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_ps(WIFI_PS_NONE)</span></code> to disable Modem-sleep mode entirely. Disabling it increases power consumption, but minimizes the delay in receiving Wi-Fi data in real time. When Modem-sleep mode is enabled, the delay in receiving Wi-Fi data may be the same as the DTIM cycle (minimum power-saving mode) or the listening interval (maximum power-saving mode).</p>
<p>Note that in coexist mode, Wi-Fi will remain active only during Wi-Fi time slice, and sleep during non Wi-Fi time slice even if <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_ps(WIFI_PS_NONE)</span></code> is called. Please refer to <a class="reference internal" href="coexist.html#coexist-policy"><span class="std std-ref">coexist policy</span></a>.</p>
<p>The default Modem-sleep mode is WIFI_PS_MIN_MODEM.</p>
</section>
<section id="ap-sleep">
<h3>AP Sleep<a class="headerlink" href="#ap-sleep" title="Permalink to this heading"></a></h3>
<p>Currently, ESP32 AP does not support all of the power-saving feature defined in Wi-Fi specification. To be specific, the AP only caches unicast data for the stations connect to this AP, but does not cache the multicast data for the stations. If stations connected to the ESP32 AP are power-saving enabled, they may experience multicast packet loss.</p>
<p>In the future, all power-saving features will be supported on ESP32 AP.</p>
</section>
<section id="disconnected-state-sleep">
<h3>Disconnected State Sleep<a class="headerlink" href="#disconnected-state-sleep" title="Permalink to this heading"></a></h3>
<p>Disconnected state is the duration without Wi-Fi connection between <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a> to <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_stopv" title="esp_wifi_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_stop()</span></code></a>.</p>
<p>Currently, ESP32 Wi-Fi supports sleep mode in disconnected state if running at station mode. This feature could be configured by Menuconfig choice <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-sta-disconnected-pm-enable"><span class="std std-ref">CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE</span></a>.</p>
<p>If <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-sta-disconnected-pm-enable"><span class="std std-ref">CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE</span></a> is enabled, RF, PHY and BB would be turned off in disconnected state when IDLE. The current would be same with current at modem-sleep.</p>
<p>The choice <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-sta-disconnected-pm-enable"><span class="std std-ref">CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE</span></a> would be selected by default, while it would be selected forcefully in Menuconfig at coexistence mode.</p>
</section>
<section id="connectionless-modules-power-saving">
<span id="connectionless-module-power-save"></span><h3>Connectionless Modules Power-saving<a class="headerlink" href="#connectionless-modules-power-saving" title="Permalink to this heading"></a></h3>
<p>Connectionless modules are those Wi-Fi modules not relying on Wi-Fi connection, e.g ESP-NOW, DPP, FTM. These modules start from <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a>, working until <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_stopv" title="esp_wifi_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_stop()</span></code></a>.</p>
<p>Currently, if ESP-NOW works at station mode, its supported to sleep at both connected state and disconnected state.</p>
<section id="connectionless-modules-tx">
<h4>Connectionless Modules TX<a class="headerlink" href="#connectionless-modules-tx" title="Permalink to this heading"></a></h4>
<p>For each connectionless module, its supported to TX at any sleeping time without any extra configuration.</p>
<p>Meanwhile, <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a> is supported at sleep as well.</p>
</section>
<section id="connectionless-modules-rx">
<h4>Connectionless Modules RX<a class="headerlink" href="#connectionless-modules-rx" title="Permalink to this heading"></a></h4>
<p>For each connectionless module, two parameters shall be configured to RX at sleep, which are <cite>Window</cite> and <cite>Interval</cite>.</p>
<p>At the start of <cite>Interval</cite> time, RF, PHY, BB would be turned on and kept for <cite>Window</cite> time. Connectionless Module could RX in the duration.</p>
<p><strong>Interval</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>There is only one <cite>Interval</cite>. Its configured by <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_connectionless_interval()</span></code>. The unit is milliseconds.</p></li>
<li><p>The default value of <cite>Interval</cite> is <cite>ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE</cite>.</p></li>
<li><p>Event <a class="reference internal" href="#wifi-event-connectionless-module-wake-interval-start">WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START</a> would be posted at the start of <cite>Interval</cite>. Since <cite>Window</cite> also starts at that moment, its recommended to TX in that event.</p></li>
<li><p>At connected state, the start of <cite>Interval</cite> would be aligned with TBTT. To improve the packet reception success rate in connectionless modules, the sender and receiver can be connected to the same AP, and packets can be transmitted within the event <a class="reference internal" href="#wifi-event-connectionless-module-wake-interval-start">WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START</a>. This synchronization helps align the connectionless modules transmission window.</p></li>
</ul>
<p>On the ESP32, TBTT timing is affected by DFS(Dynamic Frequency Scaling). To synchronize the connectionless modules transmission window using TBTT on the ESP32, DFS must be disabled.</p>
</div></blockquote>
<p><strong>Window</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>Each connectionless module has its own <cite>Window</cite> after start. Connectionless Modules Power-saving would work with the max one among them.</p></li>
<li><p><cite>Window</cite> is configured by <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">module_name_set_wake_window()</span></code>. The unit is milliseconds.</p></li>
<li><p>The default value of <cite>Window</cite> is the maximum.</p></li>
</ul>
</div></blockquote>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">RF, PHY and BB usage under different circumstances</span><a class="headerlink" href="#id9" title="Permalink to this table"></a></caption>
<tbody>
<tr class="row-odd"><td colspan="2" rowspan="2"></td>
<td colspan="2"><p>Interval</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE</span></code></p></td>
<td><p>1 - maximum</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>Window</p></td>
<td><p>0</p></td>
<td colspan="2"><p>not used</p></td>
</tr>
<tr class="row-even"><td><p>1 - maximum</p></td>
<td><p>default mode</p></td>
<td><p>used periodically (Window &lt; Interval) / used all time (Window ≥ Interval)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="default-mode">
<h4>Default Mode<a class="headerlink" href="#default-mode" title="Permalink to this heading"></a></h4>
<p>If <cite>Interval</cite> is <code class="docutils literal notranslate"><span class="pre">ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE</span></code> with non-zero <cite>Window</cite>, Connectionless Modules Power-saving would work in default mode.</p>
<p>In default mode, RF, PHY, BB would be kept on if no coexistence with non-Wi-Fi protocol.</p>
<p>With coexistence, RF, PHY, BB resources are allocated by coexistence module to Wi-Fi connectionless module and non-Wi-Fi module, using time-division method. In default mode, Wi-Fi connectionless module is allowed to use RF, BB, PHY periodically under a stable performance.</p>
<p>Its recommended to configure Connectionless Modules Power-saving to default mode if there is Wi-Fi connectionless module coexists with non-Wi-Fi module.</p>
</section>
</section>
</section>
<section id="esp32-wi-fi-throughput">
<h2>ESP32 Wi-Fi Throughput<a class="headerlink" href="#esp32-wi-fi-throughput" title="Permalink to this heading"></a></h2>
<p>The table below shows the best throughput results gained in Espressif's lab and in a shielded box.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15.4%" />
<col style="width: 15.4%" />
<col style="width: 15.4%" />
<col style="width: 15.4%" />
<col style="width: 38.5%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type/Throughput</p></th>
<th class="head"><p>Air In Lab</p></th>
<th class="head"><p>Shield-box</p></th>
<th class="head"><p>Test Tool</p></th>
<th class="head"><p>IDF Version (commit ID)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Raw 802.11 Packet RX</p></td>
<td><p>N/A</p></td>
<td><p><strong>130 MBit/s</strong></p></td>
<td><p>Internal tool</p></td>
<td><p>NA</p></td>
</tr>
<tr class="row-odd"><td><p>Raw 802.11 Packet TX</p></td>
<td><p>N/A</p></td>
<td><p><strong>130 MBit/s</strong></p></td>
<td><p>Internal tool</p></td>
<td><p>NA</p></td>
</tr>
<tr class="row-even"><td><p>UDP RX</p></td>
<td><p>30 MBit/s</p></td>
<td><p>85 MBit/s</p></td>
<td><p>iperf example</p></td>
<td><p>15575346</p></td>
</tr>
<tr class="row-odd"><td><p>UDP TX</p></td>
<td><p>30 MBit/s</p></td>
<td><p>75 MBit/s</p></td>
<td><p>iperf example</p></td>
<td><p>15575346</p></td>
</tr>
<tr class="row-even"><td><p>TCP RX</p></td>
<td><p>20 MBit/s</p></td>
<td><p>65 MBit/s</p></td>
<td><p>iperf example</p></td>
<td><p>15575346</p></td>
</tr>
<tr class="row-odd"><td><p>TCP TX</p></td>
<td><p>20 MBit/s</p></td>
<td><p>75 MBit/s</p></td>
<td><p>iperf example</p></td>
<td><p>15575346</p></td>
</tr>
</tbody>
</table>
<p>When the throughput is tested by iperf example, the sdkconfig is <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/examples/wifi/iperf/sdkconfig.defaults.esp32">examples/wifi/iperf/sdkconfig.defaults.esp32</a>.</p>
</section>
<section id="wi-fi-80211-packet-send">
<h2>Wi-Fi 80211 Packet Send<a class="headerlink" href="#wi-fi-80211-packet-send" title="Permalink to this heading"></a></h2>
<p>The <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a> API can be used to:</p>
<blockquote>
<div><ul class="simple">
<li><p>Send the beacon, probe request, probe response, and action frame.</p></li>
<li><p>Send the non-QoS data frame.</p></li>
</ul>
</div></blockquote>
<p>It cannot be used for sending encrypted or QoS frames.</p>
<section id="preconditions-of-using-esp-wifi-80211-tx">
<h3>Preconditions of Using <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a><a class="headerlink" href="#preconditions-of-using-esp-wifi-80211-tx" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>The Wi-Fi mode is station, or AP, or station/AP.</p></li>
<li><p>Either <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_promiscuous(true)</span></code>, or <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a>, or both of these APIs return <a class="reference internal" href="../api-reference/system/esp_err.html#c.ESP_OK" title="ESP_OK"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_OK</span></code></a>. This is because Wi-Fi hardware must be initialized before <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a> is called. In ESP32, both <code class="docutils literal notranslate"><span class="pre">esp_wifi_set_promiscuous(true)</span></code> and <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a> can trigger the initialization of Wi-Fi hardware.</p></li>
<li><p>The parameters of <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a> are hereby correctly provided.</p></li>
</ul>
</div></blockquote>
</section>
<section id="data-rate">
<h3>Data Rate<a class="headerlink" href="#data-rate" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>The default data rate is 1 Mbps.</p></li>
<li><p>Can set any rate through <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv429esp_wifi_config_80211_tx_rate16wifi_interface_t15wifi_phy_rate_t" title="esp_wifi_config_80211_tx_rate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_config_80211_tx_rate()</span></code></a> API.</p></li>
<li><p>Can set any bandwidth through <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv422esp_wifi_set_bandwidth16wifi_interface_t16wifi_bandwidth_t" title="esp_wifi_set_bandwidth"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_bandwidth()</span></code></a> API.</p></li>
</ul>
</div></blockquote>
</section>
<section id="side-effects-to-avoid-in-different-scenarios">
<h3>Side-Effects to Avoid in Different Scenarios<a class="headerlink" href="#side-effects-to-avoid-in-different-scenarios" title="Permalink to this heading"></a></h3>
<p>Theoretically, if the side-effects the API imposes on the Wi-Fi driver or other stations/APs are not considered, a raw 802.11 packet can be sent over the air with any destination MAC, any source MAC, any BSSID, or any other types of packet. However, robust or useful applications should avoid such side-effects. The table below provides some tips and recommendations on how to avoid the side-effects of <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a> in different scenarios.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16.7%" />
<col style="width: 83.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Scenario</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>No Wi-Fi connection</p></td>
<td><p>In this scenario, no Wi-Fi connection is set up, so there are no side-effects on the Wi-Fi driver. If <code class="docutils literal notranslate"><span class="pre">en_sys_seq==true</span></code>, the Wi-Fi driver is responsible for the sequence control. If <code class="docutils literal notranslate"><span class="pre">en_sys_seq==false</span></code>, the application needs to ensure that the buffer has the correct sequence.</p>
<p>Theoretically, the MAC address can be any address. However, this may impact other stations/APs with the same MAC/BSSID.</p>
<p>Side-effect example#1 The application calls <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a> to send a beacon with BSSID == mac_x in AP mode, but the mac_x is not the MAC of the AP interface. Moreover, there is another AP, e.g., “other-AP”, whose BSSID is mac_x. If this happens, an “unexpected behavior” may occur, because the stations which connect to the “other-AP” cannot figure out whether the beacon is from the “other-AP” or the <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a>.</p>
<p>To avoid the above-mentioned side-effects, it is recommended that:</p>
<ul class="simple">
<li><p>If <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a> is called in station mode, the first MAC should be a multicast MAC or the exact target-device’s MAC, while the second MAC should be that of the station interface.</p></li>
<li><p>If <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv417esp_wifi_80211_tx16wifi_interface_tPKvib" title="esp_wifi_80211_tx"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_80211_tx()</span></code></a> is called in AP mode, the first MAC should be a multicast MAC or the exact target-device’s MAC, while the second MAC should be that of the AP interface.</p></li>
</ul>
<p>The recommendations above are only for avoiding side-effects and can be ignored when there are good reasons.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Have Wi-Fi connection</p></td>
<td><p>When the Wi-Fi connection is already set up, and the sequence is controlled by the application, the latter may impact the sequence control of the Wi-Fi connection as a whole. So, the <code class="docutils literal notranslate"><span class="pre">en_sys_seq</span></code> need to be true, otherwise <code class="docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_ARG</span></code> is returned.</p>
<p>The MAC-address recommendations in the “No Wi-Fi connection” scenario also apply to this scenario.</p>
<p>If the Wi-Fi mode is station mode, the MAC address1 is the MAC of AP to which the station is connected, and the MAC address2 is the MAC of station interface, it is said that the packet is sent from the station to AP. Otherwise, if the Wi-Fi is in AP mode, the MAC address1 is the MAC of the station that connects to this AP, and the MAC address2 is the MAC of AP interface, it is said that the packet is sent from the AP to station. To avoid conflicting with Wi-Fi connections, the following checks are applied:</p>
<ul class="simple">
<li><p>If the packet type is data and is sent from the station to AP, the ToDS bit in IEEE 80211 frame control should be 1 and the FromDS bit should be 0. Otherwise, the packet will be discarded by Wi-Fi driver.</p></li>
<li><p>If the packet type is data and is sent from the AP to station, the ToDS bit in IEEE 80211 frame control should be 0 and the FromDS bit should be 1. Otherwise, the packet will be discarded by Wi-Fi driver.</p></li>
<li><p>If the packet is sent from station to AP or from AP to station, the Power Management, More Data, and Re-Transmission bits should be 0. Otherwise, the packet will be discarded by Wi-Fi driver.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_ARG</span></code> is returned if any check fails.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="wi-fi-sniffer-mode">
<h2>Wi-Fi Sniffer Mode<a class="headerlink" href="#wi-fi-sniffer-mode" title="Permalink to this heading"></a></h2>
<p>The Wi-Fi sniffer mode can be enabled by <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv424esp_wifi_set_promiscuousb" title="esp_wifi_set_promiscuous"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_promiscuous()</span></code></a>. If the sniffer mode is enabled, the following packets <strong>can</strong> be dumped to the application:</p>
<blockquote>
<div><ul class="simple">
<li><p>802.11 Management frame.</p></li>
<li><p>802.11 Data frame, including MPDU, AMPDU, and AMSDU.</p></li>
<li><p>802.11 MIMO frame, for MIMO frame, the sniffer only dumps the length of the frame.</p></li>
<li><p>802.11 Control frame.</p></li>
<li><p>802.11 CRC error frame.</p></li>
</ul>
</div></blockquote>
<p>The following packets will <strong>NOT</strong> be dumped to the application:</p>
<blockquote>
<div><ul class="simple">
<li><p>Other 802.11 error frames.</p></li>
</ul>
</div></blockquote>
<p>For frames that the sniffer <strong>can</strong> dump, the application can additionally decide which specific type of packets can be filtered to the application by using <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv431esp_wifi_set_promiscuous_filterPK25wifi_promiscuous_filter_t" title="esp_wifi_set_promiscuous_filter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_promiscuous_filter()</span></code></a> and <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv436esp_wifi_set_promiscuous_ctrl_filterPK25wifi_promiscuous_filter_t" title="esp_wifi_set_promiscuous_ctrl_filter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_promiscuous_ctrl_filter()</span></code></a>. By default, it will filter all 802.11 data and management frames to the application. If you want to filter the 802.11 control frames, the filter parameter in <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv431esp_wifi_set_promiscuous_filterPK25wifi_promiscuous_filter_t" title="esp_wifi_set_promiscuous_filter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_promiscuous_filter()</span></code></a> should include <cite>WIFI_PROMIS_FILTER_MASK_CTRL</cite> type, and if you want to differentiate control frames further, then call <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv436esp_wifi_set_promiscuous_ctrl_filterPK25wifi_promiscuous_filter_t" title="esp_wifi_set_promiscuous_ctrl_filter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_promiscuous_ctrl_filter()</span></code></a>.</p>
<p>The Wi-Fi sniffer mode can be enabled in the Wi-Fi mode of <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv4N11wifi_mode_t14WIFI_MODE_NULLE" title="WIFI_MODE_NULL"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">WIFI_MODE_NULL</span></code></a>, <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv4N11wifi_mode_t13WIFI_MODE_STAE" title="WIFI_MODE_STA"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">WIFI_MODE_STA</span></code></a>, <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv4N11wifi_mode_t12WIFI_MODE_APE" title="WIFI_MODE_AP"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">WIFI_MODE_AP</span></code></a>, or <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv4N11wifi_mode_t15WIFI_MODE_APSTAE" title="WIFI_MODE_APSTA"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">WIFI_MODE_APSTA</span></code></a>. In other words, the sniffer mode is active when the station is connected to the AP, or when the AP has a Wi-Fi connection. Please note that the sniffer has a <strong>great impact</strong> on the throughput of the station or AP Wi-Fi connection. Generally, the sniffer should be enabled <strong>only if</strong> the station/AP Wi-Fi connection does not experience heavy traffic.</p>
<p>Another noteworthy issue about the sniffer is the callback <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv421wifi_promiscuous_cb_t" title="wifi_promiscuous_cb_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wifi_promiscuous_cb_t</span></code></a>. The callback will be called directly in the Wi-Fi driver task, so if the application has a lot of work to do for each filtered packet, the recommendation is to post an event to the application task in the callback and defer the real work to the application task.</p>
</section>
<section id="wi-fi-multiple-antennas">
<h2>Wi-Fi Multiple Antennas<a class="headerlink" href="#wi-fi-multiple-antennas" title="Permalink to this heading"></a></h2>
<p>Please refer to the <a class="reference internal" href="phy.html"><span class="doc">PHY</span></a></p>
</section>
<section id="wi-fi-channel-state-information">
<h2>Wi-Fi Channel State Information<a class="headerlink" href="#wi-fi-channel-state-information" title="Permalink to this heading"></a></h2>
<p>Channel state information (CSI) refers to the channel information of a Wi-Fi connection. In ESP32, this information consists of channel frequency responses of sub-carriers and is estimated when packets are received from the transmitter. Each channel frequency response of sub-carrier is recorded by two bytes of signed characters. The first one is imaginary part and the second one is real part. There are up to three fields of channel frequency responses according to the type of received packet. They are legacy long training field (LLTF), high throughput LTF (HT-LTF), and space time block code HT-LTF (STBC-HT-LTF). For different types of packets which are received on channels with different state, the sub-carrier index and total bytes of signed characters of CSI are shown in the following table.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>channel</p></td>
<td><p>secondary channel</p></td>
<td colspan="3"><p>none</p></td>
<td colspan="5"><p>below</p></td>
<td colspan="5"><p>above</p></td>
</tr>
<tr class="row-even"><td rowspan="3"><p>packet</p>
<p>information</p>
</td>
<td><p>signal mode</p></td>
<td><p>non HT</p></td>
<td colspan="2"><p>HT</p></td>
<td><p>non HT</p></td>
<td colspan="4"><p>HT</p></td>
<td><p>non HT</p></td>
<td colspan="4"><p>HT</p></td>
</tr>
<tr class="row-odd"><td><p>channel bandwidth</p></td>
<td><p>20 MHz</p></td>
<td colspan="2"><p>20 MHz</p></td>
<td><p>20 MHz</p></td>
<td colspan="2"><p>20 MHz</p></td>
<td colspan="2"><p>40 MHz</p></td>
<td><p>20 MHz</p></td>
<td colspan="2"><p>20 MHz</p></td>
<td colspan="2"><p>40 MHz</p></td>
</tr>
<tr class="row-even"><td><p>STBC</p></td>
<td><p>non STBC</p></td>
<td><p>non STBC</p></td>
<td><p>STBC</p></td>
<td><p>non STBC</p></td>
<td><p>non STBC</p></td>
<td><p>STBC</p></td>
<td><p>non STBC</p></td>
<td><p>STBC</p></td>
<td><p>non STBC</p></td>
<td><p>non STBC</p></td>
<td><p>STBC</p></td>
<td><p>non STBC</p></td>
<td><p>STBC</p></td>
</tr>
<tr class="row-odd"><td rowspan="3"><p>sub-carrier</p>
<p>index</p>
</td>
<td><p>LLTF</p></td>
<td><p>0~31, -32~-1</p></td>
<td><p>0~31, -32~-1</p></td>
<td><p>0~31, -32~-1</p></td>
<td><p>0~63</p></td>
<td><p>0~63</p></td>
<td><p>0~63</p></td>
<td><p>0~63</p></td>
<td><p>0~63</p></td>
<td><p>-64~-1</p></td>
<td><p>-64~-1</p></td>
<td><p>-64~-1</p></td>
<td><p>-64~-1</p></td>
<td><p>-64~-1</p></td>
</tr>
<tr class="row-even"><td><p>HT-LTF</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>0~31, -32~-1</p></td>
<td><p>0~31, -32~-1</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>0~63</p></td>
<td><p>0~62</p></td>
<td><p>0~63, -64~-1</p></td>
<td><p>0~60, -60~-1</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>-64~-1</p></td>
<td><p>-62~-1</p></td>
<td><p>0~63, -64~-1</p></td>
<td><p>0~60, -60~-1</p></td>
</tr>
<tr class="row-odd"><td><p>STBC-HT-LTF</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>0~31, -32~-1</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>0~62</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>0~60, -60~-1</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>-62~-1</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>0~60, -60~-1</p></td>
</tr>
<tr class="row-even"><td colspan="2"><p>total bytes</p></td>
<td><p>128</p></td>
<td><p>256</p></td>
<td><p>384</p></td>
<td><p>128</p></td>
<td><p>256</p></td>
<td><p>380</p></td>
<td><p>384</p></td>
<td><p>612</p></td>
<td><p>128</p></td>
<td><p>256</p></td>
<td><p>376</p></td>
<td><p>384</p></td>
<td><p>612</p></td>
</tr>
</tbody>
</table>
<p>All of the information in the table can be found in the structure wifi_csi_info_t.</p>
<blockquote>
<div><ul class="simple">
<li><p>Secondary channel refers to secondary_channel field of rx_ctrl field.</p></li>
<li><p>Signal mode of packet refers to sig_mode field of rx_ctrl field.</p></li>
<li><p>Channel bandwidth refers to cwb field of rx_ctrl field.</p></li>
<li><p>STBC refers to stbc field of rx_ctrl field.</p></li>
<li><p>Total bytes refers to len field.</p></li>
<li><p>The CSI data corresponding to each Long Training Field (LTF) type is stored in a buffer starting from the buf field. Each item is stored as two bytes: imaginary part followed by real part. The order of each item is the same as the sub-carrier in the table. The order of LTF is: LLTF, HT-LTF, STBC-HT-LTF. However, all 3 LTFs may not be present, depending on the channel and packet information (see above).</p></li>
<li><p>If first_word_invalid field of <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv415wifi_csi_info_t" title="wifi_csi_info_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wifi_csi_info_t</span></code></a> is true, it means that the first four bytes of CSI data is invalid due to a hardware limitation in ESP32.</p></li>
<li><p>More information like RSSI, noise floor of RF, receiving time and antenna is in the rx_ctrl field.</p></li>
</ul>
</div></blockquote>
<p>When imaginary part and real part data of sub-carrier are used, please refer to the table below.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>PHY standard</p></th>
<th class="head"><p>Sub-carrier range</p></th>
<th class="head"><p>Pilot sub-carrier</p></th>
<th class="head"><p>Sub-carrier (total/data)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>802.11a/g</p></td>
<td><p>-26 to +26</p></td>
<td><p>-21, -7, +7, +21</p></td>
<td><p>52 total, 48 usable</p></td>
</tr>
<tr class="row-odd"><td><p>802.11n, 20 MHz</p></td>
<td><p>-28 to +28</p></td>
<td><p>-21, -7, +7, +21</p></td>
<td><p>56 total, 52 usable</p></td>
</tr>
<tr class="row-even"><td><p>802.11n, 40 MHz</p></td>
<td><p>-57 to +57</p></td>
<td><p>-53, -25, -11, +11, +25, +53</p></td>
<td><p>114 total, 108 usable</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>For STBC packet, CSI is provided for every space-time stream without CSD (cyclic shift delay). As each cyclic shift on the additional chains shall be -200 ns, only the CSD angle of first space-time stream is recorded in sub-carrier 0 of HT-LTF and STBC-HT-LTF for there is no channel frequency response in sub-carrier 0. CSD[10:0] is 11 bits, ranging from -pi to pi.</p></li>
<li><p>If LLTF, HT-LTF, or STBC-HT-LTF is not enabled by calling API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv423esp_wifi_set_csi_configPK17wifi_csi_config_t" title="esp_wifi_set_csi_config"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_csi_config()</span></code></a>, the total bytes of CSI data will be fewer than that in the table. For example, if LLTF and HT-LTF is not enabled and STBC-HT-LTF is enabled, when a packet is received with the condition above/HT/40MHz/STBC, the total bytes of CSI data is 244 ((61 + 60) * 2 + 2 = 244. The result is aligned to four bytes, and the last two bytes are invalid).</p></li>
</ul>
</div>
</section>
<section id="wi-fi-channel-state-information-configure">
<h2>Wi-Fi Channel State Information Configure<a class="headerlink" href="#wi-fi-channel-state-information-configure" title="Permalink to this heading"></a></h2>
<p>To use Wi-Fi CSI, the following steps need to be done.</p>
<blockquote>
<div><ul class="simple">
<li><p>Select Wi-Fi CSI in menuconfig. Go to <code class="docutils literal notranslate"><span class="pre">Menuconfig</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Components</span> <span class="pre">config</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Wi-Fi</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Wi-Fi</span> <span class="pre">CSI</span> <span class="pre">(Channel</span> <span class="pre">State</span> <span class="pre">Information)</span></code>.</p></li>
<li><p>Set CSI receiving callback function by calling API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv422esp_wifi_set_csi_rx_cb13wifi_csi_cb_tPv" title="esp_wifi_set_csi_rx_cb"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_csi_rx_cb()</span></code></a>.</p></li>
<li><p>Configure CSI by calling API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv423esp_wifi_set_csi_configPK17wifi_csi_config_t" title="esp_wifi_set_csi_config"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_csi_config()</span></code></a>.</p></li>
<li><p>Enable CSI by calling API <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv416esp_wifi_set_csib" title="esp_wifi_set_csi"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_csi()</span></code></a>.</p></li>
</ul>
</div></blockquote>
<p>The CSI receiving callback function runs from Wi-Fi task. So, do not do lengthy operations in the callback function. Instead, post necessary data to a queue and handle it from a lower priority task. Because station does not receive any packet when it is disconnected and only receives packets from AP when it is connected, it is suggested to enable sniffer mode to receive more CSI data by calling <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv424esp_wifi_set_promiscuousb" title="esp_wifi_set_promiscuous"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_promiscuous()</span></code></a>.</p>
</section>
<section id="wi-fi-ht20-40">
<h2>Wi-Fi HT20/40<a class="headerlink" href="#wi-fi-ht20-40" title="Permalink to this heading"></a></h2>
<p>ESP32 supports Wi-Fi bandwidth HT20 or HT40 and does not support HT20/40 coexist. <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv422esp_wifi_set_bandwidth16wifi_interface_t16wifi_bandwidth_t" title="esp_wifi_set_bandwidth"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_set_bandwidth()</span></code></a> can be used to change the default bandwidth of station or AP. The default bandwidth for ESP32 station and AP is HT40.</p>
<p>In station mode, the actual bandwidth is firstly negotiated during the Wi-Fi connection. It is HT40 only if both the station and the connected AP support HT40, otherwise it is HT20. If the bandwidth of connected AP is changes, the actual bandwidth is negotiated again without Wi-Fi disconnecting.</p>
<p>Similarly, in AP mode, the actual bandwidth is negotiated between AP and the stations that connect to the AP. It is HT40 if the AP and one of the stations support HT40, otherwise it is HT20.</p>
<p>In station/AP coexist mode, the station/AP can configure HT20/40 separately. If both station and AP are negotiated to HT40, the HT40 channel should be the channel of station because the station always has higher priority than AP in ESP32. For example, the configured bandwidth of AP is HT40, the configured primary channel is 6, and the configured secondary channel is 10. The station is connected to an router whose primary channel is 6 and secondary channel is 2, then the actual channel of AP is changed to primary 6 and secondary 2 automatically.</p>
<p>Theoretically, the HT40 can gain better throughput because the maximum raw physicial (PHY) data rate for HT40 is 150 Mbps while it is 72 Mbps for HT20. However, if the device is used in some special environment, e.g., there are too many other Wi-Fi devices around the ESP32 device, the performance of HT40 may be degraded. So if the applications need to support same or similar scenarios, it is recommended that the bandwidth is always configured to HT20.</p>
</section>
<section id="wi-fi-qos">
<h2>Wi-Fi QoS<a class="headerlink" href="#wi-fi-qos" title="Permalink to this heading"></a></h2>
<p>ESP32 supports all the mandatory features required in WFA Wi-Fi QoS Certification.</p>
<p>Four ACs (Access Category) are defined in Wi-Fi specification, and each AC has its own priority to access the Wi-Fi channel. Moreover, a map rule is defined to map the QoS priority of other protocol, e.g., 802.11D or TCP/IP precedence is mapped to Wi-Fi AC.</p>
<p>The table below describes how the IP Precedences are mapped to Wi-Fi ACs in ESP32. It also indicates whether the AMPDU is supported for this AC. The table is sorted from high to low priority. That is to say, the AC_VO has the highest priority.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>IP Precedence</p></th>
<th class="head"><p>Wi-Fi AC</p></th>
<th class="head"><p>Support AMPDU?</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>6, 7</p></td>
<td><p>AC_VO (Voice)</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>4, 5</p></td>
<td><p>AC_VI (Video)</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>3, 0</p></td>
<td><p>AC_BE (Best Effort)</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>1, 2</p></td>
<td><p>AC_BK (Background)</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>
<p>The application can make use of the QoS feature by configuring the IP precedence via socket option IP_TOS. Here is an example to make the socket to use VI queue:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="nb">int</span> <span class="n">ip_precedence_vi</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">const</span> <span class="nb">int</span> <span class="n">ip_precedence_offset</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">priority</span> <span class="o">=</span> <span class="p">(</span><span class="n">ip_precedence_vi</span> <span class="o">&lt;&lt;</span> <span class="n">ip_precedence_offset</span><span class="p">);</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">socket_id</span><span class="p">,</span> <span class="n">IPPROTO_IP</span><span class="p">,</span> <span class="n">IP_TOS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priority</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">priority</span><span class="p">));</span>
</pre></div>
</div>
<p>Theoretically, the higher priority AC has better performance than the lower priority AC. However, it is not always true. Here are some suggestions about how to use the Wi-Fi QoS:</p>
<blockquote>
<div><ul class="simple">
<li><p>Some really important application traffic can be put into the AC_VO queue. But avoid using the AC_VO queue for heavy traffic, as it may impact the management frames which also use this queue. Eventually, it is worth noting that the AC_VO queue does not support AMPDU, and its performance with heavy traffic is no better than other queues.</p></li>
<li><p>Avoid using more than two precedences supported by different AMPDUs, e.g., when socket A uses precedence 0, socket B uses precedence 1, and socket C uses precedence 2. This can be a bad design because it may need much more memory. To be specific, the Wi-Fi driver may generate a Block Ack session for each precedence and it needs more memory if the Block Ack session is set up.</p></li>
</ul>
</div></blockquote>
</section>
<section id="wi-fi-amsdu">
<h2>Wi-Fi AMSDU<a class="headerlink" href="#wi-fi-amsdu" title="Permalink to this heading"></a></h2>
<p>ESP32 supports receiving and transmitting AMSDU. AMSDU TX is disabled by default, since enable AMSDU TX need more memory. Select <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-amsdu-tx-enabled"><span class="std std-ref">CONFIG_ESP_WIFI_AMSDU_TX_ENABLED</span></a> to enable AMSDU Tx feature, it depends on <a class="reference internal" href="../api-reference/kconfig.html#config-spiram"><span class="std std-ref">CONFIG_SPIRAM</span></a>.</p>
</section>
<section id="wi-fi-fragment">
<h2>Wi-Fi Fragment<a class="headerlink" href="#wi-fi-fragment" title="Permalink to this heading"></a></h2>
<p>supports Wi-Fi receiving fragment, but does not support Wi-Fi transmitting fragment.</p>
</section>
<section id="wps-enrollee">
<h2>WPS Enrollee<a class="headerlink" href="#wps-enrollee" title="Permalink to this heading"></a></h2>
<p>ESP32 supports WPS enrollee feature in Wi-Fi mode <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv4N11wifi_mode_t13WIFI_MODE_STAE" title="WIFI_MODE_STA"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">WIFI_MODE_STA</span></code></a> or <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv4N11wifi_mode_t15WIFI_MODE_APSTAE" title="WIFI_MODE_APSTA"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">WIFI_MODE_APSTA</span></code></a>. Currently, ESP32 supports WPS enrollee type PBC and PIN.</p>
</section>
<section id="wi-fi-buffer-usage">
<span id="wifi-buffer-usage"></span><h2>Wi-Fi Buffer Usage<a class="headerlink" href="#wi-fi-buffer-usage" title="Permalink to this heading"></a></h2>
<p>This section is only about the dynamic buffer configuration.</p>
<section id="why-buffer-configuration-is-important">
<h3>Why Buffer Configuration Is Important<a class="headerlink" href="#why-buffer-configuration-is-important" title="Permalink to this heading"></a></h3>
<p>In order to get a high-performance system, consider the memory usage/configuration carefully for the following reasons:</p>
<blockquote>
<div><ul class="simple">
<li><p>the available memory in ESP32 is limited.</p></li>
<li><p>currently, the default type of buffer in LwIP and Wi-Fi drivers is &quot;dynamic&quot;, <strong>which means that both the LwIP and Wi-Fi share memory with the application</strong>. Programmers should always keep this in mind; otherwise, they will face a memory issue, such as &quot;running out of heap memory&quot;.</p></li>
<li><p>it is very dangerous to run out of heap memory, as this will cause ESP32 an &quot;undefined behavior&quot;. Thus, enough heap memory should be reserved for the application, so that it never runs out of it.</p></li>
<li><p>the Wi-Fi throughput heavily depends on memory-related configurations, such as the TCP window size and Wi-Fi RX/TX dynamic buffer number.</p></li>
<li><p>the peak heap memory that the ESP32 LwIP/Wi-Fi may consume depends on a number of factors, such as the maximum TCP/UDP connections that the application may have.</p></li>
<li><p>the total memory that the application requires is also an important factor when considering memory configuration.</p></li>
</ul>
</div></blockquote>
<p>Due to these reasons, there is not a good-for-all application configuration. Rather, it is recommended to consider memory configurations separately for every different application.</p>
</section>
<section id="dynamic-vs-static-buffer">
<h3>Dynamic vs. Static Buffer<a class="headerlink" href="#dynamic-vs-static-buffer" title="Permalink to this heading"></a></h3>
<p>The default type of buffer in Wi-Fi drivers is &quot;dynamic&quot;. Most of the time the dynamic buffer can significantly save memory. However, it makes the application programming a little more difficult, because in this case the application needs to consider memory usage in Wi-Fi.</p>
<p>lwIP also allocates buffers at the TCP/IP layer, and this buffer allocation is also dynamic. See <a class="reference internal" href="lwip.html#lwip-performance"><span class="std std-ref">lwIP documentation section about memory use and performance</span></a>.</p>
</section>
<section id="peak-wi-fi-dynamic-buffer">
<h3>Peak Wi-Fi Dynamic Buffer<a class="headerlink" href="#peak-wi-fi-dynamic-buffer" title="Permalink to this heading"></a></h3>
<p>The Wi-Fi driver supports several types of buffer (refer to <a class="reference internal" href="#wi-fi-buffer-configure">Wi-Fi Buffer Configure</a>). However, this section is about the usage of the dynamic Wi-Fi buffer only.
The peak heap memory that Wi-Fi consumes is the <strong>theoretically-maximum memory</strong> that the Wi-Fi driver consumes. Generally, the peak memory depends on:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(b_{rx}\)</span> the number of dynamic RX buffers that are configured</p></li>
<li><p><span class="math notranslate nohighlight">\(b_{tx}\)</span> the number of dynamic TX buffers that are configured</p></li>
<li><p><span class="math notranslate nohighlight">\(m_{rx}\)</span> the maximum packet size that the Wi-Fi driver can receive</p></li>
<li><p><span class="math notranslate nohighlight">\(m_{tx}\)</span> the maximum packet size that the Wi-Fi driver can send</p></li>
</ul>
<p>So, the peak memory that the Wi-Fi driver consumes (<span class="math notranslate nohighlight">\(p\)</span>) can be calculated with the following formula:</p>
<div class="math notranslate nohighlight">
\[p = (b_{rx} * m_{rx}) + (b_{tx} * m_{tx})\]</div>
<p>Generally, the dynamic TX long buffers and dynamic TX long long buffers can be ignored, because they are management frames which only have a small impact on the system.</p>
</section>
</section>
<section id="how-to-improve-wi-fi-performance">
<span id="id1"></span><h2>How to Improve Wi-Fi Performance<a class="headerlink" href="#how-to-improve-wi-fi-performance" title="Permalink to this heading"></a></h2>
<p>The performance of ESP32 Wi-Fi is affected by many parameters, and there are mutual constraints between each parameter. A proper configuration cannot only improve performance, but also increase available memory for applications and improve stability.</p>
<p>This section briefly explains the operating mode of the Wi-Fi/LwIP protocol stack and the role of each parameter. It also gives several recommended configuration ranks to help choose the appropriate rank according to the usage scenario.</p>
<section id="protocol-stack-operation-mode">
<h3>Protocol Stack Operation Mode<a class="headerlink" href="#protocol-stack-operation-mode" title="Permalink to this heading"></a></h3>
<figure class="align-center" id="id10">
<img alt="../_images/api-guides-WiFi-driver-how-to-improve-WiFi-performance.png" src="../_images/api-guides-WiFi-driver-how-to-improve-WiFi-performance.png" />
<figcaption>
<p><span class="caption-text">ESP32 datapath</span><a class="headerlink" href="#id10" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The ESP32 protocol stack is divided into four layers: Application, LwIP, Wi-Fi, and Hardware.</p>
<blockquote>
<div><ul class="simple">
<li><p>During receiving, hardware puts the received packet into DMA buffer, and then transfers it into the RX buffer of Wi-Fi and LwIP in turn for related protocol processing, and finally to the application layer. The Wi-Fi RX buffer and the LwIP RX buffer shares the same buffer by default. In other words, the Wi-Fi forwards the packet to LwIP by reference by default.</p></li>
<li><p>During sending, the application copies the messages to be sent into the TX buffer of the LwIP layer for TCP/IP encapsulation. The messages will then be passed to the TX buffer of the Wi-Fi layer for MAC encapsulation and wait to be sent.</p></li>
</ul>
</div></blockquote>
</section>
<section id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading"></a></h3>
<p>Increasing the size or number of the buffers mentioned above properly can improve Wi-Fi performance. Meanwhile, it will reduce available memory to the application. The following is an introduction to the parameters that users need to configure:</p>
<p><strong>RX direction:</strong></p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-static-rx-buffer-num"><span class="std std-ref">CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM</span></a></dt><dd><p>This parameter indicates the number of DMA buffer at the hardware layer. Increasing this parameter will increase the sender's one-time receiving throughput, thereby improving the Wi-Fi protocol stack ability to handle burst traffic.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-dynamic-rx-buffer-num"><span class="std std-ref">CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM</span></a></dt><dd><p>This parameter indicates the number of RX buffer in the Wi-Fi layer. Increasing this parameter will improve the performance of packet reception. This parameter needs to match the RX buffer size of the LwIP layer.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-rx-ba-win"><span class="std std-ref">CONFIG_ESP_WIFI_RX_BA_WIN</span></a></dt><dd><p>This parameter indicates the size of the AMPDU BA Window at the receiving end. This parameter should be configured to the smaller value between twice of <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-static-rx-buffer-num"><span class="std std-ref">CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM</span></a> and <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-dynamic-rx-buffer-num"><span class="std std-ref">CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-lwip-tcp-wnd-default"><span class="std std-ref">CONFIG_LWIP_TCP_WND_DEFAULT</span></a></dt><dd><p>This parameter represents the RX buffer size of the LwIP layer for each TCP stream. Its value should be configured to the value of WIFI_DYNAMIC_RX_BUFFER_NUM (KB) to reach a high and stable performance. Meanwhile, in case of multiple streams, this value needs to be reduced proportionally.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><strong>TX direction:</strong></p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-tx-buffer"><span class="std std-ref">CONFIG_ESP_WIFI_TX_BUFFER</span></a></dt><dd><p>This parameter indicates the type of TX buffer, it is recommended to configure it as a dynamic buffer, which can make full use of memory.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-dynamic-tx-buffer-num"><span class="std std-ref">CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM</span></a></dt><dd><p>This parameter indicates the number of TX buffer on the Wi-Fi layer. Increasing this parameter will improve the performance of packet sending. The parameter value needs to match the TX buffer size of the LwIP layer.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-lwip-tcp-snd-buf-default"><span class="std std-ref">CONFIG_LWIP_TCP_SND_BUF_DEFAULT</span></a></dt><dd><p>This parameter represents the TX buffer size of the LwIP layer for each TCP stream. Its value should be configured to the value of WIFI_DYNAMIC_TX_BUFFER_NUM (KB) to reach a high and stable performance. In case of multiple streams, this value needs to be reduced proportionally.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><strong>Throughput optimization by placing code in IRAM:</strong></p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-iram-opt"><span class="std std-ref">CONFIG_ESP_WIFI_IRAM_OPT</span></a></dt><dd><p>If this option is enabled, some Wi-Fi functions are moved to IRAM, improving throughput. This increases IRAM usage by 15 kB.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-rx-iram-opt"><span class="std std-ref">CONFIG_ESP_WIFI_RX_IRAM_OPT</span></a></dt><dd><p>If this option is enabled, some Wi-Fi RX functions are moved to IRAM, improving throughput. This increases IRAM usage by 16 kB.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../api-reference/kconfig.html#config-lwip-iram-optimization"><span class="std std-ref">CONFIG_LWIP_IRAM_OPTIMIZATION</span></a></dt><dd><p>If this option is enabled, some LwIP functions are moved to IRAM, improving throughput. This increases IRAM usage by 13 kB.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The buffer size mentioned above is fixed as 1.6 KB.</p>
</div>
</section>
<section id="how-to-configure-parameters">
<h3>How to Configure Parameters<a class="headerlink" href="#how-to-configure-parameters" title="Permalink to this heading"></a></h3>
<p>The memory of ESP32 is shared by protocol stack and applications.</p>
<p>Here, several configuration ranks are given. In most cases, the user should select a suitable rank for parameter configuration according to the size of the memory occupied by the application.</p>
<p>The parameters not mentioned in the following table should be set to the default.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18.2%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 18.2%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 18.2%" />
<col style="width: 9.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Rank</p></th>
<th class="head"><p>Iperf</p></th>
<th class="head"><p>TX prior</p></th>
<th class="head"><p>High-performance</p></th>
<th class="head"><p>RX prior</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Memory saving</p></th>
<th class="head"><p>Minimum</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Available memory (KB)</p></td>
<td><p>37.1</p></td>
<td><p>113.8</p></td>
<td><p>123.3</p></td>
<td><p>145.5</p></td>
<td><p>144.5</p></td>
<td><p>170.2</p></td>
<td><p>185.2</p></td>
</tr>
<tr class="row-odd"><td><p>WIFI_STATIC_RX_BUFFER_NUM</p></td>
<td><p>16</p></td>
<td><p>6</p></td>
<td><p>6</p></td>
<td><p>6</p></td>
<td><p>6</p></td>
<td><p>6</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>WIFI_DYNAMIC_RX_BUFFER_NUM</p></td>
<td><p>64</p></td>
<td><p>16</p></td>
<td><p>24</p></td>
<td><p>34</p></td>
<td><p>20</p></td>
<td><p>12</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>WIFI_DYNAMIC_TX_BUFFER_NUM</p></td>
<td><p>64</p></td>
<td><p>28</p></td>
<td><p>24</p></td>
<td><p>18</p></td>
<td><p>20</p></td>
<td><p>12</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>WIFI_RX_BA_WIN</p></td>
<td><p>32</p></td>
<td><p>8</p></td>
<td><p>12</p></td>
<td><p>12</p></td>
<td><p>10</p></td>
<td><p>6</p></td>
<td><p>Disable</p></td>
</tr>
<tr class="row-odd"><td><p>TCP_SND_BUF_DEFAULT (KB)</p></td>
<td><p>65</p></td>
<td><p>28</p></td>
<td><p>24</p></td>
<td><p>18</p></td>
<td><p>20</p></td>
<td><p>12</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>TCP_WND_DEFAULT (KB)</p></td>
<td><p>65</p></td>
<td><p>16</p></td>
<td><p>24</p></td>
<td><p>34</p></td>
<td><p>20</p></td>
<td><p>12</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>WIFI_IRAM_OPT</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
</tr>
<tr class="row-even"><td><p>WIFI_RX_IRAM_OPT</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
</tr>
<tr class="row-odd"><td><p>LWIP_IRAM_OPTIMIZATION</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
</tr>
<tr class="row-even"><td><p>TCP TX throughput (Mbit/s)</p></td>
<td><p>74.6</p></td>
<td><p>50.8</p></td>
<td><p>46.5</p></td>
<td><p>39.9</p></td>
<td><p>44.2</p></td>
<td><p>33.8</p></td>
<td><p>25.6</p></td>
</tr>
<tr class="row-odd"><td><p>TCP RX throughput (Mbit/s)</p></td>
<td><p>63.6</p></td>
<td><p>35.5</p></td>
<td><p>42.3</p></td>
<td><p>48.5</p></td>
<td><p>40.5</p></td>
<td><p>30.1</p></td>
<td><p>27.8</p></td>
</tr>
<tr class="row-even"><td><p>UDP TX throughput (Mbit/s)</p></td>
<td><p>76.2</p></td>
<td><p>75.1</p></td>
<td><p>74.1</p></td>
<td><p>72.4</p></td>
<td><p>69.6</p></td>
<td><p>64.1</p></td>
<td><p>36.5</p></td>
</tr>
<tr class="row-odd"><td><p>UDP RX throughput (Mbit/s)</p></td>
<td><p>83.1</p></td>
<td><p>66.3</p></td>
<td><p>75.1</p></td>
<td><p>75.6</p></td>
<td><p>73.1</p></td>
<td><p>65.3</p></td>
<td><p>54.7</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The test was performed with a single stream in a shielded box using an ASUS RT-N66U router.
ESP32's CPU is dual core with 240 MHz. ESP32's flash is in QIO mode with 80 MHz.</p>
</div>
<p><strong>Ranks:</strong></p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><strong>Iperf rank</strong></dt><dd><p>ESP32 extreme performance rank used to test extreme performance.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>High-performance rank</strong></dt><dd><p>The ESP32's high-performance configuration rank, suitable for scenarios where the application occupies less memory and has high-performance requirements. In this rank, users can choose to use the RX prior rank or the TX prior rank according to the usage scenario.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Default rank</strong></dt><dd><p>ESP32's default configuration rank, the available memory, and performance are in balance.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Memory saving rank</strong></dt><dd><p>This rank is suitable for scenarios where the application requires a large amount of memory, and the transceiver performance will be reduced in this rank.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Minimum rank</strong></dt><dd><p>This is the minimum configuration rank of ESP32. The protocol stack only uses the necessary memory for running. It is suitable for scenarios where there is no requirement for performance and the application requires lots of space.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</section>
<section id="using-psram">
<h3>Using PSRAM<a class="headerlink" href="#using-psram" title="Permalink to this heading"></a></h3>
<p>PSRAM is generally used when the application takes up a lot of memory. In this mode, the <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-tx-buffer"><span class="std std-ref">CONFIG_ESP_WIFI_TX_BUFFER</span></a> is forced to be static. <a class="reference internal" href="../api-reference/kconfig.html#config-esp-wifi-static-tx-buffer-num"><span class="std std-ref">CONFIG_ESP_WIFI_STATIC_TX_BUFFER_NUM</span></a> indicates the number of DMA buffers at the hardware layer, and increasing this parameter can improve performance.
The following are the recommended ranks for using PSRAM:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 25.0%" />
<col style="width: 16.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Rank</p></th>
<th class="head"><p>Iperf</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Memory saving</p></th>
<th class="head"><p>Minimum</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Available memory (KB)</p></td>
<td><p>113.8</p></td>
<td><p>152.4</p></td>
<td><p>181.2</p></td>
<td><p>202.6</p></td>
</tr>
<tr class="row-odd"><td><p>WIFI_STATIC_RX_BUFFER_NUM</p></td>
<td><p>16</p></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>WIFI_DYNAMIC_RX_BUFFER_NUM</p></td>
<td><p>128</p></td>
<td><p>128</p></td>
<td><p>128</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-odd"><td><p>WIFI_STATIC_TX_BUFFER_NUM</p></td>
<td><p>16</p></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>WIFI_RX_BA_WIN</p></td>
<td><p>16</p></td>
<td><p>16</p></td>
<td><p>8</p></td>
<td><p>Disable</p></td>
</tr>
<tr class="row-odd"><td><p>TCP_SND_BUF_DEFAULT (KB)</p></td>
<td><p>65</p></td>
<td><p>65</p></td>
<td><p>65</p></td>
<td><p>65</p></td>
</tr>
<tr class="row-even"><td><p>TCP_WND_DEFAULT (KB)</p></td>
<td><p>65</p></td>
<td><p>65</p></td>
<td><p>65</p></td>
<td><p>65</p></td>
</tr>
<tr class="row-odd"><td><p>WIFI_IRAM_OPT</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>DISABLE</p></td>
</tr>
<tr class="row-even"><td><p>WIFI_RX_IRAM_OPT</p></td>
<td><p>ENABLE</p></td>
<td><p>ENABLE</p></td>
<td><p>DISABLE</p></td>
<td><p>DISABLE</p></td>
</tr>
<tr class="row-odd"><td><p>LWIP_IRAM_OPTIMIZATION</p></td>
<td><p>ENABLE</p></td>
<td><p>DISABLE</p></td>
<td><p>DISABLE</p></td>
<td><p>DISABLE</p></td>
</tr>
<tr class="row-even"><td><p>TCP TX throughput (Mbit/s)</p></td>
<td><p>37.5</p></td>
<td><p>31.7</p></td>
<td><p>21.7</p></td>
<td><p>14.6</p></td>
</tr>
<tr class="row-odd"><td><p>TCP RX throughput (Mbit/s)</p></td>
<td><p>31.5</p></td>
<td><p>29.8</p></td>
<td><p>26.5</p></td>
<td><p>21.1</p></td>
</tr>
<tr class="row-even"><td><p>UDP TX throughput (Mbit/s)</p></td>
<td><p>69.1</p></td>
<td><p>31.5</p></td>
<td><p>27.1</p></td>
<td><p>24.1</p></td>
</tr>
<tr class="row-odd"><td><p>UDP RX throughput (Mbit/s)</p></td>
<td><p>40.1</p></td>
<td><p>38.5</p></td>
<td><p>37.5</p></td>
<td><p>36.9</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="wi-fi-menuconfig">
<h2>Wi-Fi Menuconfig<a class="headerlink" href="#wi-fi-menuconfig" title="Permalink to this heading"></a></h2>
<section id="wi-fi-buffer-configure">
<h3>Wi-Fi Buffer Configure<a class="headerlink" href="#wi-fi-buffer-configure" title="Permalink to this heading"></a></h3>
<p>If you are going to modify the default number or type of buffer, it would be helpful to also have an overview of how the buffer is allocated/freed in the data path. The following diagram shows this process in the TX direction:</p>
<figure class="align-center" id="id11">
<div class="align-default"><img height="160" src="../_images/blockdiag-cf850fcc9767e4edd028ed206e9233b46ef1d9e4.png" width="590" /></div>
<figcaption>
<p><span class="caption-text">TX Buffer Allocation</span><a class="headerlink" href="#id11" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Description:</p>
<blockquote>
<div><ul class="simple">
<li><p>The application allocates the data which needs to be sent out.</p></li>
<li><p>The application calls TCPIP-/Socket-related APIs to send the user data. These APIs will allocate a PBUF used in LwIP, and make a copy of the user data.</p></li>
<li><p>When LwIP calls a Wi-Fi API to send the PBUF, the Wi-Fi API will allocate a &quot;Dynamic Tx Buffer&quot; or &quot;Static Tx Buffer&quot;, make a copy of the LwIP PBUF, and finally send the data.</p></li>
</ul>
</div></blockquote>
<p>The following diagram shows how buffer is allocated/freed in the RX direction:</p>
<figure class="align-center" id="id12">
<div class="align-default"><img height="160" src="../_images/blockdiag-821e6baa08548a8de9c5103725c6fc8dea831bf9.png" width="600" /></div>
<figcaption>
<p><span class="caption-text">RX Buffer Allocation</span><a class="headerlink" href="#id12" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Description:</p>
<blockquote>
<div><ul class="simple">
<li><p>The Wi-Fi hardware receives a packet over the air and puts the packet content to the &quot;Static Rx Buffer&quot;, which is also called &quot;RX DMA Buffer&quot;.</p></li>
<li><p>The Wi-Fi driver allocates a &quot;Dynamic Rx Buffer&quot;, makes a copy of the &quot;Static Rx Buffer&quot;, and returns the &quot;Static Rx Buffer&quot; to hardware.</p></li>
<li><p>The Wi-Fi driver delivers the packet to the upper-layer (LwIP), and allocates a PBUF for holding the &quot;Dynamic Rx Buffer&quot;.</p></li>
<li><p>The application receives data from LwIP.</p></li>
</ul>
</div></blockquote>
<p>The diagram shows the configuration of the Wi-Fi internal buffer.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15.4%" />
<col style="width: 15.4%" />
<col style="width: 15.4%" />
<col style="width: 15.4%" />
<col style="width: 38.5%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Buffer Type</p></th>
<th class="head"><p>Alloc Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Configurable</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Static RX Buffer (Hardware RX Buffer)</p></td>
<td><p>Static</p></td>
<td><p>10 * 1600 Bytes</p></td>
<td><p>Yes</p></td>
<td><p>This is a kind of DMA memory. It is initialized in <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_initPK18wifi_init_config_t" title="esp_wifi_init"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_init()</span></code></a> and freed in <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv415esp_wifi_deinitv" title="esp_wifi_deinit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_deinit()</span></code></a>. The ‘Static Rx Buffer’ forms the hardware receiving list. Upon receiving a frame over the air, hardware writes the frame into the buffer and raises an interrupt to the CPU. Then, the Wi-Fi driver reads the content from the buffer and returns the buffer back to the list.</p>
<p>If needs be, the application can reduce the memory statically allocated by Wi-Fi. It can reduce this value from 10 to 6 to save 6400 Bytes of memory. It is not recommended to reduce the configuration to a value less than 6 unless the AMPDU feature is disabled.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Dynamic RX Buffer</p></td>
<td><p>Dynamic</p></td>
<td><p>32</p></td>
<td><p>Yes</p></td>
<td><p>The buffer length is variable and it depends on the received frames’ length. When the Wi-Fi driver receives a frame from the ‘Hardware Rx Buffer’, the ‘Dynamic Rx Buffer’ needs to be allocated from the heap. The number of the Dynamic Rx Buffer, configured in the menuconfig, is used to limit the total un-freed Dynamic Rx Buffer number.</p></td>
</tr>
<tr class="row-even"><td><p>Dynamic TX Buffer</p></td>
<td><p>Dynamic</p></td>
<td><p>32</p></td>
<td><p>Yes</p></td>
<td><p>This is a kind of DMA memory. It is allocated to the heap. When the upper-layer (LwIP) sends packets to the Wi-Fi driver, it firstly allocates a ‘Dynamic TX Buffer’ and makes a copy of the upper-layer buffer.</p>
<p>The Dynamic and Static TX Buffers are mutually exclusive.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Static TX Buffer</p></td>
<td><p>Static</p></td>
<td><p>16 * 1600Bytes</p></td>
<td><p>Yes</p></td>
<td><p>This is a kind of DMA memory. It is initialized in <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv413esp_wifi_initPK18wifi_init_config_t" title="esp_wifi_init"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_init()</span></code></a> and freed in <a class="reference internal" href="../api-reference/network/esp_wifi.html#_CPPv415esp_wifi_deinitv" title="esp_wifi_deinit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_deinit()</span></code></a>. When the upper-layer (LwIP) sends packets to the Wi-Fi driver, it firstly allocates a ‘Static TX Buffer’ and makes a copy of the upper-layer buffer.</p>
<p>The Dynamic and Static TX Buffer are mutually exclusive.</p>
<p>The TX buffer must be a DMA buffer. For this reason, if PSRAM is enabled, the TX buffer must be static.</p>
</td>
</tr>
<tr class="row-even"><td><p>Management Short Buffer</p></td>
<td><p>Dynamic</p></td>
<td><p>8</p></td>
<td><p>NO</p></td>
<td><p>Wi-Fi driver’s internal buffer.</p></td>
</tr>
<tr class="row-odd"><td><p>Management Long Buffer</p></td>
<td><p>Dynamic</p></td>
<td><p>32</p></td>
<td><p>NO</p></td>
<td><p>Wi-Fi driver’s internal buffer.</p></td>
</tr>
<tr class="row-even"><td><p>Management Long Long Buffer</p></td>
<td><p>Dynamic</p></td>
<td><p>32</p></td>
<td><p>NO</p></td>
<td><p>Wi-Fi driver’s internal buffer.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="wi-fi-nvs-flash">
<h3>Wi-Fi NVS Flash<a class="headerlink" href="#wi-fi-nvs-flash" title="Permalink to this heading"></a></h3>
<p>If the Wi-Fi NVS flash is enabled, all Wi-Fi configurations set via the Wi-Fi APIs will be stored into flash, and the Wi-Fi driver will start up with these configurations the next time it powers on/reboots. However, the application can choose to disable the Wi-Fi NVS flash if it does not need to store the configurations into persistent memory, or has its own persistent storage, or simply due to debugging reasons, etc.</p>
</section>
<section id="wi-fi-aggregate-mac-protocol-data-unit-ampdu">
<h3>Wi-Fi Aggregate MAC Protocol Data Unit (AMPDU)<a class="headerlink" href="#wi-fi-aggregate-mac-protocol-data-unit-ampdu" title="Permalink to this heading"></a></h3>
<p>ESP32 supports both receiving and transmitting AMPDU, and the AMPDU can greatly improve the Wi-Fi throughput.</p>
<p>Generally, the AMPDU should be enabled. Disabling AMPDU is usually for debugging purposes.</p>
</section>
</section>
<section id="troubleshooting">
<h2>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Permalink to this heading"></a></h2>
<p>Please refer to a separate document with <a class="reference internal" href="wireshark-user-guide.html"><span class="doc">Espressif Wireshark User Guide</span></a>.</p>
<div class="toctree-wrapper compound">
</div>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Wi-Fi Driver (api-guides/wifi)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Wi-Fi Driver (api-guides/wifi)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="host-apps.html" class="btn btn-neutral float-left" title="Running ESP-IDF Applications on Host" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="wireshark-user-guide.html" class="btn btn-neutral float-right" title="Espressif Wireshark User Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>