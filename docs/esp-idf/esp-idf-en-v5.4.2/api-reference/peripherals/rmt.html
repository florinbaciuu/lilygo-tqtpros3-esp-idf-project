<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Remote Control Transceiver (RMT) - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/peripherals/rmt.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/peripherals/rmt';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="SD Pull-up Requirements" href="sd_pullup_requirements.html" />
    <link rel="prev" title="Pulse Counter (PCNT)" href="pcnt.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth® API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Peripherals API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="adc_oneshot.html">Analog to Digital Converter (ADC) Oneshot Mode Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="adc_continuous.html">Analog to Digital Converter (ADC) Continuous Mode Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="adc_calibration.html">Analog to Digital Converter (ADC) Calibration Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk_tree.html">Clock Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="dac.html">Digital To Analog Converter (DAC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio.html">GPIO &amp; RTC GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="gptimer.html">General Purpose Timer (GPTimer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">Inter-Integrated Circuit (I2C)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2s.html">Inter-IC Sound (I2S)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lcd/index.html">LCD</a></li>
<li class="toctree-l3"><a class="reference internal" href="ledc.html">LED Control (LEDC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mcpwm.html">Motor Control Pulse Width Modulator (MCPWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="pcnt.html">Pulse Counter (PCNT)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Remote Control Transceiver (RMT)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functional-overview">Functional Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-examples">Application Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#faq">FAQ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="sd_pullup_requirements.html">SD Pull-up Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc_host.html">SDMMC Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdspi_host.html">SD SPI Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdio_slave.html">SDIO Card Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdm.html">Sigma-Delta Modulation (SDM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_flash/index.html">SPI Flash API</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_master.html">SPI Master Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_slave.html">SPI Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="touch_pad.html">Touch Sensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="twai.html">Two-Wire Automotive Interface (TWAI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="uart.html">Universal Asynchronous Receiver/Transmitter (UART)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Project Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">System API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">Peripherals API</a></li>
      <li class="breadcrumb-item active">Remote Control Transceiver (RMT)</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-reference/peripherals/rmt.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="remote-control-transceiver-rmt">
<h1>Remote Control Transceiver (RMT)<a class="headerlink" href="#remote-control-transceiver-rmt" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/v5.4.2/esp32/api-reference/peripherals/rmt.html">[中文]</a></p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>The RMT (Remote Control Transceiver) peripheral was designed to act as an infrared transceiver. However, due to the flexibility of its data format, RMT can be extended to a versatile and general-purpose transceiver, transmitting or receiving many other types of signals. From the perspective of network layering, the RMT hardware contains both physical and data link layers. The physical layer defines the communication media and bit signal representation. The data link layer defines the format of an RMT frame. The minimal data unit in the frame is called the <strong>RMT symbol</strong>, which is represented by <a class="reference internal" href="#_CPPv417rmt_symbol_word_t" title="rmt_symbol_word_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_symbol_word_t</span></code></a> in the driver.</p>
<p>ESP32 contains multiple channels in the RMT peripheral <a class="footnote-reference brackets" href="#id17" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Each channel can be independently configured as either transmitter or receiver.</p>
<p>Typically, the RMT peripheral can be used in the following scenarios:</p>
<ul class="simple">
<li><p>Transmit or receive infrared signals, with any IR protocols, e.g., NEC</p></li>
<li><p>General-purpose sequence generator</p></li>
<li><p>Transmit signals in a hardware-controlled loop, with a finite or infinite number of times</p></li>
<li><p>Multi-channel simultaneous transmission</p></li>
<li><p>Modulate the carrier to the output signal or demodulate the carrier from the input signal</p></li>
</ul>
<section id="layout-of-rmt-symbols">
<h3>Layout of RMT Symbols<a class="headerlink" href="#layout-of-rmt-symbols" title="Permalink to this heading"></a></h3>
<p>The RMT hardware defines data in its own pattern -- the <strong>RMT symbol</strong>. The diagram below illustrates the bit fields of an RMT symbol. Each symbol consists of two pairs of two values. The first value in the pair is a 15-bit value representing the signal's duration in units of RMT ticks. The second in the pair is a 1-bit value representing the signal's logic level, i.e., high or low.</p>
<figure class="align-center" id="id19">
<div><img height="216" src="../../_images/packetdiag-bcdcdf5ccc789fdfc3fd7fa4bfbd5ecccdc5c9c4.png" width="640" /></div><figcaption>
<p><span class="caption-text">Structure of RMT symbols (L - signal level)</span><a class="headerlink" href="#id19" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="rmt-transmitter-overview">
<h3>RMT Transmitter Overview<a class="headerlink" href="#rmt-transmitter-overview" title="Permalink to this heading"></a></h3>
<p>The data path and control path of an RMT TX channel is illustrated in the figure below:</p>
<figure class="align-center" id="id20">
<div class="align-default"><img height="240" src="../../_images/blockdiag-0ac1feefef35320f272114b5dbf697031589324a.png" width="804" /></div>
<figcaption>
<p><span class="caption-text">RMT Transmitter Overview</span><a class="headerlink" href="#id20" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The driver encodes the user's data into RMT data format, then the RMT transmitter can generate the waveforms according to the encoding artifacts. It is also possible to modulate a high-frequency carrier signal before being routed to a GPIO pad.</p>
</section>
<section id="rmt-receiver-overview">
<h3>RMT Receiver Overview<a class="headerlink" href="#rmt-receiver-overview" title="Permalink to this heading"></a></h3>
<p>The data path and control path of an RMT RX channel is illustrated in the figure below:</p>
<figure class="align-center" id="id21">
<div class="align-default"><img height="340" src="../../_images/blockdiag-ebc76989fd5a53e06d27d868912afef738b39887.png" width="948" /></div>
<figcaption>
<p><span class="caption-text">RMT Receiver Overview</span><a class="headerlink" href="#id21" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The RMT receiver can sample incoming signals into RMT data format, and store the data in memory. It is also possible to tell the receiver the basic characteristics of the incoming signal, so that the signal's stop condition can be recognized, and signal glitches and noise can be filtered out. The RMT peripheral also supports demodulating the high-frequency carrier from the base signal.</p>
</section>
</section>
<section id="functional-overview">
<h2>Functional Overview<a class="headerlink" href="#functional-overview" title="Permalink to this heading"></a></h2>
<p>The description of the RMT functionality is divided into the following sections:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#rmt-resource-allocation"><span class="std std-ref">Resource Allocation</span></a> - covers how to allocate and properly configure RMT channels. It also covers how to recycle channels and other resources when they are no longer used.</p></li>
<li><p><a class="reference internal" href="#rmt-carrier-modulation-and-demodulation"><span class="std std-ref">Carrier Modulation and Demodulation</span></a> - describes how to modulate and demodulate the carrier signals for TX and RX channels respectively.</p></li>
<li><p><a class="reference internal" href="#rmt-register-event-callbacks"><span class="std std-ref">Register Event Callbacks</span></a> - covers how to register user-provided event callbacks to receive RMT channel events.</p></li>
<li><p><a class="reference internal" href="#rmt-enable-and-disable-channel"><span class="std std-ref">Enable and Disable Channel</span></a> - shows how to enable and disable the RMT channel.</p></li>
<li><p><a class="reference internal" href="#rmt-initiate-tx-transaction"><span class="std std-ref">Initiate TX Transaction</span></a> - describes the steps to initiate a transaction for a TX channel.</p></li>
<li><p><a class="reference internal" href="#rmt-initiate-rx-transaction"><span class="std std-ref">Initiate RX Transaction</span></a> - describes the steps to initiate a transaction for an RX channel.</p></li>
<li><p><a class="reference internal" href="#rmt-multiple-channels-simultaneous-transmission"><span class="std std-ref">Multiple Channels Simultaneous Transmission</span></a> - describes how to collect multiple channels into a sync group so that their transmissions can be started simultaneously.</p></li>
<li><p><a class="reference internal" href="#rmt-rmt-encoder"><span class="std std-ref">RMT Encoder</span></a> - focuses on how to write a customized encoder by combining multiple primitive encoders that are provided by the driver.</p></li>
<li><p><a class="reference internal" href="#rmt-power-management"><span class="std std-ref">Power Management</span></a> - describes how different clock sources affects power consumption.</p></li>
<li><p><a class="reference internal" href="#rmt-iram-safe"><span class="std std-ref">IRAM Safe</span></a> - describes how disabling the cache affects the RMT driver, and tips to mitigate it.</p></li>
<li><p><a class="reference internal" href="#rmt-thread-safety"><span class="std std-ref">Thread Safety</span></a> - lists which APIs are guaranteed to be thread-safe by the driver.</p></li>
<li><p><a class="reference internal" href="#rmt-kconfig-options"><span class="std std-ref">Kconfig Options</span></a> - describes the various Kconfig options supported by the RMT driver.</p></li>
</ul>
<section id="resource-allocation">
<span id="rmt-resource-allocation"></span><h3>Resource Allocation<a class="headerlink" href="#resource-allocation" title="Permalink to this heading"></a></h3>
<p>Both RMT TX and RX channels are represented by <a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_channel_handle_t</span></code></a> in the driver. The driver internally manages which channels are available and hands out a free channel on request.</p>
<section id="install-rmt-tx-channel">
<h4>Install RMT TX Channel<a class="headerlink" href="#install-rmt-tx-channel" title="Permalink to this heading"></a></h4>
<p>To install an RMT TX channel, there is a configuration structure that needs to be given in advance <a class="reference internal" href="#_CPPv423rmt_tx_channel_config_t" title="rmt_tx_channel_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t</span></code></a>. The following list describes each member of the configuration structure.</p>
<ul>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t8gpio_numE" title="rmt_tx_channel_config_t::gpio_num"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::gpio_num</span></code></a> sets the GPIO number used by the transmitter.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t7clk_srcE" title="rmt_tx_channel_config_t::clk_src"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::clk_src</span></code></a> selects the source clock for the RMT channel. The available clocks are listed in <a class="reference internal" href="#_CPPv418rmt_clock_source_t" title="rmt_clock_source_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_clock_source_t</span></code></a>. Note that, the selected clock is also used by other channels, which means the user should ensure this configuration is the same when allocating other channels, regardless of TX or RX. For the effect on the power consumption of different clock sources, please refer to the <a class="reference internal" href="#rmt-power-management"><span class="std std-ref">Power Management</span></a> section.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t13resolution_hzE" title="rmt_tx_channel_config_t::resolution_hz"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::resolution_hz</span></code></a> sets the resolution of the internal tick counter. The timing parameter of the RMT signal is calculated based on this <strong>tick</strong>.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t17mem_block_symbolsE" title="rmt_tx_channel_config_t::mem_block_symbols"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::mem_block_symbols</span></code></a> has a slightly different meaning based on if the DMA backend is enabled or not.</p>
<blockquote>
<div><ul class="simple">
<li><p>If the DMA is enabled via <a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t8with_dmaE" title="rmt_tx_channel_config_t::with_dma"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::with_dma</span></code></a>, then this field controls the size of the internal DMA buffer. To achieve a better throughput and smaller CPU overhead, you can set a larger value, e.g., <code class="docutils literal notranslate"><span class="pre">1024</span></code>.</p></li>
<li><p>If DMA is not used, this field controls the size of the dedicated memory block owned by the channel, which should be at least 64.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t17trans_queue_depthE" title="rmt_tx_channel_config_t::trans_queue_depth"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::trans_queue_depth</span></code></a> sets the depth of the internal transaction queue, the deeper the queue, the more transactions can be prepared in the backlog.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t10invert_outE" title="rmt_tx_channel_config_t::invert_out"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::invert_out</span></code></a> is used to decide whether to invert the RMT signal before sending it to the GPIO pad.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t8with_dmaE" title="rmt_tx_channel_config_t::with_dma"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::with_dma</span></code></a> enables the DMA backend for the channel. Using the DMA allows a significant amount of the channel's workload to be offloaded from the CPU. However, the DMA backend is not available on all ESP chips, please refer to [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rmt">TRM</a>] before you enable this option. Or you might encounter a <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_SUPPORTED" title="ESP_ERR_NOT_SUPPORTED"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_SUPPORTED</span></code></a> error.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t13intr_priorityE" title="rmt_tx_channel_config_t::intr_priority"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::intr_priority</span></code></a> Set the priority of the interrupt. If set to <code class="docutils literal notranslate"><span class="pre">0</span></code> , then the driver will use a interrupt with low or medium priority (priority level may be one of 1,2 or 3), otherwise use the priority indicated by <a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t13intr_priorityE" title="rmt_tx_channel_config_t::intr_priority"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::intr_priority</span></code></a>. Please use the number form (1,2,3) , not the bitmask form ((1&lt;&lt;1),(1&lt;&lt;2),(1&lt;&lt;3)). Please pay attention that once the interrupt priority is set, it cannot be changed until <a class="reference internal" href="#_CPPv415rmt_del_channel20rmt_channel_handle_t" title="rmt_del_channel"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_del_channel()</span></code></a> is called.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t8allow_pdE" title="rmt_tx_channel_config_t::allow_pd"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::allow_pd</span></code></a> configures if the driver allows the system to power down the peripheral in light sleep mode. Before entering sleep, the system will backup the RMT register context, which will be restored later when the system exit the sleep mode. Powering down the peripheral can save more power, but at the cost of more memory consumed to save the register context. It's a tradeoff between power consumption and memory consumption. This configuration option relies on specific hardware feature, if you enable it on an unsupported chip, you will see error message like <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">able</span> <span class="pre">to</span> <span class="pre">power</span> <span class="pre">down</span> <span class="pre">in</span> <span class="pre">light</span> <span class="pre">sleep</span></code>.</p></li>
</ul>
<p>Once the <a class="reference internal" href="#_CPPv423rmt_tx_channel_config_t" title="rmt_tx_channel_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t</span></code></a> structure is populated with mandatory parameters, users can call <a class="reference internal" href="#_CPPv418rmt_new_tx_channelPK23rmt_tx_channel_config_tP20rmt_channel_handle_t" title="rmt_new_tx_channel"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code></a> to allocate and initialize a TX channel. This function returns an RMT channel handle if it runs correctly. Specifically, when there are no more free channels in the RMT resource pool, this function returns <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_FOUND" title="ESP_ERR_NOT_FOUND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_FOUND</span></code></a> error. If some feature (e.g., DMA backend) is not supported by the hardware, it returns <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_SUPPORTED" title="ESP_ERR_NOT_SUPPORTED"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_SUPPORTED</span></code></a> error.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rmt_channel_handle_t</span><span class="w"> </span><span class="n">tx_chan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">rmt_tx_channel_config_t</span><span class="w"> </span><span class="n">tx_chan_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RMT_CLK_SRC_DEFAULT</span><span class="p">,</span><span class="w">   </span><span class="c1">// select source clock</span>
<span class="w">    </span><span class="p">.</span><span class="n">gpio_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">                    </span><span class="c1">// GPIO number</span>
<span class="w">    </span><span class="p">.</span><span class="n">mem_block_symbols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w">          </span><span class="c1">// memory block size, 64 * 4 = 256 Bytes</span>
<span class="w">    </span><span class="p">.</span><span class="n">resolution_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1 MHz tick resolution, i.e., 1 tick = 1 µs</span>
<span class="w">    </span><span class="p">.</span><span class="n">trans_queue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w">           </span><span class="c1">// set the number of transactions that can pend in the background</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">invert_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w">        </span><span class="c1">// do not invert output signal</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">with_dma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w">          </span><span class="c1">// do not need DMA backend</span>
<span class="p">};</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_new_tx_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_chan_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tx_chan</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="install-rmt-rx-channel">
<h4>Install RMT RX Channel<a class="headerlink" href="#install-rmt-rx-channel" title="Permalink to this heading"></a></h4>
<p>To install an RMT RX channel, there is a configuration structure that needs to be given in advance <a class="reference internal" href="#_CPPv423rmt_rx_channel_config_t" title="rmt_rx_channel_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t</span></code></a>. The following list describes each member of the configuration structure.</p>
<ul>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t8gpio_numE" title="rmt_rx_channel_config_t::gpio_num"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::gpio_num</span></code></a> sets the GPIO number used by the receiver.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t7clk_srcE" title="rmt_rx_channel_config_t::clk_src"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::clk_src</span></code></a> selects the source clock for the RMT channel. The available clocks are listed in <a class="reference internal" href="#_CPPv418rmt_clock_source_t" title="rmt_clock_source_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_clock_source_t</span></code></a>. Note that, the selected clock is also used by other channels, which means the user should ensure this configuration is the same when allocating other channels, regardless of TX or RX. For the effect on the power consumption of different clock sources, please refer to the <a class="reference internal" href="#rmt-power-management"><span class="std std-ref">Power Management</span></a> section.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t13resolution_hzE" title="rmt_rx_channel_config_t::resolution_hz"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::resolution_hz</span></code></a> sets the resolution of the internal tick counter. The timing parameter of the RMT signal is calculated based on this <strong>tick</strong>.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t17mem_block_symbolsE" title="rmt_rx_channel_config_t::mem_block_symbols"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::mem_block_symbols</span></code></a> has a slightly different meaning based on whether the DMA backend is enabled.</p>
<blockquote>
<div><ul class="simple">
<li><p>If the DMA is enabled via <a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t8with_dmaE" title="rmt_rx_channel_config_t::with_dma"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::with_dma</span></code></a>, this field controls the maximum size of the DMA buffer.</p></li>
<li><p>If DMA is not used, this field controls the size of the dedicated memory block owned by the channel, which should be at least 64.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t9invert_inE" title="rmt_rx_channel_config_t::invert_in"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::invert_in</span></code></a> is used to invert the input signals before it is passed to the RMT receiver. The inversion is done by the GPIO matrix instead of by the RMT peripheral.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t8with_dmaE" title="rmt_rx_channel_config_t::with_dma"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::with_dma</span></code></a> enables the DMA backend for the channel. Using the DMA allows a significant amount of the channel's workload to be offloaded from the CPU. However, the DMA backend is not available on all ESP chips, please refer to [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rmt">TRM</a>] before you enable this option. Or you might encounter a <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_SUPPORTED" title="ESP_ERR_NOT_SUPPORTED"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_SUPPORTED</span></code></a> error.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t13intr_priorityE" title="rmt_rx_channel_config_t::intr_priority"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::intr_priority</span></code></a> Set the priority of the interrupt. If set to <code class="docutils literal notranslate"><span class="pre">0</span></code> , then the driver will use a interrupt with low or medium priority (priority level may be one of 1,2 or 3), otherwise use the priority indicated by <a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t13intr_priorityE" title="rmt_rx_channel_config_t::intr_priority"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::intr_priority</span></code></a>. Please use the number form (1,2,3) , not the bitmask form ((1&lt;&lt;1),(1&lt;&lt;2),(1&lt;&lt;3)). Please pay attention that once the interrupt priority is set, it cannot be changed until <a class="reference internal" href="#_CPPv415rmt_del_channel20rmt_channel_handle_t" title="rmt_del_channel"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_del_channel()</span></code></a> is called.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23rmt_rx_channel_config_t8allow_pdE" title="rmt_rx_channel_config_t::allow_pd"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t::allow_pd</span></code></a> configures if the driver allows the system to power down the peripheral in light sleep mode. Before entering sleep, the system will backup the RMT register context, which will be restored later when the system exit the sleep mode. Powering down the peripheral can save more power, but at the cost of more memory consumed to save the register context. It's a tradeoff between power consumption and memory consumption. This configuration option relies on specific hardware feature, if you enable it on an unsupported chip, you will see error message like <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">able</span> <span class="pre">to</span> <span class="pre">power</span> <span class="pre">down</span> <span class="pre">in</span> <span class="pre">light</span> <span class="pre">sleep</span></code>.</p></li>
</ul>
<p>Once the <a class="reference internal" href="#_CPPv423rmt_rx_channel_config_t" title="rmt_rx_channel_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_rx_channel_config_t</span></code></a> structure is populated with mandatory parameters, users can call <a class="reference internal" href="#_CPPv418rmt_new_rx_channelPK23rmt_rx_channel_config_tP20rmt_channel_handle_t" title="rmt_new_rx_channel"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_rx_channel()</span></code></a> to allocate and initialize an RX channel. This function returns an RMT channel handle if it runs correctly. Specifically, when there are no more free channels in the RMT resource pool, this function returns <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_FOUND" title="ESP_ERR_NOT_FOUND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_FOUND</span></code></a> error. If some feature (e.g., DMA backend) is not supported by the hardware, it returns <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_SUPPORTED" title="ESP_ERR_NOT_SUPPORTED"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_SUPPORTED</span></code></a> error.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rmt_channel_handle_t</span><span class="w"> </span><span class="n">rx_chan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">rmt_rx_channel_config_t</span><span class="w"> </span><span class="n">rx_chan_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RMT_CLK_SRC_DEFAULT</span><span class="p">,</span><span class="w">   </span><span class="c1">// select source clock</span>
<span class="w">    </span><span class="p">.</span><span class="n">resolution_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1 MHz tick resolution, i.e., 1 tick = 1 µs</span>
<span class="w">    </span><span class="p">.</span><span class="n">mem_block_symbols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w">          </span><span class="c1">// memory block size, 64 * 4 = 256 Bytes</span>
<span class="w">    </span><span class="p">.</span><span class="n">gpio_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">                    </span><span class="c1">// GPIO number</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">invert_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w">         </span><span class="c1">// do not invert input signal</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">with_dma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w">          </span><span class="c1">// do not need DMA backend</span>
<span class="p">};</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_new_rx_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx_chan_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rx_chan</span><span class="p">));</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When multiple RMT channels are allocated at the same time, the group’s prescale is determined based on the resolution of the first channel. The driver then selects the appropriate prescale from low to high. To avoid prescale conflicts when allocating multiple channels, allocate channels in order of their target resolution, either from highest to lowest or lowest to highest.</p>
</div>
</section>
<section id="uninstall-rmt-channel">
<h4>Uninstall RMT Channel<a class="headerlink" href="#uninstall-rmt-channel" title="Permalink to this heading"></a></h4>
<p>If a previously installed RMT channel is no longer needed, it is recommended to recycle the resources by calling <a class="reference internal" href="#_CPPv415rmt_del_channel20rmt_channel_handle_t" title="rmt_del_channel"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_del_channel()</span></code></a>, which in return allows the underlying software and hardware resources to be reused for other purposes.</p>
</section>
</section>
<section id="carrier-modulation-and-demodulation">
<span id="rmt-carrier-modulation-and-demodulation"></span><h3>Carrier Modulation and Demodulation<a class="headerlink" href="#carrier-modulation-and-demodulation" title="Permalink to this heading"></a></h3>
<p>The RMT transmitter can generate a carrier wave and modulate it onto the message signal. Compared to the message signal, the carrier signal's frequency is significantly higher. In addition, the user can only set the frequency and duty cycle for the carrier signal. The RMT receiver can demodulate the carrier signal from the incoming signal. Note that, carrier modulation and demodulation are not supported on all ESP chips, please refer to [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rmt">TRM</a>] before configuring the carrier, or you might encounter a <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_SUPPORTED" title="ESP_ERR_NOT_SUPPORTED"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_SUPPORTED</span></code></a> error.</p>
<p>Carrier-related configurations lie in <a class="reference internal" href="#_CPPv420rmt_carrier_config_t" title="rmt_carrier_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_carrier_config_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N20rmt_carrier_config_t12frequency_hzE" title="rmt_carrier_config_t::frequency_hz"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_carrier_config_t::frequency_hz</span></code></a> sets the carrier frequency, in Hz.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N20rmt_carrier_config_t10duty_cycleE" title="rmt_carrier_config_t::duty_cycle"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_carrier_config_t::duty_cycle</span></code></a> sets the carrier duty cycle.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N20rmt_carrier_config_t19polarity_active_lowE" title="rmt_carrier_config_t::polarity_active_low"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_carrier_config_t::polarity_active_low</span></code></a> sets the carrier polarity, i.e., on which level the carrier is applied.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N20rmt_carrier_config_t9always_onE" title="rmt_carrier_config_t::always_on"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_carrier_config_t::always_on</span></code></a> sets whether to output the carrier even when the data transmission has finished. This configuration is only valid for the TX channel.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the RX channel, we should not set the carrier frequency exactly to the theoretical value. It is recommended to leave a tolerance for the carrier frequency. For example, in the snippet below, we set the frequency to 25 KHz, instead of the 38 KHz configured on the TX side. The reason is that reflection and refraction occur when a signal travels through the air, leading to distortion on the receiver side.</p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rmt_carrier_config_t</span><span class="w"> </span><span class="n">tx_carrier_cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">duty_cycle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.33</span><span class="p">,</span><span class="w">                 </span><span class="c1">// duty cycle 33%</span>
<span class="w">    </span><span class="p">.</span><span class="n">frequency_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">38000</span><span class="p">,</span><span class="w">              </span><span class="c1">// 38 KHz</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">polarity_active_low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="c1">// carrier should be modulated to high level</span>
<span class="p">};</span>
<span class="c1">// modulate carrier to TX channel</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_apply_carrier</span><span class="p">(</span><span class="n">tx_chan</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tx_carrier_cfg</span><span class="p">));</span>

<span class="n">rmt_carrier_config_t</span><span class="w"> </span><span class="n">rx_carrier_cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">duty_cycle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.33</span><span class="p">,</span><span class="w">                 </span><span class="c1">// duty cycle 33%</span>
<span class="w">    </span><span class="p">.</span><span class="n">frequency_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">25000</span><span class="p">,</span><span class="w">              </span><span class="c1">// 25 KHz carrier, should be smaller than the transmitter&#39;s carrier frequency</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">polarity_active_low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="c1">// the carrier is modulated to high level</span>
<span class="p">};</span>
<span class="c1">// demodulate carrier from RX channel</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_apply_carrier</span><span class="p">(</span><span class="n">rx_chan</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rx_carrier_cfg</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="register-event-callbacks">
<span id="rmt-register-event-callbacks"></span><h3>Register Event Callbacks<a class="headerlink" href="#register-event-callbacks" title="Permalink to this heading"></a></h3>
<p>When an event occurs on an RMT channel (e.g., transmission or receiving is completed), the CPU is notified of this event via an interrupt. If you have some function that needs to be called when a particular events occur, you can register a callback for that event to the RMT driver's ISR (Interrupt Service Routine) by calling <a class="reference internal" href="#_CPPv431rmt_tx_register_event_callbacks20rmt_channel_handle_tPK24rmt_tx_event_callbacks_tPv" title="rmt_tx_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_tx_register_event_callbacks()</span></code></a> and <a class="reference internal" href="#_CPPv431rmt_rx_register_event_callbacks20rmt_channel_handle_tPK24rmt_rx_event_callbacks_tPv" title="rmt_rx_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_rx_register_event_callbacks()</span></code></a> for TX and RX channel respectively. Since the registered callback functions are called in the interrupt context, the user should ensure the callback function does not block, e.g., by making sure that only FreeRTOS APIs with the <code class="docutils literal notranslate"><span class="pre">FromISR</span></code> suffix are called from within the function. The callback function has a boolean return value used to indicate whether a higher priority task has been unblocked by the callback.</p>
<p>The TX channel-supported event callbacks are listed in the <a class="reference internal" href="#_CPPv424rmt_tx_event_callbacks_t" title="rmt_tx_event_callbacks_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_tx_event_callbacks_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N24rmt_tx_event_callbacks_t13on_trans_doneE" title="rmt_tx_event_callbacks_t::on_trans_done"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_event_callbacks_t::on_trans_done</span></code></a> sets a callback function for the &quot;trans-done&quot; event. The function prototype is declared in <a class="reference internal" href="#_CPPv422rmt_tx_done_callback_t" title="rmt_tx_done_callback_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_tx_done_callback_t</span></code></a>.</p></li>
</ul>
<p>The RX channel-supported event callbacks are listed in the <a class="reference internal" href="#_CPPv424rmt_rx_event_callbacks_t" title="rmt_rx_event_callbacks_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_rx_event_callbacks_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N24rmt_rx_event_callbacks_t12on_recv_doneE" title="rmt_rx_event_callbacks_t::on_recv_done"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_event_callbacks_t::on_recv_done</span></code></a> sets a callback function for &quot;receive-done&quot; event. The function prototype is declared in <a class="reference internal" href="#_CPPv422rmt_rx_done_callback_t" title="rmt_rx_done_callback_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_rx_done_callback_t</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The &quot;receive-done&quot; is not equivalent to &quot;receive-finished&quot;. This callback can also be called at a &quot;partial-receive-done&quot; time, for many times during one receive transaction.</p>
</div>
<p>Users can save their own context in <a class="reference internal" href="#_CPPv431rmt_tx_register_event_callbacks20rmt_channel_handle_tPK24rmt_tx_event_callbacks_tPv" title="rmt_tx_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_tx_register_event_callbacks()</span></code></a> and <a class="reference internal" href="#_CPPv431rmt_rx_register_event_callbacks20rmt_channel_handle_tPK24rmt_rx_event_callbacks_tPv" title="rmt_rx_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_rx_register_event_callbacks()</span></code></a> as well, via the parameter <code class="docutils literal notranslate"><span class="pre">user_data</span></code>. The user data is directly passed to each callback function.</p>
<p>In the callback function, users can fetch the event-specific data that is filled by the driver in the <code class="docutils literal notranslate"><span class="pre">edata</span></code>. Note that the <code class="docutils literal notranslate"><span class="pre">edata</span></code> pointer is <strong>only</strong> valid during the callback, please do not try to save this pointer and use that outside of the callback function.</p>
<p>The TX-done event data is defined in <a class="reference internal" href="#_CPPv424rmt_tx_done_event_data_t" title="rmt_tx_done_event_data_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_tx_done_event_data_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N24rmt_tx_done_event_data_t11num_symbolsE" title="rmt_tx_done_event_data_t::num_symbols"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_done_event_data_t::num_symbols</span></code></a> indicates the number of transmitted RMT symbols. This also reflects the size of the encoding artifacts. Please note, this value accounts for the <code class="docutils literal notranslate"><span class="pre">EOF</span></code> symbol as well, which is appended by the driver to mark the end of one transaction.</p></li>
</ul>
<p>The RX-complete event data is defined in <a class="reference internal" href="#_CPPv424rmt_rx_done_event_data_t" title="rmt_rx_done_event_data_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_rx_done_event_data_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N24rmt_rx_done_event_data_t16received_symbolsE" title="rmt_rx_done_event_data_t::received_symbols"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_done_event_data_t::received_symbols</span></code></a> points to the received RMT symbols. These symbols are saved in the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> parameter of the <a class="reference internal" href="#_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t" title="rmt_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_receive()</span></code></a> function. Users should not free this receive buffer before the callback returns. If you also enabled the partial receive feature, then the user buffer will be used as a &quot;second level buffer&quot;, where its content can be overwritten by data comes in afterwards. In this case, you should copy the received data to another place if you want to keep it or process it later.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N24rmt_rx_done_event_data_t11num_symbolsE" title="rmt_rx_done_event_data_t::num_symbols"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_done_event_data_t::num_symbols</span></code></a> indicates the number of received RMT symbols. This value is not larger than the <code class="docutils literal notranslate"><span class="pre">buffer_size</span></code> parameter of <a class="reference internal" href="#_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t" title="rmt_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_receive()</span></code></a> function. If the <code class="docutils literal notranslate"><span class="pre">buffer_size</span></code> is not sufficient to accommodate all the received RMT symbols, the driver only keeps the maximum number of symbols that the buffer can hold, and excess symbols are discarded or ignored.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N24rmt_rx_done_event_data_t7is_lastE" title="rmt_rx_done_event_data_t::is_last"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_done_event_data_t::is_last</span></code></a> indicates whether the current received buffer is the last one in the transaction. This is useful when you enable the partial reception feature by <a class="reference internal" href="#_CPPv4N20rmt_receive_config_t23extra_rmt_receive_flags13en_partial_rxE" title="rmt_receive_config_t::extra_rmt_receive_flags::en_partial_rx"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_receive_config_t::extra_rmt_receive_flags::en_partial_rx</span></code></a>.</p></li>
</ul>
</section>
<section id="enable-and-disable-channel">
<span id="rmt-enable-and-disable-channel"></span><h3>Enable and Disable Channel<a class="headerlink" href="#enable-and-disable-channel" title="Permalink to this heading"></a></h3>
<p><a class="reference internal" href="#_CPPv410rmt_enable20rmt_channel_handle_t" title="rmt_enable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_enable()</span></code></a> must be called in advance before transmitting or receiving RMT symbols. For TX channels, enabling a channel enables a specific interrupt and prepares the hardware to dispatch transactions. For RX channels, enabling a channel enables an interrupt, but the receiver is not started during this time, as the characteristics of the incoming signal have yet to be specified. The receiver is started in <a class="reference internal" href="#_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t" title="rmt_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_receive()</span></code></a>.</p>
<p><a class="reference internal" href="#_CPPv411rmt_disable20rmt_channel_handle_t" title="rmt_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_disable()</span></code></a> does the opposite by disabling the interrupt and clearing any pending interrupts. The transmitter and receiver are disabled as well.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_enable</span><span class="p">(</span><span class="n">tx_chan</span><span class="p">));</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_enable</span><span class="p">(</span><span class="n">rx_chan</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="initiate-tx-transaction">
<span id="rmt-initiate-tx-transaction"></span><h3>Initiate TX Transaction<a class="headerlink" href="#initiate-tx-transaction" title="Permalink to this heading"></a></h3>
<p>RMT is a special communication peripheral, as it is unable to transmit raw byte streams like SPI and I2C. RMT can only send data in its own format <a class="reference internal" href="#_CPPv417rmt_symbol_word_t" title="rmt_symbol_word_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_symbol_word_t</span></code></a>. However, the hardware does not help to convert the user data into RMT symbols, this can only be done in software by the so-called <strong>RMT Encoder</strong>. The encoder is responsible for encoding user data into RMT symbols and then writing to the RMT memory block or the DMA buffer. For how to create an RMT encoder, please refer to <a class="reference internal" href="#rmt-rmt-encoder"><span class="std std-ref">RMT Encoder</span></a>.</p>
<p>Once you created an encoder, you can initiate a TX transaction by calling <a class="reference internal" href="#_CPPv412rmt_transmit20rmt_channel_handle_t20rmt_encoder_handle_tPKv6size_tPK21rmt_transmit_config_t" title="rmt_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_transmit()</span></code></a>. This function takes several positional parameters like channel handle, encoder handle, and payload buffer. Besides, you also need to provide a transmission-specific configuration in <a class="reference internal" href="#_CPPv421rmt_transmit_config_t" title="rmt_transmit_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_transmit_config_t</span></code></a>:</p>
<ul>
<li><p><a class="reference internal" href="#_CPPv4N21rmt_transmit_config_t10loop_countE" title="rmt_transmit_config_t::loop_count"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_transmit_config_t::loop_count</span></code></a> sets the number of transmission loops. After the transmitter has finished one round of transmission, it can restart the same transmission again if this value is not set to zero. As the loop is controlled by hardware, the RMT channel can be used to generate many periodic sequences with minimal CPU intervention.</p>
<blockquote>
<div><ul class="simple">
<li><p>Setting <a class="reference internal" href="#_CPPv4N21rmt_transmit_config_t10loop_countE" title="rmt_transmit_config_t::loop_count"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_transmit_config_t::loop_count</span></code></a> to <cite>-1</cite> means an infinite loop transmission. In this case, the channel does not stop until <a class="reference internal" href="#_CPPv411rmt_disable20rmt_channel_handle_t" title="rmt_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_disable()</span></code></a> is called. The &quot;trans-done&quot; event is not generated as well.</p></li>
<li><p>Setting <a class="reference internal" href="#_CPPv4N21rmt_transmit_config_t10loop_countE" title="rmt_transmit_config_t::loop_count"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_transmit_config_t::loop_count</span></code></a> to a positive number means finite number of iterations. In this case, the &quot;trans-done&quot; event is when the specified number of iterations have completed.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <strong>loop transmit</strong> feature is not supported on all ESP chips, please refer to [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rmt">TRM</a>] before you configure this option, or you might encounter <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_SUPPORTED" title="ESP_ERR_NOT_SUPPORTED"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_SUPPORTED</span></code></a> error.</p>
</div>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="#_CPPv4N21rmt_transmit_config_t9eot_levelE" title="rmt_transmit_config_t::eot_level"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_transmit_config_t::eot_level</span></code></a> sets the output level when the transmitter finishes working or stops working by calling <a class="reference internal" href="#_CPPv411rmt_disable20rmt_channel_handle_t" title="rmt_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_disable()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N21rmt_transmit_config_t17queue_nonblockingE" title="rmt_transmit_config_t::queue_nonblocking"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_transmit_config_t::queue_nonblocking</span></code></a> sets whether to wait for a free slot in the transaction queue when it is full. If this value is set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, then the function will return with an error code <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_INVALID_STATE" title="ESP_ERR_INVALID_STATE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_STATE</span></code></a> when the queue is full. Otherwise, the function will block until a free slot is available in the queue.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a limitation in the transmission size if the <a class="reference internal" href="#_CPPv4N21rmt_transmit_config_t10loop_countE" title="rmt_transmit_config_t::loop_count"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_transmit_config_t::loop_count</span></code></a> is set to non-zero, i.e., to enable the loop feature. The encoded RMT symbols should not exceed the capacity of the RMT hardware memory block size, or you might see an error message like <code class="docutils literal notranslate"><span class="pre">encoding</span> <span class="pre">artifacts</span> <span class="pre">can't</span> <span class="pre">exceed</span> <span class="pre">hw</span> <span class="pre">memory</span> <span class="pre">block</span> <span class="pre">for</span> <span class="pre">loop</span> <span class="pre">transmission</span></code>. If you have to start a large transaction by loop, you can try either of the following methods.</p>
<ul class="simple">
<li><p>Increase the <a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t17mem_block_symbolsE" title="rmt_tx_channel_config_t::mem_block_symbols"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::mem_block_symbols</span></code></a>. This approach does not work if the DMA backend is also enabled.</p></li>
<li><p>Customize an encoder and construct an infinite loop in the encoding function. See also <a class="reference internal" href="#rmt-rmt-encoder"><span class="std std-ref">RMT Encoder</span></a>.</p></li>
</ul>
</div>
<p>Internally, <a class="reference internal" href="#_CPPv412rmt_transmit20rmt_channel_handle_t20rmt_encoder_handle_tPKv6size_tPK21rmt_transmit_config_t" title="rmt_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_transmit()</span></code></a> constructs a transaction descriptor and sends it to a job queue, which is dispatched in the ISR. So it is possible that the transaction is not started yet when <a class="reference internal" href="#_CPPv412rmt_transmit20rmt_channel_handle_t20rmt_encoder_handle_tPKv6size_tPK21rmt_transmit_config_t" title="rmt_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_transmit()</span></code></a> returns. You cannot recycle or modify the payload buffer until the transaction is finished. You can get the transaction completion event by registering a callback function via <a class="reference internal" href="#_CPPv431rmt_tx_register_event_callbacks20rmt_channel_handle_tPK24rmt_tx_event_callbacks_tPv" title="rmt_tx_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_tx_register_event_callbacks()</span></code></a>. To ensure all pending transactions to complete, you can also use <a class="reference internal" href="#_CPPv420rmt_tx_wait_all_done20rmt_channel_handle_ti" title="rmt_tx_wait_all_done"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_tx_wait_all_done()</span></code></a>.</p>
</section>
<section id="multiple-channels-simultaneous-transmission">
<span id="rmt-multiple-channels-simultaneous-transmission"></span><h3>Multiple Channels Simultaneous Transmission<a class="headerlink" href="#multiple-channels-simultaneous-transmission" title="Permalink to this heading"></a></h3>
<p>In some real-time control applications (e.g., to make two robotic arms move simultaneously), you do not want any time drift between different channels. The RMT driver can help to manage this by creating a so-called <strong>Sync Manager</strong>. The sync manager is represented by <a class="reference internal" href="#_CPPv425rmt_sync_manager_handle_t" title="rmt_sync_manager_handle_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_sync_manager_handle_t</span></code></a> in the driver. The procedure of RMT sync transmission is shown as follows:</p>
<figure class="align-center" id="id22">
<img alt="RMT TX Sync" src="../../_images/rmt_tx_sync.png" />
<figcaption>
<p><span class="caption-text">RMT TX Sync</span><a class="headerlink" href="#id22" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<section id="install-rmt-sync-manager">
<h4>Install RMT Sync Manager<a class="headerlink" href="#install-rmt-sync-manager" title="Permalink to this heading"></a></h4>
<p>To create a sync manager, the user needs to tell which channels are going to be managed in the <a class="reference internal" href="#_CPPv425rmt_sync_manager_config_t" title="rmt_sync_manager_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_sync_manager_config_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N25rmt_sync_manager_config_t16tx_channel_arrayE" title="rmt_sync_manager_config_t::tx_channel_array"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_sync_manager_config_t::tx_channel_array</span></code></a> points to the array of TX channels to be managed.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N25rmt_sync_manager_config_t10array_sizeE" title="rmt_sync_manager_config_t::array_size"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_sync_manager_config_t::array_size</span></code></a> sets the number of channels to be managed.</p></li>
</ul>
<p><a class="reference internal" href="#_CPPv420rmt_new_sync_managerPK25rmt_sync_manager_config_tP25rmt_sync_manager_handle_t" title="rmt_new_sync_manager"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_sync_manager()</span></code></a> can return a manager handle on success. This function could also fail due to various errors such as invalid arguments, etc. Especially, when the sync manager has been installed before, and there are no hardware resources to create another manager, this function reports <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_FOUND" title="ESP_ERR_NOT_FOUND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_FOUND</span></code></a> error. In addition, if the sync manager is not supported by the hardware, it reports a <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_SUPPORTED" title="ESP_ERR_NOT_SUPPORTED"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_SUPPORTED</span></code></a> error. Please refer to [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rmt">TRM</a>] before using the sync manager feature.</p>
</section>
<section id="start-transmission-simultaneously">
<h4>Start Transmission Simultaneously<a class="headerlink" href="#start-transmission-simultaneously" title="Permalink to this heading"></a></h4>
<p>For any managed TX channel, it does not start the machine until <a class="reference internal" href="#_CPPv412rmt_transmit20rmt_channel_handle_t20rmt_encoder_handle_tPKv6size_tPK21rmt_transmit_config_t" title="rmt_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_transmit()</span></code></a> has been called on all channels in <a class="reference internal" href="#_CPPv4N25rmt_sync_manager_config_t16tx_channel_arrayE" title="rmt_sync_manager_config_t::tx_channel_array"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_sync_manager_config_t::tx_channel_array</span></code></a>. Before that, the channel is just put in a waiting state. TX channels will usually complete their transactions at different times due to differing transactions, thus resulting in a loss of sync. So before restarting a simultaneous transmission, the user needs to call <a class="reference internal" href="#_CPPv414rmt_sync_reset25rmt_sync_manager_handle_t" title="rmt_sync_reset"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_sync_reset()</span></code></a> to synchronize all channels again.</p>
<p>Calling <a class="reference internal" href="#_CPPv420rmt_del_sync_manager25rmt_sync_manager_handle_t" title="rmt_del_sync_manager"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_del_sync_manager()</span></code></a> can recycle the sync manager and enable the channels to initiate transactions independently afterward.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rmt_channel_handle_t</span><span class="w"> </span><span class="n">tx_channels</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">NULL</span><span class="p">};</span><span class="w"> </span><span class="c1">// declare two channels</span>
<span class="kt">int</span><span class="w"> </span><span class="n">tx_gpio_number</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span>
<span class="c1">// install channels one by one</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rmt_tx_channel_config_t</span><span class="w"> </span><span class="n">tx_chan_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">clk_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RMT_CLK_SRC_DEFAULT</span><span class="p">,</span><span class="w">       </span><span class="c1">// select source clock</span>
<span class="w">        </span><span class="p">.</span><span class="n">gpio_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx_gpio_number</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w">    </span><span class="c1">// GPIO number</span>
<span class="w">        </span><span class="p">.</span><span class="n">mem_block_symbols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w">          </span><span class="c1">// memory block size, 64 * 4 = 256 Bytes</span>
<span class="w">        </span><span class="p">.</span><span class="n">resolution_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="c1">// 1 MHz resolution</span>
<span class="w">        </span><span class="p">.</span><span class="n">trans_queue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">           </span><span class="c1">// set the number of transactions that can pend in the background</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_new_tx_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_chan_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tx_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="p">}</span>
<span class="c1">// enable the channels</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_enable</span><span class="p">(</span><span class="n">tx_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="p">}</span>
<span class="c1">// install sync manager</span>
<span class="n">rmt_sync_manager_handle_t</span><span class="w"> </span><span class="n">synchro</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">rmt_sync_manager_config_t</span><span class="w"> </span><span class="n">synchro_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">tx_channel_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx_channels</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">array_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tx_channels</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tx_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
<span class="p">};</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_new_sync_manager</span><span class="p">(</span><span class="o">&amp;</span><span class="n">synchro_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">synchro</span><span class="p">));</span>

<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_transmit</span><span class="p">(</span><span class="n">tx_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">led_strip_encoders</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">led_data</span><span class="p">,</span><span class="w"> </span><span class="n">led_num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">transmit_config</span><span class="p">));</span>
<span class="c1">// tx_channels[0] does not start transmission until call of `rmt_transmit()` for tx_channels[1] returns</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_transmit</span><span class="p">(</span><span class="n">tx_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">led_strip_encoders</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">led_data</span><span class="p">,</span><span class="w"> </span><span class="n">led_num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">transmit_config</span><span class="p">));</span>
</pre></div>
</div>
</section>
</section>
<section id="initiate-rx-transaction">
<span id="rmt-initiate-rx-transaction"></span><h3>Initiate RX Transaction<a class="headerlink" href="#initiate-rx-transaction" title="Permalink to this heading"></a></h3>
<p>As also discussed in the <a class="reference internal" href="#rmt-enable-and-disable-channel"><span class="std std-ref">Enable and Disable Channel</span></a>, calling <a class="reference internal" href="#_CPPv410rmt_enable20rmt_channel_handle_t" title="rmt_enable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_enable()</span></code></a> does not prepare an RX to receive RMT symbols. The user needs to specify the basic characteristics of the incoming signals in <a class="reference internal" href="#_CPPv420rmt_receive_config_t" title="rmt_receive_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_receive_config_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N20rmt_receive_config_t19signal_range_min_nsE" title="rmt_receive_config_t::signal_range_min_ns"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_receive_config_t::signal_range_min_ns</span></code></a> specifies the minimal valid pulse duration in either high or low logic levels. A pulse width that is smaller than this value is treated as a glitch, and ignored by the hardware.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N20rmt_receive_config_t19signal_range_max_nsE" title="rmt_receive_config_t::signal_range_max_ns"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_receive_config_t::signal_range_max_ns</span></code></a> specifies the maximum valid pulse duration in either high or low logic levels. A pulse width that is bigger than this value is treated as <strong>Stop Signal</strong>, and the receiver generates receive-complete event immediately.</p></li>
<li><p>If the incoming packet is long, that they cannot be stored in the user buffer at once, you can enable the partial reception feature by setting <a class="reference internal" href="#_CPPv4N20rmt_receive_config_t23extra_rmt_receive_flags13en_partial_rxE" title="rmt_receive_config_t::extra_rmt_receive_flags::en_partial_rx"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_receive_config_t::extra_rmt_receive_flags::en_partial_rx</span></code></a> to <code class="docutils literal notranslate"><span class="pre">true</span></code>. In this case, the driver invokes <a class="reference internal" href="#_CPPv4N24rmt_rx_event_callbacks_t12on_recv_doneE" title="rmt_rx_event_callbacks_t::on_recv_done"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_event_callbacks_t::on_recv_done</span></code></a> callback multiple times during one transaction, when the user buffer is <strong>almost full</strong>. You can check the value of :cpp:member::<cite>rmt_rx_done_event_data_t::is_last</cite> to know if the transaction is about to finish. Please note this features is not supported on all ESP series chips because it relies on hardware abilities like &quot;ping-pong receive&quot; or &quot;DMA receive&quot;.</p></li>
</ul>
<p>The RMT receiver starts the RX machine after the user calls <a class="reference internal" href="#_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t" title="rmt_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_receive()</span></code></a> with the provided configuration above. Note that, this configuration is transaction specific, which means, to start a new round of reception, the user needs to set the <a class="reference internal" href="#_CPPv420rmt_receive_config_t" title="rmt_receive_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_receive_config_t</span></code></a> again. The receiver saves the incoming signals into its internal memory block or DMA buffer, in the format of <a class="reference internal" href="#_CPPv417rmt_symbol_word_t" title="rmt_symbol_word_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_symbol_word_t</span></code></a>.</p>
<p>Due to the limited size of the memory block, the RMT receiver can only save short frames whose length is not longer than the memory block capacity. Long frames are truncated by the hardware, and the driver reports an error message: <code class="docutils literal notranslate"><span class="pre">hw</span> <span class="pre">buffer</span> <span class="pre">too</span> <span class="pre">small,</span> <span class="pre">received</span> <span class="pre">symbols</span> <span class="pre">truncated</span></code>.</p>
<p>The copy destination should be provided in the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> parameter of <a class="reference internal" href="#_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t" title="rmt_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_receive()</span></code></a> function. If this buffer overflows due to an insufficient buffer size, the receiver can continue to work, but overflowed symbols are dropped and the following error message is reported: <code class="docutils literal notranslate"><span class="pre">user</span> <span class="pre">buffer</span> <span class="pre">too</span> <span class="pre">small,</span> <span class="pre">received</span> <span class="pre">symbols</span> <span class="pre">truncated</span></code>. Please take care of the lifecycle of the <code class="docutils literal notranslate"><span class="pre">buffer</span></code> parameter, ensuring that the buffer is not recycled before the receiver is finished or stopped.</p>
<p>The receiver is stopped by the driver when it finishes working, i.e., receive a signal whose duration is bigger than <a class="reference internal" href="#_CPPv4N20rmt_receive_config_t19signal_range_max_nsE" title="rmt_receive_config_t::signal_range_max_ns"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_receive_config_t::signal_range_max_ns</span></code></a>. The user needs to call <a class="reference internal" href="#_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t" title="rmt_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_receive()</span></code></a> again to restart the receiver, if necessary. The user can get the received data in the <a class="reference internal" href="#_CPPv4N24rmt_rx_event_callbacks_t12on_recv_doneE" title="rmt_rx_event_callbacks_t::on_recv_done"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_rx_event_callbacks_t::on_recv_done</span></code></a> callback. See also <a class="reference internal" href="#rmt-register-event-callbacks"><span class="std std-ref">Register Event Callbacks</span></a> for more information.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">example_rmt_rx_done_callback</span><span class="p">(</span><span class="n">rmt_channel_handle_t</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">rmt_rx_done_event_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">edata</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">high_task_wakeup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w">    </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">receive_queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">QueueHandle_t</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// send the received RMT symbols to the parser task</span>
<span class="w">    </span><span class="n">xQueueSendFromISR</span><span class="p">(</span><span class="n">receive_queue</span><span class="p">,</span><span class="w"> </span><span class="n">edata</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">high_task_wakeup</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// return whether any task is woken up</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">high_task_wakeup</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">receive_queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rmt_rx_done_event_data_t</span><span class="p">));</span>
<span class="n">rmt_rx_event_callbacks_t</span><span class="w"> </span><span class="n">cbs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">on_recv_done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_rmt_rx_done_callback</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_rx_register_event_callbacks</span><span class="p">(</span><span class="n">rx_channel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cbs</span><span class="p">,</span><span class="w"> </span><span class="n">receive_queue</span><span class="p">));</span>

<span class="c1">// the following timing requirement is based on NEC protocol</span>
<span class="n">rmt_receive_config_t</span><span class="w"> </span><span class="n">receive_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">signal_range_min_ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1250</span><span class="p">,</span><span class="w">     </span><span class="c1">// the shortest duration for NEC signal is 560 µs, 1250 ns &lt; 560 µs, valid signal is not treated as noise</span>
<span class="w">    </span><span class="p">.</span><span class="n">signal_range_max_ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12000000</span><span class="p">,</span><span class="w"> </span><span class="c1">// the longest duration for NEC signal is 9000 µs, 12000000 ns &gt; 9000 µs, the receive does not stop early</span>
<span class="p">};</span>

<span class="n">rmt_symbol_word_t</span><span class="w"> </span><span class="n">raw_symbols</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span><span class="w"> </span><span class="c1">// 64 symbols should be sufficient for a standard NEC frame</span>
<span class="c1">// ready to receive</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">rmt_receive</span><span class="p">(</span><span class="n">rx_channel</span><span class="p">,</span><span class="w"> </span><span class="n">raw_symbols</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">raw_symbols</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">receive_config</span><span class="p">));</span>
<span class="c1">// wait for the RX-done signal</span>
<span class="n">rmt_rx_done_event_data_t</span><span class="w"> </span><span class="n">rx_data</span><span class="p">;</span>
<span class="n">xQueueReceive</span><span class="p">(</span><span class="n">receive_queue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rx_data</span><span class="p">,</span><span class="w"> </span><span class="n">portMAX_DELAY</span><span class="p">);</span>
<span class="c1">// parse the received symbols</span>
<span class="n">example_parse_nec_frame</span><span class="p">(</span><span class="n">rx_data</span><span class="p">.</span><span class="n">received_symbols</span><span class="p">,</span><span class="w"> </span><span class="n">rx_data</span><span class="p">.</span><span class="n">num_symbols</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="rmt-encoder">
<span id="rmt-rmt-encoder"></span><h3>RMT Encoder<a class="headerlink" href="#rmt-encoder" title="Permalink to this heading"></a></h3>
<p>An RMT encoder is part of the RMT TX transaction, whose responsibility is to generate and write the correct RMT symbols into hardware memory or DMA buffer at a specific time. There are some special restrictions for an encoding function:</p>
<ul class="simple">
<li><p>During a single transaction, the encoding function may be called multiple times. This is necessary because the target RMT memory block cannot hold all the artifacts at once. To overcome this limitation, the driver utilizes a <strong>ping-pong</strong> approach, where the encoding session is divided into multiple parts. This means that the encoder needs to <strong>keep track of its state</strong> to continue encoding from where it left off in the previous part.</p></li>
<li><p>The encoding function is running in the ISR context. To speed up the encoding session, it is highly recommended to put the encoding function into IRAM. This can also avoid the cache miss during encoding.</p></li>
</ul>
<p>To help get started with the RMT driver faster, some commonly used encoders are provided out-of-the-box. They can either work alone or be chained together into a new encoder. See also <a class="reference external" href="https://en.wikipedia.org/wiki/Composite_pattern">Composite Pattern</a> for the principle behind it. The driver has defined the encoder interface in <a class="reference internal" href="#_CPPv413rmt_encoder_t" title="rmt_encoder_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_encoder_t</span></code></a>, it contains the following functions:</p>
<ul>
<li><p><a class="reference internal" href="#_CPPv4N13rmt_encoder_t6encodeE" title="rmt_encoder_t::encode"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_encoder_t::encode</span></code></a> is the fundamental function of an encoder. This is where the encoding session happens.</p>
<blockquote>
<div><ul class="simple">
<li><p>The function might be called multiple times within a single transaction. The encode function should return the state of the current encoding session.</p></li>
<li><p>The supported states are listed in the <a class="reference internal" href="#_CPPv418rmt_encode_state_t" title="rmt_encode_state_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_encode_state_t</span></code></a>. If the result contains <a class="reference internal" href="#_CPPv4N18rmt_encode_state_t21RMT_ENCODING_COMPLETEE" title="RMT_ENCODING_COMPLETE"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">RMT_ENCODING_COMPLETE</span></code></a>, it means the current encoder has finished work.</p></li>
<li><p>If the result contains <a class="reference internal" href="#_CPPv4N18rmt_encode_state_t21RMT_ENCODING_MEM_FULLE" title="RMT_ENCODING_MEM_FULL"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">RMT_ENCODING_MEM_FULL</span></code></a>, the program needs to yield from the current session, as there is no space to save more encoding artifacts.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="#_CPPv4N13rmt_encoder_t5resetE" title="rmt_encoder_t::reset"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_encoder_t::reset</span></code></a> should reset the encoder state back to the initial state (the RMT encoder is stateful).</p>
<blockquote>
<div><ul class="simple">
<li><p>If the RMT transmitter is manually stopped without resetting its corresponding encoder, subsequent encoding session can be erroneous.</p></li>
<li><p>This function is also called implicitly in <a class="reference internal" href="#_CPPv411rmt_disable20rmt_channel_handle_t" title="rmt_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_disable()</span></code></a>.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="#_CPPv4N13rmt_encoder_t3delE" title="rmt_encoder_t::del"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_encoder_t::del</span></code></a> should free the resources allocated by the encoder.</p></li>
</ul>
<section id="copy-encoder">
<h4>Copy Encoder<a class="headerlink" href="#copy-encoder" title="Permalink to this heading"></a></h4>
<p>A copy encoder is created by calling <a class="reference internal" href="#_CPPv420rmt_new_copy_encoderPK25rmt_copy_encoder_config_tP20rmt_encoder_handle_t" title="rmt_new_copy_encoder"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_copy_encoder()</span></code></a>. A copy encoder's main functionality is to copy the RMT symbols from user space into the driver layer. It is usually used to encode <code class="docutils literal notranslate"><span class="pre">const</span></code> data, i.e., data does not change at runtime after initialization such as the leading code in the IR protocol.</p>
<p>A configuration structure <a class="reference internal" href="#_CPPv425rmt_copy_encoder_config_t" title="rmt_copy_encoder_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_copy_encoder_config_t</span></code></a> should be provided in advance before calling <a class="reference internal" href="#_CPPv420rmt_new_copy_encoderPK25rmt_copy_encoder_config_tP20rmt_encoder_handle_t" title="rmt_new_copy_encoder"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_copy_encoder()</span></code></a>. Currently, this configuration is reserved for future expansion, and has no specific use or setting items for now.</p>
</section>
<section id="bytes-encoder">
<h4>Bytes Encoder<a class="headerlink" href="#bytes-encoder" title="Permalink to this heading"></a></h4>
<p>A bytes encoder is created by calling <a class="reference internal" href="#_CPPv421rmt_new_bytes_encoderPK26rmt_bytes_encoder_config_tP20rmt_encoder_handle_t" title="rmt_new_bytes_encoder"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_bytes_encoder()</span></code></a>. The bytes encoder's main functionality is to convert the user space byte stream into RMT symbols dynamically. It is usually used to encode dynamic data, e.g., the address and command fields in the IR protocol.</p>
<p>A configuration structure <a class="reference internal" href="#_CPPv426rmt_bytes_encoder_config_t" title="rmt_bytes_encoder_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_bytes_encoder_config_t</span></code></a> should be provided in advance before calling <a class="reference internal" href="#_CPPv421rmt_new_bytes_encoderPK26rmt_bytes_encoder_config_tP20rmt_encoder_handle_t" title="rmt_new_bytes_encoder"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_bytes_encoder()</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N26rmt_bytes_encoder_config_t4bit0E" title="rmt_bytes_encoder_config_t::bit0"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_bytes_encoder_config_t::bit0</span></code></a> and <a class="reference internal" href="#_CPPv4N26rmt_bytes_encoder_config_t4bit1E" title="rmt_bytes_encoder_config_t::bit1"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_bytes_encoder_config_t::bit1</span></code></a> are necessary to specify the encoder how to represent bit zero and bit one in the format of <a class="reference internal" href="#_CPPv417rmt_symbol_word_t" title="rmt_symbol_word_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_symbol_word_t</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N26rmt_bytes_encoder_config_t9msb_firstE" title="rmt_bytes_encoder_config_t::msb_first"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_bytes_encoder_config_t::msb_first</span></code></a> sets the bit endianness of each byte. If it is set to true, the encoder encodes the <strong>Most Significant Bit</strong> first. Otherwise, it encodes the <strong>Least Significant Bit</strong> first.</p></li>
</ul>
<p>Besides the primitive encoders provided by the driver, the user can implement his own encoder by chaining the existing encoders together. A common encoder chain is shown as follows:</p>
<figure class="align-center" id="id23">
<div class="align-default"><img height="360" src="../../_images/blockdiag-4bddad00e342fb307bc97b71a853a66568ca4f0d.png" width="800" /></div>
<figcaption>
<p><span class="caption-text">RMT Encoder Chain</span><a class="headerlink" href="#id23" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="simple-callback-encoder">
<h4>Simple Callback Encoder<a class="headerlink" href="#simple-callback-encoder" title="Permalink to this heading"></a></h4>
<p>A simple callback encoder is created by calling <a class="reference internal" href="#_CPPv422rmt_new_simple_encoderPK27rmt_simple_encoder_config_tP20rmt_encoder_handle_t" title="rmt_new_simple_encoder"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_simple_encoder()</span></code></a>. The simple callback encoder allows you to provide a callback that reads data from userspace and writes symbols to the output stream without having to chain other encoders. The callback itself gets a pointer to the data passed to <a class="reference internal" href="#_CPPv412rmt_transmit20rmt_channel_handle_t20rmt_encoder_handle_tPKv6size_tPK21rmt_transmit_config_t" title="rmt_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_transmit()</span></code></a>, a counter indicating the amount of symbols already written by the callback in this transmission, and a pointer where to write the encoded RMT symbols as well as the free space there. If the space is not enough for the callback to encode something, it can return 0 and the RMT will wait for previous symbols to be transmitted and call the callback again, now with more space available. If the callback successfully writes RMT symbols, it should return the number of symbols written.</p>
<p>A configuration structure <a class="reference internal" href="#_CPPv427rmt_simple_encoder_config_t" title="rmt_simple_encoder_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_simple_encoder_config_t</span></code></a> should be provided in advance before calling <a class="reference internal" href="#_CPPv422rmt_new_simple_encoderPK27rmt_simple_encoder_config_tP20rmt_encoder_handle_t" title="rmt_new_simple_encoder"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_simple_encoder()</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N27rmt_simple_encoder_config_t8callbackE" title="rmt_simple_encoder_config_t::callback"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_simple_encoder_config_t::callback</span></code></a> and <a class="reference internal" href="#_CPPv4N27rmt_simple_encoder_config_t3argE" title="rmt_simple_encoder_config_t::arg"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_simple_encoder_config_t::arg</span></code></a> provide the callback function and an opaque argument that will be passed to that function.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N27rmt_simple_encoder_config_t14min_chunk_sizeE" title="rmt_simple_encoder_config_t::min_chunk_size"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_simple_encoder_config_t::min_chunk_size</span></code></a> specifies the minimum amount of free space, in symbols, the encoder will be always be able to write some data to. In other words, when this amount of free space is passed to the encoder, it should never return 0 (except when the encoder is done encoding symbols).</p></li>
</ul>
<p>While the functionality of an encoding process using the simple callback encoder can usually also realized by chaining other encoders, the simple callback can be more easy to understand and maintain than an encoder chain.</p>
</section>
<section id="customize-rmt-encoder-for-nec-protocol">
<h4>Customize RMT Encoder for NEC Protocol<a class="headerlink" href="#customize-rmt-encoder-for-nec-protocol" title="Permalink to this heading"></a></h4>
<p>This section demonstrates how to write an NEC encoder. The NEC IR protocol uses pulse distance encoding of the message bits. Each pulse burst is <code class="docutils literal notranslate"><span class="pre">562.5</span> <span class="pre">µs</span></code> in length, logical bits are transmitted as follows. It is worth mentioning that the least significant bit of each byte is sent first.</p>
<ul class="simple">
<li><p>Logical <code class="docutils literal notranslate"><span class="pre">0</span></code>: a <code class="docutils literal notranslate"><span class="pre">562.5</span> <span class="pre">µs</span></code> pulse burst followed by a <code class="docutils literal notranslate"><span class="pre">562.5</span> <span class="pre">µs</span></code> space, with a total transmit time of <code class="docutils literal notranslate"><span class="pre">1.125</span> <span class="pre">ms</span></code></p></li>
<li><p>Logical <code class="docutils literal notranslate"><span class="pre">1</span></code>: a <code class="docutils literal notranslate"><span class="pre">562.5</span> <span class="pre">µs</span></code> pulse burst followed by a <code class="docutils literal notranslate"><span class="pre">1.6875</span> <span class="pre">ms</span></code> space, with a total transmit time of <code class="docutils literal notranslate"><span class="pre">2.25</span> <span class="pre">ms</span></code></p></li>
</ul>
<p>When a key is pressed on the remote controller, the transmitted message includes the following elements in the specified order:</p>
<figure class="align-center" id="id24">
<img alt="IR NEC Frame" src="../../_images/ir_nec.png" />
<figcaption>
<p><span class="caption-text">IR NEC Frame</span><a class="headerlink" href="#id24" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">9</span> <span class="pre">ms</span></code> leading pulse burst, also called the &quot;AGC pulse&quot;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4.5</span> <span class="pre">ms</span></code> space</p></li>
<li><p>8-bit address for the receiving device</p></li>
<li><p>8-bit logical inverse of the address</p></li>
<li><p>8-bit command</p></li>
<li><p>8-bit logical inverse of the command</p></li>
<li><p>a final <code class="docutils literal notranslate"><span class="pre">562.5</span> <span class="pre">µs</span></code> pulse burst to signify the end of message transmission</p></li>
</ul>
<p>Then you can construct the NEC <a class="reference internal" href="#_CPPv4N13rmt_encoder_t6encodeE" title="rmt_encoder_t::encode"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_encoder_t::encode</span></code></a> function in the same order, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// IR NEC scan code representation</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">address</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">command</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">ir_nec_scan_code_t</span><span class="p">;</span>

<span class="c1">// construct an encoder by combining primitive encoders</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rmt_encoder_t</span><span class="w"> </span><span class="n">base</span><span class="p">;</span><span class="w">           </span><span class="c1">// the base &quot;class&quot; declares the standard encoder interface</span>
<span class="w">    </span><span class="n">rmt_encoder_t</span><span class="w"> </span><span class="o">*</span><span class="n">copy_encoder</span><span class="p">;</span><span class="w">  </span><span class="c1">// use the copy_encoder to encode the leading and ending pulse</span>
<span class="w">    </span><span class="n">rmt_encoder_t</span><span class="w"> </span><span class="o">*</span><span class="n">bytes_encoder</span><span class="p">;</span><span class="w"> </span><span class="c1">// use the bytes_encoder to encode the address and command data</span>
<span class="w">    </span><span class="n">rmt_symbol_word_t</span><span class="w"> </span><span class="n">nec_leading_symbol</span><span class="p">;</span><span class="w"> </span><span class="c1">// NEC leading code with RMT representation</span>
<span class="w">    </span><span class="n">rmt_symbol_word_t</span><span class="w"> </span><span class="n">nec_ending_symbol</span><span class="p">;</span><span class="w">  </span><span class="c1">// NEC ending code with RMT representation</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w"> </span><span class="c1">// record the current encoding state, i.e., we are in which encoding phase</span>
<span class="p">}</span><span class="w"> </span><span class="n">rmt_ir_nec_encoder_t</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">rmt_encode_ir_nec</span><span class="p">(</span><span class="n">rmt_encoder_t</span><span class="w"> </span><span class="o">*</span><span class="n">encoder</span><span class="p">,</span><span class="w"> </span><span class="n">rmt_channel_handle_t</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">primary_data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">data_size</span><span class="p">,</span><span class="w"> </span><span class="n">rmt_encode_state_t</span><span class="w"> </span><span class="o">*</span><span class="n">ret_state</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">rmt_ir_nec_encoder_t</span><span class="w"> </span><span class="o">*</span><span class="n">nec_encoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__containerof</span><span class="p">(</span><span class="n">encoder</span><span class="p">,</span><span class="w"> </span><span class="n">rmt_ir_nec_encoder_t</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">);</span>
<span class="w">    </span><span class="n">rmt_encode_state_t</span><span class="w"> </span><span class="n">session_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RMT_ENCODING_RESET</span><span class="p">;</span>
<span class="w">    </span><span class="n">rmt_encode_state_t</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RMT_ENCODING_RESET</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">encoded_symbols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ir_nec_scan_code_t</span><span class="w"> </span><span class="o">*</span><span class="n">scan_code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ir_nec_scan_code_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">primary_data</span><span class="p">;</span>
<span class="w">    </span><span class="n">rmt_encoder_handle_t</span><span class="w"> </span><span class="n">copy_encoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nec_encoder</span><span class="o">-&gt;</span><span class="n">copy_encoder</span><span class="p">;</span>
<span class="w">    </span><span class="n">rmt_encoder_handle_t</span><span class="w"> </span><span class="n">bytes_encoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nec_encoder</span><span class="o">-&gt;</span><span class="n">bytes_encoder</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">nec_encoder</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="c1">// send leading code</span>
<span class="w">        </span><span class="n">encoded_symbols</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">copy_encoder</span><span class="o">-&gt;</span><span class="n">encode</span><span class="p">(</span><span class="n">copy_encoder</span><span class="p">,</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nec_encoder</span><span class="o">-&gt;</span><span class="n">nec_leading_symbol</span><span class="p">,</span>
<span class="w">                                                </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rmt_symbol_word_t</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">session_state</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">session_state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RMT_ENCODING_COMPLETE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">nec_encoder</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// we can only switch to the next state when the current encoder finished</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">session_state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RMT_ENCODING_MEM_FULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">RMT_ENCODING_MEM_FULL</span><span class="p">;</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="c1">// yield if there is no free space to put other encoding artifacts</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// fall-through</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="c1">// send address</span>
<span class="w">        </span><span class="n">encoded_symbols</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">bytes_encoder</span><span class="o">-&gt;</span><span class="n">encode</span><span class="p">(</span><span class="n">bytes_encoder</span><span class="p">,</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scan_code</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">session_state</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">session_state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RMT_ENCODING_COMPLETE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">nec_encoder</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// we can only switch to the next state when the current encoder finished</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">session_state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RMT_ENCODING_MEM_FULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">RMT_ENCODING_MEM_FULL</span><span class="p">;</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="c1">// yield if there is no free space to put other encoding artifacts</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// fall-through</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"> </span><span class="c1">// send command</span>
<span class="w">        </span><span class="n">encoded_symbols</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">bytes_encoder</span><span class="o">-&gt;</span><span class="n">encode</span><span class="p">(</span><span class="n">bytes_encoder</span><span class="p">,</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scan_code</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">session_state</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">session_state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RMT_ENCODING_COMPLETE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">nec_encoder</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// we can only switch to the next state when the current encoder finished</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">session_state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RMT_ENCODING_MEM_FULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">RMT_ENCODING_MEM_FULL</span><span class="p">;</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="c1">// yield if there is no free space to put other encoding artifacts</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// fall-through</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="c1">// send ending code</span>
<span class="w">        </span><span class="n">encoded_symbols</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">copy_encoder</span><span class="o">-&gt;</span><span class="n">encode</span><span class="p">(</span><span class="n">copy_encoder</span><span class="p">,</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nec_encoder</span><span class="o">-&gt;</span><span class="n">nec_ending_symbol</span><span class="p">,</span>
<span class="w">                                                </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rmt_symbol_word_t</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">session_state</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">session_state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RMT_ENCODING_COMPLETE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">nec_encoder</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RMT_ENCODING_RESET</span><span class="p">;</span><span class="w"> </span><span class="c1">// back to the initial encoding session</span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">RMT_ENCODING_COMPLETE</span><span class="p">;</span><span class="w"> </span><span class="c1">// telling the caller the NEC encoding has finished</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">session_state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RMT_ENCODING_MEM_FULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">RMT_ENCODING_MEM_FULL</span><span class="p">;</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="c1">// yield if there is no free space to put other encoding artifacts</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="nl">out</span><span class="p">:</span>
<span class="w">    </span><span class="o">*</span><span class="n">ret_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">encoded_symbols</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A full sample code can be found in <a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/rmt/ir_nec_transceiver">peripherals/rmt/ir_nec_transceiver</a>. In the above snippet, we use a <code class="docutils literal notranslate"><span class="pre">switch-case</span></code> and several <code class="docutils literal notranslate"><span class="pre">goto</span></code> statements to implement a <a class="reference external" href="https://en.wikipedia.org/wiki/Finite-state_machine">Finite-state machine</a> . With this pattern, users can construct much more complex IR protocols.</p>
</section>
</section>
<section id="power-management">
<span id="rmt-power-management"></span><h3>Power Management<a class="headerlink" href="#power-management" title="Permalink to this heading"></a></h3>
<p>When power management is enabled, i.e., <a class="reference internal" href="../kconfig.html#config-pm-enable"><span class="std std-ref">CONFIG_PM_ENABLE</span></a> is on, the system may adjust or disable the clock source before going to sleep. As a result, the time base inside the RMT can't work as expected.</p>
<p>The driver can prevent the above issue by creating a power management lock. The lock type is set based on different clock sources. The driver will acquire the lock in <a class="reference internal" href="#_CPPv410rmt_enable20rmt_channel_handle_t" title="rmt_enable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_enable()</span></code></a>, and release it in <a class="reference internal" href="#_CPPv411rmt_disable20rmt_channel_handle_t" title="rmt_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_disable()</span></code></a>. That means, any RMT transactions in between these two functions are guaranteed to work correctly and stable.</p>
</section>
<section id="iram-safe">
<span id="rmt-iram-safe"></span><h3>IRAM Safe<a class="headerlink" href="#iram-safe" title="Permalink to this heading"></a></h3>
<p>By default, the RMT interrupt is deferred when the Cache is disabled for reasons like writing or erasing the main Flash. Thus the transaction-done interrupt does not get handled in time, which is not acceptable in a real-time application. What is worse, when the RMT transaction relies on <strong>ping-pong</strong> interrupt to successively encode or copy RMT symbols, a delayed interrupt can lead to an unpredictable result.</p>
<p>There is a Kconfig option <a class="reference internal" href="../kconfig.html#config-rmt-isr-iram-safe"><span class="std std-ref">CONFIG_RMT_ISR_IRAM_SAFE</span></a> that has the following features:</p>
<ol class="arabic simple">
<li><p>Enable the interrupt being serviced even when the cache is disabled</p></li>
<li><p>Place all functions used by the ISR into IRAM <a class="footnote-reference brackets" href="#id18" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></li>
<li><p>Place the driver object into DRAM in case it is mapped to PSRAM by accident</p></li>
</ol>
<p>This Kconfig option allows the interrupt handler to run while the cache is disabled but comes at the cost of increased IRAM consumption.</p>
<p>Another Kconfig option <a class="reference internal" href="../kconfig.html#config-rmt-recv-func-in-iram"><span class="std std-ref">CONFIG_RMT_RECV_FUNC_IN_IRAM</span></a> can place <a class="reference internal" href="#_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t" title="rmt_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_receive()</span></code></a> into the IRAM as well. So that the receive function can be used even when the flash cache is disabled.</p>
</section>
<section id="thread-safety">
<span id="rmt-thread-safety"></span><h3>Thread Safety<a class="headerlink" href="#thread-safety" title="Permalink to this heading"></a></h3>
<p>The factory function <a class="reference internal" href="#_CPPv418rmt_new_tx_channelPK23rmt_tx_channel_config_tP20rmt_channel_handle_t" title="rmt_new_tx_channel"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code></a>, <a class="reference internal" href="#_CPPv418rmt_new_rx_channelPK23rmt_rx_channel_config_tP20rmt_channel_handle_t" title="rmt_new_rx_channel"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_rx_channel()</span></code></a> and <a class="reference internal" href="#_CPPv420rmt_new_sync_managerPK25rmt_sync_manager_config_tP25rmt_sync_manager_handle_t" title="rmt_new_sync_manager"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_new_sync_manager()</span></code></a> are guaranteed to be thread-safe by the driver, which means, user can call them from different RTOS tasks without protection by extra locks.
Other functions that take the <a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_channel_handle_t</span></code></a> and <a class="reference internal" href="#_CPPv425rmt_sync_manager_handle_t" title="rmt_sync_manager_handle_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">rmt_sync_manager_handle_t</span></code></a> as the first positional parameter, are not thread-safe. which means the user should avoid calling them from multiple tasks.</p>
<p>The following functions are allowed to use under ISR context as well.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t" title="rmt_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rmt_receive()</span></code></a></p></li>
</ul>
</section>
<section id="kconfig-options">
<span id="rmt-kconfig-options"></span><h3>Kconfig Options<a class="headerlink" href="#kconfig-options" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="../kconfig.html#config-rmt-isr-iram-safe"><span class="std std-ref">CONFIG_RMT_ISR_IRAM_SAFE</span></a> controls whether the default ISR handler can work when cache is disabled, see also <a class="reference internal" href="#rmt-iram-safe"><span class="std std-ref">IRAM Safe</span></a> for more information.</p></li>
<li><p><a class="reference internal" href="../kconfig.html#config-rmt-enable-debug-log"><span class="std std-ref">CONFIG_RMT_ENABLE_DEBUG_LOG</span></a> is used to enable the debug log at the cost of increased firmware binary size.</p></li>
<li><p><a class="reference internal" href="../kconfig.html#config-rmt-recv-func-in-iram"><span class="std std-ref">CONFIG_RMT_RECV_FUNC_IN_IRAM</span></a> controls where to place the RMT receive function (IRAM or Flash), see <a class="reference internal" href="#rmt-iram-safe"><span class="std std-ref">IRAM Safe</span></a> for more information.</p></li>
</ul>
</section>
</section>
<section id="application-examples">
<h2>Application Examples<a class="headerlink" href="#application-examples" title="Permalink to this heading"></a></h2>
<p><ul class="simple">
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/rmt/led_strip">peripherals/rmt/led_strip</a> demonstrates how to use the RMT peripheral to drive a WS2812 LED strip, which is able to change the number of LEDs and the chasing effect.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/rmt/led_strip_simple_encoder">peripherals/rmt/led_strip_simple_encoder</a> demonstrates how to use the RMT peripheral to drive a WS2812 LED strip by implementing a callback that converts RGB pixels into a format recognized by the hardware.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/rmt/ir_nec_transceiver">peripherals/rmt/ir_nec_transceiver</a> demonstrates how to use the RMT peripheral to implement the encoding and decoding of remote IR NEC protocol.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/rmt/dshot_esc">peripherals/rmt/dshot_esc</a> demonstrates how to use the RMT TX channel to achieve infinite loop transmission. It constructs an RMT encoder for the DShot digital protocol. This protocol is primarily used for communication between flight controllers and electronic speed controllers, offering greater resistance to electrical noise compared to traditional analog protocols.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/rmt/onewire">peripherals/rmt/onewire</a> demonstrates how to simulate the 1-wire hardware protocol by using the <cite>onewire_bus</cite> library, and read data from multiple DS18B20 temperature sensors on the bus. This library is built upon a pair of transmit and receive channels of the RMT peripheral.</p></li>
</ul>
</p>
</section>
<section id="faq">
<h2>FAQ<a class="headerlink" href="#faq" title="Permalink to this heading"></a></h2>
<ul>
<li><p>Why the RMT transmits more data than expected?</p>
<blockquote>
<div><p>The encoding for the RMT transmission is carried out within the ISR context. Should the RMT encoding process be prolonged (for example, through logging or tracing the procedure) or if it is delayed due to interrupt latency and preemptive interrupts, the hardware transmitter might read from the memory before the encoder has written to it. Consequently, the transmitter would end up sending outdated data. Although it's not possible to instruct the transmitter to pause and wait, this issue can be mitigated by employing a combination of the following strategies:</p>
<blockquote>
<div><ul class="simple">
<li><p>Increase the <a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t17mem_block_symbolsE" title="rmt_tx_channel_config_t::mem_block_symbols"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::mem_block_symbols</span></code></a>, in steps of 64.</p></li>
<li><p>Place the encoding function in the IRAM with <code class="docutils literal notranslate"><span class="pre">IRAM_ATTR</span></code> attribute.</p></li>
<li><p>Enable the <a class="reference internal" href="#_CPPv4N23rmt_tx_channel_config_t8with_dmaE" title="rmt_tx_channel_config_t::with_dma"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_channel_config_t::with_dma</span></code></a> if DMA is available.</p></li>
<li><p>Install the RMT driver on a separate CPU core to avoid competing for the same CPU resources with other interrupt heavy peripherals (e.g. WiFi, Bluetooth).</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</section>
<section id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h2>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_rmt/include/driver/rmt_tx.h">components/esp_driver_rmt/include/driver/rmt_tx.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/rmt_tx.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_rmt
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_rmt
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418rmt_new_tx_channelPK23rmt_tx_channel_config_tP20rmt_channel_handle_t">
<span id="_CPPv318rmt_new_tx_channelPK23rmt_tx_channel_config_tP20rmt_channel_handle_t"></span><span id="_CPPv218rmt_new_tx_channelPK23rmt_tx_channel_config_tP20rmt_channel_handle_t"></span><span id="rmt_new_tx_channel__rmt_tx_channel_config_tCP.rmt_channel_handle_tP"></span><span class="target" id="rmt__tx_8h_1a4c388006e730edc558b87f578b9956ae"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_new_tx_channel</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv423rmt_tx_channel_config_t" title="rmt_tx_channel_config_t"><span class="n"><span class="pre">rmt_tx_channel_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span>, <a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_chan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418rmt_new_tx_channelPK23rmt_tx_channel_config_tP20rmt_channel_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a RMT TX channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>config</strong> -- <strong>[in]</strong> TX channel configurations </p></li>
<li><p><strong>ret_chan</strong> -- <strong>[out]</strong> Returned generic RMT channel handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Create RMT TX channel successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Create RMT TX channel failed because of invalid argument</p></li>
<li><p>ESP_ERR_NO_MEM: Create RMT TX channel failed because out of memory</p></li>
<li><p>ESP_ERR_NOT_FOUND: Create RMT TX channel failed because all RMT channels are used up and no more free one</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED: Create RMT TX channel failed because some feature is not supported by hardware, e.g. DMA feature is not supported by hardware</p></li>
<li><p>ESP_FAIL: Create RMT TX channel failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412rmt_transmit20rmt_channel_handle_t20rmt_encoder_handle_tPKv6size_tPK21rmt_transmit_config_t">
<span id="_CPPv312rmt_transmit20rmt_channel_handle_t20rmt_encoder_handle_tPKv6size_tPK21rmt_transmit_config_t"></span><span id="_CPPv212rmt_transmit20rmt_channel_handle_t20rmt_encoder_handle_tPKv6size_tPK21rmt_transmit_config_t"></span><span id="rmt_transmit__rmt_channel_handle_t.rmt_encoder_handle_t.voidCP.s.rmt_transmit_config_tCP"></span><span class="target" id="rmt__tx_8h_1a55311e4b643690542a913ea2d241006d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_transmit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">tx_channel</span></span>, <a class="reference internal" href="#_CPPv420rmt_encoder_handle_t" title="rmt_encoder_handle_t"><span class="n"><span class="pre">rmt_encoder_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">encoder</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">payload</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">payload_bytes</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv421rmt_transmit_config_t" title="rmt_transmit_config_t"><span class="n"><span class="pre">rmt_transmit_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412rmt_transmit20rmt_channel_handle_t20rmt_encoder_handle_tPKv6size_tPK21rmt_transmit_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit data by RMT TX channel. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function constructs a transaction descriptor then pushes to a queue. The transaction will not start immediately if there's another one under processing. Based on the setting of <code class="docutils literal notranslate"><a class="reference internal" href="#structrmt__transmit__config__t_1a86c2f0f4379d5c541af28aa571539ec3"><span class="std std-ref"><span class="pre">rmt_transmit_config_t::queue_nonblocking</span></span></a></code>, if there're too many transactions pending in the queue, this function can block until it has free slot, otherwise just return quickly. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The payload data to be transmitted will be encoded into RMT symbols by the specific <code class="docutils literal notranslate"><span class="pre">encoder</span></code>. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You CAN'T modify the <code class="docutils literal notranslate"><span class="pre">payload</span></code> during the transmission, it should be kept valid until the transmission is finished.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tx_channel</strong> -- <strong>[in]</strong> RMT TX channel that created by <code class="docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code></p></li>
<li><p><strong>encoder</strong> -- <strong>[in]</strong> RMT encoder that created by various factory APIs like <code class="docutils literal notranslate"><span class="pre">rmt_new_bytes_encoder()</span></code></p></li>
<li><p><strong>payload</strong> -- <strong>[in]</strong> The raw data to be encoded into RMT symbols </p></li>
<li><p><strong>payload_bytes</strong> -- <strong>[in]</strong> Size of the <code class="docutils literal notranslate"><span class="pre">payload</span></code> in bytes </p></li>
<li><p><strong>config</strong> -- <strong>[in]</strong> Transmission specific configuration </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Transmit data successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Transmit data failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Transmit data failed because channel is not enabled</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED: Transmit data failed because some feature is not supported by hardware, e.g. unsupported loop count</p></li>
<li><p>ESP_FAIL: Transmit data failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420rmt_tx_wait_all_done20rmt_channel_handle_ti">
<span id="_CPPv320rmt_tx_wait_all_done20rmt_channel_handle_ti"></span><span id="_CPPv220rmt_tx_wait_all_done20rmt_channel_handle_ti"></span><span id="rmt_tx_wait_all_done__rmt_channel_handle_t.i"></span><span class="target" id="rmt__tx_8h_1a3233756086a0e5eaddeadf08e60bb8a2"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_tx_wait_all_done</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">tx_channel</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420rmt_tx_wait_all_done20rmt_channel_handle_ti" title="Permalink to this definition"></a><br /></dt>
<dd><p>Wait for all pending TX transactions done. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will block forever if the pending transaction can't be finished within a limited time (e.g. an infinite loop transaction). See also <code class="docutils literal notranslate"><span class="pre">rmt_disable()</span></code> for how to terminate a working channel.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tx_channel</strong> -- <strong>[in]</strong> RMT TX channel that created by <code class="docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code></p></li>
<li><p><strong>timeout_ms</strong> -- <strong>[in]</strong> Wait timeout, in ms. Specially, -1 means to wait forever. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Flush transactions successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Flush transactions failed because of invalid argument</p></li>
<li><p>ESP_ERR_TIMEOUT: Flush transactions failed because of timeout</p></li>
<li><p>ESP_FAIL: Flush transactions failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431rmt_tx_register_event_callbacks20rmt_channel_handle_tPK24rmt_tx_event_callbacks_tPv">
<span id="_CPPv331rmt_tx_register_event_callbacks20rmt_channel_handle_tPK24rmt_tx_event_callbacks_tPv"></span><span id="_CPPv231rmt_tx_register_event_callbacks20rmt_channel_handle_tPK24rmt_tx_event_callbacks_tPv"></span><span id="rmt_tx_register_event_callbacks__rmt_channel_handle_t.rmt_tx_event_callbacks_tCP.voidP"></span><span class="target" id="rmt__tx_8h_1a8797667badcb20109d7f8d0ffdb73155"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_tx_register_event_callbacks</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">tx_channel</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv424rmt_tx_event_callbacks_t" title="rmt_tx_event_callbacks_t"><span class="n"><span class="pre">rmt_tx_event_callbacks_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cbs</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">user_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431rmt_tx_register_event_callbacks20rmt_channel_handle_tPK24rmt_tx_event_callbacks_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set event callbacks for RMT TX channel. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>User can deregister a previously registered callback by calling this function and setting the callback member in the <code class="docutils literal notranslate"><span class="pre">cbs</span></code> structure to NULL. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_RMT_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. The variables used in the function should be in the SRAM as well. The <code class="docutils literal notranslate"><span class="pre">user_data</span></code> should also reside in SRAM.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tx_channel</strong> -- <strong>[in]</strong> RMT generic channel that created by <code class="docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code></p></li>
<li><p><strong>cbs</strong> -- <strong>[in]</strong> Group of callback functions </p></li>
<li><p><strong>user_data</strong> -- <strong>[in]</strong> User data, which will be passed to callback functions directly </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Set event callbacks successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Set event callbacks failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Set event callbacks failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420rmt_new_sync_managerPK25rmt_sync_manager_config_tP25rmt_sync_manager_handle_t">
<span id="_CPPv320rmt_new_sync_managerPK25rmt_sync_manager_config_tP25rmt_sync_manager_handle_t"></span><span id="_CPPv220rmt_new_sync_managerPK25rmt_sync_manager_config_tP25rmt_sync_manager_handle_t"></span><span id="rmt_new_sync_manager__rmt_sync_manager_config_tCP.rmt_sync_manager_handle_tP"></span><span class="target" id="rmt__tx_8h_1af81dce96cd75b6891560edd9b3c0963c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_new_sync_manager</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv425rmt_sync_manager_config_t" title="rmt_sync_manager_config_t"><span class="n"><span class="pre">rmt_sync_manager_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span>, <a class="reference internal" href="#_CPPv425rmt_sync_manager_handle_t" title="rmt_sync_manager_handle_t"><span class="n"><span class="pre">rmt_sync_manager_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_synchro</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420rmt_new_sync_managerPK25rmt_sync_manager_config_tP25rmt_sync_manager_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a synchronization manager for multiple TX channels, so that the managed channel can start transmitting at the same time. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All the channels to be managed should be enabled by <code class="docutils literal notranslate"><span class="pre">rmt_enable()</span></code> before put them into sync manager.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>config</strong> -- <strong>[in]</strong> Synchronization manager configuration </p></li>
<li><p><strong>ret_synchro</strong> -- <strong>[out]</strong> Returned synchronization manager handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Create sync manager successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Create sync manager failed because of invalid argument</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED: Create sync manager failed because it is not supported by hardware</p></li>
<li><p>ESP_ERR_INVALID_STATE: Create sync manager failed because not all channels are enabled</p></li>
<li><p>ESP_ERR_NO_MEM: Create sync manager failed because out of memory</p></li>
<li><p>ESP_ERR_NOT_FOUND: Create sync manager failed because all sync controllers are used up and no more free one</p></li>
<li><p>ESP_FAIL: Create sync manager failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420rmt_del_sync_manager25rmt_sync_manager_handle_t">
<span id="_CPPv320rmt_del_sync_manager25rmt_sync_manager_handle_t"></span><span id="_CPPv220rmt_del_sync_manager25rmt_sync_manager_handle_t"></span><span id="rmt_del_sync_manager__rmt_sync_manager_handle_t"></span><span class="target" id="rmt__tx_8h_1a06720b1ff8155c7ce770f207cbc23754"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_del_sync_manager</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv425rmt_sync_manager_handle_t" title="rmt_sync_manager_handle_t"><span class="n"><span class="pre">rmt_sync_manager_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">synchro</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420rmt_del_sync_manager25rmt_sync_manager_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delete synchronization manager. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>synchro</strong> -- <strong>[in]</strong> Synchronization manager handle returned from <code class="docutils literal notranslate"><span class="pre">rmt_new_sync_manager()</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Delete the synchronization manager successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Delete the synchronization manager failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Delete the synchronization manager failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414rmt_sync_reset25rmt_sync_manager_handle_t">
<span id="_CPPv314rmt_sync_reset25rmt_sync_manager_handle_t"></span><span id="_CPPv214rmt_sync_reset25rmt_sync_manager_handle_t"></span><span id="rmt_sync_reset__rmt_sync_manager_handle_t"></span><span class="target" id="rmt__tx_8h_1a6ab4ed8d4a2ddb8b9f1d87f9d81f102a"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_sync_reset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv425rmt_sync_manager_handle_t" title="rmt_sync_manager_handle_t"><span class="n"><span class="pre">rmt_sync_manager_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">synchro</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414rmt_sync_reset25rmt_sync_manager_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reset synchronization manager. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>synchro</strong> -- <strong>[in]</strong> Synchronization manager handle returned from <code class="docutils literal notranslate"><span class="pre">rmt_new_sync_manager()</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Reset the synchronization manager successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Reset the synchronization manager failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Reset the synchronization manager failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418rmt_tx_switch_gpio20rmt_channel_handle_t10gpio_num_tb">
<span id="_CPPv318rmt_tx_switch_gpio20rmt_channel_handle_t10gpio_num_tb"></span><span id="_CPPv218rmt_tx_switch_gpio20rmt_channel_handle_t10gpio_num_tb"></span><span id="rmt_tx_switch_gpio__rmt_channel_handle_t.gpio_num_t.b"></span><span class="target" id="rmt__tx_8h_1a03134570e57b6357411a09dbdc1dc9d7"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_tx_switch_gpio</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">channel</span></span>, <span class="n"><span class="pre">gpio_num_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">gpio_num</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">invert_out</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418rmt_tx_switch_gpio20rmt_channel_handle_t10gpio_num_tb" title="Permalink to this definition"></a><br /></dt>
<dd><p>Switch GPIO for RMT TX channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> -- <strong>[in]</strong> RMT TX channel handle </p></li>
<li><p><strong>gpio_num</strong> -- <strong>[in]</strong> New GPIO number to be used </p></li>
<li><p><strong>invert_out</strong> -- <strong>[in]</strong> Whether to invert the output signal </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Switch GPIO successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Switch GPIO failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Switch GPIO failed because channel is not disabled</p></li>
<li><p>ESP_FAIL: Switch GPIO failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv424rmt_tx_event_callbacks_t">
<span id="_CPPv324rmt_tx_event_callbacks_t"></span><span id="_CPPv224rmt_tx_event_callbacks_t"></span><span id="rmt_tx_event_callbacks_t"></span><span class="target" id="structrmt__tx__event__callbacks__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_tx_event_callbacks_t</span></span></span><a class="headerlink" href="#_CPPv424rmt_tx_event_callbacks_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Group of RMT TX callbacks. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The callbacks are all running under ISR environment </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_RMT_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. The variables used in the function should be in the SRAM as well. </p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N24rmt_tx_event_callbacks_t13on_trans_doneE">
<span id="_CPPv3N24rmt_tx_event_callbacks_t13on_trans_doneE"></span><span id="_CPPv2N24rmt_tx_event_callbacks_t13on_trans_doneE"></span><span id="rmt_tx_event_callbacks_t::on_trans_done__rmt_tx_done_callback_t"></span><span class="target" id="structrmt__tx__event__callbacks__t_1a3b09c19c8f80f11c777315325996c013"></span><a class="reference internal" href="#_CPPv422rmt_tx_done_callback_t" title="rmt_tx_done_callback_t"><span class="n"><span class="pre">rmt_tx_done_callback_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">on_trans_done</span></span></span><a class="headerlink" href="#_CPPv4N24rmt_tx_event_callbacks_t13on_trans_doneE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Event callback, invoked when transmission is finished </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv423rmt_tx_channel_config_t">
<span id="_CPPv323rmt_tx_channel_config_t"></span><span id="_CPPv223rmt_tx_channel_config_t"></span><span id="rmt_tx_channel_config_t"></span><span class="target" id="structrmt__tx__channel__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_tx_channel_config_t</span></span></span><a class="headerlink" href="#_CPPv423rmt_tx_channel_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT TX channel specific configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t8gpio_numE">
<span id="_CPPv3N23rmt_tx_channel_config_t8gpio_numE"></span><span id="_CPPv2N23rmt_tx_channel_config_t8gpio_numE"></span><span id="rmt_tx_channel_config_t::gpio_num__gpio_num_t"></span><span class="target" id="structrmt__tx__channel__config__t_1aca4ba122d70c3694cb54b5e1967917d6"></span><span class="n"><span class="pre">gpio_num_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gpio_num</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t8gpio_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO number used by RMT TX channel. Set to -1 if unused </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t7clk_srcE">
<span id="_CPPv3N23rmt_tx_channel_config_t7clk_srcE"></span><span id="_CPPv2N23rmt_tx_channel_config_t7clk_srcE"></span><span id="rmt_tx_channel_config_t::clk_src__rmt_clock_source_t"></span><span class="target" id="structrmt__tx__channel__config__t_1a503255c0dc9e1ecac213d967b2471871"></span><a class="reference internal" href="#_CPPv418rmt_clock_source_t" title="rmt_clock_source_t"><span class="n"><span class="pre">rmt_clock_source_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_src</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t7clk_srcE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Clock source of RMT TX channel, channels in the same group must use the same clock source </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t13resolution_hzE">
<span id="_CPPv3N23rmt_tx_channel_config_t13resolution_hzE"></span><span id="_CPPv2N23rmt_tx_channel_config_t13resolution_hzE"></span><span id="rmt_tx_channel_config_t::resolution_hz__uint32_t"></span><span class="target" id="structrmt__tx__channel__config__t_1a12c2ea331b584bbc58e6a1df8af4d6f3"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">resolution_hz</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t13resolution_hzE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Channel clock resolution, in Hz </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t17mem_block_symbolsE">
<span id="_CPPv3N23rmt_tx_channel_config_t17mem_block_symbolsE"></span><span id="_CPPv2N23rmt_tx_channel_config_t17mem_block_symbolsE"></span><span id="rmt_tx_channel_config_t::mem_block_symbols__s"></span><span class="target" id="structrmt__tx__channel__config__t_1a446782ef9cd00886d8295f76a7317d60"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_block_symbols</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t17mem_block_symbolsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size of memory block, in number of <code class="docutils literal notranslate"><a class="reference internal" href="#unionrmt__symbol__word__t"><span class="std std-ref"><span class="pre">rmt_symbol_word_t</span></span></a></code>, must be an even. In the DMA mode, this field controls the DMA buffer size, it can be set to a large value; In the normal mode, this field controls the number of RMT memory block that will be used by the channel. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t17trans_queue_depthE">
<span id="_CPPv3N23rmt_tx_channel_config_t17trans_queue_depthE"></span><span id="_CPPv2N23rmt_tx_channel_config_t17trans_queue_depthE"></span><span id="rmt_tx_channel_config_t::trans_queue_depth__s"></span><span class="target" id="structrmt__tx__channel__config__t_1a0eb850a84830c652b37cd8eb50ffa8e3"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">trans_queue_depth</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t17trans_queue_depthE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Depth of internal transfer queue, increase this value can support more transfers pending in the background </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t13intr_priorityE">
<span id="_CPPv3N23rmt_tx_channel_config_t13intr_priorityE"></span><span id="_CPPv2N23rmt_tx_channel_config_t13intr_priorityE"></span><span id="rmt_tx_channel_config_t::intr_priority__i"></span><span class="target" id="structrmt__tx__channel__config__t_1a001c7d041a02b592b36f6ea23e2cbbea"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">intr_priority</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t13intr_priorityE" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT interrupt priority, if set to 0, the driver will try to allocate an interrupt with a relative low priority (1,2,3) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t10invert_outE">
<span id="_CPPv3N23rmt_tx_channel_config_t10invert_outE"></span><span id="_CPPv2N23rmt_tx_channel_config_t10invert_outE"></span><span id="rmt_tx_channel_config_t::invert_out__uint32_t"></span><span class="target" id="structrmt__tx__channel__config__t_1a7328e4b7c5938bdea5d10735a7f43672"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">invert_out</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t10invert_outE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Whether to invert the RMT channel signal before output to GPIO pad </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t8with_dmaE">
<span id="_CPPv3N23rmt_tx_channel_config_t8with_dmaE"></span><span id="_CPPv2N23rmt_tx_channel_config_t8with_dmaE"></span><span id="rmt_tx_channel_config_t::with_dma__uint32_t"></span><span class="target" id="structrmt__tx__channel__config__t_1a0c786a7ce7dd6a5fdefd7349cab6f096"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">with_dma</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t8with_dmaE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If set, the driver will allocate an RMT channel with DMA capability </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t12io_loop_backE">
<span id="_CPPv3N23rmt_tx_channel_config_t12io_loop_backE"></span><span id="_CPPv2N23rmt_tx_channel_config_t12io_loop_backE"></span><span id="rmt_tx_channel_config_t::io_loop_back__uint32_t"></span><span class="target" id="structrmt__tx__channel__config__t_1a88b1f7316358fe26d7973b8ce895f839"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">io_loop_back</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t12io_loop_backE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The signal output from the GPIO will be fed to the input path as well </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t10io_od_modeE">
<span id="_CPPv3N23rmt_tx_channel_config_t10io_od_modeE"></span><span id="_CPPv2N23rmt_tx_channel_config_t10io_od_modeE"></span><span id="rmt_tx_channel_config_t::io_od_mode__uint32_t"></span><span class="target" id="structrmt__tx__channel__config__t_1a62d237e77e9785ce27620110708f55cb"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">io_od_mode</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t10io_od_modeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Configure the GPIO as open-drain mode </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t8allow_pdE">
<span id="_CPPv3N23rmt_tx_channel_config_t8allow_pdE"></span><span id="_CPPv2N23rmt_tx_channel_config_t8allow_pdE"></span><span id="rmt_tx_channel_config_t::allow_pd__uint32_t"></span><span class="target" id="structrmt__tx__channel__config__t_1a45fe5ad58c476d690fb269c8165aa7b6"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_pd</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t8allow_pdE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If set, driver allows the power domain to be powered off when system enters sleep mode. This can save power, but at the expense of more RAM being consumed to save register context. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_tx_channel_config_t5flagsE">
<span id="_CPPv3N23rmt_tx_channel_config_t5flagsE"></span><span id="_CPPv2N23rmt_tx_channel_config_t5flagsE"></span><span id="rmt_tx_channel_config_t::flags__rmt_tx_channel_config_t"></span><span class="target" id="structrmt__tx__channel__config__t_1ad97812b6b31237879dba8e681e634895"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv423rmt_tx_channel_config_t" title="rmt_tx_channel_config_t"><span class="n"><span class="pre">rmt_tx_channel_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_tx_channel_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>TX channel config flags </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv421rmt_transmit_config_t">
<span id="_CPPv321rmt_transmit_config_t"></span><span id="_CPPv221rmt_transmit_config_t"></span><span id="rmt_transmit_config_t"></span><span class="target" id="structrmt__transmit__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_transmit_config_t</span></span></span><a class="headerlink" href="#_CPPv421rmt_transmit_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT transmit specific configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21rmt_transmit_config_t10loop_countE">
<span id="_CPPv3N21rmt_transmit_config_t10loop_countE"></span><span id="_CPPv2N21rmt_transmit_config_t10loop_countE"></span><span id="rmt_transmit_config_t::loop_count__i"></span><span class="target" id="structrmt__transmit__config__t_1a248dc72fb51380490eaf0b9df3c894b8"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">loop_count</span></span></span><a class="headerlink" href="#_CPPv4N21rmt_transmit_config_t10loop_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Specify the times of transmission in a loop, -1 means transmitting in an infinite loop </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21rmt_transmit_config_t9eot_levelE">
<span id="_CPPv3N21rmt_transmit_config_t9eot_levelE"></span><span id="_CPPv2N21rmt_transmit_config_t9eot_levelE"></span><span id="rmt_transmit_config_t::eot_level__uint32_t"></span><span class="target" id="structrmt__transmit__config__t_1a21be51b6d6c5c964454761caf3bc36cc"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eot_level</span></span></span><a class="headerlink" href="#_CPPv4N21rmt_transmit_config_t9eot_levelE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set the output level for the &quot;End Of Transmission&quot; </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21rmt_transmit_config_t17queue_nonblockingE">
<span id="_CPPv3N21rmt_transmit_config_t17queue_nonblockingE"></span><span id="_CPPv2N21rmt_transmit_config_t17queue_nonblockingE"></span><span id="rmt_transmit_config_t::queue_nonblocking__uint32_t"></span><span class="target" id="structrmt__transmit__config__t_1a86c2f0f4379d5c541af28aa571539ec3"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">queue_nonblocking</span></span></span><a class="headerlink" href="#_CPPv4N21rmt_transmit_config_t17queue_nonblockingE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If set, when the transaction queue is full, driver will not block the thread but return directly </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21rmt_transmit_config_t5flagsE">
<span id="_CPPv3N21rmt_transmit_config_t5flagsE"></span><span id="_CPPv2N21rmt_transmit_config_t5flagsE"></span><span id="rmt_transmit_config_t::flags__rmt_transmit_config_t"></span><span class="target" id="structrmt__transmit__config__t_1ac9c016d429b614c1000debb8757d097e"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv421rmt_transmit_config_t" title="rmt_transmit_config_t"><span class="n"><span class="pre">rmt_transmit_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N21rmt_transmit_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit specific config flags </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv425rmt_sync_manager_config_t">
<span id="_CPPv325rmt_sync_manager_config_t"></span><span id="_CPPv225rmt_sync_manager_config_t"></span><span id="rmt_sync_manager_config_t"></span><span class="target" id="structrmt__sync__manager__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_sync_manager_config_t</span></span></span><a class="headerlink" href="#_CPPv425rmt_sync_manager_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Synchronous manager configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N25rmt_sync_manager_config_t16tx_channel_arrayE">
<span id="_CPPv3N25rmt_sync_manager_config_t16tx_channel_arrayE"></span><span id="_CPPv2N25rmt_sync_manager_config_t16tx_channel_arrayE"></span><span id="rmt_sync_manager_config_t::tx_channel_array__rmt_channel_handle_tCP"></span><span class="target" id="structrmt__sync__manager__config__t_1ac4e8b624f3655f60f48b917297eb9e01"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">tx_channel_array</span></span></span><a class="headerlink" href="#_CPPv4N25rmt_sync_manager_config_t16tx_channel_arrayE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Array of TX channels that are about to be managed by a synchronous controller </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N25rmt_sync_manager_config_t10array_sizeE">
<span id="_CPPv3N25rmt_sync_manager_config_t10array_sizeE"></span><span id="_CPPv2N25rmt_sync_manager_config_t10array_sizeE"></span><span id="rmt_sync_manager_config_t::array_size__s"></span><span class="target" id="structrmt__sync__manager__config__t_1a653b1df5310689a2ab08f5f65fc5abef"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">array_size</span></span></span><a class="headerlink" href="#_CPPv4N25rmt_sync_manager_config_t10array_sizeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size of the <code class="docutils literal notranslate"><span class="pre">tx_channel_array</span></code></p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id3">
<h3>Header File<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_rmt/include/driver/rmt_rx.h">components/esp_driver_rmt/include/driver/rmt_rx.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/rmt_rx.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_rmt
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_rmt
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id4">
<h3>Functions<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418rmt_new_rx_channelPK23rmt_rx_channel_config_tP20rmt_channel_handle_t">
<span id="_CPPv318rmt_new_rx_channelPK23rmt_rx_channel_config_tP20rmt_channel_handle_t"></span><span id="_CPPv218rmt_new_rx_channelPK23rmt_rx_channel_config_tP20rmt_channel_handle_t"></span><span id="rmt_new_rx_channel__rmt_rx_channel_config_tCP.rmt_channel_handle_tP"></span><span class="target" id="rmt__rx_8h_1a2068e0897fe3f0ba3c87380ab9df5633"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_new_rx_channel</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv423rmt_rx_channel_config_t" title="rmt_rx_channel_config_t"><span class="n"><span class="pre">rmt_rx_channel_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span>, <a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_chan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418rmt_new_rx_channelPK23rmt_rx_channel_config_tP20rmt_channel_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a RMT RX channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>config</strong> -- <strong>[in]</strong> RX channel configurations </p></li>
<li><p><strong>ret_chan</strong> -- <strong>[out]</strong> Returned generic RMT channel handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Create RMT RX channel successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Create RMT RX channel failed because of invalid argument</p></li>
<li><p>ESP_ERR_NO_MEM: Create RMT RX channel failed because out of memory</p></li>
<li><p>ESP_ERR_NOT_FOUND: Create RMT RX channel failed because all RMT channels are used up and no more free one</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED: Create RMT RX channel failed because some feature is not supported by hardware, e.g. DMA feature is not supported by hardware</p></li>
<li><p>ESP_FAIL: Create RMT RX channel failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t">
<span id="_CPPv311rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t"></span><span id="_CPPv211rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t"></span><span id="rmt_receive__rmt_channel_handle_t.voidP.s.rmt_receive_config_tCP"></span><span class="target" id="rmt__rx_8h_1a1cd0849bb5653626776721d6fad018b5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_receive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">rx_channel</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">buffer_size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv420rmt_receive_config_t" title="rmt_receive_config_t"><span class="n"><span class="pre">rmt_receive_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411rmt_receive20rmt_channel_handle_tPv6size_tPK20rmt_receive_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initiate a receive job for RMT RX channel. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is non-blocking, it initiates a new receive job and then returns. User should check the received data from the <code class="docutils literal notranslate"><span class="pre">on_recv_done</span></code> callback that registered by <code class="docutils literal notranslate"><span class="pre">rmt_rx_register_event_callbacks()</span></code>. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function can also be called in ISR context. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want this function to work even when the flash cache is disabled, please enable the <code class="docutils literal notranslate"><span class="pre">CONFIG_RMT_RECV_FUNC_IN_IRAM</span></code> option.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rx_channel</strong> -- <strong>[in]</strong> RMT RX channel that created by <code class="docutils literal notranslate"><span class="pre">rmt_new_rx_channel()</span></code></p></li>
<li><p><strong>buffer</strong> -- <strong>[in]</strong> The buffer to store the received RMT symbols </p></li>
<li><p><strong>buffer_size</strong> -- <strong>[in]</strong> size of the <code class="docutils literal notranslate"><span class="pre">buffer</span></code>, in bytes </p></li>
<li><p><strong>config</strong> -- <strong>[in]</strong> Receive specific configurations </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Initiate receive job successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Initiate receive job failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Initiate receive job failed because channel is not enabled</p></li>
<li><p>ESP_FAIL: Initiate receive job failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431rmt_rx_register_event_callbacks20rmt_channel_handle_tPK24rmt_rx_event_callbacks_tPv">
<span id="_CPPv331rmt_rx_register_event_callbacks20rmt_channel_handle_tPK24rmt_rx_event_callbacks_tPv"></span><span id="_CPPv231rmt_rx_register_event_callbacks20rmt_channel_handle_tPK24rmt_rx_event_callbacks_tPv"></span><span id="rmt_rx_register_event_callbacks__rmt_channel_handle_t.rmt_rx_event_callbacks_tCP.voidP"></span><span class="target" id="rmt__rx_8h_1a7a5109e9ca466ee306c2bc35322332c8"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_rx_register_event_callbacks</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">rx_channel</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv424rmt_rx_event_callbacks_t" title="rmt_rx_event_callbacks_t"><span class="n"><span class="pre">rmt_rx_event_callbacks_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cbs</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">user_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431rmt_rx_register_event_callbacks20rmt_channel_handle_tPK24rmt_rx_event_callbacks_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set callbacks for RMT RX channel. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>User can deregister a previously registered callback by calling this function and setting the callback member in the <code class="docutils literal notranslate"><span class="pre">cbs</span></code> structure to NULL. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_RMT_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. The variables used in the function should be in the SRAM as well. The <code class="docutils literal notranslate"><span class="pre">user_data</span></code> should also reside in SRAM.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rx_channel</strong> -- <strong>[in]</strong> RMT generic channel that created by <code class="docutils literal notranslate"><span class="pre">rmt_new_rx_channel()</span></code></p></li>
<li><p><strong>cbs</strong> -- <strong>[in]</strong> Group of callback functions </p></li>
<li><p><strong>user_data</strong> -- <strong>[in]</strong> User data, which will be passed to callback functions directly </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Set event callbacks successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Set event callbacks failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Set event callbacks failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id5">
<h3>Structures<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv424rmt_rx_event_callbacks_t">
<span id="_CPPv324rmt_rx_event_callbacks_t"></span><span id="_CPPv224rmt_rx_event_callbacks_t"></span><span id="rmt_rx_event_callbacks_t"></span><span class="target" id="structrmt__rx__event__callbacks__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_rx_event_callbacks_t</span></span></span><a class="headerlink" href="#_CPPv424rmt_rx_event_callbacks_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Group of RMT RX callbacks. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The callbacks are all running under ISR environment </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_RMT_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. The variables used in the function should be in the SRAM as well. </p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N24rmt_rx_event_callbacks_t12on_recv_doneE">
<span id="_CPPv3N24rmt_rx_event_callbacks_t12on_recv_doneE"></span><span id="_CPPv2N24rmt_rx_event_callbacks_t12on_recv_doneE"></span><span id="rmt_rx_event_callbacks_t::on_recv_done__rmt_rx_done_callback_t"></span><span class="target" id="structrmt__rx__event__callbacks__t_1a2c0b1710e2d46100225178c6358c7bc1"></span><a class="reference internal" href="#_CPPv422rmt_rx_done_callback_t" title="rmt_rx_done_callback_t"><span class="n"><span class="pre">rmt_rx_done_callback_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">on_recv_done</span></span></span><a class="headerlink" href="#_CPPv4N24rmt_rx_event_callbacks_t12on_recv_doneE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Event callback, invoked when the RMT channel reception is finished or partial data is received </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv423rmt_rx_channel_config_t">
<span id="_CPPv323rmt_rx_channel_config_t"></span><span id="_CPPv223rmt_rx_channel_config_t"></span><span id="rmt_rx_channel_config_t"></span><span class="target" id="structrmt__rx__channel__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_rx_channel_config_t</span></span></span><a class="headerlink" href="#_CPPv423rmt_rx_channel_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT RX channel specific configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t8gpio_numE">
<span id="_CPPv3N23rmt_rx_channel_config_t8gpio_numE"></span><span id="_CPPv2N23rmt_rx_channel_config_t8gpio_numE"></span><span id="rmt_rx_channel_config_t::gpio_num__gpio_num_t"></span><span class="target" id="structrmt__rx__channel__config__t_1ae6183f42d32b3a5e01c3525cacce0c52"></span><span class="n"><span class="pre">gpio_num_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gpio_num</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t8gpio_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO number used by RMT RX channel. Set to -1 if unused </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t7clk_srcE">
<span id="_CPPv3N23rmt_rx_channel_config_t7clk_srcE"></span><span id="_CPPv2N23rmt_rx_channel_config_t7clk_srcE"></span><span id="rmt_rx_channel_config_t::clk_src__rmt_clock_source_t"></span><span class="target" id="structrmt__rx__channel__config__t_1a397e39fa08ce58d55740ea630925b559"></span><a class="reference internal" href="#_CPPv418rmt_clock_source_t" title="rmt_clock_source_t"><span class="n"><span class="pre">rmt_clock_source_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_src</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t7clk_srcE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Clock source of RMT RX channel, channels in the same group must use the same clock source </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t13resolution_hzE">
<span id="_CPPv3N23rmt_rx_channel_config_t13resolution_hzE"></span><span id="_CPPv2N23rmt_rx_channel_config_t13resolution_hzE"></span><span id="rmt_rx_channel_config_t::resolution_hz__uint32_t"></span><span class="target" id="structrmt__rx__channel__config__t_1af3c1a3f7f47b2e2ab05e0202dc05b6c0"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">resolution_hz</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t13resolution_hzE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Channel clock resolution, in Hz </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t17mem_block_symbolsE">
<span id="_CPPv3N23rmt_rx_channel_config_t17mem_block_symbolsE"></span><span id="_CPPv2N23rmt_rx_channel_config_t17mem_block_symbolsE"></span><span id="rmt_rx_channel_config_t::mem_block_symbols__s"></span><span class="target" id="structrmt__rx__channel__config__t_1a848eb3bc43493c73f99bde37b8ac56ed"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_block_symbols</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t17mem_block_symbolsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size of memory block, in number of <code class="docutils literal notranslate"><a class="reference internal" href="#unionrmt__symbol__word__t"><span class="std std-ref"><span class="pre">rmt_symbol_word_t</span></span></a></code>, must be an even. In the DMA mode, this field controls the DMA buffer size, it can be set to a large value (e.g. 1024); In the normal mode, this field controls the number of RMT memory block that will be used by the channel. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t13intr_priorityE">
<span id="_CPPv3N23rmt_rx_channel_config_t13intr_priorityE"></span><span id="_CPPv2N23rmt_rx_channel_config_t13intr_priorityE"></span><span id="rmt_rx_channel_config_t::intr_priority__i"></span><span class="target" id="structrmt__rx__channel__config__t_1ae07c8c8bcb3abf1004a9af943c5ef9f3"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">intr_priority</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t13intr_priorityE" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT interrupt priority, if set to 0, the driver will try to allocate an interrupt with a relative low priority (1,2,3) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t9invert_inE">
<span id="_CPPv3N23rmt_rx_channel_config_t9invert_inE"></span><span id="_CPPv2N23rmt_rx_channel_config_t9invert_inE"></span><span id="rmt_rx_channel_config_t::invert_in__uint32_t"></span><span class="target" id="structrmt__rx__channel__config__t_1ad6b9c140f1df0a89bb27ecdc2cdde82a"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">invert_in</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t9invert_inE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Whether to invert the incoming RMT channel signal </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t8with_dmaE">
<span id="_CPPv3N23rmt_rx_channel_config_t8with_dmaE"></span><span id="_CPPv2N23rmt_rx_channel_config_t8with_dmaE"></span><span id="rmt_rx_channel_config_t::with_dma__uint32_t"></span><span class="target" id="structrmt__rx__channel__config__t_1a60f9239ca29e8408bd9325aa1ddbf0e1"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">with_dma</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t8with_dmaE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If set, the driver will allocate an RMT channel with DMA capability </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t12io_loop_backE">
<span id="_CPPv3N23rmt_rx_channel_config_t12io_loop_backE"></span><span id="_CPPv2N23rmt_rx_channel_config_t12io_loop_backE"></span><span id="rmt_rx_channel_config_t::io_loop_back__uint32_t"></span><span class="target" id="structrmt__rx__channel__config__t_1a940835db3566fdbdd7625fcdb14a853c"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">io_loop_back</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t12io_loop_backE" title="Permalink to this definition"></a><br /></dt>
<dd><p>For debug/test, the signal output from the GPIO will be fed to the input path as well </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t8allow_pdE">
<span id="_CPPv3N23rmt_rx_channel_config_t8allow_pdE"></span><span id="_CPPv2N23rmt_rx_channel_config_t8allow_pdE"></span><span id="rmt_rx_channel_config_t::allow_pd__uint32_t"></span><span class="target" id="structrmt__rx__channel__config__t_1ab24d3be6196aca3fbe5438dbdb25d129"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_pd</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t8allow_pdE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If set, driver allows the power domain to be powered off when system enters sleep mode. This can save power, but at the expense of more RAM being consumed to save register context. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23rmt_rx_channel_config_t5flagsE">
<span id="_CPPv3N23rmt_rx_channel_config_t5flagsE"></span><span id="_CPPv2N23rmt_rx_channel_config_t5flagsE"></span><span id="rmt_rx_channel_config_t::flags__rmt_rx_channel_config_t"></span><span class="target" id="structrmt__rx__channel__config__t_1a5bb612d0b78de49ec26eb5113a9fc8b9"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv423rmt_rx_channel_config_t" title="rmt_rx_channel_config_t"><span class="n"><span class="pre">rmt_rx_channel_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N23rmt_rx_channel_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>RX channel config flags </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv420rmt_receive_config_t">
<span id="_CPPv320rmt_receive_config_t"></span><span id="_CPPv220rmt_receive_config_t"></span><span id="rmt_receive_config_t"></span><span class="target" id="structrmt__receive__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_receive_config_t</span></span></span><a class="headerlink" href="#_CPPv420rmt_receive_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT receive specific configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_receive_config_t19signal_range_min_nsE">
<span id="_CPPv3N20rmt_receive_config_t19signal_range_min_nsE"></span><span id="_CPPv2N20rmt_receive_config_t19signal_range_min_nsE"></span><span id="rmt_receive_config_t::signal_range_min_ns__uint32_t"></span><span class="target" id="structrmt__receive__config__t_1a4c85b449f229ce32472b3a7fd58f6080"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">signal_range_min_ns</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_receive_config_t19signal_range_min_nsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>A pulse whose width is smaller than this threshold will be treated as glitch and ignored </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_receive_config_t19signal_range_max_nsE">
<span id="_CPPv3N20rmt_receive_config_t19signal_range_max_nsE"></span><span id="_CPPv2N20rmt_receive_config_t19signal_range_max_nsE"></span><span id="rmt_receive_config_t::signal_range_max_ns__uint32_t"></span><span class="target" id="structrmt__receive__config__t_1a7029b62be012bdc8f22b58c86e474361"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">signal_range_max_ns</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_receive_config_t19signal_range_max_nsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT will stop receiving if one symbol level has kept more than <code class="docutils literal notranslate"><span class="pre">signal_range_max_ns</span></code></p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_receive_config_t5flagsE">
<span id="_CPPv3N20rmt_receive_config_t5flagsE"></span><span id="_CPPv2N20rmt_receive_config_t5flagsE"></span><span id="rmt_receive_config_t::flags__rmt_receive_config_t::extra_rmt_receive_flags"></span><span class="target" id="structrmt__receive__config__t_1a0f42b88c03be95a6107838049b67b5e9"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv420rmt_receive_config_t" title="rmt_receive_config_t"><span class="n"><span class="pre">rmt_receive_config_t</span></span></a><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4N20rmt_receive_config_t23extra_rmt_receive_flagsE" title="rmt_receive_config_t::extra_rmt_receive_flags"><span class="n"><span class="pre">extra_rmt_receive_flags</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_receive_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Receive specific config flags </p>
</dd></dl>

</div>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_receive_config_t23extra_rmt_receive_flagsE">
<span id="_CPPv3N20rmt_receive_config_t23extra_rmt_receive_flagsE"></span><span id="_CPPv2N20rmt_receive_config_t23extra_rmt_receive_flagsE"></span><span id="rmt_receive_config_t::extra_rmt_receive_flags"></span><span class="target" id="structrmt__receive__config__t_1_1extra__rmt__receive__flags"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">extra_rmt_receive_flags</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_receive_config_t23extra_rmt_receive_flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Receive specific flags. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_receive_config_t23extra_rmt_receive_flags13en_partial_rxE">
<span id="_CPPv3N20rmt_receive_config_t23extra_rmt_receive_flags13en_partial_rxE"></span><span id="_CPPv2N20rmt_receive_config_t23extra_rmt_receive_flags13en_partial_rxE"></span><span id="rmt_receive_config_t::extra_rmt_receive_flags::en_partial_rx__uint32_t"></span><span class="target" id="structrmt__receive__config__t_1_1extra__rmt__receive__flags_1a55f2fe5d195ed3c73ef583e10b1d9c9d"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">en_partial_rx</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_receive_config_t23extra_rmt_receive_flags13en_partial_rxE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set this flag if the incoming data is very long, and the driver can only receive the data piece by piece, because the user buffer is not sufficient to save all the data. </p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</section>
<section id="id6">
<h3>Header File<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_rmt/include/driver/rmt_common.h">components/esp_driver_rmt/include/driver/rmt_common.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/rmt_common.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_rmt
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_rmt
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id7">
<h3>Functions<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415rmt_del_channel20rmt_channel_handle_t">
<span id="_CPPv315rmt_del_channel20rmt_channel_handle_t"></span><span id="_CPPv215rmt_del_channel20rmt_channel_handle_t"></span><span id="rmt_del_channel__rmt_channel_handle_t"></span><span class="target" id="rmt__common_8h_1a34ac0a578e971eaae026749574da59bc"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_del_channel</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">channel</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415rmt_del_channel20rmt_channel_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delete an RMT channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>channel</strong> -- <strong>[in]</strong> RMT generic channel that created by <code class="docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code> or <code class="docutils literal notranslate"><span class="pre">rmt_new_rx_channel()</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Delete RMT channel successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Delete RMT channel failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Delete RMT channel failed because it is still in working</p></li>
<li><p>ESP_FAIL: Delete RMT channel failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417rmt_apply_carrier20rmt_channel_handle_tPK20rmt_carrier_config_t">
<span id="_CPPv317rmt_apply_carrier20rmt_channel_handle_tPK20rmt_carrier_config_t"></span><span id="_CPPv217rmt_apply_carrier20rmt_channel_handle_tPK20rmt_carrier_config_t"></span><span id="rmt_apply_carrier__rmt_channel_handle_t.rmt_carrier_config_tCP"></span><span class="target" id="rmt__common_8h_1a6ba993a479c01d995f552fac871a54f4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_apply_carrier</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">channel</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv420rmt_carrier_config_t" title="rmt_carrier_config_t"><span class="n"><span class="pre">rmt_carrier_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417rmt_apply_carrier20rmt_channel_handle_tPK20rmt_carrier_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Apply modulation feature for TX channel or demodulation feature for RX channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> -- <strong>[in]</strong> RMT generic channel that created by <code class="docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code> or <code class="docutils literal notranslate"><span class="pre">rmt_new_rx_channel()</span></code></p></li>
<li><p><strong>config</strong> -- <strong>[in]</strong> Carrier configuration. Specially, a NULL config means to disable the carrier modulation or demodulation feature </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Apply carrier configuration successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Apply carrier configuration failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Apply carrier configuration failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410rmt_enable20rmt_channel_handle_t">
<span id="_CPPv310rmt_enable20rmt_channel_handle_t"></span><span id="_CPPv210rmt_enable20rmt_channel_handle_t"></span><span id="rmt_enable__rmt_channel_handle_t"></span><span class="target" id="rmt__common_8h_1aa4a5fe722722f222f685e1aed401e802"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_enable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">channel</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410rmt_enable20rmt_channel_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enable the RMT channel. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will acquire a PM lock that might be installed during channel allocation</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>channel</strong> -- <strong>[in]</strong> RMT generic channel that created by <code class="docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code> or <code class="docutils literal notranslate"><span class="pre">rmt_new_rx_channel()</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Enable RMT channel successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Enable RMT channel failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Enable RMT channel failed because it's enabled already</p></li>
<li><p>ESP_FAIL: Enable RMT channel failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411rmt_disable20rmt_channel_handle_t">
<span id="_CPPv311rmt_disable20rmt_channel_handle_t"></span><span id="_CPPv211rmt_disable20rmt_channel_handle_t"></span><span id="rmt_disable__rmt_channel_handle_t"></span><span class="target" id="rmt__common_8h_1add90592b59687a6ea9ac65ed337f740e"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_disable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">channel</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411rmt_disable20rmt_channel_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Disable the RMT channel. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will release a PM lock that might be installed during channel allocation</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>channel</strong> -- <strong>[in]</strong> RMT generic channel that created by <code class="docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code> or <code class="docutils literal notranslate"><span class="pre">rmt_new_rx_channel()</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Disable RMT channel successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Disable RMT channel failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Disable RMT channel failed because it's not enabled yet</p></li>
<li><p>ESP_FAIL: Disable RMT channel failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id8">
<h3>Structures<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv420rmt_carrier_config_t">
<span id="_CPPv320rmt_carrier_config_t"></span><span id="_CPPv220rmt_carrier_config_t"></span><span id="rmt_carrier_config_t"></span><span class="target" id="structrmt__carrier__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_carrier_config_t</span></span></span><a class="headerlink" href="#_CPPv420rmt_carrier_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT carrier wave configuration (for either modulation or demodulation) </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_carrier_config_t12frequency_hzE">
<span id="_CPPv3N20rmt_carrier_config_t12frequency_hzE"></span><span id="_CPPv2N20rmt_carrier_config_t12frequency_hzE"></span><span id="rmt_carrier_config_t::frequency_hz__uint32_t"></span><span class="target" id="structrmt__carrier__config__t_1aed459f4a86c14d26d9cc6264e1cd7573"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">frequency_hz</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_carrier_config_t12frequency_hzE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Carrier wave frequency, in Hz, 0 means disabling the carrier </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_carrier_config_t10duty_cycleE">
<span id="_CPPv3N20rmt_carrier_config_t10duty_cycleE"></span><span id="_CPPv2N20rmt_carrier_config_t10duty_cycleE"></span><span id="rmt_carrier_config_t::duty_cycle__float"></span><span class="target" id="structrmt__carrier__config__t_1a197642f2fbe6e6a24c4e4bcfca888e99"></span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">duty_cycle</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_carrier_config_t10duty_cycleE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Carrier wave duty cycle (0~100%) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_carrier_config_t19polarity_active_lowE">
<span id="_CPPv3N20rmt_carrier_config_t19polarity_active_lowE"></span><span id="_CPPv2N20rmt_carrier_config_t19polarity_active_lowE"></span><span id="rmt_carrier_config_t::polarity_active_low__uint32_t"></span><span class="target" id="structrmt__carrier__config__t_1a3328d4c36aa5ceff57685d5a0e9c4f22"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">polarity_active_low</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_carrier_config_t19polarity_active_lowE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Specify the polarity of carrier, by default it's modulated to base signal's high level </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_carrier_config_t9always_onE">
<span id="_CPPv3N20rmt_carrier_config_t9always_onE"></span><span id="_CPPv2N20rmt_carrier_config_t9always_onE"></span><span id="rmt_carrier_config_t::always_on__uint32_t"></span><span class="target" id="structrmt__carrier__config__t_1a19cd1080525a8828fe0f74069cc626cf"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">always_on</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_carrier_config_t9always_onE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If set, the carrier can always exist even there's not transfer undergoing </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20rmt_carrier_config_t5flagsE">
<span id="_CPPv3N20rmt_carrier_config_t5flagsE"></span><span id="_CPPv2N20rmt_carrier_config_t5flagsE"></span><span id="rmt_carrier_config_t::flags__rmt_carrier_config_t"></span><span class="target" id="structrmt__carrier__config__t_1a4400c87c20b0b4fd2b61a732a377c8c9"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv420rmt_carrier_config_t" title="rmt_carrier_config_t"><span class="n"><span class="pre">rmt_carrier_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N20rmt_carrier_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Carrier config flags </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id9">
<h3>Header File<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_rmt/include/driver/rmt_encoder.h">components/esp_driver_rmt/include/driver/rmt_encoder.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/rmt_encoder.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_rmt
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_rmt
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id10">
<h3>Functions<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421rmt_new_bytes_encoderPK26rmt_bytes_encoder_config_tP20rmt_encoder_handle_t">
<span id="_CPPv321rmt_new_bytes_encoderPK26rmt_bytes_encoder_config_tP20rmt_encoder_handle_t"></span><span id="_CPPv221rmt_new_bytes_encoderPK26rmt_bytes_encoder_config_tP20rmt_encoder_handle_t"></span><span id="rmt_new_bytes_encoder__rmt_bytes_encoder_config_tCP.rmt_encoder_handle_tP"></span><span class="target" id="rmt__encoder_8h_1acb45f1d282d5b8e91b609ae03920f939"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_new_bytes_encoder</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv426rmt_bytes_encoder_config_t" title="rmt_bytes_encoder_config_t"><span class="n"><span class="pre">rmt_bytes_encoder_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span>, <a class="reference internal" href="#_CPPv420rmt_encoder_handle_t" title="rmt_encoder_handle_t"><span class="n"><span class="pre">rmt_encoder_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_encoder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421rmt_new_bytes_encoderPK26rmt_bytes_encoder_config_tP20rmt_encoder_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create RMT bytes encoder, which can encode byte stream into RMT symbols. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>config</strong> -- <strong>[in]</strong> Bytes encoder configuration </p></li>
<li><p><strong>ret_encoder</strong> -- <strong>[out]</strong> Returned encoder handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Create RMT bytes encoder successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Create RMT bytes encoder failed because of invalid argument</p></li>
<li><p>ESP_ERR_NO_MEM: Create RMT bytes encoder failed because out of memory</p></li>
<li><p>ESP_FAIL: Create RMT bytes encoder failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431rmt_bytes_encoder_update_config20rmt_encoder_handle_tPK26rmt_bytes_encoder_config_t">
<span id="_CPPv331rmt_bytes_encoder_update_config20rmt_encoder_handle_tPK26rmt_bytes_encoder_config_t"></span><span id="_CPPv231rmt_bytes_encoder_update_config20rmt_encoder_handle_tPK26rmt_bytes_encoder_config_t"></span><span id="rmt_bytes_encoder_update_config__rmt_encoder_handle_t.rmt_bytes_encoder_config_tCP"></span><span class="target" id="rmt__encoder_8h_1a6433ca1266d38fa9b4e517a6b6ba1778"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_bytes_encoder_update_config</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_encoder_handle_t" title="rmt_encoder_handle_t"><span class="n"><span class="pre">rmt_encoder_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bytes_encoder</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv426rmt_bytes_encoder_config_t" title="rmt_bytes_encoder_config_t"><span class="n"><span class="pre">rmt_bytes_encoder_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431rmt_bytes_encoder_update_config20rmt_encoder_handle_tPK26rmt_bytes_encoder_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Update the configuration of the bytes encoder. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The configurations of the bytes encoder is also set up by <code class="docutils literal notranslate"><span class="pre">rmt_new_bytes_encoder()</span></code>. This function is used to update the configuration of the bytes encoder at runtime.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bytes_encoder</strong> -- <strong>[in]</strong> Bytes encoder handle, created by e.g <code class="docutils literal notranslate"><span class="pre">rmt_new_bytes_encoder()</span></code></p></li>
<li><p><strong>config</strong> -- <strong>[in]</strong> Bytes encoder configuration </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Update RMT bytes encoder successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Update RMT bytes encoder failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Update RMT bytes encoder failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420rmt_new_copy_encoderPK25rmt_copy_encoder_config_tP20rmt_encoder_handle_t">
<span id="_CPPv320rmt_new_copy_encoderPK25rmt_copy_encoder_config_tP20rmt_encoder_handle_t"></span><span id="_CPPv220rmt_new_copy_encoderPK25rmt_copy_encoder_config_tP20rmt_encoder_handle_t"></span><span id="rmt_new_copy_encoder__rmt_copy_encoder_config_tCP.rmt_encoder_handle_tP"></span><span class="target" id="rmt__encoder_8h_1a8fc38ec919ec57a6ec04b1b4a4e447b7"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_new_copy_encoder</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv425rmt_copy_encoder_config_t" title="rmt_copy_encoder_config_t"><span class="n"><span class="pre">rmt_copy_encoder_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span>, <a class="reference internal" href="#_CPPv420rmt_encoder_handle_t" title="rmt_encoder_handle_t"><span class="n"><span class="pre">rmt_encoder_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_encoder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420rmt_new_copy_encoderPK25rmt_copy_encoder_config_tP20rmt_encoder_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create RMT copy encoder, which copies the given RMT symbols into RMT memory. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>config</strong> -- <strong>[in]</strong> Copy encoder configuration </p></li>
<li><p><strong>ret_encoder</strong> -- <strong>[out]</strong> Returned encoder handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Create RMT copy encoder successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Create RMT copy encoder failed because of invalid argument</p></li>
<li><p>ESP_ERR_NO_MEM: Create RMT copy encoder failed because out of memory</p></li>
<li><p>ESP_FAIL: Create RMT copy encoder failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422rmt_new_simple_encoderPK27rmt_simple_encoder_config_tP20rmt_encoder_handle_t">
<span id="_CPPv322rmt_new_simple_encoderPK27rmt_simple_encoder_config_tP20rmt_encoder_handle_t"></span><span id="_CPPv222rmt_new_simple_encoderPK27rmt_simple_encoder_config_tP20rmt_encoder_handle_t"></span><span id="rmt_new_simple_encoder__rmt_simple_encoder_config_tCP.rmt_encoder_handle_tP"></span><span class="target" id="rmt__encoder_8h_1adf4d95cf42af9286be7dd822f5fb87fa"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_new_simple_encoder</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv427rmt_simple_encoder_config_t" title="rmt_simple_encoder_config_t"><span class="n"><span class="pre">rmt_simple_encoder_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span>, <a class="reference internal" href="#_CPPv420rmt_encoder_handle_t" title="rmt_encoder_handle_t"><span class="n"><span class="pre">rmt_encoder_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_encoder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422rmt_new_simple_encoderPK27rmt_simple_encoder_config_tP20rmt_encoder_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create RMT simple callback encoder, which uses a callback to convert incoming data into RMT symbols. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>config</strong> -- <strong>[in]</strong> Simple callback encoder configuration </p></li>
<li><p><strong>ret_encoder</strong> -- <strong>[out]</strong> Returned encoder handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Create RMT simple callback encoder successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Create RMT simple callback encoder failed because of invalid argument</p></li>
<li><p>ESP_ERR_NO_MEM: Create RMT simple callback encoder failed because out of memory</p></li>
<li><p>ESP_FAIL: Create RMT simple callback encoder failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415rmt_del_encoder20rmt_encoder_handle_t">
<span id="_CPPv315rmt_del_encoder20rmt_encoder_handle_t"></span><span id="_CPPv215rmt_del_encoder20rmt_encoder_handle_t"></span><span id="rmt_del_encoder__rmt_encoder_handle_t"></span><span class="target" id="rmt__encoder_8h_1a0ba7559b547636473ae852ad0a3e09b2"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_del_encoder</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_encoder_handle_t" title="rmt_encoder_handle_t"><span class="n"><span class="pre">rmt_encoder_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">encoder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415rmt_del_encoder20rmt_encoder_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delete RMT encoder. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoder</strong> -- <strong>[in]</strong> RMT encoder handle, created by e.g <code class="docutils literal notranslate"><span class="pre">rmt_new_bytes_encoder()</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Delete RMT encoder successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Delete RMT encoder failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Delete RMT encoder failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417rmt_encoder_reset20rmt_encoder_handle_t">
<span id="_CPPv317rmt_encoder_reset20rmt_encoder_handle_t"></span><span id="_CPPv217rmt_encoder_reset20rmt_encoder_handle_t"></span><span id="rmt_encoder_reset__rmt_encoder_handle_t"></span><span class="target" id="rmt__encoder_8h_1acae171c5af630eec9077eeb0f5a930c4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_encoder_reset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420rmt_encoder_handle_t" title="rmt_encoder_handle_t"><span class="n"><span class="pre">rmt_encoder_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">encoder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417rmt_encoder_reset20rmt_encoder_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reset RMT encoder. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoder</strong> -- <strong>[in]</strong> RMT encoder handle, created by e.g <code class="docutils literal notranslate"><span class="pre">rmt_new_bytes_encoder()</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Reset RMT encoder successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Reset RMT encoder failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Reset RMT encoder failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421rmt_alloc_encoder_mem6size_t">
<span id="_CPPv321rmt_alloc_encoder_mem6size_t"></span><span id="_CPPv221rmt_alloc_encoder_mem6size_t"></span><span id="rmt_alloc_encoder_mem__s"></span><span class="target" id="rmt__encoder_8h_1abc4c0e421dc01ce0d944f33c5b1c3f85"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">rmt_alloc_encoder_mem</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421rmt_alloc_encoder_mem6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>A helper function to allocate a proper memory for RMT encoder. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>size</strong> -- Size of memory to be allocated </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to the allocated memory if the allocation is successful, NULL otherwise </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id11">
<h3>Structures<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv413rmt_encoder_t">
<span id="_CPPv313rmt_encoder_t"></span><span id="_CPPv213rmt_encoder_t"></span><span id="rmt_encoder_t"></span><span class="target" id="structrmt__encoder__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_encoder_t</span></span></span><a class="headerlink" href="#_CPPv413rmt_encoder_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Interface of RMT encoder. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13rmt_encoder_t6encodeE">
<span id="_CPPv3N13rmt_encoder_t6encodeE"></span><span id="_CPPv2N13rmt_encoder_t6encodeE"></span><span class="target" id="structrmt__encoder__t_1af4583c2ec692da2c854a72ef0da79bb1"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">encode</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv413rmt_encoder_t" title="rmt_encoder_t"><span class="n"><span class="pre">rmt_encoder_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoder</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tx_channel</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">primary_data</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">data_size</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv418rmt_encode_state_t" title="rmt_encode_state_t"><span class="n"><span class="pre">rmt_encode_state_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ret_state</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv4N13rmt_encoder_t6encodeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Encode the user data into RMT symbols and write into RMT memory. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The encoding function will also be called from an ISR context, thus the function must not call any blocking API. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It's recommended to put this function implementation in the IRAM, to achieve a high performance and less interrupt latency.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Param encoder<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> Encoder handle </p>
</dd>
<dt class="field-even">Param tx_channel<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[in]</strong> RMT TX channel handle, returned from <code class="docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code></p>
</dd>
<dt class="field-odd">Param primary_data<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> App data to be encoded into RMT symbols </p>
</dd>
<dt class="field-even">Param data_size<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[in]</strong> Size of primary_data, in bytes </p>
</dd>
<dt class="field-odd">Param ret_state<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[out]</strong> Returned current encoder's state </p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p>Number of RMT symbols that the primary data has been encoded into </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13rmt_encoder_t5resetE">
<span id="_CPPv3N13rmt_encoder_t5resetE"></span><span id="_CPPv2N13rmt_encoder_t5resetE"></span><span class="target" id="structrmt__encoder__t_1ac9bdb7d035af338b4ce074f6836450bd"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">reset</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv413rmt_encoder_t" title="rmt_encoder_t"><span class="n"><span class="pre">rmt_encoder_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoder</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv4N13rmt_encoder_t5resetE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reset encoding state. </p>
<dl class="field-list simple">
<dt class="field-odd">Param encoder<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> Encoder handle </p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: reset encoder successfully</p></li>
<li><p>ESP_FAIL: reset encoder failed </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13rmt_encoder_t3delE">
<span id="_CPPv3N13rmt_encoder_t3delE"></span><span id="_CPPv2N13rmt_encoder_t3delE"></span><span class="target" id="structrmt__encoder__t_1a2d4252d6364bd1e2210f7b7cd5f43f3b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">del</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv413rmt_encoder_t" title="rmt_encoder_t"><span class="n"><span class="pre">rmt_encoder_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoder</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv4N13rmt_encoder_t3delE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delete encoder object. </p>
<dl class="field-list simple">
<dt class="field-odd">Param encoder<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> Encoder handle </p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: delete encoder successfully</p></li>
<li><p>ESP_FAIL: delete encoder failed </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv426rmt_bytes_encoder_config_t">
<span id="_CPPv326rmt_bytes_encoder_config_t"></span><span id="_CPPv226rmt_bytes_encoder_config_t"></span><span id="rmt_bytes_encoder_config_t"></span><span class="target" id="structrmt__bytes__encoder__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_bytes_encoder_config_t</span></span></span><a class="headerlink" href="#_CPPv426rmt_bytes_encoder_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Bytes encoder configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N26rmt_bytes_encoder_config_t4bit0E">
<span id="_CPPv3N26rmt_bytes_encoder_config_t4bit0E"></span><span id="_CPPv2N26rmt_bytes_encoder_config_t4bit0E"></span><span id="rmt_bytes_encoder_config_t::bit0__rmt_symbol_word_t"></span><span class="target" id="structrmt__bytes__encoder__config__t_1aaef691c499c69c4e5924888c21d39dee"></span><a class="reference internal" href="#_CPPv417rmt_symbol_word_t" title="rmt_symbol_word_t"><span class="n"><span class="pre">rmt_symbol_word_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bit0</span></span></span><a class="headerlink" href="#_CPPv4N26rmt_bytes_encoder_config_t4bit0E" title="Permalink to this definition"></a><br /></dt>
<dd><p>How to represent BIT0 in RMT symbol </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N26rmt_bytes_encoder_config_t4bit1E">
<span id="_CPPv3N26rmt_bytes_encoder_config_t4bit1E"></span><span id="_CPPv2N26rmt_bytes_encoder_config_t4bit1E"></span><span id="rmt_bytes_encoder_config_t::bit1__rmt_symbol_word_t"></span><span class="target" id="structrmt__bytes__encoder__config__t_1ad61f30608b821977fbd2800e67f0a907"></span><a class="reference internal" href="#_CPPv417rmt_symbol_word_t" title="rmt_symbol_word_t"><span class="n"><span class="pre">rmt_symbol_word_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bit1</span></span></span><a class="headerlink" href="#_CPPv4N26rmt_bytes_encoder_config_t4bit1E" title="Permalink to this definition"></a><br /></dt>
<dd><p>How to represent BIT1 in RMT symbol </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N26rmt_bytes_encoder_config_t9msb_firstE">
<span id="_CPPv3N26rmt_bytes_encoder_config_t9msb_firstE"></span><span id="_CPPv2N26rmt_bytes_encoder_config_t9msb_firstE"></span><span id="rmt_bytes_encoder_config_t::msb_first__uint32_t"></span><span class="target" id="structrmt__bytes__encoder__config__t_1aae764470ebc74902a3f8e3243fe3dfbe"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">msb_first</span></span></span><a class="headerlink" href="#_CPPv4N26rmt_bytes_encoder_config_t9msb_firstE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Whether to encode MSB bit first </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N26rmt_bytes_encoder_config_t5flagsE">
<span id="_CPPv3N26rmt_bytes_encoder_config_t5flagsE"></span><span id="_CPPv2N26rmt_bytes_encoder_config_t5flagsE"></span><span id="rmt_bytes_encoder_config_t::flags__rmt_bytes_encoder_config_t"></span><span class="target" id="structrmt__bytes__encoder__config__t_1adcce0bed254916c48114ce4d4e6a3995"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv426rmt_bytes_encoder_config_t" title="rmt_bytes_encoder_config_t"><span class="n"><span class="pre">rmt_bytes_encoder_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N26rmt_bytes_encoder_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Encoder config flag </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv425rmt_copy_encoder_config_t">
<span id="_CPPv325rmt_copy_encoder_config_t"></span><span id="_CPPv225rmt_copy_encoder_config_t"></span><span id="rmt_copy_encoder_config_t"></span><span class="target" id="structrmt__copy__encoder__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_copy_encoder_config_t</span></span></span><a class="headerlink" href="#_CPPv425rmt_copy_encoder_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Copy encoder configuration. </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv427rmt_simple_encoder_config_t">
<span id="_CPPv327rmt_simple_encoder_config_t"></span><span id="_CPPv227rmt_simple_encoder_config_t"></span><span id="rmt_simple_encoder_config_t"></span><span class="target" id="structrmt__simple__encoder__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_simple_encoder_config_t</span></span></span><a class="headerlink" href="#_CPPv427rmt_simple_encoder_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Simple callback encoder configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N27rmt_simple_encoder_config_t8callbackE">
<span id="_CPPv3N27rmt_simple_encoder_config_t8callbackE"></span><span id="_CPPv2N27rmt_simple_encoder_config_t8callbackE"></span><span id="rmt_simple_encoder_config_t::callback__rmt_encode_simple_cb_t"></span><span class="target" id="structrmt__simple__encoder__config__t_1ac5ef6e1bbe1156e27858e85bd95b7fb0"></span><a class="reference internal" href="#_CPPv422rmt_encode_simple_cb_t" title="rmt_encode_simple_cb_t"><span class="n"><span class="pre">rmt_encode_simple_cb_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">callback</span></span></span><a class="headerlink" href="#_CPPv4N27rmt_simple_encoder_config_t8callbackE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback to call for encoding data into RMT items </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N27rmt_simple_encoder_config_t3argE">
<span id="_CPPv3N27rmt_simple_encoder_config_t3argE"></span><span id="_CPPv2N27rmt_simple_encoder_config_t3argE"></span><span id="rmt_simple_encoder_config_t::arg__voidP"></span><span class="target" id="structrmt__simple__encoder__config__t_1abbd31114c718af7c8fbe7728f62ee200"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">arg</span></span></span><a class="headerlink" href="#_CPPv4N27rmt_simple_encoder_config_t3argE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Opaque user-supplied argument for callback </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N27rmt_simple_encoder_config_t14min_chunk_sizeE">
<span id="_CPPv3N27rmt_simple_encoder_config_t14min_chunk_sizeE"></span><span id="_CPPv2N27rmt_simple_encoder_config_t14min_chunk_sizeE"></span><span id="rmt_simple_encoder_config_t::min_chunk_size__s"></span><span class="target" id="structrmt__simple__encoder__config__t_1a7b3a5af03632b9752b684a7a2e39defb"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">min_chunk_size</span></span></span><a class="headerlink" href="#_CPPv4N27rmt_simple_encoder_config_t14min_chunk_sizeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Minimum amount of free space, in RMT symbols, the encoder needs in order to guarantee it always returns non-zero. Defaults to 64 if zero / not given. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv422rmt_encode_simple_cb_t">
<span id="_CPPv322rmt_encode_simple_cb_t"></span><span id="_CPPv222rmt_encode_simple_cb_t"></span><span id="rmt_encode_simple_cb_t"></span><span class="target" id="rmt__encoder_8h_1aa9597a50804fa860fc7e4f9627a58ba5"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">rmt_encode_simple_cb_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">data_size</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">symbols_written</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">symbols_free</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv417rmt_symbol_word_t" title="rmt_symbol_word_t"><span class="n"><span class="pre">rmt_symbol_word_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">done</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv422rmt_encode_simple_cb_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback for simple callback encoder. </p>
<p>This will get called to encode the data stream of given length (as passed to rmt_transmit by the user) into symbols to be sent by the hardware.</p>
<p>The callback will be initially called with symbol_pos=0. If the callback encodes N symbols and finishes, the next callback will always be with symbols_written=N. If the callback then encodes M symbols, the next callback will always be with symbol_pos=N+M, etc. The only exception is when the encoder is reset (e.g. to begin a new transaction) in which case symbol_pos will always restart at 0.</p>
<p>If the amount of free space in the symbol buffer (as indicated by symbols_free) is too low, the function can return 0 as result and the RMT will call the function again once there is more space available. Note that the callback should eventually return non-0 if called with free space of <a class="reference internal" href="#structrmt__simple__encoder__config__t_1a7b3a5af03632b9752b684a7a2e39defb"><span class="std std-ref">rmt_simple_encoder_config_t::min_chunk_size</span></a> or more. It is acceptable to return 0 for a given free space N, then on the next call (possibly with a larger free buffer space) return less or more than N symbols.</p>
<p>When the transaction is done (all data_size data is encoded), the callback can indicate this by setting *done to true. This can either happen on the last callback call that returns an amount of symbols encoded, or on a callback that returns zero. In either case, the callback will not be called again for this transaction.</p>
<dl class="field-list simple">
<dt class="field-odd">Param data<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> Data pointer, as passed to rmt_transmit() </p>
</dd>
<dt class="field-even">Param data_size<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[in]</strong> Size of the data, as passed to rmt_transmit() </p>
</dd>
<dt class="field-odd">Param symbols_written<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> Current position in encoded stream, in symbols </p>
</dd>
<dt class="field-even">Param symbols_free<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[in]</strong> The maximum amount of symbols that can be written into the <code class="docutils literal notranslate"><span class="pre">symbols</span></code> buffer </p>
</dd>
<dt class="field-odd">Param symbols<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[out]</strong> Symbols to be sent to the RMT hardware </p>
</dd>
<dt class="field-even">Param done<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[out]</strong> Setting this to true marks this transaction as finished </p>
</dd>
<dt class="field-odd">Param arg<span class="colon">:</span></dt>
<dd class="field-odd"><p>Opaque argument </p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p>Amount of symbols encoded in this callback round. 0 if more space is needed. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv418rmt_encode_state_t">
<span id="_CPPv318rmt_encode_state_t"></span><span id="_CPPv218rmt_encode_state_t"></span><span class="target" id="rmt__encoder_8h_1a3ec6b963d5d4f27ce664ba636409f2e6"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_encode_state_t</span></span></span><a class="headerlink" href="#_CPPv418rmt_encode_state_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT encoding state. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N18rmt_encode_state_t18RMT_ENCODING_RESETE">
<span id="_CPPv3N18rmt_encode_state_t18RMT_ENCODING_RESETE"></span><span id="_CPPv2N18rmt_encode_state_t18RMT_ENCODING_RESETE"></span><span class="target" id="rmt__encoder_8h_1a3ec6b963d5d4f27ce664ba636409f2e6a8d26f1d7101400d007a82f68edaa236b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RMT_ENCODING_RESET</span></span></span><a class="headerlink" href="#_CPPv4N18rmt_encode_state_t18RMT_ENCODING_RESETE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The encoding session is in reset state </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N18rmt_encode_state_t21RMT_ENCODING_COMPLETEE">
<span id="_CPPv3N18rmt_encode_state_t21RMT_ENCODING_COMPLETEE"></span><span id="_CPPv2N18rmt_encode_state_t21RMT_ENCODING_COMPLETEE"></span><span class="target" id="rmt__encoder_8h_1a3ec6b963d5d4f27ce664ba636409f2e6afec08b2339e0fed9e94edf15f85f71ce"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RMT_ENCODING_COMPLETE</span></span></span><a class="headerlink" href="#_CPPv4N18rmt_encode_state_t21RMT_ENCODING_COMPLETEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The encoding session is finished, the caller can continue with subsequent encoding </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N18rmt_encode_state_t21RMT_ENCODING_MEM_FULLE">
<span id="_CPPv3N18rmt_encode_state_t21RMT_ENCODING_MEM_FULLE"></span><span id="_CPPv2N18rmt_encode_state_t21RMT_ENCODING_MEM_FULLE"></span><span class="target" id="rmt__encoder_8h_1a3ec6b963d5d4f27ce664ba636409f2e6aec2034b9ab1f317414c694a346a14dba"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RMT_ENCODING_MEM_FULL</span></span></span><a class="headerlink" href="#_CPPv4N18rmt_encode_state_t21RMT_ENCODING_MEM_FULLE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The encoding artifact memory is full, the caller should return from current encoding session </p>
</dd></dl>

</dd></dl>

</section>
<section id="id12">
<h3>Header File<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_rmt/include/driver/rmt_types.h">components/esp_driver_rmt/include/driver/rmt_types.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/rmt_types.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_rmt</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_rmt
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_rmt
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id13">
<h3>Structures<a class="headerlink" href="#id13" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv424rmt_tx_done_event_data_t">
<span id="_CPPv324rmt_tx_done_event_data_t"></span><span id="_CPPv224rmt_tx_done_event_data_t"></span><span id="rmt_tx_done_event_data_t"></span><span class="target" id="structrmt__tx__done__event__data__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_tx_done_event_data_t</span></span></span><a class="headerlink" href="#_CPPv424rmt_tx_done_event_data_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of RMT TX done event data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N24rmt_tx_done_event_data_t11num_symbolsE">
<span id="_CPPv3N24rmt_tx_done_event_data_t11num_symbolsE"></span><span id="_CPPv2N24rmt_tx_done_event_data_t11num_symbolsE"></span><span id="rmt_tx_done_event_data_t::num_symbols__s"></span><span class="target" id="structrmt__tx__done__event__data__t_1a3bb7f582fe619baee473799956261aaa"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_symbols</span></span></span><a class="headerlink" href="#_CPPv4N24rmt_tx_done_event_data_t11num_symbolsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The number of transmitted RMT symbols, including one EOF symbol, which is appended by the driver to mark the end of a transmission. For a loop transmission, this value only counts for one round. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv424rmt_rx_done_event_data_t">
<span id="_CPPv324rmt_rx_done_event_data_t"></span><span id="_CPPv224rmt_rx_done_event_data_t"></span><span id="rmt_rx_done_event_data_t"></span><span class="target" id="structrmt__rx__done__event__data__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_rx_done_event_data_t</span></span></span><a class="headerlink" href="#_CPPv424rmt_rx_done_event_data_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of RMT RX done event data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N24rmt_rx_done_event_data_t16received_symbolsE">
<span id="_CPPv3N24rmt_rx_done_event_data_t16received_symbolsE"></span><span id="_CPPv2N24rmt_rx_done_event_data_t16received_symbolsE"></span><span id="rmt_rx_done_event_data_t::received_symbols__rmt_symbol_word_tP"></span><span class="target" id="structrmt__rx__done__event__data__t_1af77ae7cda315f2c38c0c7f5a45ea3b35"></span><a class="reference internal" href="#_CPPv417rmt_symbol_word_t" title="rmt_symbol_word_t"><span class="n"><span class="pre">rmt_symbol_word_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">received_symbols</span></span></span><a class="headerlink" href="#_CPPv4N24rmt_rx_done_event_data_t16received_symbolsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Point to the received RMT symbols </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N24rmt_rx_done_event_data_t11num_symbolsE">
<span id="_CPPv3N24rmt_rx_done_event_data_t11num_symbolsE"></span><span id="_CPPv2N24rmt_rx_done_event_data_t11num_symbolsE"></span><span id="rmt_rx_done_event_data_t::num_symbols__s"></span><span class="target" id="structrmt__rx__done__event__data__t_1a791aaeb17ed432821b88b238575f7398"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_symbols</span></span></span><a class="headerlink" href="#_CPPv4N24rmt_rx_done_event_data_t11num_symbolsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The number of received RMT symbols </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N24rmt_rx_done_event_data_t7is_lastE">
<span id="_CPPv3N24rmt_rx_done_event_data_t7is_lastE"></span><span id="_CPPv2N24rmt_rx_done_event_data_t7is_lastE"></span><span id="rmt_rx_done_event_data_t::is_last__uint32_t"></span><span class="target" id="structrmt__rx__done__event__data__t_1ad9d3d0bff7c9b21db392b8d3722ff30d"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_last</span></span></span><a class="headerlink" href="#_CPPv4N24rmt_rx_done_event_data_t7is_lastE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Indicating if the current received data are the last part of the transaction </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N24rmt_rx_done_event_data_t5flagsE">
<span id="_CPPv3N24rmt_rx_done_event_data_t5flagsE"></span><span id="_CPPv2N24rmt_rx_done_event_data_t5flagsE"></span><span id="rmt_rx_done_event_data_t::flags__rmt_rx_done_event_data_t"></span><span class="target" id="structrmt__rx__done__event__data__t_1a398e05e0a4173e9936c59fd7365794e3"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv424rmt_rx_done_event_data_t" title="rmt_rx_done_event_data_t"><span class="n"><span class="pre">rmt_rx_done_event_data_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N24rmt_rx_done_event_data_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Extra flags </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id14">
<h3>Type Definitions<a class="headerlink" href="#id14" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv420rmt_channel_handle_t">
<span id="_CPPv320rmt_channel_handle_t"></span><span id="_CPPv220rmt_channel_handle_t"></span><span id="rmt_channel_handle_t"></span><span class="target" id="esp__driver__rmt_2include_2driver_2rmt__types_8h_1a18a2e19fa5acd05d0eaf641ee8c050a6"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rmt_channel_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></span><a class="headerlink" href="#_CPPv420rmt_channel_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of RMT channel handle. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv425rmt_sync_manager_handle_t">
<span id="_CPPv325rmt_sync_manager_handle_t"></span><span id="_CPPv225rmt_sync_manager_handle_t"></span><span id="rmt_sync_manager_handle_t"></span><span class="target" id="esp__driver__rmt_2include_2driver_2rmt__types_8h_1a3c7e7cef8a0d14fc07875029e6163b4c"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rmt_sync_manager_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">rmt_sync_manager_handle_t</span></span></span><a class="headerlink" href="#_CPPv425rmt_sync_manager_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of RMT synchronization manager handle. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv420rmt_encoder_handle_t">
<span id="_CPPv320rmt_encoder_handle_t"></span><span id="_CPPv220rmt_encoder_handle_t"></span><span id="rmt_encoder_handle_t"></span><span class="target" id="esp__driver__rmt_2include_2driver_2rmt__types_8h_1a3b39a5dcf3f8947c4cf9893dd586d4f1"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413rmt_encoder_t" title="rmt_encoder_t"><span class="n"><span class="pre">rmt_encoder_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">rmt_encoder_handle_t</span></span></span><a class="headerlink" href="#_CPPv420rmt_encoder_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of RMT encoder handle. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv422rmt_tx_done_callback_t">
<span id="_CPPv322rmt_tx_done_callback_t"></span><span id="_CPPv222rmt_tx_done_callback_t"></span><span id="rmt_tx_done_callback_t"></span><span class="target" id="esp__driver__rmt_2include_2driver_2rmt__types_8h_1abf4a0c5b794ed3af949b2b7c15c0e1f2"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">rmt_tx_done_callback_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tx_chan</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv424rmt_tx_done_event_data_t" title="rmt_tx_done_event_data_t"><span class="n"><span class="pre">rmt_tx_done_event_data_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edata</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">user_ctx</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv422rmt_tx_done_callback_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Prototype of RMT event callback. </p>
<dl class="field-list simple">
<dt class="field-odd">Param tx_chan<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> RMT channel handle, created from <code class="docutils literal notranslate"><span class="pre">rmt_new_tx_channel()</span></code></p>
</dd>
<dt class="field-even">Param edata<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[in]</strong> Point to RMT event data. The lifecycle of this pointer memory is inside this function, user should copy it into static memory if used outside this function. </p>
</dd>
<dt class="field-odd">Param user_ctx<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> User registered context, passed from <code class="docutils literal notranslate"><span class="pre">rmt_tx_register_event_callbacks()</span></code></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether a high priority task has been waken up by this callback function </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv422rmt_rx_done_callback_t">
<span id="_CPPv322rmt_rx_done_callback_t"></span><span id="_CPPv222rmt_rx_done_callback_t"></span><span id="rmt_rx_done_callback_t"></span><span class="target" id="esp__driver__rmt_2include_2driver_2rmt__types_8h_1a06633417dcfd22292db9cb574afdec5d"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">rmt_rx_done_callback_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv420rmt_channel_handle_t" title="rmt_channel_handle_t"><span class="n"><span class="pre">rmt_channel_handle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rx_chan</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv424rmt_rx_done_event_data_t" title="rmt_rx_done_event_data_t"><span class="n"><span class="pre">rmt_rx_done_event_data_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edata</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">user_ctx</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv422rmt_rx_done_callback_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Prototype of RMT event callback. </p>
<dl class="field-list simple">
<dt class="field-odd">Param rx_chan<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> RMT channel handle, created from <code class="docutils literal notranslate"><span class="pre">rmt_new_rx_channel()</span></code></p>
</dd>
<dt class="field-even">Param edata<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[in]</strong> Point to RMT event data. The lifecycle of this pointer memory is inside this function, user should copy it into static memory if used outside this function. </p>
</dd>
<dt class="field-odd">Param user_ctx<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> User registered context, passed from <code class="docutils literal notranslate"><span class="pre">rmt_rx_register_event_callbacks()</span></code></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether a high priority task has been waken up by this function </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id15">
<h3>Header File<a class="headerlink" href="#id15" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/hal/include/hal/rmt_types.h">components/hal/include/hal/rmt_types.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;hal/rmt_types.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="unions">
<h3>Unions<a class="headerlink" href="#unions" title="Permalink to this heading"></a></h3>
<dl class="cpp union">
<dt class="sig sig-object cpp" id="_CPPv417rmt_symbol_word_t">
<span id="_CPPv317rmt_symbol_word_t"></span><span id="_CPPv217rmt_symbol_word_t"></span><span class="target" id="unionrmt__symbol__word__t"></span><span class="k"><span class="pre">union</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_symbol_word_t</span></span></span><a class="headerlink" href="#_CPPv417rmt_symbol_word_t" title="Permalink to this definition"></a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;rmt_types.h&gt;</em></div>
<p>The layout of RMT symbol stored in memory, which is decided by the hardware design. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17rmt_symbol_word_t9duration0E">
<span id="_CPPv3N17rmt_symbol_word_t9duration0E"></span><span id="_CPPv2N17rmt_symbol_word_t9duration0E"></span><span id="rmt_symbol_word_t::duration0__uint16_t"></span><span class="target" id="unionrmt__symbol__word__t_1a14b3d10f26f16312f7eb2bab44d69a2c"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">duration0</span></span></span><a class="headerlink" href="#_CPPv4N17rmt_symbol_word_t9duration0E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Duration of level0 </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17rmt_symbol_word_t6level0E">
<span id="_CPPv3N17rmt_symbol_word_t6level0E"></span><span id="_CPPv2N17rmt_symbol_word_t6level0E"></span><span id="rmt_symbol_word_t::level0__uint16_t"></span><span class="target" id="unionrmt__symbol__word__t_1ab2059c02a79fa320639b05344f322556"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">level0</span></span></span><a class="headerlink" href="#_CPPv4N17rmt_symbol_word_t6level0E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Level of the first part </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17rmt_symbol_word_t9duration1E">
<span id="_CPPv3N17rmt_symbol_word_t9duration1E"></span><span id="_CPPv2N17rmt_symbol_word_t9duration1E"></span><span id="rmt_symbol_word_t::duration1__uint16_t"></span><span class="target" id="unionrmt__symbol__word__t_1abf3ff1506c03aae8fd8aa0e56881a626"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">duration1</span></span></span><a class="headerlink" href="#_CPPv4N17rmt_symbol_word_t9duration1E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Duration of level1 </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17rmt_symbol_word_t6level1E">
<span id="_CPPv3N17rmt_symbol_word_t6level1E"></span><span id="_CPPv2N17rmt_symbol_word_t6level1E"></span><span id="rmt_symbol_word_t::level1__uint16_t"></span><span class="target" id="unionrmt__symbol__word__t_1a7eff687083863c833e6afbd1f138c15e"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">level1</span></span></span><a class="headerlink" href="#_CPPv4N17rmt_symbol_word_t6level1E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Level of the second part </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp">
<span class="target" id="unionrmt__symbol__word__t_1a4fbe0c00ab5d43d3f6dbdeb69937dae3"></span><span class="sig-name descname"><span class="pre">struct</span> <span class="pre">rmt_symbol_word_t</span></span></dt>
<dd></dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17rmt_symbol_word_t3valE">
<span id="_CPPv3N17rmt_symbol_word_t3valE"></span><span id="_CPPv2N17rmt_symbol_word_t3valE"></span><span id="rmt_symbol_word_t::val__uint32_t"></span><span class="target" id="unionrmt__symbol__word__t_1a65d8238bc47404d9c7a7ec6b34f06299"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">val</span></span></span><a class="headerlink" href="#_CPPv4N17rmt_symbol_word_t3valE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Equivalent unsigned value for the RMT symbol </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id16">
<h3>Type Definitions<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv418rmt_clock_source_t">
<span id="_CPPv318rmt_clock_source_t"></span><span id="_CPPv218rmt_clock_source_t"></span><span id="rmt_clock_source_t"></span><span class="target" id="hal_2include_2hal_2rmt__types_8h_1a0c8e8a3478a3255504859a475eea94a4"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="clk_tree.html#_CPPv424soc_periph_rmt_clk_src_t" title="soc_periph_rmt_clk_src_t"><span class="n"><span class="pre">soc_periph_rmt_clk_src_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rmt_clock_source_t</span></span></span><a class="headerlink" href="#_CPPv418rmt_clock_source_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>RMT group clock source. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>User should select the clock source based on the power and resolution requirement </p>
</div>
</dd></dl>

<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Different ESP chip series might have different numbers of RMT channels. Please refer to [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rmt">TRM</a>] for details. The driver does not forbid you from applying for more RMT channels, but it returns an error when there are no hardware resources available. Please always check the return value when doing <a class="reference external" href="#resource-allocation">Resource Allocation</a>.</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>The callback function, e.g., <a class="reference internal" href="#_CPPv4N24rmt_tx_event_callbacks_t13on_trans_doneE" title="rmt_tx_event_callbacks_t::on_trans_done"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">rmt_tx_event_callbacks_t::on_trans_done</span></code></a>, and the functions invoked by itself should also reside in IRAM, users need to take care of this by themselves.</p>
</aside>
</aside>
</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Remote Control Transceiver (RMT) (api-reference/peripherals/rmt)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Remote Control Transceiver (RMT) (api-reference/peripherals/rmt)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pcnt.html" class="btn btn-neutral float-left" title="Pulse Counter (PCNT)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sd_pullup_requirements.html" class="btn btn-neutral float-right" title="SD Pull-up Requirements" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>