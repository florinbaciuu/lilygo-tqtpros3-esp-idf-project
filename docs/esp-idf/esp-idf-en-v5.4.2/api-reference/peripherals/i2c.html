<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Inter-Integrated Circuit (I2C) - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/peripherals/i2c.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/peripherals/i2c';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="I2C Slave v1.0" href="i2c_slave_v1.html" />
    <link rel="prev" title="General Purpose Timer (GPTimer)" href="gptimer.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth® API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Peripherals API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="adc_oneshot.html">Analog to Digital Converter (ADC) Oneshot Mode Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="adc_continuous.html">Analog to Digital Converter (ADC) Continuous Mode Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="adc_calibration.html">Analog to Digital Converter (ADC) Calibration Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk_tree.html">Clock Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="dac.html">Digital To Analog Converter (DAC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio.html">GPIO &amp; RTC GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="gptimer.html">General Purpose Timer (GPTimer)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Inter-Integrated Circuit (I2C)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i2c-clock-configuration">I2C Clock Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i2c-file-structure">I2C File Structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functional-overview">Functional Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-examples">Application Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="i2s.html">Inter-IC Sound (I2S)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lcd/index.html">LCD</a></li>
<li class="toctree-l3"><a class="reference internal" href="ledc.html">LED Control (LEDC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mcpwm.html">Motor Control Pulse Width Modulator (MCPWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="pcnt.html">Pulse Counter (PCNT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rmt.html">Remote Control Transceiver (RMT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sd_pullup_requirements.html">SD Pull-up Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc_host.html">SDMMC Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdspi_host.html">SD SPI Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdio_slave.html">SDIO Card Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdm.html">Sigma-Delta Modulation (SDM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_flash/index.html">SPI Flash API</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_master.html">SPI Master Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_slave.html">SPI Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="touch_pad.html">Touch Sensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="twai.html">Two-Wire Automotive Interface (TWAI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="uart.html">Universal Asynchronous Receiver/Transmitter (UART)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Project Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">System API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">Peripherals API</a></li>
      <li class="breadcrumb-item active">Inter-Integrated Circuit (I2C)</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-reference/peripherals/i2c.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="inter-integrated-circuit-i2c">
<h1>Inter-Integrated Circuit (I2C)<a class="headerlink" href="#inter-integrated-circuit-i2c" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/v5.4.2/esp32/api-reference/peripherals/i2c.html">[中文]</a></p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>I2C is a serial, synchronous, multi-device, half-duplex communication protocol that allows co-existence of multiple masters and slaves on the same bus. I2C uses two bidirectional open-drain lines: serial data line (SDA) and serial clock line (SCL), pulled up by resistors.</p>
<p>ESP32 has 2 I2C controller(s) (also called port), responsible for handling communication on the I2C bus.</p>
<p>A single I2C controller can be a master or a slave.</p>
<p>Typically, an I2C slave device has a 7-bit address or 10-bit address. ESP32 supports both I2C Standard-mode (Sm) and Fast-mode (Fm) which can go up to 100 kHz and 400 kHz respectively.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The clock frequency of SCL in master mode should not be larger than 400 kHz.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The frequency of SCL is influenced by both the pull-up resistor and the wire capacitance. Therefore, it is strongly recommended to choose appropriate pull-up resistors to make the frequency accurate. The recommended value for pull-up resistors usually ranges from 1 kΩ to 10 kΩ.</p>
<p>Keep in mind that the higher the frequency, the smaller the pull-up resistor should be (but not less than 1 kΩ). Indeed, large resistors will decline the current, which will increase the clock switching time and reduce the frequency. A range of 2 kΩ to 5 kΩ is recommended, but adjustments may also be necessary depending on their current draw requirements.</p>
</div>
<div class="toctree-wrapper compound">
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We realized that our first version of the I2C slave driver had some problems and was not easy to use, so we have prepared a second version of the I2C slave driver, which solves many of the problems with our current I2C slave and which will be the focus of our maintenance. We encourage and recommend that you use the second version of the I2C slave driver, which you can do by enabling <a class="reference internal" href="../kconfig.html#config-i2c-enable-slave-driver-version-2"><span class="std std-ref">CONFIG_I2C_ENABLE_SLAVE_DRIVER_VERSION_2</span></a>. This document focuses on the content of I2C slave v2.0. If you still want to read programming guide of I2C slave v1.0, please refer to <a class="reference internal" href="i2c_slave_v1.html#i2c-slave-v1"><span class="std std-ref">I2C Slave v1.0</span></a>. The I2C slave v1.0 driver will be removed with the IDF v6.0 update.</p>
</div>
</section>
<section id="i2c-clock-configuration">
<h2>I2C Clock Configuration<a class="headerlink" href="#i2c-clock-configuration" title="Permalink to this heading"></a></h2>
<p><ul class="simple">
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">i2c_clock_source_t::I2C_CLK_SRC_DEFAULT</span></code>: Default I2C source clock.</p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">i2c_clock_source_t::I2C_CLK_SRC_APB</span></code>: APB clock as I2C clock source.</p></li>
</ul>
</p>
</section>
<section id="i2c-file-structure">
<h2>I2C File Structure<a class="headerlink" href="#i2c-file-structure" title="Permalink to this heading"></a></h2>
<figure class="align-center" id="id10">
<img alt="I2C file structure" src="../../_images/i2c_code_structure.png" />
<figcaption>
<p><span class="caption-text">I2C file structure</span><a class="headerlink" href="#id10" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p><strong>Public headers that need to be included in the I2C application</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i2c.h</span></code>: The header file of legacy I2C APIs (for apps using legacy driver).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i2c_master.h</span></code>: The header file that provides standard communication mode specific APIs (for apps using new driver with master mode).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i2c_slave.h</span></code>: The header file that provides standard communication mode specific APIs (for apps using new driver with slave mode).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The legacy driver can't coexist with the new driver. Include <code class="docutils literal notranslate"><span class="pre">i2c.h</span></code> to use the legacy driver or the other two headers to use the new driver. Please keep in mind that the legacy driver is now deprecated and will be removed in future.</p>
</div>
<p><strong>Public headers that have been included in the headers above</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i2c_types_legacy.h</span></code>: The legacy public types that are only used in the legacy driver.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i2c_types.h</span></code>: The header file that provides public types.</p></li>
</ul>
</section>
<section id="functional-overview">
<h2>Functional Overview<a class="headerlink" href="#functional-overview" title="Permalink to this heading"></a></h2>
<p>The I2C driver offers following services:</p>
<ul class="simple">
<li><p><a class="reference external" href="#resource-allocation">Resource Allocation</a> - covers how to allocate I2C bus with properly set of configurations. It also covers how to recycle the resources when they finished working.</p></li>
<li><p><a class="reference external" href="#i2c_master_controller">I2C Master Controller</a> - covers behavior of I2C master controller. Introduce data transmit, data receive, and data transmit and receive.</p></li>
<li><p><a class="reference external" href="#i2c_slave_controller">I2C Slave Controller</a> - covers behavior of I2C slave controller. Involve data transmit and data receive.</p></li>
<li><p><a class="reference external" href="#power-management">Power Management</a> - describes how different source clock will affect power consumption.</p></li>
<li><p><a class="reference external" href="#iram-safe">IRAM Safe</a> - describes tips on how to make the I2C interrupt work better along with a disabled cache.</p></li>
<li><p><a class="reference external" href="#thread-safety">Thread Safety</a> - lists which APIs are guaranteed to be thread safe by the driver.</p></li>
<li><p><a class="reference external" href="#kconfig-options">Kconfig Options</a> - lists the supported Kconfig options that can bring different effects to the driver.</p></li>
</ul>
<section id="resource-allocation">
<h3>Resource Allocation<a class="headerlink" href="#resource-allocation" title="Permalink to this heading"></a></h3>
<p>The I2C master bus is represented by <a class="reference internal" href="#_CPPv423i2c_master_bus_handle_t" title="i2c_master_bus_handle_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_master_bus_handle_t</span></code></a> in the driver. The available ports are managed in a resource pool that allocates a free port on request.</p>
<section id="install-i2c-master-bus-and-device">
<h4>Install I2C master bus and device<a class="headerlink" href="#install-i2c-master-bus-and-device" title="Permalink to this heading"></a></h4>
<p>The I2C master bus is designed based on bus-device model. So <a class="reference internal" href="#_CPPv423i2c_master_bus_config_t" title="i2c_master_bus_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_master_bus_config_t</span></code></a> and <a class="reference internal" href="#_CPPv419i2c_device_config_t" title="i2c_device_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_device_config_t</span></code></a> are required separately to allocate the I2C master bus instance and I2C device instance.</p>
<figure class="align-center" id="id11">
<img alt="I2C master bus-device module" src="../../_images/i2c_master_module.png" />
<figcaption>
<p><span class="caption-text">I2C master bus-device module</span><a class="headerlink" href="#id11" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>I2C master bus requires the configuration that specified by <a class="reference internal" href="#_CPPv423i2c_master_bus_config_t" title="i2c_master_bus_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_master_bus_config_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t8i2c_portE" title="i2c_master_bus_config_t::i2c_port"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::i2c_port</span></code></a> sets the I2C port used by the controller.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t10sda_io_numE" title="i2c_master_bus_config_t::sda_io_num"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::sda_io_num</span></code></a> sets the GPIO number for the serial data bus (SDA).</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t10scl_io_numE" title="i2c_master_bus_config_t::scl_io_num"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::scl_io_num</span></code></a> sets the GPIO number for the serial clock bus (SCL).</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t10clk_sourceE" title="i2c_master_bus_config_t::clk_source"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::clk_source</span></code></a> selects the source clock for I2C bus. The available clocks are listed in <a class="reference internal" href="#_CPPv418i2c_clock_source_t" title="i2c_clock_source_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_clock_source_t</span></code></a>. For the effect on power consumption of different clock source, please refer to <a class="reference external" href="#power-management">Power Management</a>  section.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t17glitch_ignore_cntE" title="i2c_master_bus_config_t::glitch_ignore_cnt"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::glitch_ignore_cnt</span></code></a> sets the glitch period of master bus, if the glitch period on the line is less than this value, it can be filtered out, typically value is 7.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t13intr_priorityE" title="i2c_master_bus_config_t::intr_priority"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::intr_priority</span></code></a> sets the priority of the interrupt. If set to <code class="docutils literal notranslate"><span class="pre">0</span></code> , then the driver will use a interrupt with low or medium priority (priority level may be one of 1, 2 or 3), otherwise use the priority indicated by <a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t13intr_priorityE" title="i2c_master_bus_config_t::intr_priority"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::intr_priority</span></code></a>. Please use the number form (1, 2, 3) , not the bitmask form ((1&lt;&lt;1), (1&lt;&lt;2), (1&lt;&lt;3)).</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t17trans_queue_depthE" title="i2c_master_bus_config_t::trans_queue_depth"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::trans_queue_depth</span></code></a> sets the depth of internal transfer queue. Only valid in asynchronous transaction.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t22enable_internal_pullupE" title="i2c_master_bus_config_t::enable_internal_pullup"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::enable_internal_pullup</span></code></a> enables internal pullups. Note: This is not strong enough to pullup buses under high-speed frequency. A suitable external pullup is recommended.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23i2c_master_bus_config_t8allow_pdE" title="i2c_master_bus_config_t::allow_pd"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_bus_config_t::allow_pd</span></code></a> configures if the driver allows the system to power down the peripheral in light sleep mode. Before entering sleep, the system will backup the I2C register context, which will be restored later when the system exit the sleep mode. Powering down the peripheral can save more power, but at the cost of more memory consumed to save the register context. It's a tradeoff between power consumption and memory consumption. This configuration option relies on specific hardware feature, if you enable it on an unsupported chip, you will see error message like <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">able</span> <span class="pre">to</span> <span class="pre">power</span> <span class="pre">down</span> <span class="pre">in</span> <span class="pre">light</span> <span class="pre">sleep</span></code>.</p></li>
</ul>
<p>If the configurations in <a class="reference internal" href="#_CPPv423i2c_master_bus_config_t" title="i2c_master_bus_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_master_bus_config_t</span></code></a> is specified, then <a class="reference internal" href="#_CPPv418i2c_new_master_busPK23i2c_master_bus_config_tP23i2c_master_bus_handle_t" title="i2c_new_master_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_new_master_bus()</span></code></a> can be called to allocate and initialize an I2C master bus. This function will return an I2C bus handle if it runs correctly. Specifically, when there are no more I2C port available, this function will return <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_FOUND" title="ESP_ERR_NOT_FOUND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_FOUND</span></code></a> error.</p>
<p>I2C master device requires the configuration that specified by <a class="reference internal" href="#_CPPv419i2c_device_config_t" title="i2c_device_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_device_config_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N19i2c_device_config_t15dev_addr_lengthE" title="i2c_device_config_t::dev_addr_length"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_device_config_t::dev_addr_length</span></code></a> configure the address bit length of the slave device. It can be chosen from enumerator <a class="reference internal" href="#_CPPv4N18i2c_addr_bit_len_t18I2C_ADDR_BIT_LEN_7E" title="I2C_ADDR_BIT_LEN_7"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">I2C_ADDR_BIT_LEN_7</span></code></a> or <a class="reference internal" href="#_CPPv4N18i2c_addr_bit_len_t19I2C_ADDR_BIT_LEN_10E" title="I2C_ADDR_BIT_LEN_10"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">I2C_ADDR_BIT_LEN_10</span></code></a> (if supported).</p></li>
<li><p><a class="reference internal" href="#_CPPv4N19i2c_device_config_t14device_addressE" title="i2c_device_config_t::device_address"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_device_config_t::device_address</span></code></a> sets the I2C device raw address. Please parse the device address to this member directly. For example, the device address is 0x28, then parse 0x28 to <a class="reference internal" href="#_CPPv4N19i2c_device_config_t14device_addressE" title="i2c_device_config_t::device_address"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_device_config_t::device_address</span></code></a>, don't carry a write or read bit.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N19i2c_device_config_t12scl_speed_hzE" title="i2c_device_config_t::scl_speed_hz"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_device_config_t::scl_speed_hz</span></code></a> sets the SCL line frequency of this device.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N19i2c_device_config_t11scl_wait_usE" title="i2c_device_config_t::scl_wait_us"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_device_config_t::scl_wait_us</span></code></a> sets the SCL await time (in μs). Usually this value should not be very small because slave stretch will happen in pretty long time (It's possible even stretch for 12 ms). Set <code class="docutils literal notranslate"><span class="pre">0</span></code> means use default register value.</p></li>
</ul>
<p>Once the <a class="reference internal" href="#_CPPv419i2c_device_config_t" title="i2c_device_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_device_config_t</span></code></a> structure is populated with mandatory parameters, <a class="reference internal" href="#_CPPv425i2c_master_bus_add_device23i2c_master_bus_handle_tPK19i2c_device_config_tP23i2c_master_dev_handle_t" title="i2c_master_bus_add_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_bus_add_device()</span></code></a> can be called to allocate an I2C device instance and mounted to the master bus then. This function will return an I2C device handle if it runs correctly. Specifically, when the I2C bus is not initialized properly, calling this function will result in a <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_INVALID_ARG" title="ESP_ERR_INVALID_ARG"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_ARG</span></code></a> error.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/i2c_master.h&quot;</span>

<span class="n">i2c_master_bus_config_t</span><span class="w"> </span><span class="n">i2c_mst_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_CLK_SRC_DEFAULT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">i2c_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEST_I2C_PORT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_SCL_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">sda_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_SDA_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">glitch_ignore_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">enable_internal_pullup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">i2c_master_bus_handle_t</span><span class="w"> </span><span class="n">bus_handle</span><span class="p">;</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_new_master_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_mst_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bus_handle</span><span class="p">));</span>

<span class="n">i2c_device_config_t</span><span class="w"> </span><span class="n">dev_cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">dev_addr_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_ADDR_BIT_LEN_7</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x58</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_speed_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">i2c_master_dev_handle_t</span><span class="w"> </span><span class="n">dev_handle</span><span class="p">;</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_master_bus_add_device</span><span class="p">(</span><span class="n">bus_handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_cfg</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_handle</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="get-i2c-master-handle-via-port">
<h4>Get I2C master handle via port<a class="headerlink" href="#get-i2c-master-handle-via-port" title="Permalink to this heading"></a></h4>
<p>When the I2C master handle has been initialized in one module (e.g. the audio module), but it is not convenient to acquire this handle in another module (e.g. the video module). You can use the helper function, <a class="reference internal" href="#_CPPv425i2c_master_get_bus_handle14i2c_port_num_tP23i2c_master_bus_handle_t" title="i2c_master_get_bus_handle"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_get_bus_handle()</span></code></a> to retrieve the initialized handle via port. Ensure that the handle has already been initialized beforehand to avoid potential errors.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Source File 1</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/i2c_master.h&quot;</span>
<span class="n">i2c_master_bus_handle_t</span><span class="w"> </span><span class="n">bus_handle</span><span class="p">;</span>
<span class="n">i2c_master_bus_config_t</span><span class="w"> </span><span class="n">i2c_mst_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="c1">// same as others</span>
<span class="p">};</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_new_master_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_mst_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bus_handle</span><span class="p">));</span>

<span class="c1">// Source File 2</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/i2c_master.h&quot;</span>
<span class="n">i2c_master_bus_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_master_get_bus_handle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="uninstall-i2c-master-bus-and-device">
<h4>Uninstall I2C master bus and device<a class="headerlink" href="#uninstall-i2c-master-bus-and-device" title="Permalink to this heading"></a></h4>
<p>If a previously installed I2C bus or device is no longer needed, it's recommended to recycle the resource by calling <a class="reference internal" href="#_CPPv424i2c_master_bus_rm_device23i2c_master_dev_handle_t" title="i2c_master_bus_rm_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_bus_rm_device()</span></code></a> or <a class="reference internal" href="#_CPPv418i2c_del_master_bus23i2c_master_bus_handle_t" title="i2c_del_master_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_del_master_bus()</span></code></a>, so as to release the underlying hardware.</p>
</section>
<section id="install-i2c-slave-device">
<h4>Install I2C slave device<a class="headerlink" href="#install-i2c-slave-device" title="Permalink to this heading"></a></h4>
<p>I2C slave requires the configuration specified by <a class="reference internal" href="#_CPPv418i2c_slave_config_t" title="i2c_slave_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_slave_config_t</span></code></a>:</p>
<p><ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N18i2c_slave_config_t8i2c_portE" title="i2c_slave_config_t::i2c_port"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::i2c_port</span></code></a> sets the I2C port used by the controller.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N18i2c_slave_config_t10sda_io_numE" title="i2c_slave_config_t::sda_io_num"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::sda_io_num</span></code></a> sets the GPIO number for serial data bus (SDA).</p></li>
<li><p><a class="reference internal" href="#_CPPv4N18i2c_slave_config_t10scl_io_numE" title="i2c_slave_config_t::scl_io_num"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::scl_io_num</span></code></a> sets the GPIO number for serial clock bus (SCL).</p></li>
<li><p><a class="reference internal" href="#_CPPv4N18i2c_slave_config_t10clk_sourceE" title="i2c_slave_config_t::clk_source"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::clk_source</span></code></a> selects the source clock for I2C bus. The available clocks are listed in <a class="reference internal" href="#_CPPv418i2c_clock_source_t" title="i2c_clock_source_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_clock_source_t</span></code></a>. For the effect on power consumption of different clock source, please refer to <a class="reference external" href="#power-management">Power Management</a>  section.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N18i2c_slave_config_t14send_buf_depthE" title="i2c_slave_config_t::send_buf_depth"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::send_buf_depth</span></code></a> sets the sending software buffer length.</p></li>
<li><p><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::receive_buf_depth</span></code> sets the receiving software buffer length.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N18i2c_slave_config_t13intr_priorityE" title="i2c_slave_config_t::intr_priority"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::intr_priority</span></code></a> sets the priority of the interrupt. If set to <code class="docutils literal notranslate"><span class="pre">0</span></code> , then the driver will use a interrupt with low or medium priority (priority level may be one of 1, 2 or 3), otherwise use the priority indicated by <a class="reference internal" href="#_CPPv4N18i2c_slave_config_t13intr_priorityE" title="i2c_slave_config_t::intr_priority"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::intr_priority</span></code></a>. Please use the number form (1, 2, 3), instead of the bitmask form ((1&lt;&lt;1), (1&lt;&lt;2), (1&lt;&lt;3)). Please pay attention that once the interrupt priority is set, it cannot be changed until <a class="reference internal" href="#_CPPv420i2c_del_slave_device22i2c_slave_dev_handle_t" title="i2c_del_slave_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_del_slave_device()</span></code></a> is called.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N18i2c_slave_config_t12addr_bit_lenE" title="i2c_slave_config_t::addr_bit_len"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::addr_bit_len</span></code></a> Set this variable to <code class="docutils literal notranslate"><span class="pre">I2C_ADDR_BIT_LEN_10</span></code> if the slave should have a 10-bit address.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N18i2c_slave_config_t8allow_pdE" title="i2c_slave_config_t::allow_pd"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::allow_pd</span></code></a> If set, the driver will backup/restore the I2C registers before/after entering/exist sleep mode. By this approach, the system can power off I2C's power domain. This can save power, but at the expense of more RAM being consumed.</p></li>
<li><p><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_config_t::enable_internal_pullup</span></code> Set this to enable internal pull-up. Even though, an output pull-up resistance is strongly recommended.</p></li>
</ul>
</p>
<p>Once the <a class="reference internal" href="#_CPPv418i2c_slave_config_t" title="i2c_slave_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_slave_config_t</span></code></a> structure is populated with mandatory parameters, <a class="reference internal" href="#_CPPv420i2c_new_slave_devicePK18i2c_slave_config_tP22i2c_slave_dev_handle_t" title="i2c_new_slave_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_new_slave_device()</span></code></a> can be called to allocate and initialize an I2C master bus. This function will return an I2C bus handle if it runs correctly. Specifically, when there are no more I2C port available, this function will return <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_FOUND" title="ESP_ERR_NOT_FOUND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_FOUND</span></code></a> error.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">i2c_slave_config_t</span><span class="w"> </span><span class="n">i2c_slv_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">i2c_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_SLAVE_NUM</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_CLK_SRC_DEFAULT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_SLAVE_SCL_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">sda_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_SLAVE_SDA_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">slave_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ESP_SLAVE_ADDR</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">send_buf_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">receive_buf_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">i2c_slave_dev_handle_t</span><span class="w"> </span><span class="n">slave_handle</span><span class="p">;</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_new_slave_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_slv_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slave_handle</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="uninstall-i2c-slave-device">
<h4>Uninstall I2C slave device<a class="headerlink" href="#uninstall-i2c-slave-device" title="Permalink to this heading"></a></h4>
<p>If a previously installed I2C bus is no longer needed, it's recommended to recycle the resource by calling <a class="reference internal" href="#_CPPv420i2c_del_slave_device22i2c_slave_dev_handle_t" title="i2c_del_slave_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_del_slave_device()</span></code></a>, so that to release the underlying hardware.</p>
</section>
</section>
<section id="i2c-master-controller">
<h3>I2C Master Controller<a class="headerlink" href="#i2c-master-controller" title="Permalink to this heading"></a></h3>
<p>After installing the I2C master driver by <a class="reference internal" href="#_CPPv418i2c_new_master_busPK23i2c_master_bus_config_tP23i2c_master_bus_handle_t" title="i2c_new_master_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_new_master_bus()</span></code></a>, ESP32 is ready to communicate with other I2C devices. I2C APIs allow the standard transactions. Like the wave as follows:</p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{
    "head": {
        "text": "Standard I2C Transaction Timing Diagram"
    },
    "signal": [
    {
        "node":"A.....B...................C..D.E...............F...G",
        "period": 0.5},
    {
        "name": "SDA",
        "wave": "1.0...3...3.|.3...4...5...1..0.6...6.|.6...7...10..1", "data": "A6 . A0 R/W ACK D7 . D0 ACK",
        "period": 0.5},
    {
        "name": "SCL",
        "wave": "1...0..1.0.1|0.1.0.1.0.1.0......1.0.1|0.1.0.1.0..1..",
        "period": 0.5}
    ],
    "config":
    {
        "skin": "narrow"
    },
    "edge": [
        "B<->C Write address",
        "E<->F Write data"
    ]
}

</script>
</div>
<section id="i2c-master-write">
<h4>I2C Master Write<a class="headerlink" href="#i2c-master-write" title="Permalink to this heading"></a></h4>
<p>After installing I2C master bus successfully, you can simply call <a class="reference internal" href="#_CPPv419i2c_master_transmit23i2c_master_dev_handle_tPK7uint8_t6size_ti" title="i2c_master_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_transmit()</span></code></a> to write data to the slave device. The principle of this function can be explained by following chart.</p>
<p>In order to organize the process, the driver uses a command link, that should be populated with a sequence of commands and then passed to I2C controller for execution.</p>
<figure class="align-center" id="id12">
<img alt="I2C master write to slave" src="../../_images/i2c_master_write_slave.png" />
<figcaption>
<p><span class="caption-text">I2C master write to slave</span><a class="headerlink" href="#id12" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Simple example for writing data to slave:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define DATA_LENGTH 100</span>
<span class="n">i2c_master_bus_config_t</span><span class="w"> </span><span class="n">i2c_mst_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_CLK_SRC_DEFAULT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">i2c_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_PORT_NUM_0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_SCL_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">sda_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_SDA_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">glitch_ignore_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">i2c_master_bus_handle_t</span><span class="w"> </span><span class="n">bus_handle</span><span class="p">;</span>

<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_new_master_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_mst_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bus_handle</span><span class="p">));</span>

<span class="n">i2c_device_config_t</span><span class="w"> </span><span class="n">dev_cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">dev_addr_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_ADDR_BIT_LEN_7</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x58</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_speed_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">i2c_master_dev_handle_t</span><span class="w"> </span><span class="n">dev_handle</span><span class="p">;</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_master_bus_add_device</span><span class="p">(</span><span class="n">bus_handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_cfg</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_handle</span><span class="p">));</span>

<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_master_transmit</span><span class="p">(</span><span class="n">dev_handle</span><span class="p">,</span><span class="w"> </span><span class="n">data_wr</span><span class="p">,</span><span class="w"> </span><span class="n">DATA_LENGTH</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">));</span>
</pre></div>
</div>
<p>I2C master write also supports transmit multi-buffer in one transaction. Take following transaction as a simple example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">control_phase_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">control_phase_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="cm">/*condition*/</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">control_phase_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">control_phase_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">cmd_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">cmd_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="cm">/*condition*/</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">cmds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">BYTESHIFT</span><span class="p">(</span><span class="n">lcd_cmd</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="n">BYTESHIFT</span><span class="p">(</span><span class="n">lcd_cmd</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">BYTESHIFT</span><span class="p">(</span><span class="n">lcd_cmd</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">BYTESHIFT</span><span class="p">(</span><span class="n">lcd_cmd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)};</span>
<span class="w">    </span><span class="n">cmd_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cmds</span><span class="p">;</span>
<span class="w">    </span><span class="n">cmd_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">lcd_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">lcd_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">lcd_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">lcd_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">i2c_master_transmit_multi_buffer_info_t</span><span class="w"> </span><span class="n">lcd_i2c_buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{.</span><span class="n">write_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">control_phase_byte</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">control_phase_size</span><span class="p">},</span>
<span class="w">    </span><span class="p">{.</span><span class="n">write_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cmd_buffer</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cmd_buffer_size</span><span class="p">},</span>
<span class="w">    </span><span class="p">{.</span><span class="n">write_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lcd_buffer</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lcd_buffer_size</span><span class="p">},</span>
<span class="p">};</span>

<span class="n">i2c_master_multi_buffer_transmit</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">lcd_i2c_buffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">lcd_i2c_buffer</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">i2c_master_transmit_multi_buffer_info_t</span><span class="p">),</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="i2c-master-read">
<h4>I2C Master Read<a class="headerlink" href="#i2c-master-read" title="Permalink to this heading"></a></h4>
<p>After installing I2C master bus successfully, you can simply call <a class="reference internal" href="#_CPPv418i2c_master_receive23i2c_master_dev_handle_tP7uint8_t6size_ti" title="i2c_master_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_receive()</span></code></a> to read data from the slave device. The principle of this function can be explained by following chart.</p>
<figure class="align-center" id="id13">
<img alt="I2C master read from slave" src="../../_images/i2c_master_read_slave.png" />
<figcaption>
<p><span class="caption-text">I2C master read from slave</span><a class="headerlink" href="#id13" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Simple example for reading data from slave:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define DATA_LENGTH 100</span>
<span class="n">i2c_master_bus_config_t</span><span class="w"> </span><span class="n">i2c_mst_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_CLK_SRC_DEFAULT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">i2c_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_PORT_NUM_0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_SCL_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">sda_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_SDA_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">glitch_ignore_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">i2c_master_bus_handle_t</span><span class="w"> </span><span class="n">bus_handle</span><span class="p">;</span>

<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_new_master_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_mst_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bus_handle</span><span class="p">));</span>

<span class="n">i2c_device_config_t</span><span class="w"> </span><span class="n">dev_cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">dev_addr_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_ADDR_BIT_LEN_7</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x58</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_speed_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">i2c_master_dev_handle_t</span><span class="w"> </span><span class="n">dev_handle</span><span class="p">;</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_master_bus_add_device</span><span class="p">(</span><span class="n">bus_handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_cfg</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_handle</span><span class="p">));</span>

<span class="n">i2c_master_receive</span><span class="p">(</span><span class="n">dev_handle</span><span class="p">,</span><span class="w"> </span><span class="n">data_rd</span><span class="p">,</span><span class="w"> </span><span class="n">DATA_LENGTH</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="i2c-master-write-and-read">
<h4>I2C Master Write and Read<a class="headerlink" href="#i2c-master-write-and-read" title="Permalink to this heading"></a></h4>
<p>Some I2C device needs write configurations before reading data from it. Therefore, an interface called <a class="reference internal" href="#_CPPv427i2c_master_transmit_receive23i2c_master_dev_handle_tPK7uint8_t6size_tP7uint8_t6size_ti" title="i2c_master_transmit_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_transmit_receive()</span></code></a> can help. The principle of this function can be explained by following chart.</p>
<figure class="align-center" id="id14">
<img alt="I2C master write to slave and read from slave" src="../../_images/i2c_master_write_read_slave.png" />
<figcaption>
<p><span class="caption-text">I2C master write to slave and read from slave</span><a class="headerlink" href="#id14" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Please note that no STOP condition bit is inserted between the write and read operations; therefore, this function is suited to read a register from an I2C device. A simple example for writing and reading from a slave device:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">i2c_device_config_t</span><span class="w"> </span><span class="n">dev_cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">dev_addr_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_ADDR_BIT_LEN_7</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x58</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_speed_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">i2c_master_dev_handle_t</span><span class="w"> </span><span class="n">dev_handle</span><span class="p">;</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_master_bus_add_device</span><span class="p">(</span><span class="n">bus_handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_cfg</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_handle</span><span class="p">));</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x20</span><span class="p">};</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_master_transmit_receive</span><span class="p">(</span><span class="n">dev_handle</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="i2c-master-probe">
<h4>I2C Master Probe<a class="headerlink" href="#i2c-master-probe" title="Permalink to this heading"></a></h4>
<p>I2C driver can use <a class="reference internal" href="#_CPPv416i2c_master_probe23i2c_master_bus_handle_t8uint16_ti" title="i2c_master_probe"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_probe()</span></code></a> to detect whether the specific device has been connected on I2C bus. If this function return <code class="docutils literal notranslate"><span class="pre">ESP_OK</span></code>, that means the device has been detected.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Pull-ups must be connected to the SCL and SDA pins when this function is called. If you get <cite>ESP_ERR_TIMEOUT</cite> while <cite>xfer_timeout_ms</cite> was parsed correctly, you should check the pull-up resistors. If you do not have proper resistors nearby, setting <cite>flags.enable_internal_pullup</cite> as true is also acceptable.</p>
</div>
<figure class="align-center" id="id15">
<img alt="I2C master probe" src="../../_images/i2c_master_probe.png" />
<figcaption>
<p><span class="caption-text">I2C master probe</span><a class="headerlink" href="#id15" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Simple example for probing an I2C device:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">i2c_master_bus_config_t</span><span class="w"> </span><span class="n">i2c_mst_config_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_CLK_SRC_DEFAULT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">i2c_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEST_I2C_PORT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_SCL_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">sda_io_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_SDA_IO</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">glitch_ignore_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">enable_internal_pullup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">i2c_master_bus_handle_t</span><span class="w"> </span><span class="n">bus_handle</span><span class="p">;</span>

<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_new_master_bus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_mst_config_1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bus_handle</span><span class="p">));</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_master_probe</span><span class="p">(</span><span class="n">bus_handle</span><span class="p">,</span><span class="w"> </span><span class="mh">0x22</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">));</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_del_master_bus</span><span class="p">(</span><span class="n">bus_handle</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="i2c-master-execute-customized-transactions">
<h4>I2C Master Execute Customized Transactions<a class="headerlink" href="#i2c-master-execute-customized-transactions" title="Permalink to this heading"></a></h4>
<p>Not all I2C devices strictly adhere to the standard I2C protocol, as different manufacturers may implement custom variations. For example, some devices require the address to be shifted, while others do not. Similarly, certain devices mandate acknowledgment (ACK) checks for specific operations, whereas others might not. To accommodate these variations, <a class="reference internal" href="#_CPPv437i2c_master_execute_defined_operations23i2c_master_dev_handle_tP19i2c_operation_job_t6size_ti" title="i2c_master_execute_defined_operations"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_execute_defined_operations()</span></code></a> function allow developers to define and execute fully customized I2C transactions. This flexibility ensures seamless communication with non-standard devices by tailoring the transaction sequence, addressing, and acknowledgment behavior to the device's specific requirements.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to define your address in <a class="reference internal" href="#_CPPv419i2c_operation_job_t" title="i2c_operation_job_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_operation_job_t</span></code></a>, please set <a class="reference internal" href="#_CPPv4N19i2c_device_config_t14device_addressE" title="i2c_device_config_t::device_address"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_device_config_t::device_address</span></code></a> as I2C_DEVICE_ADDRESS_NOT_USED to skip internal address configuration in driver.</p>
</div>
<p>For address configuration of using defined transactions, given that a device address is 0x20, there are two situations, see following example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">i2c_device_config_t</span><span class="w"> </span><span class="n">i2c_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">device_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_DEVICE_ADDRESS_NOT_USED</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_speed_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">scl_wait_us</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20000</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">i2c_master_dev_handle_t</span><span class="w"> </span><span class="n">dev_handle</span><span class="p">;</span>

<span class="n">i2c_master_bus_add_device</span><span class="p">(</span><span class="n">bus_handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i2c_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_handle</span><span class="p">);</span>

<span class="c1">// Situation one: The device does not allow device address shift</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">address1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x20</span><span class="p">;</span>
<span class="n">i2c_operation_job_t</span><span class="w"> </span><span class="n">i2c_ops1</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_START</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_WRITE</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">ack_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">address1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">total_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_STOP</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>

<span class="c1">// Situation one: The device should left shift one byte with carrying a write or read bit (official protocol)</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">address2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x20</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// (0x20 &lt;&lt; 1 | 1)</span>
<span class="n">i2c_operation_job_t</span><span class="w"> </span><span class="n">i2c_ops2</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_START</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_WRITE</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">ack_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">address2</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">total_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_STOP</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There are also some devices does not need an address, you can directly do transaction with data:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x11</span><span class="p">,</span><span class="w"> </span><span class="mh">0x22</span><span class="p">,</span><span class="w"> </span><span class="mh">0x33</span><span class="p">,</span><span class="w"> </span><span class="mh">0x44</span><span class="p">,</span><span class="w"> </span><span class="mh">0x55</span><span class="p">,</span><span class="w"> </span><span class="mh">0x66</span><span class="p">,</span><span class="w"> </span><span class="mh">0x77</span><span class="p">,</span><span class="w"> </span><span class="mh">0x88</span><span class="p">};</span>

<span class="n">i2c_operation_job_t</span><span class="w"> </span><span class="n">i2c_ops</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_START</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_WRITE</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">ack_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">total_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_STOP</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>

<span class="n">i2c_master_execute_defined_operations</span><span class="p">(</span><span class="n">dev_handle</span><span class="p">,</span><span class="w"> </span><span class="n">i2c_ops</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">i2c_ops</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">i2c_operation_job_t</span><span class="p">),</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
</pre></div>
</div>
<p>As for read direction, the theory is same but please always be aware the last byte of read before stop should always be nack. Example is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x20</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">rcv_data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="n">i2c_operation_job_t</span><span class="w"> </span><span class="n">i2c_ops</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_START</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_WRITE</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">ack_check</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">total_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_READ</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">ack_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_ACK_VAL</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">rcv_data</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">total_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_READ</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">ack_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_NACK_VAL</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">rcv_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">9</span><span class="p">),</span><span class="w"> </span><span class="p">.</span><span class="n">total_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="c1">// This must be nack.</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_MASTER_CMD_STOP</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>

<span class="n">i2c_master_execute_defined_operations</span><span class="p">(</span><span class="n">dev_handle</span><span class="p">,</span><span class="w"> </span><span class="n">i2c_ops</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">i2c_ops</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">i2c_operation_job_t</span><span class="p">),</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="i2c-slave-controller">
<h3>I2C Slave Controller<a class="headerlink" href="#i2c-slave-controller" title="Permalink to this heading"></a></h3>
<p>After installing the I2C slave driver by <a class="reference internal" href="#_CPPv420i2c_new_slave_devicePK18i2c_slave_config_tP22i2c_slave_dev_handle_t" title="i2c_new_slave_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_new_slave_device()</span></code></a>, ESP32 is ready to communicate with other I2C masters as a slave.</p>
<p>The I2C slave is not as subjective as the I2C master which knows when it should send data and when it should receive data. The I2C slave is very passive in most cases, that means the I2C slave's ability to send and receive data is largely dependent on the master's actions. Therefore, we throw two callback functions in the driver that represent read requests and write requests from the I2C master.</p>
<section id="i2c-slave-write">
<h4>I2C Slave Write<a class="headerlink" href="#i2c-slave-write" title="Permalink to this heading"></a></h4>
<p>You can get I2C slave write event be register <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_event_callbacks_t::on_request</span></code> callback, and in a task when get the request event, you can call <cite>i2c_slave_write</cite> to send data.</p>
<p>Simple example for transmitting data:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Prepare a callback function</span>
<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">i2c_slave_request_cb</span><span class="p">(</span><span class="n">i2c_slave_dev_handle_t</span><span class="w"> </span><span class="n">i2c_slave</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">i2c_slave_request_event_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">evt_data</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">i2c_slave_event_t</span><span class="w"> </span><span class="n">evt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_SLAVE_EVT_TX</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">xQueueSendFromISR</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">event_queue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">evt</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTaskWoken</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xTaskWoken</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Register callback in a task</span>
<span class="n">i2c_slave_event_callbacks_t</span><span class="w"> </span><span class="n">cbs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">on_request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_slave_request_cb</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_slave_register_event_callbacks</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cbs</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">context</span><span class="p">));</span>

<span class="c1">// Waiting for request event and send data in a task</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">i2c_slave_task</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">write_len</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">data_buffer</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">i2c_slave_event_t</span><span class="w"> </span><span class="n">evt</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xQueueReceive</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">event_queue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">evt</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_slave_write</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">data_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">write_len</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">vTaskDelete</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="i2c-slave-read">
<h4>I2C Slave Read<a class="headerlink" href="#i2c-slave-read" title="Permalink to this heading"></a></h4>
<p>Same as write, you can get I2C slave read event be register <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_event_callbacks_t::on_receive</span></code> callback, and in a task when get the request event, you can save the data and do what you want.</p>
<p>Simple example for receiving data:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Prepare a callback function</span>
<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">i2c_slave_receive_cb</span><span class="p">(</span><span class="n">i2c_slave_dev_handle_t</span><span class="w"> </span><span class="n">i2c_slave</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">i2c_slave_rx_done_event_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">evt_data</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">i2c_slave_event_t</span><span class="w"> </span><span class="n">evt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_SLAVE_EVT_RX</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// You can get data and length via i2c_slave_rx_done_event_data_t</span>
<span class="w">    </span><span class="n">xQueueSendFromISR</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">event_queue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">evt</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTaskWoken</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">xTaskWoken</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Register callback in a task</span>
<span class="n">i2c_slave_event_callbacks_t</span><span class="w"> </span><span class="n">cbs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">on_receive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_slave_receive_cb</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">i2c_slave_register_event_callbacks</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cbs</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">context</span><span class="p">));</span>
</pre></div>
</div>
</section>
</section>
<section id="register-event-callbacks">
<h3>Register Event Callbacks<a class="headerlink" href="#register-event-callbacks" title="Permalink to this heading"></a></h3>
<section id="i2c-master-callbacks">
<h4>I2C master callbacks<a class="headerlink" href="#i2c-master-callbacks" title="Permalink to this heading"></a></h4>
<p>When an I2C master bus triggers an interrupt, a specific event will be generated and notify the CPU. If you have some functions that need to be called when those events occurred, you can hook your functions to the ISR (Interrupt Service Routine) by calling <a class="reference internal" href="#_CPPv435i2c_master_register_event_callbacks23i2c_master_dev_handle_tPK28i2c_master_event_callbacks_tPv" title="i2c_master_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_register_event_callbacks()</span></code></a>. Since the registered callback functions are called in the interrupt context, users should ensure the callback function doesn't attempt to block (e.g. by making sure that only FreeRTOS APIs with <code class="docutils literal notranslate"><span class="pre">ISR</span></code> suffix are called from the function). The callback functions are required to return a boolean value, to tell the ISR whether a high priority task is woken up by it.</p>
<p>I2C master event callbacks are listed in the <a class="reference internal" href="#_CPPv428i2c_master_event_callbacks_t" title="i2c_master_event_callbacks_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_master_event_callbacks_t</span></code></a>.</p>
<p>Although I2C is a synchronous communication protocol, asynchronous behavior is supported by registering above callbacks. In this way, I2C APIs will be non-blocking interface. But note that on the same bus, only one device can adopt asynchronous operation.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>I2C master asynchronous transaction is still an experimental feature (The issue is that when asynchronous transaction is very large, it will cause memory problem).</p>
</div>
<ul class="simple">
<li><p><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_master_event_callbacks_t::on_recv_done</span></code> sets a callback function for master &quot;transaction-done&quot; event. The function prototype is declared in <a class="reference internal" href="#_CPPv421i2c_master_callback_t" title="i2c_master_callback_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_master_callback_t</span></code></a>.</p></li>
</ul>
</section>
<section id="i2c-slave-callbacks">
<h4>I2C slave callbacks<a class="headerlink" href="#i2c-slave-callbacks" title="Permalink to this heading"></a></h4>
<p>When an I2C slave bus triggers an interrupt, a specific event will be generated and notify the CPU. If you have some function that needs to be called when those events occurred, you can hook your function to the ISR (Interrupt Service Routine) by calling <a class="reference internal" href="#_CPPv434i2c_slave_register_event_callbacks22i2c_slave_dev_handle_tPK27i2c_slave_event_callbacks_tPv" title="i2c_slave_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_slave_register_event_callbacks()</span></code></a>. Since the registered callback functions are called in the interrupt context, users should ensure the callback function doesn't attempt to block (e.g. by making sure that only FreeRTOS APIs with <code class="docutils literal notranslate"><span class="pre">ISR</span></code> suffix are called from the function). The callback function has a boolean return value, to tell the caller whether a high priority task is woken up by it.</p>
<p>I2C slave event callbacks are listed in the <a class="reference internal" href="#_CPPv427i2c_slave_event_callbacks_t" title="i2c_slave_event_callbacks_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_slave_event_callbacks_t</span></code></a>.</p>
<p><ul class="simple">
<li><p><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_event_callbacks_t::on_request</span></code> sets a callback function for request event.</p></li>
<li><p><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">i2c_slave_event_callbacks_t::on_receive</span></code> sets a callback function for receive event. The function prototype is declared in <a class="reference internal" href="#_CPPv429i2c_slave_received_callback_t" title="i2c_slave_received_callback_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">i2c_slave_received_callback_t</span></code></a>.</p></li>
</ul>
</p>
</section>
</section>
<section id="power-management">
<h3>Power Management<a class="headerlink" href="#power-management" title="Permalink to this heading"></a></h3>
<p>When the power management is enabled (i.e. <a class="reference internal" href="../kconfig.html#config-pm-enable"><span class="std std-ref">CONFIG_PM_ENABLE</span></a> is on), the system will adjust or stop the source clock of I2C FIFO before going into Light-sleep mode, thus potentially changing the I2C signals and leading to transmitting or receiving invalid data.</p>
<p>However, the driver can prevent the system from changing APB frequency by acquiring a power management lock of type <a class="reference internal" href="../system/power_management.html#_CPPv4N18esp_pm_lock_type_t19ESP_PM_APB_FREQ_MAXE" title="ESP_PM_APB_FREQ_MAX"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code></a>. Whenever user creates an I2C bus that has selected <a class="reference internal" href="clk_tree.html#_CPPv4N24soc_periph_i2c_clk_src_t15I2C_CLK_SRC_APBE" title="I2C_CLK_SRC_APB"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">I2C_CLK_SRC_APB</span></code></a> as the clock source, the driver will guarantee that the power management lock is acquired when I2C operations begin and the lock will be released automatically when I2C operations finish.</p>
</section>
<section id="iram-safe">
<h3>IRAM Safe<a class="headerlink" href="#iram-safe" title="Permalink to this heading"></a></h3>
<p>By default, the I2C interrupt will be deferred when the cache is disabled for reasons like writing or erasing flash. Thus the event callback functions will not get executed in time, which is not expected in a real-time application.</p>
<p>There's a Kconfig option <a class="reference internal" href="../kconfig.html#config-i2c-isr-iram-safe"><span class="std std-ref">CONFIG_I2C_ISR_IRAM_SAFE</span></a> that will:</p>
<ol class="arabic simple">
<li><p>Enable the interrupt being serviced even when cache is disabled.</p></li>
<li><p>Place all functions that used by the ISR into IRAM.</p></li>
<li><p>Place driver object into DRAM (in case it's mapped to PSRAM by accident).</p></li>
</ol>
<p>This will allow the interrupt to run while the cache is disabled but will come at the cost of increased IRAM consumption.</p>
</section>
<section id="thread-safety">
<h3>Thread Safety<a class="headerlink" href="#thread-safety" title="Permalink to this heading"></a></h3>
<p>The factory function <a class="reference internal" href="#_CPPv418i2c_new_master_busPK23i2c_master_bus_config_tP23i2c_master_bus_handle_t" title="i2c_new_master_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_new_master_bus()</span></code></a> and <a class="reference internal" href="#_CPPv420i2c_new_slave_devicePK18i2c_slave_config_tP22i2c_slave_dev_handle_t" title="i2c_new_slave_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_new_slave_device()</span></code></a> are guaranteed to be thread safe by the driver, which means that the functions can be called from different RTOS tasks without protection by extra locks.</p>
<p>I2C master operation functions are also guaranteed to be thread safe by bus operation semaphore.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv419i2c_master_transmit23i2c_master_dev_handle_tPK7uint8_t6size_ti" title="i2c_master_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_transmit()</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv432i2c_master_multi_buffer_transmit23i2c_master_dev_handle_tP39i2c_master_transmit_multi_buffer_info_t6size_ti" title="i2c_master_multi_buffer_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_multi_buffer_transmit()</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv427i2c_master_transmit_receive23i2c_master_dev_handle_tPK7uint8_t6size_tP7uint8_t6size_ti" title="i2c_master_transmit_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_transmit_receive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv418i2c_master_receive23i2c_master_dev_handle_tP7uint8_t6size_ti" title="i2c_master_receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_receive()</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv416i2c_master_probe23i2c_master_bus_handle_t8uint16_ti" title="i2c_master_probe"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_master_probe()</span></code></a></p></li>
</ul>
<p>I2C slave operation functions are also guaranteed to be thread safe by bus operation semaphore.</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">i2c_slave_write()</span></code></p></li>
</ul>
<p>Other functions are not guaranteed to be thread-safe. Thus, you should avoid calling them in different tasks without mutex protection.</p>
</section>
<section id="kconfig-options">
<h3>Kconfig Options<a class="headerlink" href="#kconfig-options" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="../kconfig.html#config-i2c-isr-iram-safe"><span class="std std-ref">CONFIG_I2C_ISR_IRAM_SAFE</span></a> controls whether the default ISR handler can work when cache is disabled, see also <a class="reference external" href="#iram-safe">IRAM Safe</a> for more information.</p></li>
<li><p><a class="reference internal" href="../kconfig.html#config-i2c-enable-debug-log"><span class="std std-ref">CONFIG_I2C_ENABLE_DEBUG_LOG</span></a> is used to enable the debug log at the cost of increased firmware binary size.</p></li>
<li><p><a class="reference internal" href="../kconfig.html#config-i2c-enable-slave-driver-version-2"><span class="std std-ref">CONFIG_I2C_ENABLE_SLAVE_DRIVER_VERSION_2</span></a> is used to enable the I2C slave driver v2.0.</p></li>
</ul>
</section>
</section>
<section id="application-examples">
<h2>Application Examples<a class="headerlink" href="#application-examples" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/i2c/i2c_eeprom">peripherals/i2c/i2c_eeprom</a> demonstrates how to use the I2C master mode to read and write data from a connected EEPROM.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/i2c/i2c_tools">peripherals/i2c/i2c_tools</a> demonstrates how to use the I2C Tools for developing I2C related applications, providing command-line tools for configuring the I2C bus, scanning for devices, reading and setting registers, and examining registers.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/i2c/i2c_slave_network_sensor">peripherals/i2c/i2c_slave_network_sensor</a> demonstrates how to use the I2C slave for developing I2C related applications, providing how I2C slave can behave as a network sensor, and use event callbacks to receive and send data.</p></li>
</ul>
</section>
<section id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h2>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_i2c/include/driver/i2c_master.h">components/esp_driver_i2c/include/driver/i2c_master.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/i2c_master.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_i2c</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_i2c</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_i2c
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_i2c
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418i2c_new_master_busPK23i2c_master_bus_config_tP23i2c_master_bus_handle_t">
<span id="_CPPv318i2c_new_master_busPK23i2c_master_bus_config_tP23i2c_master_bus_handle_t"></span><span id="_CPPv218i2c_new_master_busPK23i2c_master_bus_config_tP23i2c_master_bus_handle_t"></span><span id="i2c_new_master_bus__i2c_master_bus_config_tCP.i2c_master_bus_handle_tP"></span><span class="target" id="i2c__master_8h_1a8b7fdce3caaf798fa98b3aff7d82307c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_new_master_bus</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv423i2c_master_bus_config_t" title="i2c_master_bus_config_t"><span class="n"><span class="pre">i2c_master_bus_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">bus_config</span></span>, <a class="reference internal" href="#_CPPv423i2c_master_bus_handle_t" title="i2c_master_bus_handle_t"><span class="n"><span class="pre">i2c_master_bus_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_bus_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418i2c_new_master_busPK23i2c_master_bus_config_tP23i2c_master_bus_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Allocate an I2C master bus. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bus_config</strong> -- <strong>[in]</strong> I2C master bus configuration. </p></li>
<li><p><strong>ret_bus_handle</strong> -- <strong>[out]</strong> I2C bus handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: I2C master bus initialized successfully.</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C bus initialization failed because of invalid argument.</p></li>
<li><p>ESP_ERR_NO_MEM: Create I2C bus failed because of out of memory.</p></li>
<li><p>ESP_ERR_NOT_FOUND: No more free bus. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425i2c_master_bus_add_device23i2c_master_bus_handle_tPK19i2c_device_config_tP23i2c_master_dev_handle_t">
<span id="_CPPv325i2c_master_bus_add_device23i2c_master_bus_handle_tPK19i2c_device_config_tP23i2c_master_dev_handle_t"></span><span id="_CPPv225i2c_master_bus_add_device23i2c_master_bus_handle_tPK19i2c_device_config_tP23i2c_master_dev_handle_t"></span><span id="i2c_master_bus_add_device__i2c_master_bus_handle_t.i2c_device_config_tCP.i2c_master_dev_handle_tP"></span><span class="target" id="i2c__master_8h_1ae690479d35ee94fe6274b9c20cb579af"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_bus_add_device</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_bus_handle_t" title="i2c_master_bus_handle_t"><span class="n"><span class="pre">i2c_master_bus_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bus_handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv419i2c_device_config_t" title="i2c_device_config_t"><span class="n"><span class="pre">i2c_device_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dev_config</span></span>, <a class="reference internal" href="#_CPPv423i2c_master_dev_handle_t" title="i2c_master_dev_handle_t"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425i2c_master_bus_add_device23i2c_master_bus_handle_tPK19i2c_device_config_tP23i2c_master_dev_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Add I2C master BUS device. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bus_handle</strong> -- <strong>[in]</strong> I2C bus handle. </p></li>
<li><p><strong>dev_config</strong> -- <strong>[in]</strong> device config. </p></li>
<li><p><strong>ret_handle</strong> -- <strong>[out]</strong> device handle. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Create I2C master device successfully.</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C bus initialization failed because of invalid argument.</p></li>
<li><p>ESP_ERR_NO_MEM: Create I2C bus failed because of out of memory. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418i2c_del_master_bus23i2c_master_bus_handle_t">
<span id="_CPPv318i2c_del_master_bus23i2c_master_bus_handle_t"></span><span id="_CPPv218i2c_del_master_bus23i2c_master_bus_handle_t"></span><span id="i2c_del_master_bus__i2c_master_bus_handle_t"></span><span class="target" id="i2c__master_8h_1ac8decac09ff01e77171512349159fc0f"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_del_master_bus</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_bus_handle_t" title="i2c_master_bus_handle_t"><span class="n"><span class="pre">i2c_master_bus_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bus_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418i2c_del_master_bus23i2c_master_bus_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deinitialize the I2C master bus and delete the handle. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bus_handle</strong> -- <strong>[in]</strong> I2C bus handle. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Delete I2C bus success, otherwise, failed.</p></li>
<li><p>Otherwise: Some module delete failed. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424i2c_master_bus_rm_device23i2c_master_dev_handle_t">
<span id="_CPPv324i2c_master_bus_rm_device23i2c_master_dev_handle_t"></span><span id="_CPPv224i2c_master_bus_rm_device23i2c_master_dev_handle_t"></span><span id="i2c_master_bus_rm_device__i2c_master_dev_handle_t"></span><span class="target" id="i2c__master_8h_1aff297d2a05b2176d6786af0239cb5075"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_bus_rm_device</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_dev_handle_t" title="i2c_master_dev_handle_t"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424i2c_master_bus_rm_device23i2c_master_dev_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C master bus delete device. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- i2c device handle </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: If device is successfully deleted. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419i2c_master_transmit23i2c_master_dev_handle_tPK7uint8_t6size_ti">
<span id="_CPPv319i2c_master_transmit23i2c_master_dev_handle_tPK7uint8_t6size_ti"></span><span id="_CPPv219i2c_master_transmit23i2c_master_dev_handle_tPK7uint8_t6size_ti"></span><span id="i2c_master_transmit__i2c_master_dev_handle_t.uint8_tCP.s.i"></span><span class="target" id="i2c__master_8h_1a02aa71920768a072eb410af3933af6e0"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_transmit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_dev_handle_t" title="i2c_master_dev_handle_t"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">write_buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">write_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xfer_timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419i2c_master_transmit23i2c_master_dev_handle_tPK7uint8_t6size_ti" title="Permalink to this definition"></a><br /></dt>
<dd><p>Perform a write transaction on the I2C bus. The transaction will be undergoing until it finishes or it reaches the timeout provided. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a callback was registered with <code class="docutils literal notranslate"><span class="pre">i2c_master_register_event_callbacks</span></code>, the transaction will be asynchronous, and thus, this function will return directly, without blocking. You will get finish information from callback. Besides, data buffer should always be completely prepared when callback is registered, otherwise, the data will get corrupt.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i2c_dev</strong> -- <strong>[in]</strong> I2C master device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_master_bus_add_device</span></code>. </p></li>
<li><p><strong>write_buffer</strong> -- <strong>[in]</strong> Data bytes to send on the I2C bus. </p></li>
<li><p><strong>write_size</strong> -- <strong>[in]</strong> Size, in bytes, of the write buffer. </p></li>
<li><p><strong>xfer_timeout_ms</strong> -- <strong>[in]</strong> Wait timeout, in ms. Note: -1 means wait forever. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: I2C master transmit success</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C master transmit parameter invalid.</p></li>
<li><p>ESP_ERR_TIMEOUT: Operation timeout(larger than xfer_timeout_ms) because the bus is busy or hardware crash. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv432i2c_master_multi_buffer_transmit23i2c_master_dev_handle_tP39i2c_master_transmit_multi_buffer_info_t6size_ti">
<span id="_CPPv332i2c_master_multi_buffer_transmit23i2c_master_dev_handle_tP39i2c_master_transmit_multi_buffer_info_t6size_ti"></span><span id="_CPPv232i2c_master_multi_buffer_transmit23i2c_master_dev_handle_tP39i2c_master_transmit_multi_buffer_info_t6size_ti"></span><span id="i2c_master_multi_buffer_transmit__i2c_master_dev_handle_t.i2c_master_transmit_multi_buffer_info_tP.s.i"></span><span class="target" id="i2c__master_8h_1a2b5b33c7a5f60d3a15bebb7af0390a3e"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_multi_buffer_transmit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_dev_handle_t" title="i2c_master_dev_handle_t"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_dev</span></span>, <a class="reference internal" href="#_CPPv439i2c_master_transmit_multi_buffer_info_t" title="i2c_master_transmit_multi_buffer_info_t"><span class="n"><span class="pre">i2c_master_transmit_multi_buffer_info_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">buffer_info_array</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">array_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xfer_timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432i2c_master_multi_buffer_transmit23i2c_master_dev_handle_tP39i2c_master_transmit_multi_buffer_info_t6size_ti" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit multiple buffers of data over an I2C bus. </p>
<p>This function transmits multiple buffers of data over an I2C bus using the specified I2C master device handle. It takes in an array of buffer information structures along with the size of the array and a transfer timeout value in milliseconds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i2c_dev</strong> -- I2C master device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_master_bus_add_device</span></code>. </p></li>
<li><p><strong>buffer_info_array</strong> -- Pointer to buffer information array. </p></li>
<li><p><strong>array_size</strong> -- size of buffer information array. </p></li>
<li><p><strong>xfer_timeout_ms</strong> -- Wait timeout, in ms. Note: -1 means wait forever.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: I2C master transmit success</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C master transmit parameter invalid.</p></li>
<li><p>ESP_ERR_TIMEOUT: Operation timeout(larger than xfer_timeout_ms) because the bus is busy or hardware crash. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427i2c_master_transmit_receive23i2c_master_dev_handle_tPK7uint8_t6size_tP7uint8_t6size_ti">
<span id="_CPPv327i2c_master_transmit_receive23i2c_master_dev_handle_tPK7uint8_t6size_tP7uint8_t6size_ti"></span><span id="_CPPv227i2c_master_transmit_receive23i2c_master_dev_handle_tPK7uint8_t6size_tP7uint8_t6size_ti"></span><span id="i2c_master_transmit_receive__i2c_master_dev_handle_t.uint8_tCP.s.uint8_tP.s.i"></span><span class="target" id="i2c__master_8h_1a73c4350c9f16744f68dae08587cef3b3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_transmit_receive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_dev_handle_t" title="i2c_master_dev_handle_t"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">write_buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">write_size</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">read_buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">read_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xfer_timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427i2c_master_transmit_receive23i2c_master_dev_handle_tPK7uint8_t6size_tP7uint8_t6size_ti" title="Permalink to this definition"></a><br /></dt>
<dd><p>Perform a write-read transaction on the I2C bus. The transaction will be undergoing until it finishes or it reaches the timeout provided. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a callback was registered with <code class="docutils literal notranslate"><span class="pre">i2c_master_register_event_callbacks</span></code>, the transaction will be asynchronous, and thus, this function will return directly, without blocking. You will get finish information from callback. Besides, data buffer should always be completely prepared when callback is registered, otherwise, the data will get corrupt.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i2c_dev</strong> -- <strong>[in]</strong> I2C master device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_master_bus_add_device</span></code>. </p></li>
<li><p><strong>write_buffer</strong> -- <strong>[in]</strong> Data bytes to send on the I2C bus. </p></li>
<li><p><strong>write_size</strong> -- <strong>[in]</strong> Size, in bytes, of the write buffer. </p></li>
<li><p><strong>read_buffer</strong> -- <strong>[out]</strong> Data bytes received from i2c bus. </p></li>
<li><p><strong>read_size</strong> -- <strong>[in]</strong> Size, in bytes, of the read buffer. </p></li>
<li><p><strong>xfer_timeout_ms</strong> -- <strong>[in]</strong> Wait timeout, in ms. Note: -1 means wait forever. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: I2C master transmit-receive success</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C master transmit parameter invalid.</p></li>
<li><p>ESP_ERR_TIMEOUT: Operation timeout(larger than xfer_timeout_ms) because the bus is busy or hardware crash. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418i2c_master_receive23i2c_master_dev_handle_tP7uint8_t6size_ti">
<span id="_CPPv318i2c_master_receive23i2c_master_dev_handle_tP7uint8_t6size_ti"></span><span id="_CPPv218i2c_master_receive23i2c_master_dev_handle_tP7uint8_t6size_ti"></span><span id="i2c_master_receive__i2c_master_dev_handle_t.uint8_tP.s.i"></span><span class="target" id="i2c__master_8h_1a05632292bb4f387725d01d8328787068"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_receive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_dev_handle_t" title="i2c_master_dev_handle_t"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_dev</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">read_buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">read_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xfer_timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418i2c_master_receive23i2c_master_dev_handle_tP7uint8_t6size_ti" title="Permalink to this definition"></a><br /></dt>
<dd><p>Perform a read transaction on the I2C bus. The transaction will be undergoing until it finishes or it reaches the timeout provided. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a callback was registered with <code class="docutils literal notranslate"><span class="pre">i2c_master_register_event_callbacks</span></code>, the transaction will be asynchronous, and thus, this function will return directly, without blocking. You will get finish information from callback. Besides, data buffer should always be completely prepared when callback is registered, otherwise, the data will get corrupt.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i2c_dev</strong> -- <strong>[in]</strong> I2C master device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_master_bus_add_device</span></code>. </p></li>
<li><p><strong>read_buffer</strong> -- <strong>[out]</strong> Data bytes received from i2c bus. </p></li>
<li><p><strong>read_size</strong> -- <strong>[in]</strong> Size, in bytes, of the read buffer. </p></li>
<li><p><strong>xfer_timeout_ms</strong> -- <strong>[in]</strong> Wait timeout, in ms. Note: -1 means wait forever. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: I2C master receive success</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C master receive parameter invalid.</p></li>
<li><p>ESP_ERR_TIMEOUT: Operation timeout(larger than xfer_timeout_ms) because the bus is busy or hardware crash. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416i2c_master_probe23i2c_master_bus_handle_t8uint16_ti">
<span id="_CPPv316i2c_master_probe23i2c_master_bus_handle_t8uint16_ti"></span><span id="_CPPv216i2c_master_probe23i2c_master_bus_handle_t8uint16_ti"></span><span id="i2c_master_probe__i2c_master_bus_handle_t.uint16_t.i"></span><span class="target" id="i2c__master_8h_1afb7141b859d576fff00ae1a9a746e31d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_probe</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_bus_handle_t" title="i2c_master_bus_handle_t"><span class="n"><span class="pre">i2c_master_bus_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bus_handle</span></span>, <span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">address</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xfer_timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416i2c_master_probe23i2c_master_bus_handle_t8uint16_ti" title="Permalink to this definition"></a><br /></dt>
<dd><p>Probe I2C address, if address is correct and ACK is received, this function will return ESP_OK. </p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>Pull-ups must be connected to the SCL and SDA pins when this function is called. If you get <code class="docutils literal notranslate"><span class="pre">ESP_ERR_TIMEOUT</span> <span class="pre">while</span></code>xfer_timeout_ms<code class="docutils literal notranslate"><span class="pre">was</span> <span class="pre">parsed</span> <span class="pre">correctly,</span> <span class="pre">you</span> <span class="pre">should</span> <span class="pre">check</span> <span class="pre">the</span> <span class="pre">pull-up</span> <span class="pre">resistors.</span> <span class="pre">If</span> <span class="pre">you</span> <span class="pre">do</span> <span class="pre">not</span> <span class="pre">have</span> <span class="pre">proper</span> <span class="pre">resistors</span> <span class="pre">nearby.</span> </code>flags.enable_internal_pullup` is also acceptable.</p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The principle of this function is to sent device address with a write command. If the device on your I2C bus, there would be an ACK signal and function returns <code class="docutils literal notranslate"><span class="pre">ESP_OK</span></code>. If the device is not on your I2C bus, there would be a NACK signal and function returns <code class="docutils literal notranslate"><span class="pre">ESP_ERR_NOT_FOUND</span></code>. <code class="docutils literal notranslate"><span class="pre">ESP_ERR_TIMEOUT</span></code> is not an expected failure, which indicated that the i2c probe not works properly, usually caused by pull-up resistors not be connected properly. Suggestion check data on SDA/SCL line to see whether there is ACK/NACK signal is on line when i2c probe function fails.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are lots of I2C devices all over the world, we assume that not all I2C device support the behavior like <code class="docutils literal notranslate"><span class="pre">device_address+nack/ack</span></code>. So, if the on line data is strange and no ack/nack got respond. Please check the device datasheet.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bus_handle</strong> -- <strong>[in]</strong> I2C master device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_master_bus_add_device</span></code>. </p></li>
<li><p><strong>address</strong> -- <strong>[in]</strong> I2C device address that you want to probe. </p></li>
<li><p><strong>xfer_timeout_ms</strong> -- <strong>[in]</strong> Wait timeout, in ms. Note: -1 means wait forever (Not recommended in this function).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: I2C device probe successfully</p></li>
<li><p>ESP_ERR_NOT_FOUND: I2C probe failed, doesn't find the device with specific address you gave.</p></li>
<li><p>ESP_ERR_TIMEOUT: Operation timeout(larger than xfer_timeout_ms) because the bus is busy or hardware crash. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv437i2c_master_execute_defined_operations23i2c_master_dev_handle_tP19i2c_operation_job_t6size_ti">
<span id="_CPPv337i2c_master_execute_defined_operations23i2c_master_dev_handle_tP19i2c_operation_job_t6size_ti"></span><span id="_CPPv237i2c_master_execute_defined_operations23i2c_master_dev_handle_tP19i2c_operation_job_t6size_ti"></span><span id="i2c_master_execute_defined_operations__i2c_master_dev_handle_t.i2c_operation_job_tP.s.i"></span><span class="target" id="i2c__master_8h_1a9475fd56c74c8ebb2a969501598ce185"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_execute_defined_operations</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_dev_handle_t" title="i2c_master_dev_handle_t"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_dev</span></span>, <a class="reference internal" href="#_CPPv419i2c_operation_job_t" title="i2c_operation_job_t"><span class="n"><span class="pre">i2c_operation_job_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">i2c_operation</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">operation_list_num</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xfer_timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv437i2c_master_execute_defined_operations23i2c_master_dev_handle_tP19i2c_operation_job_t6size_ti" title="Permalink to this definition"></a><br /></dt>
<dd><p>Execute a series of pre-defined I2C operations. </p>
<p>This function processes a list of I2C operations, such as start, write, read, and stop, according to the user-defined <code class="docutils literal notranslate"><a class="reference internal" href="#structi2c__operation__job__t"><span class="std std-ref"><span class="pre">i2c_operation_job_t</span></span></a></code> array. It performs these operations sequentially on the specified I2C master device.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ack_value</span></code> field in the READ operation must be set to <code class="docutils literal notranslate"><span class="pre">I2C_NACK_VAL</span></code> if the next operation is a STOP command. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i2c_dev</strong> -- <strong>[in]</strong> Handle to the I2C master device. </p></li>
<li><p><strong>i2c_operation</strong> -- <strong>[in]</strong> Pointer to an array of user-defined I2C operation jobs. Each job specifies a command and associated parameters. </p></li>
<li><p><strong>operation_list_num</strong> -- <strong>[in]</strong> The number of operations in the <code class="docutils literal notranslate"><span class="pre">i2c_operation</span></code> array. </p></li>
<li><p><strong>xfer_timeout_ms</strong> -- <strong>[in]</strong> Timeout for the transaction, in milliseconds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Transaction completed successfully.</p></li>
<li><p>ESP_ERR_INVALID_ARG: One or more arguments are invalid.</p></li>
<li><p>ESP_ERR_TIMEOUT: Transaction timed out.</p></li>
<li><p>ESP_FAIL: Other error during transaction.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv435i2c_master_register_event_callbacks23i2c_master_dev_handle_tPK28i2c_master_event_callbacks_tPv">
<span id="_CPPv335i2c_master_register_event_callbacks23i2c_master_dev_handle_tPK28i2c_master_event_callbacks_tPv"></span><span id="_CPPv235i2c_master_register_event_callbacks23i2c_master_dev_handle_tPK28i2c_master_event_callbacks_tPv"></span><span id="i2c_master_register_event_callbacks__i2c_master_dev_handle_t.i2c_master_event_callbacks_tCP.voidP"></span><span class="target" id="i2c__master_8h_1a6205b72a8101ae0f46a1dfb96123c8bd"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_register_event_callbacks</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_dev_handle_t" title="i2c_master_dev_handle_t"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv428i2c_master_event_callbacks_t" title="i2c_master_event_callbacks_t"><span class="n"><span class="pre">i2c_master_event_callbacks_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cbs</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">user_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435i2c_master_register_event_callbacks23i2c_master_dev_handle_tPK28i2c_master_event_callbacks_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Register I2C transaction callbacks for a master device. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>User can deregister a previously registered callback by calling this function and setting the callback member in the <code class="docutils literal notranslate"><span class="pre">cbs</span></code> structure to NULL. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_I2C_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. The variables used in the function should be in the SRAM as well. The <code class="docutils literal notranslate"><span class="pre">user_data</span></code> should also reside in SRAM. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the callback is used for helping asynchronous transaction. On the same bus, only one device can be used for performing asynchronous operation.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i2c_dev</strong> -- <strong>[in]</strong> I2C master device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_master_bus_add_device</span></code>. </p></li>
<li><p><strong>cbs</strong> -- <strong>[in]</strong> Group of callback functions </p></li>
<li><p><strong>user_data</strong> -- <strong>[in]</strong> User data, which will be passed to callback functions directly </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Set I2C transaction callbacks successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Set I2C transaction callbacks failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Set I2C transaction callbacks failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420i2c_master_bus_reset23i2c_master_bus_handle_t">
<span id="_CPPv320i2c_master_bus_reset23i2c_master_bus_handle_t"></span><span id="_CPPv220i2c_master_bus_reset23i2c_master_bus_handle_t"></span><span id="i2c_master_bus_reset__i2c_master_bus_handle_t"></span><span class="target" id="i2c__master_8h_1a61e3bf3c74d07c5d7829567379d8502b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_bus_reset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_bus_handle_t" title="i2c_master_bus_handle_t"><span class="n"><span class="pre">i2c_master_bus_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bus_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420i2c_master_bus_reset23i2c_master_bus_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reset the I2C master bus. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bus_handle</strong> -- I2C bus handle. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Reset succeed.</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C master bus handle is not initialized.</p></li>
<li><p>Otherwise: Reset failed. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428i2c_master_bus_wait_all_done23i2c_master_bus_handle_ti">
<span id="_CPPv328i2c_master_bus_wait_all_done23i2c_master_bus_handle_ti"></span><span id="_CPPv228i2c_master_bus_wait_all_done23i2c_master_bus_handle_ti"></span><span id="i2c_master_bus_wait_all_done__i2c_master_bus_handle_t.i"></span><span class="target" id="i2c__master_8h_1a473e0e3c9d5c0f3d55213fdf3eb156b6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_bus_wait_all_done</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423i2c_master_bus_handle_t" title="i2c_master_bus_handle_t"><span class="n"><span class="pre">i2c_master_bus_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bus_handle</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428i2c_master_bus_wait_all_done23i2c_master_bus_handle_ti" title="Permalink to this definition"></a><br /></dt>
<dd><p>Wait for all pending I2C transactions done. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bus_handle</strong> -- <strong>[in]</strong> I2C bus handle </p></li>
<li><p><strong>timeout_ms</strong> -- <strong>[in]</strong> Wait timeout, in ms. Specially, -1 means to wait forever. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Flush transactions successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Flush transactions failed because of invalid argument</p></li>
<li><p>ESP_ERR_TIMEOUT: Flush transactions failed because of timeout</p></li>
<li><p>ESP_FAIL: Flush transactions failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425i2c_master_get_bus_handle14i2c_port_num_tP23i2c_master_bus_handle_t">
<span id="_CPPv325i2c_master_get_bus_handle14i2c_port_num_tP23i2c_master_bus_handle_t"></span><span id="_CPPv225i2c_master_get_bus_handle14i2c_port_num_tP23i2c_master_bus_handle_t"></span><span id="i2c_master_get_bus_handle__i2c_port_num_t.i2c_master_bus_handle_tP"></span><span class="target" id="i2c__master_8h_1a3dc14ac945517027c2952b92d5503fdf"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_get_bus_handle</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414i2c_port_num_t" title="i2c_port_num_t"><span class="n"><span class="pre">i2c_port_num_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">port_num</span></span>, <a class="reference internal" href="#_CPPv423i2c_master_bus_handle_t" title="i2c_master_bus_handle_t"><span class="n"><span class="pre">i2c_master_bus_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425i2c_master_get_bus_handle14i2c_port_num_tP23i2c_master_bus_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieves the I2C master bus handle for a specified I2C port number. </p>
<p>This function retrieves the I2C master bus handle for the given I2C port number. Please make sure the handle has already been initialized, and this function would simply returns the existing handle. Note that the returned handle still can't be used concurrently</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>port_num</strong> -- I2C port number for which the handle is to be retrieved. </p></li>
<li><p><strong>ret_handle</strong> -- Pointer to a variable where the retrieved handle will be stored. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Success. The handle is retrieved successfully.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Invalid argument, such as invalid port number</p></li>
<li><p>ESP_ERR_INVALID_STATE: Invalid state, such as the I2C port is not initialized. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv423i2c_master_bus_config_t">
<span id="_CPPv323i2c_master_bus_config_t"></span><span id="_CPPv223i2c_master_bus_config_t"></span><span id="i2c_master_bus_config_t"></span><span class="target" id="structi2c__master__bus__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_bus_config_t</span></span></span><a class="headerlink" href="#_CPPv423i2c_master_bus_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C master bus specific configurations. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t8i2c_portE">
<span id="_CPPv3N23i2c_master_bus_config_t8i2c_portE"></span><span id="_CPPv2N23i2c_master_bus_config_t8i2c_portE"></span><span id="i2c_master_bus_config_t::i2c_port__i2c_port_num_t"></span><span class="target" id="structi2c__master__bus__config__t_1a888d7e6715b0d449a9c11b0a18076ff8"></span><a class="reference internal" href="#_CPPv414i2c_port_num_t" title="i2c_port_num_t"><span class="n"><span class="pre">i2c_port_num_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_port</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t8i2c_portE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C port number, <code class="docutils literal notranslate"><span class="pre">-1</span></code> for auto selecting, (not include LP I2C instance) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t10sda_io_numE">
<span id="_CPPv3N23i2c_master_bus_config_t10sda_io_numE"></span><span id="_CPPv2N23i2c_master_bus_config_t10sda_io_numE"></span><span id="i2c_master_bus_config_t::sda_io_num__gpio_num_t"></span><span class="target" id="structi2c__master__bus__config__t_1a43cc5ad9bdaae0124f04f260e8531499"></span><span class="n"><span class="pre">gpio_num_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sda_io_num</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t10sda_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO number of I2C SDA signal, pulled-up internally </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t10scl_io_numE">
<span id="_CPPv3N23i2c_master_bus_config_t10scl_io_numE"></span><span id="_CPPv2N23i2c_master_bus_config_t10scl_io_numE"></span><span id="i2c_master_bus_config_t::scl_io_num__gpio_num_t"></span><span class="target" id="structi2c__master__bus__config__t_1a206902c300f7de03d408486018dde35a"></span><span class="n"><span class="pre">gpio_num_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scl_io_num</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t10scl_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO number of I2C SCL signal, pulled-up internally </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t10clk_sourceE">
<span id="_CPPv3N23i2c_master_bus_config_t10clk_sourceE"></span><span id="_CPPv2N23i2c_master_bus_config_t10clk_sourceE"></span><span id="i2c_master_bus_config_t::clk_source__i2c_clock_source_t"></span><span class="target" id="structi2c__master__bus__config__t_1ae73ca96548db08d8ec26d4fcea932139"></span><a class="reference internal" href="#_CPPv418i2c_clock_source_t" title="i2c_clock_source_t"><span class="n"><span class="pre">i2c_clock_source_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_source</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t10clk_sourceE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Clock source of I2C master bus </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t17glitch_ignore_cntE">
<span id="_CPPv3N23i2c_master_bus_config_t17glitch_ignore_cntE"></span><span id="_CPPv2N23i2c_master_bus_config_t17glitch_ignore_cntE"></span><span id="i2c_master_bus_config_t::glitch_ignore_cnt__uint8_t"></span><span class="target" id="structi2c__master__bus__config__t_1ae90a364b7862811a55d4a38d5cd317cd"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">glitch_ignore_cnt</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t17glitch_ignore_cntE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If the glitch period on the line is less than this value, it can be filtered out, typically value is 7 (unit: I2C module clock cycle) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t13intr_priorityE">
<span id="_CPPv3N23i2c_master_bus_config_t13intr_priorityE"></span><span id="_CPPv2N23i2c_master_bus_config_t13intr_priorityE"></span><span id="i2c_master_bus_config_t::intr_priority__i"></span><span class="target" id="structi2c__master__bus__config__t_1a83fa65c6d3857f36bc58a8a8b9aaf97b"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">intr_priority</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t13intr_priorityE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C interrupt priority, if set to 0, driver will select the default priority (1,2,3). </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t17trans_queue_depthE">
<span id="_CPPv3N23i2c_master_bus_config_t17trans_queue_depthE"></span><span id="_CPPv2N23i2c_master_bus_config_t17trans_queue_depthE"></span><span id="i2c_master_bus_config_t::trans_queue_depth__s"></span><span class="target" id="structi2c__master__bus__config__t_1ab65e3b23a03e6f44bf6886b5205f85f3"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">trans_queue_depth</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t17trans_queue_depthE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Depth of internal transfer queue, increase this value can support more transfers pending in the background, only valid in asynchronous transaction. (Typically max_device_num * per_transaction) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t22enable_internal_pullupE">
<span id="_CPPv3N23i2c_master_bus_config_t22enable_internal_pullupE"></span><span id="_CPPv2N23i2c_master_bus_config_t22enable_internal_pullupE"></span><span id="i2c_master_bus_config_t::enable_internal_pullup__uint32_t"></span><span class="target" id="structi2c__master__bus__config__t_1aae8f2b32310fc1e280ffd6e72b1b555a"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">enable_internal_pullup</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t22enable_internal_pullupE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enable internal pullups. Note: This is not strong enough to pullup buses under high-speed frequency. Recommend proper external pull-up if possible </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t8allow_pdE">
<span id="_CPPv3N23i2c_master_bus_config_t8allow_pdE"></span><span id="_CPPv2N23i2c_master_bus_config_t8allow_pdE"></span><span id="i2c_master_bus_config_t::allow_pd__uint32_t"></span><span class="target" id="structi2c__master__bus__config__t_1ad39e386d6bc36299213c68a87bff89d1"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_pd</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t8allow_pdE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If set, the driver will backup/restore the I2C registers before/after entering/exist sleep mode. By this approach, the system can power off I2C's power domain. This can save power, but at the expense of more RAM being consumed </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_bus_config_t5flagsE">
<span id="_CPPv3N23i2c_master_bus_config_t5flagsE"></span><span id="_CPPv2N23i2c_master_bus_config_t5flagsE"></span><span id="i2c_master_bus_config_t::flags__i2c_master_bus_config_t"></span><span class="target" id="structi2c__master__bus__config__t_1af3bd77a0085b97354c01a49827ccc7bb"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv423i2c_master_bus_config_t" title="i2c_master_bus_config_t"><span class="n"><span class="pre">i2c_master_bus_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_bus_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C master config flags </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv419i2c_device_config_t">
<span id="_CPPv319i2c_device_config_t"></span><span id="_CPPv219i2c_device_config_t"></span><span id="i2c_device_config_t"></span><span class="target" id="structi2c__device__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_device_config_t</span></span></span><a class="headerlink" href="#_CPPv419i2c_device_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C device configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_device_config_t15dev_addr_lengthE">
<span id="_CPPv3N19i2c_device_config_t15dev_addr_lengthE"></span><span id="_CPPv2N19i2c_device_config_t15dev_addr_lengthE"></span><span id="i2c_device_config_t::dev_addr_length__i2c_addr_bit_len_t"></span><span class="target" id="structi2c__device__config__t_1a881b9d67a791354609232817d7d8aedc"></span><a class="reference internal" href="#_CPPv418i2c_addr_bit_len_t" title="i2c_addr_bit_len_t"><span class="n"><span class="pre">i2c_addr_bit_len_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dev_addr_length</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_device_config_t15dev_addr_lengthE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Select the address length of the slave device. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_device_config_t14device_addressE">
<span id="_CPPv3N19i2c_device_config_t14device_addressE"></span><span id="_CPPv2N19i2c_device_config_t14device_addressE"></span><span id="i2c_device_config_t::device_address__uint16_t"></span><span class="target" id="structi2c__device__config__t_1a61b7bedea02d57214dc1bc743c98c865"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_address</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_device_config_t14device_addressE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C device raw address. (The 7/10 bit address without read/write bit). Macro I2C_DEVICE_ADDRESS_NOT_USED (0xFFFF) stands for skip the address config inside driver. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_device_config_t12scl_speed_hzE">
<span id="_CPPv3N19i2c_device_config_t12scl_speed_hzE"></span><span id="_CPPv2N19i2c_device_config_t12scl_speed_hzE"></span><span id="i2c_device_config_t::scl_speed_hz__uint32_t"></span><span class="target" id="structi2c__device__config__t_1a2e66b72614e4934bec07a8c081eecf3e"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scl_speed_hz</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_device_config_t12scl_speed_hzE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C SCL line frequency. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_device_config_t11scl_wait_usE">
<span id="_CPPv3N19i2c_device_config_t11scl_wait_usE"></span><span id="_CPPv2N19i2c_device_config_t11scl_wait_usE"></span><span id="i2c_device_config_t::scl_wait_us__uint32_t"></span><span class="target" id="structi2c__device__config__t_1a817463d1e0b73ccc25d65e339318314c"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scl_wait_us</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_device_config_t11scl_wait_usE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Timeout value. (unit: us). Please note this value should not be so small that it can handle stretch/disturbance properly. If 0 is set, that means use the default reg value </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_device_config_t17disable_ack_checkE">
<span id="_CPPv3N19i2c_device_config_t17disable_ack_checkE"></span><span id="_CPPv2N19i2c_device_config_t17disable_ack_checkE"></span><span id="i2c_device_config_t::disable_ack_check__uint32_t"></span><span class="target" id="structi2c__device__config__t_1a258522a6694bd30c6ab6f79d35244956"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">disable_ack_check</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_device_config_t17disable_ack_checkE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Disable ACK check. If this is set false, that means ack check is enabled, the transaction will be stopped and API returns error when nack is detected. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_device_config_t5flagsE">
<span id="_CPPv3N19i2c_device_config_t5flagsE"></span><span id="_CPPv2N19i2c_device_config_t5flagsE"></span><span id="i2c_device_config_t::flags__i2c_device_config_t"></span><span class="target" id="structi2c__device__config__t_1a96b8a9b880f72b2f51ddebbf911785bc"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv419i2c_device_config_t" title="i2c_device_config_t"><span class="n"><span class="pre">i2c_device_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_device_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C device config flags </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv419i2c_operation_job_t">
<span id="_CPPv319i2c_operation_job_t"></span><span id="_CPPv219i2c_operation_job_t"></span><span id="i2c_operation_job_t"></span><span class="target" id="structi2c__operation__job__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_operation_job_t</span></span></span><a class="headerlink" href="#_CPPv419i2c_operation_job_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Structure representing an I2C operation job. </p>
<p>This structure is used to define individual I2C operations (write or read) within a sequence of I2C master transactions. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_operation_job_t7commandE">
<span id="_CPPv3N19i2c_operation_job_t7commandE"></span><span id="_CPPv2N19i2c_operation_job_t7commandE"></span><span id="i2c_operation_job_t::command__i2c_master_command_t"></span><span class="target" id="structi2c__operation__job__t_1a0b804218b6ad347757d47cc8062a68cb"></span><a class="reference internal" href="#_CPPv420i2c_master_command_t" title="i2c_master_command_t"><span class="n"><span class="pre">i2c_master_command_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">command</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_operation_job_t7commandE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C command indicating the type of operation (START, WRITE, READ, or STOP) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_operation_job_t9ack_checkE">
<span id="_CPPv3N19i2c_operation_job_t9ack_checkE"></span><span id="_CPPv2N19i2c_operation_job_t9ack_checkE"></span><span id="i2c_operation_job_t::ack_check__b"></span><span class="target" id="structi2c__operation__job__t_1afdf03b95f35076397394d4b7b017f4ad"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ack_check</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_operation_job_t9ack_checkE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Whether to enable ACK check during WRITE operation </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_operation_job_t4dataE">
<span id="_CPPv3N19i2c_operation_job_t4dataE"></span><span id="_CPPv2N19i2c_operation_job_t4dataE"></span><span id="i2c_operation_job_t::data__uint8_tP"></span><span class="target" id="structi2c__operation__job__t_1a59a347e40efbfb8972f4b5d50fe512b6"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">data</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_operation_job_t4dataE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to the data to be written</p>
<p>Pointer to the buffer for storing the data read from the bus </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_operation_job_t11total_bytesE">
<span id="_CPPv3N19i2c_operation_job_t11total_bytesE"></span><span id="_CPPv2N19i2c_operation_job_t11total_bytesE"></span><span id="i2c_operation_job_t::total_bytes__s"></span><span class="target" id="structi2c__operation__job__t_1a25857b027b821c2a359c86f298f0d63e"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">total_bytes</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_operation_job_t11total_bytesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Total number of bytes to write</p>
<p>Total number of bytes to read </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_operation_job_t5writeE">
<span id="_CPPv3N19i2c_operation_job_t5writeE"></span><span id="_CPPv2N19i2c_operation_job_t5writeE"></span><span id="i2c_operation_job_t::write__i2c_operation_job_t"></span><span class="target" id="structi2c__operation__job__t_1a51fb117ea7fb560732cad12a3f4b0539"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv419i2c_operation_job_t" title="i2c_operation_job_t"><span class="n"><span class="pre">i2c_operation_job_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">write</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_operation_job_t5writeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Structure for WRITE command. </p>
<p>Used when the <code class="docutils literal notranslate"><span class="pre">command</span></code> is set to <code class="docutils literal notranslate"><span class="pre">I2C_MASTER_CMD_WRITE</span></code>. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_operation_job_t9ack_valueE">
<span id="_CPPv3N19i2c_operation_job_t9ack_valueE"></span><span id="_CPPv2N19i2c_operation_job_t9ack_valueE"></span><span id="i2c_operation_job_t::ack_value__i2c_ack_value_t"></span><span class="target" id="structi2c__operation__job__t_1a46bb2706af4194cb4624d8bb9142c84d"></span><a class="reference internal" href="#_CPPv415i2c_ack_value_t" title="i2c_ack_value_t"><span class="n"><span class="pre">i2c_ack_value_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ack_value</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_operation_job_t9ack_valueE" title="Permalink to this definition"></a><br /></dt>
<dd><p>ACK value to send after the read (ACK or NACK) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_operation_job_t4readE">
<span id="_CPPv3N19i2c_operation_job_t4readE"></span><span id="_CPPv2N19i2c_operation_job_t4readE"></span><span id="i2c_operation_job_t::read__i2c_operation_job_t"></span><span class="target" id="structi2c__operation__job__t_1a187c980741efef54316a84c32c7afbfb"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv419i2c_operation_job_t" title="i2c_operation_job_t"><span class="n"><span class="pre">i2c_operation_job_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">read</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_operation_job_t4readE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Structure for READ command. </p>
<p>Used when the <code class="docutils literal notranslate"><span class="pre">command</span></code> is set to <code class="docutils literal notranslate"><span class="pre">I2C_MASTER_CMD_READ</span></code>. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv439i2c_master_transmit_multi_buffer_info_t">
<span id="_CPPv339i2c_master_transmit_multi_buffer_info_t"></span><span id="_CPPv239i2c_master_transmit_multi_buffer_info_t"></span><span id="i2c_master_transmit_multi_buffer_info_t"></span><span class="target" id="structi2c__master__transmit__multi__buffer__info__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_transmit_multi_buffer_info_t</span></span></span><a class="headerlink" href="#_CPPv439i2c_master_transmit_multi_buffer_info_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C master transmit buffer information structure. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N39i2c_master_transmit_multi_buffer_info_t12write_bufferE">
<span id="_CPPv3N39i2c_master_transmit_multi_buffer_info_t12write_bufferE"></span><span id="_CPPv2N39i2c_master_transmit_multi_buffer_info_t12write_bufferE"></span><span id="i2c_master_transmit_multi_buffer_info_t::write_buffer__uint8_tP"></span><span class="target" id="structi2c__master__transmit__multi__buffer__info__t_1a890bd07c4bb781ff604e48e6e7cb224e"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">write_buffer</span></span></span><a class="headerlink" href="#_CPPv4N39i2c_master_transmit_multi_buffer_info_t12write_bufferE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to buffer to be written. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N39i2c_master_transmit_multi_buffer_info_t11buffer_sizeE">
<span id="_CPPv3N39i2c_master_transmit_multi_buffer_info_t11buffer_sizeE"></span><span id="_CPPv2N39i2c_master_transmit_multi_buffer_info_t11buffer_sizeE"></span><span id="i2c_master_transmit_multi_buffer_info_t::buffer_size__s"></span><span class="target" id="structi2c__master__transmit__multi__buffer__info__t_1a742dea21fc7e34856ee2b2e76d84d06a"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">buffer_size</span></span></span><a class="headerlink" href="#_CPPv4N39i2c_master_transmit_multi_buffer_info_t11buffer_sizeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size of data to be written. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv428i2c_master_event_callbacks_t">
<span id="_CPPv328i2c_master_event_callbacks_t"></span><span id="_CPPv228i2c_master_event_callbacks_t"></span><span id="i2c_master_event_callbacks_t"></span><span class="target" id="structi2c__master__event__callbacks__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_event_callbacks_t</span></span></span><a class="headerlink" href="#_CPPv428i2c_master_event_callbacks_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Group of I2C master callbacks, can be used to get status during transaction or doing other small things. But take care potential concurrency issues. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The callbacks are all running under ISR context </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_I2C_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. The variables used in the function should be in the SRAM as well. </p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N28i2c_master_event_callbacks_t13on_trans_doneE">
<span id="_CPPv3N28i2c_master_event_callbacks_t13on_trans_doneE"></span><span id="_CPPv2N28i2c_master_event_callbacks_t13on_trans_doneE"></span><span id="i2c_master_event_callbacks_t::on_trans_done__i2c_master_callback_t"></span><span class="target" id="structi2c__master__event__callbacks__t_1a4cb686f762ab9744939d35a2aab2c1ff"></span><a class="reference internal" href="#_CPPv421i2c_master_callback_t" title="i2c_master_callback_t"><span class="n"><span class="pre">i2c_master_callback_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">on_trans_done</span></span></span><a class="headerlink" href="#_CPPv4N28i2c_master_event_callbacks_t13on_trans_doneE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C master transaction finish callback </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.I2C_DEVICE_ADDRESS_NOT_USED">
<span class="target" id="i2c__master_8h_1a01df8b1b7cf96e609dc11950a99a2f9e"></span><span class="sig-name descname"><span class="n"><span class="pre">I2C_DEVICE_ADDRESS_NOT_USED</span></span></span><a class="headerlink" href="#c.I2C_DEVICE_ADDRESS_NOT_USED" title="Permalink to this definition"></a><br /></dt>
<dd><p>Skip carry address bit in driver transmit and receive </p>
</dd></dl>

</section>
<section id="id1">
<h3>Header File<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_i2c/include/driver/i2c_slave.h">components/esp_driver_i2c/include/driver/i2c_slave.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/i2c_slave.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_i2c</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_i2c</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_i2c
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_i2c
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id2">
<h3>Functions<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417i2c_slave_receive22i2c_slave_dev_handle_tP7uint8_t6size_t">
<span id="_CPPv317i2c_slave_receive22i2c_slave_dev_handle_tP7uint8_t6size_t"></span><span id="_CPPv217i2c_slave_receive22i2c_slave_dev_handle_tP7uint8_t6size_t"></span><span id="i2c_slave_receive__i2c_slave_dev_handle_t.uint8_tP.s"></span><span class="target" id="i2c__slave_8h_1aae93439a7e311d04752cba17bc1f0ee2"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_receive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422i2c_slave_dev_handle_t" title="i2c_slave_dev_handle_t"><span class="n"><span class="pre">i2c_slave_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_slave</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">data</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">buffer_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417i2c_slave_receive22i2c_slave_dev_handle_tP7uint8_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Read bytes from I2C internal buffer. Start a job to receive I2C data. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is non-blocking, it initiates a new receive job and then returns. User should check the received data from the <code class="docutils literal notranslate"><span class="pre">on_recv_done</span></code> callback that registered by <code class="docutils literal notranslate"><span class="pre">i2c_slave_register_event_callbacks()</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i2c_slave</strong> -- <strong>[in]</strong> I2C slave device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_new_slave_device</span></code>. </p></li>
<li><p><strong>data</strong> -- <strong>[out]</strong> Buffer to store data from I2C fifo. Should be valid until <code class="docutils literal notranslate"><span class="pre">on_recv_done</span></code> is triggered. </p></li>
<li><p><strong>buffer_size</strong> -- <strong>[in]</strong> Buffer size of data that provided by users. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: I2C slave receive success.</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C slave receive parameter invalid.</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED: This function should be work in fifo mode, but I2C_SLAVE_NONFIFO mode is configured </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418i2c_slave_transmit22i2c_slave_dev_handle_tPK7uint8_tii">
<span id="_CPPv318i2c_slave_transmit22i2c_slave_dev_handle_tPK7uint8_tii"></span><span id="_CPPv218i2c_slave_transmit22i2c_slave_dev_handle_tPK7uint8_tii"></span><span id="i2c_slave_transmit__i2c_slave_dev_handle_t.uint8_tCP.i.i"></span><span class="target" id="i2c__slave_8h_1a8533c9d659600c4996784c561893c2e3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_transmit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422i2c_slave_dev_handle_t" title="i2c_slave_dev_handle_t"><span class="n"><span class="pre">i2c_slave_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_slave</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xfer_timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418i2c_slave_transmit22i2c_slave_dev_handle_tPK7uint8_tii" title="Permalink to this definition"></a><br /></dt>
<dd><p>Write bytes to internal ringbuffer of the I2C slave data. When the TX fifo empty, the ISR will fill the hardware FIFO with the internal ringbuffer's data. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you connect this slave device to some master device, the data transaction direction is from slave device to master device.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i2c_slave</strong> -- <strong>[in]</strong> I2C slave device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_new_slave_device</span></code>. </p></li>
<li><p><strong>data</strong> -- <strong>[in]</strong> Buffer to write to slave fifo, can pickup by master. Can be freed after this function returns. Equal or larger than <code class="docutils literal notranslate"><span class="pre">size</span></code>. </p></li>
<li><p><strong>size</strong> -- <strong>[in]</strong> In bytes, of <code class="docutils literal notranslate"><span class="pre">data</span></code> buffer. </p></li>
<li><p><strong>xfer_timeout_ms</strong> -- <strong>[in]</strong> Wait timeout, in ms. Note: -1 means wait forever. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: I2C slave transmit success.</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C slave transmit parameter invalid.</p></li>
<li><p>ESP_ERR_TIMEOUT: Operation timeout(larger than xfer_timeout_ms) because the device is busy or hardware crash.</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED: This function should be work in fifo mode, but I2C_SLAVE_NONFIFO mode is configured </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420i2c_new_slave_devicePK18i2c_slave_config_tP22i2c_slave_dev_handle_t">
<span id="_CPPv320i2c_new_slave_devicePK18i2c_slave_config_tP22i2c_slave_dev_handle_t"></span><span id="_CPPv220i2c_new_slave_devicePK18i2c_slave_config_tP22i2c_slave_dev_handle_t"></span><span id="i2c_new_slave_device__i2c_slave_config_tCP.i2c_slave_dev_handle_tP"></span><span class="target" id="i2c__slave_8h_1aa9633318ae5fbc19687ace90e949a21c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_new_slave_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv418i2c_slave_config_t" title="i2c_slave_config_t"><span class="n"><span class="pre">i2c_slave_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">slave_config</span></span>, <a class="reference internal" href="#_CPPv422i2c_slave_dev_handle_t" title="i2c_slave_dev_handle_t"><span class="n"><span class="pre">i2c_slave_dev_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420i2c_new_slave_devicePK18i2c_slave_config_tP22i2c_slave_dev_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize an I2C slave device. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slave_config</strong> -- <strong>[in]</strong> I2C slave device configurations </p></li>
<li><p><strong>ret_handle</strong> -- <strong>[out]</strong> Return a generic I2C device handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: I2C slave device initialized successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C device initialization failed because of invalid argument.</p></li>
<li><p>ESP_ERR_NO_MEM: Create I2C device failed because of out of memory. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv434i2c_slave_register_event_callbacks22i2c_slave_dev_handle_tPK27i2c_slave_event_callbacks_tPv">
<span id="_CPPv334i2c_slave_register_event_callbacks22i2c_slave_dev_handle_tPK27i2c_slave_event_callbacks_tPv"></span><span id="_CPPv234i2c_slave_register_event_callbacks22i2c_slave_dev_handle_tPK27i2c_slave_event_callbacks_tPv"></span><span id="i2c_slave_register_event_callbacks__i2c_slave_dev_handle_t.i2c_slave_event_callbacks_tCP.voidP"></span><span class="target" id="i2c__slave_8h_1a66f466c0835c926ec2a9f4aa69b42f9b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_register_event_callbacks</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422i2c_slave_dev_handle_t" title="i2c_slave_dev_handle_t"><span class="n"><span class="pre">i2c_slave_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_slave</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv427i2c_slave_event_callbacks_t" title="i2c_slave_event_callbacks_t"><span class="n"><span class="pre">i2c_slave_event_callbacks_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cbs</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">user_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434i2c_slave_register_event_callbacks22i2c_slave_dev_handle_tPK27i2c_slave_event_callbacks_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set I2C slave event callbacks for I2C slave channel. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>User can deregister a previously registered callback by calling this function and setting the callback member in the <code class="docutils literal notranslate"><span class="pre">cbs</span></code> structure to NULL. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_I2C_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. The variables used in the function should be in the SRAM as well. The <code class="docutils literal notranslate"><span class="pre">user_data</span></code> should also reside in SRAM.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i2c_slave</strong> -- <strong>[in]</strong> I2C slave device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_new_slave_device</span></code>. </p></li>
<li><p><strong>cbs</strong> -- <strong>[in]</strong> Group of callback functions </p></li>
<li><p><strong>user_data</strong> -- <strong>[in]</strong> User data, which will be passed to callback functions directly </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Set I2C transaction callbacks successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Set I2C transaction callbacks failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Set I2C transaction callbacks failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420i2c_del_slave_device22i2c_slave_dev_handle_t">
<span id="_CPPv320i2c_del_slave_device22i2c_slave_dev_handle_t"></span><span id="_CPPv220i2c_del_slave_device22i2c_slave_dev_handle_t"></span><span id="i2c_del_slave_device__i2c_slave_dev_handle_t"></span><span class="target" id="i2c__slave_8h_1ad624bb3e3b1c67cce9140ccd78d67808"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_del_slave_device</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422i2c_slave_dev_handle_t" title="i2c_slave_dev_handle_t"><span class="n"><span class="pre">i2c_slave_dev_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">i2c_slave</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420i2c_del_slave_device22i2c_slave_dev_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deinitialize the I2C slave device. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>i2c_slave</strong> -- <strong>[in]</strong> I2C slave device handle that created by <code class="docutils literal notranslate"><span class="pre">i2c_new_slave_device</span></code>. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Delete I2C device successfully.</p></li>
<li><p>ESP_ERR_INVALID_ARG: I2C device initialization failed because of invalid argument. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id3">
<h3>Structures<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv418i2c_slave_config_t">
<span id="_CPPv318i2c_slave_config_t"></span><span id="_CPPv218i2c_slave_config_t"></span><span id="i2c_slave_config_t"></span><span class="target" id="structi2c__slave__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_config_t</span></span></span><a class="headerlink" href="#_CPPv418i2c_slave_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C slave specific configurations. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t8i2c_portE">
<span id="_CPPv3N18i2c_slave_config_t8i2c_portE"></span><span id="_CPPv2N18i2c_slave_config_t8i2c_portE"></span><span id="i2c_slave_config_t::i2c_port__i2c_port_num_t"></span><span class="target" id="structi2c__slave__config__t_1ae53ab2aa9e3e7dea1658c323fe21264c"></span><a class="reference internal" href="#_CPPv414i2c_port_num_t" title="i2c_port_num_t"><span class="n"><span class="pre">i2c_port_num_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_port</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t8i2c_portE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C port number, <code class="docutils literal notranslate"><span class="pre">-1</span></code> for auto selecting </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t10sda_io_numE">
<span id="_CPPv3N18i2c_slave_config_t10sda_io_numE"></span><span id="_CPPv2N18i2c_slave_config_t10sda_io_numE"></span><span id="i2c_slave_config_t::sda_io_num__gpio_num_t"></span><span class="target" id="structi2c__slave__config__t_1ad888942037fa7aefc5dae02f91094569"></span><span class="n"><span class="pre">gpio_num_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sda_io_num</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t10sda_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>SDA IO number used by I2C bus </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t10scl_io_numE">
<span id="_CPPv3N18i2c_slave_config_t10scl_io_numE"></span><span id="_CPPv2N18i2c_slave_config_t10scl_io_numE"></span><span id="i2c_slave_config_t::scl_io_num__gpio_num_t"></span><span class="target" id="structi2c__slave__config__t_1a816ce118e9225ed27d2d192dbdc5e140"></span><span class="n"><span class="pre">gpio_num_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scl_io_num</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t10scl_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>SCL IO number used by I2C bus </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t10clk_sourceE">
<span id="_CPPv3N18i2c_slave_config_t10clk_sourceE"></span><span id="_CPPv2N18i2c_slave_config_t10clk_sourceE"></span><span id="i2c_slave_config_t::clk_source__i2c_clock_source_t"></span><span class="target" id="structi2c__slave__config__t_1aaaa2f42a037feba2743f177fb57ff08f"></span><a class="reference internal" href="#_CPPv418i2c_clock_source_t" title="i2c_clock_source_t"><span class="n"><span class="pre">i2c_clock_source_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_source</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t10clk_sourceE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Clock source of I2C bus. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t14send_buf_depthE">
<span id="_CPPv3N18i2c_slave_config_t14send_buf_depthE"></span><span id="_CPPv2N18i2c_slave_config_t14send_buf_depthE"></span><span id="i2c_slave_config_t::send_buf_depth__uint32_t"></span><span class="target" id="structi2c__slave__config__t_1aece081cc795237258b833df8d1144e64"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">send_buf_depth</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t14send_buf_depthE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Depth of internal transfer ringbuffer, increase this value can support more transfers pending in the background </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t10slave_addrE">
<span id="_CPPv3N18i2c_slave_config_t10slave_addrE"></span><span id="_CPPv2N18i2c_slave_config_t10slave_addrE"></span><span id="i2c_slave_config_t::slave_addr__uint16_t"></span><span class="target" id="structi2c__slave__config__t_1ac510e3ef3426a3a1a33d8913f2e3e0b1"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">slave_addr</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t10slave_addrE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C slave address </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t12addr_bit_lenE">
<span id="_CPPv3N18i2c_slave_config_t12addr_bit_lenE"></span><span id="_CPPv2N18i2c_slave_config_t12addr_bit_lenE"></span><span id="i2c_slave_config_t::addr_bit_len__i2c_addr_bit_len_t"></span><span class="target" id="structi2c__slave__config__t_1ab1444cfb1d3661867de949b0fef486e8"></span><a class="reference internal" href="#_CPPv418i2c_addr_bit_len_t" title="i2c_addr_bit_len_t"><span class="n"><span class="pre">i2c_addr_bit_len_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">addr_bit_len</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t12addr_bit_lenE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C slave address in bit length </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t13intr_priorityE">
<span id="_CPPv3N18i2c_slave_config_t13intr_priorityE"></span><span id="_CPPv2N18i2c_slave_config_t13intr_priorityE"></span><span id="i2c_slave_config_t::intr_priority__i"></span><span class="target" id="structi2c__slave__config__t_1a4c75c50fbc8920534cdccd294501b418"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">intr_priority</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t13intr_priorityE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C interrupt priority, if set to 0, driver will select the default priority (1,2,3). </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t8allow_pdE">
<span id="_CPPv3N18i2c_slave_config_t8allow_pdE"></span><span id="_CPPv2N18i2c_slave_config_t8allow_pdE"></span><span id="i2c_slave_config_t::allow_pd__uint32_t"></span><span class="target" id="structi2c__slave__config__t_1a2e3e301b3090251a2679c7c514ddae50"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_pd</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t8allow_pdE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If set, the driver will backup/restore the I2C registers before/after entering/exist sleep mode. By this approach, the system can power off I2C's power domain. This can save power, but at the expense of more RAM being consumed </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_slave_config_t5flagsE">
<span id="_CPPv3N18i2c_slave_config_t5flagsE"></span><span id="_CPPv2N18i2c_slave_config_t5flagsE"></span><span id="i2c_slave_config_t::flags__i2c_slave_config_t"></span><span class="target" id="structi2c__slave__config__t_1af747fc33843f81f5e32cd4bec3aef474"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv418i2c_slave_config_t" title="i2c_slave_config_t"><span class="n"><span class="pre">i2c_slave_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_slave_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C slave config flags </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv427i2c_slave_event_callbacks_t">
<span id="_CPPv327i2c_slave_event_callbacks_t"></span><span id="_CPPv227i2c_slave_event_callbacks_t"></span><span id="i2c_slave_event_callbacks_t"></span><span class="target" id="structi2c__slave__event__callbacks__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_event_callbacks_t</span></span></span><a class="headerlink" href="#_CPPv427i2c_slave_event_callbacks_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Group of I2C slave callbacks (e.g. get i2c slave stretch cause). But take care of potential concurrency issues. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The callbacks are all running under ISR context </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_I2C_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. The variables used in the function should be in the SRAM as well. </p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N27i2c_slave_event_callbacks_t12on_recv_doneE">
<span id="_CPPv3N27i2c_slave_event_callbacks_t12on_recv_doneE"></span><span id="_CPPv2N27i2c_slave_event_callbacks_t12on_recv_doneE"></span><span id="i2c_slave_event_callbacks_t::on_recv_done__i2c_slave_received_callback_t"></span><span class="target" id="structi2c__slave__event__callbacks__t_1a0771d60985bc48fe38489d802821659a"></span><a class="reference internal" href="#_CPPv429i2c_slave_received_callback_t" title="i2c_slave_received_callback_t"><span class="n"><span class="pre">i2c_slave_received_callback_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">on_recv_done</span></span></span><a class="headerlink" href="#_CPPv4N27i2c_slave_event_callbacks_t12on_recv_doneE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C slave receive done callback </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id4">
<h3>Header File<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_i2c/include/driver/i2c_types.h">components/esp_driver_i2c/include/driver/i2c_types.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/i2c_types.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_i2c</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_i2c</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_i2c
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_i2c
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id5">
<h3>Structures<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv423i2c_master_event_data_t">
<span id="_CPPv323i2c_master_event_data_t"></span><span id="_CPPv223i2c_master_event_data_t"></span><span id="i2c_master_event_data_t"></span><span class="target" id="structi2c__master__event__data__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_event_data_t</span></span></span><a class="headerlink" href="#_CPPv423i2c_master_event_data_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Data type used in I2C event callback. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23i2c_master_event_data_t5eventE">
<span id="_CPPv3N23i2c_master_event_data_t5eventE"></span><span id="_CPPv2N23i2c_master_event_data_t5eventE"></span><span id="i2c_master_event_data_t::event__i2c_master_event_t"></span><span class="target" id="structi2c__master__event__data__t_1ae569d86623eaafbf5c7b51b21bd27edc"></span><a class="reference internal" href="#_CPPv418i2c_master_event_t" title="i2c_master_event_t"><span class="n"><span class="pre">i2c_master_event_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">event</span></span></span><a class="headerlink" href="#_CPPv4N23i2c_master_event_data_t5eventE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The I2C hardware event that I2C callback is called. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv430i2c_slave_rx_done_event_data_t">
<span id="_CPPv330i2c_slave_rx_done_event_data_t"></span><span id="_CPPv230i2c_slave_rx_done_event_data_t"></span><span id="i2c_slave_rx_done_event_data_t"></span><span class="target" id="structi2c__slave__rx__done__event__data__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_rx_done_event_data_t</span></span></span><a class="headerlink" href="#_CPPv430i2c_slave_rx_done_event_data_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Event structure used in I2C slave. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N30i2c_slave_rx_done_event_data_t6bufferE">
<span id="_CPPv3N30i2c_slave_rx_done_event_data_t6bufferE"></span><span id="_CPPv2N30i2c_slave_rx_done_event_data_t6bufferE"></span><span id="i2c_slave_rx_done_event_data_t::buffer__uint8_tP"></span><span class="target" id="structi2c__slave__rx__done__event__data__t_1a6dd5f457bac5b190cf7e438dedf753b6"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">buffer</span></span></span><a class="headerlink" href="#_CPPv4N30i2c_slave_rx_done_event_data_t6bufferE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer for buffer received in callback. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv430i2c_slave_request_event_data_t">
<span id="_CPPv330i2c_slave_request_event_data_t"></span><span id="_CPPv230i2c_slave_request_event_data_t"></span><span id="i2c_slave_request_event_data_t"></span><span class="target" id="structi2c__slave__request__event__data__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_request_event_data_t</span></span></span><a class="headerlink" href="#_CPPv430i2c_slave_request_event_data_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Event structure used in I2C slave request. </p>
</dd></dl>

</section>
<section id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv414i2c_port_num_t">
<span id="_CPPv314i2c_port_num_t"></span><span id="_CPPv214i2c_port_num_t"></span><span id="i2c_port_num_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a22813704953ee764016d446ae08dda65"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_port_num_t</span></span></span><a class="headerlink" href="#_CPPv414i2c_port_num_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C port number. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv423i2c_master_bus_handle_t">
<span id="_CPPv323i2c_master_bus_handle_t"></span><span id="_CPPv223i2c_master_bus_handle_t"></span><span id="i2c_master_bus_handle_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a3e24ff4054f94697f977f23edc643335"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">i2c_master_bus_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_bus_handle_t</span></span></span><a class="headerlink" href="#_CPPv423i2c_master_bus_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of I2C master bus handle. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv423i2c_master_dev_handle_t">
<span id="_CPPv323i2c_master_dev_handle_t"></span><span id="_CPPv223i2c_master_dev_handle_t"></span><span id="i2c_master_dev_handle_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a4b7ecffb54a9053c65555e4dbc54ffe8"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">i2c_master_dev_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></span><a class="headerlink" href="#_CPPv423i2c_master_dev_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of I2C master bus device handle. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv422i2c_slave_dev_handle_t">
<span id="_CPPv322i2c_slave_dev_handle_t"></span><span id="_CPPv222i2c_slave_dev_handle_t"></span><span id="i2c_slave_dev_handle_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a803ce5c0bc7c6133d7906447a3471931"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">i2c_slave_dev_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_dev_handle_t</span></span></span><a class="headerlink" href="#_CPPv422i2c_slave_dev_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of I2C slave device handle. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv421i2c_master_callback_t">
<span id="_CPPv321i2c_master_callback_t"></span><span id="_CPPv221i2c_master_callback_t"></span><span id="i2c_master_callback_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a3748022ec7a6f521b1f5a750a03c7fe3"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_callback_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv423i2c_master_dev_handle_t" title="i2c_master_dev_handle_t"><span class="n"><span class="pre">i2c_master_dev_handle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">i2c_dev</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv423i2c_master_event_data_t" title="i2c_master_event_data_t"><span class="n"><span class="pre">i2c_master_event_data_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">evt_data</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv421i2c_master_callback_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>An callback for I2C transaction. </p>
<dl class="field-list simple">
<dt class="field-odd">Param i2c_dev<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> Handle for I2C device. </p>
</dd>
<dt class="field-even">Param evt_data<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[out]</strong> I2C capture event data, fed by driver </p>
</dd>
<dt class="field-odd">Param arg<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> User data, set in <code class="docutils literal notranslate"><span class="pre">i2c_master_register_event_callbacks()</span></code></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether a high priority task has been waken up by this function </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv429i2c_slave_received_callback_t">
<span id="_CPPv329i2c_slave_received_callback_t"></span><span id="_CPPv229i2c_slave_received_callback_t"></span><span id="i2c_slave_received_callback_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1ae3e1960fd5a6179130a15ebd34ce4a12"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_received_callback_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv422i2c_slave_dev_handle_t" title="i2c_slave_dev_handle_t"><span class="n"><span class="pre">i2c_slave_dev_handle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">i2c_slave</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv430i2c_slave_rx_done_event_data_t" title="i2c_slave_rx_done_event_data_t"><span class="n"><span class="pre">i2c_slave_rx_done_event_data_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">evt_data</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv429i2c_slave_received_callback_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback signature for I2C slave. </p>
<dl class="field-list simple">
<dt class="field-odd">Param i2c_slave<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> Handle for I2C slave. </p>
</dd>
<dt class="field-even">Param evt_data<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[out]</strong> I2C capture event data, fed by driver </p>
</dd>
<dt class="field-odd">Param arg<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> User data, set in <code class="docutils literal notranslate"><span class="pre">i2c_slave_register_event_callbacks()</span></code></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether a high priority task has been waken up by this function </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv428i2c_slave_request_callback_t">
<span id="_CPPv328i2c_slave_request_callback_t"></span><span id="_CPPv228i2c_slave_request_callback_t"></span><span id="i2c_slave_request_callback_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a4d46f6a4b2301a7383fbd7ca90338ac6"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_request_callback_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv422i2c_slave_dev_handle_t" title="i2c_slave_dev_handle_t"><span class="n"><span class="pre">i2c_slave_dev_handle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">i2c_slave</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv430i2c_slave_request_event_data_t" title="i2c_slave_request_event_data_t"><span class="n"><span class="pre">i2c_slave_request_event_data_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">evt_data</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv428i2c_slave_request_callback_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback signature for I2C slave request event. When this callback is triggered that means master want to read data from slave while there is no data in slave fifo. So user should write data to fifo via <code class="docutils literal notranslate"><span class="pre">i2c_slave_write</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Param i2c_slave<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> Handle for I2C slave. </p>
</dd>
<dt class="field-even">Param evt_data<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[out]</strong> I2C receive event data, fed by driver </p>
</dd>
<dt class="field-odd">Param arg<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> User data, set in <code class="docutils literal notranslate"><span class="pre">i2c_slave_register_event_callbacks()</span></code></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether a high priority task has been waken up by this function </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv419i2c_master_status_t">
<span id="_CPPv319i2c_master_status_t"></span><span id="_CPPv219i2c_master_status_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a83a9d4c48cecd529889ee2d488102b04"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_status_t</span></span></span><a class="headerlink" href="#_CPPv419i2c_master_status_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enumeration for I2C fsm status. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_master_status_t15I2C_STATUS_READE">
<span id="_CPPv3N19i2c_master_status_t15I2C_STATUS_READE"></span><span id="_CPPv2N19i2c_master_status_t15I2C_STATUS_READE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a83a9d4c48cecd529889ee2d488102b04ad1890085fd53c0369e8c0c318ca988c8"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_STATUS_READ</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_master_status_t15I2C_STATUS_READE" title="Permalink to this definition"></a><br /></dt>
<dd><p>read status for current master command </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_master_status_t16I2C_STATUS_WRITEE">
<span id="_CPPv3N19i2c_master_status_t16I2C_STATUS_WRITEE"></span><span id="_CPPv2N19i2c_master_status_t16I2C_STATUS_WRITEE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a83a9d4c48cecd529889ee2d488102b04a722b840c58132798b4830fad7edba364"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_STATUS_WRITE</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_master_status_t16I2C_STATUS_WRITEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>write status for current master command </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_master_status_t16I2C_STATUS_STARTE">
<span id="_CPPv3N19i2c_master_status_t16I2C_STATUS_STARTE"></span><span id="_CPPv2N19i2c_master_status_t16I2C_STATUS_STARTE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a83a9d4c48cecd529889ee2d488102b04a23ad2f6161cb227dce545c2b4c2c7f63"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_STATUS_START</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_master_status_t16I2C_STATUS_STARTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Start status for current master command </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_master_status_t15I2C_STATUS_STOPE">
<span id="_CPPv3N19i2c_master_status_t15I2C_STATUS_STOPE"></span><span id="_CPPv2N19i2c_master_status_t15I2C_STATUS_STOPE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a83a9d4c48cecd529889ee2d488102b04a82b0542f34821950b31957dcd91fb4e2"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_STATUS_STOP</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_master_status_t15I2C_STATUS_STOPE" title="Permalink to this definition"></a><br /></dt>
<dd><p>stop status for current master command </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_master_status_t15I2C_STATUS_IDLEE">
<span id="_CPPv3N19i2c_master_status_t15I2C_STATUS_IDLEE"></span><span id="_CPPv2N19i2c_master_status_t15I2C_STATUS_IDLEE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a83a9d4c48cecd529889ee2d488102b04add17c078b02e52d37b0cbd47ae09ab40"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_STATUS_IDLE</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_master_status_t15I2C_STATUS_IDLEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>idle status for current master command </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_master_status_t20I2C_STATUS_ACK_ERRORE">
<span id="_CPPv3N19i2c_master_status_t20I2C_STATUS_ACK_ERRORE"></span><span id="_CPPv2N19i2c_master_status_t20I2C_STATUS_ACK_ERRORE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a83a9d4c48cecd529889ee2d488102b04a7aaf7a3643477f83afa56dd2d9689aed"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_STATUS_ACK_ERROR</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_master_status_t20I2C_STATUS_ACK_ERRORE" title="Permalink to this definition"></a><br /></dt>
<dd><p>ack error status for current master command </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_master_status_t15I2C_STATUS_DONEE">
<span id="_CPPv3N19i2c_master_status_t15I2C_STATUS_DONEE"></span><span id="_CPPv2N19i2c_master_status_t15I2C_STATUS_DONEE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a83a9d4c48cecd529889ee2d488102b04a9f5024a35710b260041d351d794afa9a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_STATUS_DONE</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_master_status_t15I2C_STATUS_DONEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C command done </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19i2c_master_status_t18I2C_STATUS_TIMEOUTE">
<span id="_CPPv3N19i2c_master_status_t18I2C_STATUS_TIMEOUTE"></span><span id="_CPPv2N19i2c_master_status_t18I2C_STATUS_TIMEOUTE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a83a9d4c48cecd529889ee2d488102b04a78c887643d2970d4667641cf7bf81790"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_STATUS_TIMEOUT</span></span></span><a class="headerlink" href="#_CPPv4N19i2c_master_status_t18I2C_STATUS_TIMEOUTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C bus status error, and operation timeout </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv418i2c_master_event_t">
<span id="_CPPv318i2c_master_event_t"></span><span id="_CPPv218i2c_master_event_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a515f0c8b583f8851ce4d6474168769af"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_event_t</span></span></span><a class="headerlink" href="#_CPPv418i2c_master_event_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enumeration for I2C event. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_master_event_t15I2C_EVENT_ALIVEE">
<span id="_CPPv3N18i2c_master_event_t15I2C_EVENT_ALIVEE"></span><span id="_CPPv2N18i2c_master_event_t15I2C_EVENT_ALIVEE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a515f0c8b583f8851ce4d6474168769afaaafc9945c3b6ff0ab54820d61a54cc25"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_EVENT_ALIVE</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_master_event_t15I2C_EVENT_ALIVEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>i2c bus in alive status. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_master_event_t14I2C_EVENT_DONEE">
<span id="_CPPv3N18i2c_master_event_t14I2C_EVENT_DONEE"></span><span id="_CPPv2N18i2c_master_event_t14I2C_EVENT_DONEE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a515f0c8b583f8851ce4d6474168769afa43d00f7d92100d4af6df5514e4ccf1d1"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_EVENT_DONE</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_master_event_t14I2C_EVENT_DONEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>i2c bus transaction done </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_master_event_t14I2C_EVENT_NACKE">
<span id="_CPPv3N18i2c_master_event_t14I2C_EVENT_NACKE"></span><span id="_CPPv2N18i2c_master_event_t14I2C_EVENT_NACKE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a515f0c8b583f8851ce4d6474168769afad5903fb98a5310653faddca089e195bf"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_EVENT_NACK</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_master_event_t14I2C_EVENT_NACKE" title="Permalink to this definition"></a><br /></dt>
<dd><p>i2c bus nack </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_master_event_t17I2C_EVENT_TIMEOUTE">
<span id="_CPPv3N18i2c_master_event_t17I2C_EVENT_TIMEOUTE"></span><span id="_CPPv2N18i2c_master_event_t17I2C_EVENT_TIMEOUTE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a515f0c8b583f8851ce4d6474168769afa299f1238cd89e2b485cbebc15db1b874"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_EVENT_TIMEOUT</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_master_event_t17I2C_EVENT_TIMEOUTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>i2c bus timeout </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv420i2c_master_command_t">
<span id="_CPPv320i2c_master_command_t"></span><span id="_CPPv220i2c_master_command_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a81aef52e385747b0245f8c40660dfc5c"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_master_command_t</span></span></span><a class="headerlink" href="#_CPPv420i2c_master_command_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enum for I2C master commands. </p>
<p>These commands are used to define the I2C master operations. They correspond to hardware-level commands supported by the I2C peripheral. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_master_command_t20I2C_MASTER_CMD_STARTE">
<span id="_CPPv3N20i2c_master_command_t20I2C_MASTER_CMD_STARTE"></span><span id="_CPPv2N20i2c_master_command_t20I2C_MASTER_CMD_STARTE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a81aef52e385747b0245f8c40660dfc5cad6430e0f6c5219d21320e2d50dbc103a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_CMD_START</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_master_command_t20I2C_MASTER_CMD_STARTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Start or Restart condition </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_master_command_t20I2C_MASTER_CMD_WRITEE">
<span id="_CPPv3N20i2c_master_command_t20I2C_MASTER_CMD_WRITEE"></span><span id="_CPPv2N20i2c_master_command_t20I2C_MASTER_CMD_WRITEE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a81aef52e385747b0245f8c40660dfc5ca4501da7c91a7dcdbd242f3adca0a62b5"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_CMD_WRITE</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_master_command_t20I2C_MASTER_CMD_WRITEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Write operation </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_master_command_t19I2C_MASTER_CMD_READE">
<span id="_CPPv3N20i2c_master_command_t19I2C_MASTER_CMD_READE"></span><span id="_CPPv2N20i2c_master_command_t19I2C_MASTER_CMD_READE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a81aef52e385747b0245f8c40660dfc5ca7dd422e8c19dbc633d3c82a5ce711c7e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_CMD_READ</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_master_command_t19I2C_MASTER_CMD_READE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Read operation </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_master_command_t19I2C_MASTER_CMD_STOPE">
<span id="_CPPv3N20i2c_master_command_t19I2C_MASTER_CMD_STOPE"></span><span id="_CPPv2N20i2c_master_command_t19I2C_MASTER_CMD_STOPE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a81aef52e385747b0245f8c40660dfc5cac2ca277dac3ae7e424fd023da1f6b5fc"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_CMD_STOP</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_master_command_t19I2C_MASTER_CMD_STOPE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stop condition </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv415i2c_ack_value_t">
<span id="_CPPv315i2c_ack_value_t"></span><span id="_CPPv215i2c_ack_value_t"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a3d7ebc3d86ad2ec89e83b40e72d97e57"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_ack_value_t</span></span></span><a class="headerlink" href="#_CPPv415i2c_ack_value_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enum for I2C master ACK values. </p>
<p>These values define the acknowledgment (ACK) behavior during read operations. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15i2c_ack_value_t11I2C_ACK_VALE">
<span id="_CPPv3N15i2c_ack_value_t11I2C_ACK_VALE"></span><span id="_CPPv2N15i2c_ack_value_t11I2C_ACK_VALE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a3d7ebc3d86ad2ec89e83b40e72d97e57a8bfc9474668206fc1b89618617e95e1d"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_ACK_VAL</span></span></span><a class="headerlink" href="#_CPPv4N15i2c_ack_value_t11I2C_ACK_VALE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Acknowledge (ACK) signal </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15i2c_ack_value_t12I2C_NACK_VALE">
<span id="_CPPv3N15i2c_ack_value_t12I2C_NACK_VALE"></span><span id="_CPPv2N15i2c_ack_value_t12I2C_NACK_VALE"></span><span class="target" id="esp__driver__i2c_2include_2driver_2i2c__types_8h_1a3d7ebc3d86ad2ec89e83b40e72d97e57a434908dbb419f44ecc9cb138494bc029"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_NACK_VAL</span></span></span><a class="headerlink" href="#_CPPv4N15i2c_ack_value_t12I2C_NACK_VALE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Not Acknowledge (NACK) signal </p>
</dd></dl>

</dd></dl>

</section>
<section id="id6">
<h3>Header File<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/hal/include/hal/i2c_types.h">components/hal/include/hal/i2c_types.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;hal/i2c_types.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id7">
<h3>Structures<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv420i2c_hal_clk_config_t">
<span id="_CPPv320i2c_hal_clk_config_t"></span><span id="_CPPv220i2c_hal_clk_config_t"></span><span id="i2c_hal_clk_config_t"></span><span class="target" id="structi2c__hal__clk__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_hal_clk_config_t</span></span></span><a class="headerlink" href="#_CPPv420i2c_hal_clk_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Data structure for calculating I2C bus timing. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_hal_clk_config_t8clkm_divE">
<span id="_CPPv3N20i2c_hal_clk_config_t8clkm_divE"></span><span id="_CPPv2N20i2c_hal_clk_config_t8clkm_divE"></span><span id="i2c_hal_clk_config_t::clkm_div__uint16_t"></span><span class="target" id="structi2c__hal__clk__config__t_1a4f10e124062954ef368ebc7a40cbc32a"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clkm_div</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_hal_clk_config_t8clkm_divE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C core clock divider </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_hal_clk_config_t7scl_lowE">
<span id="_CPPv3N20i2c_hal_clk_config_t7scl_lowE"></span><span id="_CPPv2N20i2c_hal_clk_config_t7scl_lowE"></span><span id="i2c_hal_clk_config_t::scl_low__uint16_t"></span><span class="target" id="structi2c__hal__clk__config__t_1a35a27c53739edbb517774fb163c8191d"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scl_low</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_hal_clk_config_t7scl_lowE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C scl low period </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_hal_clk_config_t8scl_highE">
<span id="_CPPv3N20i2c_hal_clk_config_t8scl_highE"></span><span id="_CPPv2N20i2c_hal_clk_config_t8scl_highE"></span><span id="i2c_hal_clk_config_t::scl_high__uint16_t"></span><span class="target" id="structi2c__hal__clk__config__t_1ade5c427366a505d7f158de5a83b2f094"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scl_high</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_hal_clk_config_t8scl_highE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C scl high period </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_hal_clk_config_t13scl_wait_highE">
<span id="_CPPv3N20i2c_hal_clk_config_t13scl_wait_highE"></span><span id="_CPPv2N20i2c_hal_clk_config_t13scl_wait_highE"></span><span id="i2c_hal_clk_config_t::scl_wait_high__uint16_t"></span><span class="target" id="structi2c__hal__clk__config__t_1aa7cfedd027c6e6bd3e02a8a522d0c17d"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scl_wait_high</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_hal_clk_config_t13scl_wait_highE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C scl wait_high period </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_hal_clk_config_t8sda_holdE">
<span id="_CPPv3N20i2c_hal_clk_config_t8sda_holdE"></span><span id="_CPPv2N20i2c_hal_clk_config_t8sda_holdE"></span><span id="i2c_hal_clk_config_t::sda_hold__uint16_t"></span><span class="target" id="structi2c__hal__clk__config__t_1a778ad2041c59c0dc365887b1220327ed"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sda_hold</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_hal_clk_config_t8sda_holdE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C scl low period </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_hal_clk_config_t10sda_sampleE">
<span id="_CPPv3N20i2c_hal_clk_config_t10sda_sampleE"></span><span id="_CPPv2N20i2c_hal_clk_config_t10sda_sampleE"></span><span id="i2c_hal_clk_config_t::sda_sample__uint16_t"></span><span class="target" id="structi2c__hal__clk__config__t_1a2aaa75ee93ce964462e6f3bf6fc9bd46"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sda_sample</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_hal_clk_config_t10sda_sampleE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C sda sample time </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_hal_clk_config_t5setupE">
<span id="_CPPv3N20i2c_hal_clk_config_t5setupE"></span><span id="_CPPv2N20i2c_hal_clk_config_t5setupE"></span><span id="i2c_hal_clk_config_t::setup__uint16_t"></span><span class="target" id="structi2c__hal__clk__config__t_1aac2a81547e3a8949bef79437181bddfe"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">setup</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_hal_clk_config_t5setupE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C start and stop condition setup period </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_hal_clk_config_t4holdE">
<span id="_CPPv3N20i2c_hal_clk_config_t4holdE"></span><span id="_CPPv2N20i2c_hal_clk_config_t4holdE"></span><span id="i2c_hal_clk_config_t::hold__uint16_t"></span><span class="target" id="structi2c__hal__clk__config__t_1ada257b588fa003812325e534164b1353"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hold</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_hal_clk_config_t4holdE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C start and stop condition hold period </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20i2c_hal_clk_config_t4toutE">
<span id="_CPPv3N20i2c_hal_clk_config_t4toutE"></span><span id="_CPPv2N20i2c_hal_clk_config_t4toutE"></span><span id="i2c_hal_clk_config_t::tout__uint16_t"></span><span class="target" id="structi2c__hal__clk__config__t_1a973b87305f7ebc4b5fb94d6e950441f9"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tout</span></span></span><a class="headerlink" href="#_CPPv4N20i2c_hal_clk_config_t4toutE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C bus timeout period </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id8">
<h3>Type Definitions<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv418i2c_clock_source_t">
<span id="_CPPv318i2c_clock_source_t"></span><span id="_CPPv218i2c_clock_source_t"></span><span id="i2c_clock_source_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ac6a02ed3c807404f3f86742b33588073"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="clk_tree.html#_CPPv424soc_periph_i2c_clk_src_t" title="soc_periph_i2c_clk_src_t"><span class="n"><span class="pre">soc_periph_i2c_clk_src_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_clock_source_t</span></span></span><a class="headerlink" href="#_CPPv418i2c_clock_source_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C group clock source. </p>
</dd></dl>

</section>
<section id="id9">
<h3>Enumerations<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv410i2c_port_t">
<span id="_CPPv310i2c_port_t"></span><span id="_CPPv210i2c_port_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a72b72a4935fc360548c99edfb1d5fb52"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_port_t</span></span></span><a class="headerlink" href="#_CPPv410i2c_port_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C port number, can be I2C_NUM_0 ~ (I2C_NUM_MAX-1). </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10i2c_port_t9I2C_NUM_0E">
<span id="_CPPv3N10i2c_port_t9I2C_NUM_0E"></span><span id="_CPPv2N10i2c_port_t9I2C_NUM_0E"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a72b72a4935fc360548c99edfb1d5fb52af1b73432b6590bfb0e2ec8bb75606223"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_NUM_0</span></span></span><a class="headerlink" href="#_CPPv4N10i2c_port_t9I2C_NUM_0E" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C port 0 </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10i2c_port_t9I2C_NUM_1E">
<span id="_CPPv3N10i2c_port_t9I2C_NUM_1E"></span><span id="_CPPv2N10i2c_port_t9I2C_NUM_1E"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a72b72a4935fc360548c99edfb1d5fb52ab250eba954fef7798a489dba9244deb4"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_NUM_1</span></span></span><a class="headerlink" href="#_CPPv4N10i2c_port_t9I2C_NUM_1E" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C port 1 </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10i2c_port_t11I2C_NUM_MAXE">
<span id="_CPPv3N10i2c_port_t11I2C_NUM_MAXE"></span><span id="_CPPv2N10i2c_port_t11I2C_NUM_MAXE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a72b72a4935fc360548c99edfb1d5fb52a479df7cfc7e9b2c19a435d5106fd0221"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_NUM_MAX</span></span></span><a class="headerlink" href="#_CPPv4N10i2c_port_t11I2C_NUM_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C port max </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv418i2c_addr_bit_len_t">
<span id="_CPPv318i2c_addr_bit_len_t"></span><span id="_CPPv218i2c_addr_bit_len_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a2b6062591524a3484ab29cbf6507de87"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_addr_bit_len_t</span></span></span><a class="headerlink" href="#_CPPv418i2c_addr_bit_len_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enumeration for I2C device address bit length. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_addr_bit_len_t18I2C_ADDR_BIT_LEN_7E">
<span id="_CPPv3N18i2c_addr_bit_len_t18I2C_ADDR_BIT_LEN_7E"></span><span id="_CPPv2N18i2c_addr_bit_len_t18I2C_ADDR_BIT_LEN_7E"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a2b6062591524a3484ab29cbf6507de87a11d36826169337f23fcc8514881f8621"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_ADDR_BIT_LEN_7</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_addr_bit_len_t18I2C_ADDR_BIT_LEN_7E" title="Permalink to this definition"></a><br /></dt>
<dd><p>i2c address bit length 7 </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N18i2c_addr_bit_len_t19I2C_ADDR_BIT_LEN_10E">
<span id="_CPPv3N18i2c_addr_bit_len_t19I2C_ADDR_BIT_LEN_10E"></span><span id="_CPPv2N18i2c_addr_bit_len_t19I2C_ADDR_BIT_LEN_10E"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a2b6062591524a3484ab29cbf6507de87ac005913b71b9ddfef2d7b32e7ff9261c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_ADDR_BIT_LEN_10</span></span></span><a class="headerlink" href="#_CPPv4N18i2c_addr_bit_len_t19I2C_ADDR_BIT_LEN_10E" title="Permalink to this definition"></a><br /></dt>
<dd><p>i2c address bit length 10 </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv410i2c_mode_t">
<span id="_CPPv310i2c_mode_t"></span><span id="_CPPv210i2c_mode_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ac1e2996ebee909590af8e3cc1c316c25"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_mode_t</span></span></span><a class="headerlink" href="#_CPPv410i2c_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10i2c_mode_t14I2C_MODE_SLAVEE">
<span id="_CPPv3N10i2c_mode_t14I2C_MODE_SLAVEE"></span><span id="_CPPv2N10i2c_mode_t14I2C_MODE_SLAVEE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ac1e2996ebee909590af8e3cc1c316c25a10a3fafafb52ab45984aa5d5a17171a0"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MODE_SLAVE</span></span></span><a class="headerlink" href="#_CPPv4N10i2c_mode_t14I2C_MODE_SLAVEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C slave mode </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10i2c_mode_t15I2C_MODE_MASTERE">
<span id="_CPPv3N10i2c_mode_t15I2C_MODE_MASTERE"></span><span id="_CPPv2N10i2c_mode_t15I2C_MODE_MASTERE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ac1e2996ebee909590af8e3cc1c316c25a166443f9a57684d8e4970f28a7acf982"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MODE_MASTER</span></span></span><a class="headerlink" href="#_CPPv4N10i2c_mode_t15I2C_MODE_MASTERE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C master mode </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10i2c_mode_t12I2C_MODE_MAXE">
<span id="_CPPv3N10i2c_mode_t12I2C_MODE_MAXE"></span><span id="_CPPv2N10i2c_mode_t12I2C_MODE_MAXE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ac1e2996ebee909590af8e3cc1c316c25a9cd5f147dfb75f1be9b3ed757be15ae9"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MODE_MAX</span></span></span><a class="headerlink" href="#_CPPv4N10i2c_mode_t12I2C_MODE_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv48i2c_rw_t">
<span id="_CPPv38i2c_rw_t"></span><span id="_CPPv28i2c_rw_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ab5a46f08f942c368818ffc0789f3b573"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_rw_t</span></span></span><a class="headerlink" href="#_CPPv48i2c_rw_t" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N8i2c_rw_t16I2C_MASTER_WRITEE">
<span id="_CPPv3N8i2c_rw_t16I2C_MASTER_WRITEE"></span><span id="_CPPv2N8i2c_rw_t16I2C_MASTER_WRITEE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ab5a46f08f942c368818ffc0789f3b573a26142ea4e9632dc03b60ba56467a07c0"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_WRITE</span></span></span><a class="headerlink" href="#_CPPv4N8i2c_rw_t16I2C_MASTER_WRITEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C write data </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N8i2c_rw_t15I2C_MASTER_READE">
<span id="_CPPv3N8i2c_rw_t15I2C_MASTER_READE"></span><span id="_CPPv2N8i2c_rw_t15I2C_MASTER_READE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ab5a46f08f942c368818ffc0789f3b573ac51f9be531d6d17fb679812ea1f047de"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_READ</span></span></span><a class="headerlink" href="#_CPPv4N8i2c_rw_t15I2C_MASTER_READE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C read data </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv416i2c_trans_mode_t">
<span id="_CPPv316i2c_trans_mode_t"></span><span id="_CPPv216i2c_trans_mode_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a7c126154bf2a76ad4c94293a8c84ee41"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_trans_mode_t</span></span></span><a class="headerlink" href="#_CPPv416i2c_trans_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16i2c_trans_mode_t23I2C_DATA_MODE_MSB_FIRSTE">
<span id="_CPPv3N16i2c_trans_mode_t23I2C_DATA_MODE_MSB_FIRSTE"></span><span id="_CPPv2N16i2c_trans_mode_t23I2C_DATA_MODE_MSB_FIRSTE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a7c126154bf2a76ad4c94293a8c84ee41ad04124b1795b6d112b28dcebc41afc8f"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_DATA_MODE_MSB_FIRST</span></span></span><a class="headerlink" href="#_CPPv4N16i2c_trans_mode_t23I2C_DATA_MODE_MSB_FIRSTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C data msb first </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16i2c_trans_mode_t23I2C_DATA_MODE_LSB_FIRSTE">
<span id="_CPPv3N16i2c_trans_mode_t23I2C_DATA_MODE_LSB_FIRSTE"></span><span id="_CPPv2N16i2c_trans_mode_t23I2C_DATA_MODE_LSB_FIRSTE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a7c126154bf2a76ad4c94293a8c84ee41a3a9fdb0357ef13faf969f0ff3cfcc2d7"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_DATA_MODE_LSB_FIRST</span></span></span><a class="headerlink" href="#_CPPv4N16i2c_trans_mode_t23I2C_DATA_MODE_LSB_FIRSTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C data lsb first </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16i2c_trans_mode_t17I2C_DATA_MODE_MAXE">
<span id="_CPPv3N16i2c_trans_mode_t17I2C_DATA_MODE_MAXE"></span><span id="_CPPv2N16i2c_trans_mode_t17I2C_DATA_MODE_MAXE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a7c126154bf2a76ad4c94293a8c84ee41a12484898cb6b04034899d254e5452d7c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_DATA_MODE_MAX</span></span></span><a class="headerlink" href="#_CPPv4N16i2c_trans_mode_t17I2C_DATA_MODE_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv415i2c_addr_mode_t">
<span id="_CPPv315i2c_addr_mode_t"></span><span id="_CPPv215i2c_addr_mode_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a7e11a27bbb10c136b92884ed8cf2e61a"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_addr_mode_t</span></span></span><a class="headerlink" href="#_CPPv415i2c_addr_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15i2c_addr_mode_t14I2C_ADDR_BIT_7E">
<span id="_CPPv3N15i2c_addr_mode_t14I2C_ADDR_BIT_7E"></span><span id="_CPPv2N15i2c_addr_mode_t14I2C_ADDR_BIT_7E"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a7e11a27bbb10c136b92884ed8cf2e61aa764d1146167e79ec306b49e7989ffcb1"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_ADDR_BIT_7</span></span></span><a class="headerlink" href="#_CPPv4N15i2c_addr_mode_t14I2C_ADDR_BIT_7E" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C 7bit address for slave mode </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15i2c_addr_mode_t15I2C_ADDR_BIT_10E">
<span id="_CPPv3N15i2c_addr_mode_t15I2C_ADDR_BIT_10E"></span><span id="_CPPv2N15i2c_addr_mode_t15I2C_ADDR_BIT_10E"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a7e11a27bbb10c136b92884ed8cf2e61aa4a043e9565945e4210faa630e4ad9a62"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_ADDR_BIT_10</span></span></span><a class="headerlink" href="#_CPPv4N15i2c_addr_mode_t15I2C_ADDR_BIT_10E" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C 10bit address for slave mode </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15i2c_addr_mode_t16I2C_ADDR_BIT_MAXE">
<span id="_CPPv3N15i2c_addr_mode_t16I2C_ADDR_BIT_MAXE"></span><span id="_CPPv2N15i2c_addr_mode_t16I2C_ADDR_BIT_MAXE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a7e11a27bbb10c136b92884ed8cf2e61aa85edbe27a18d36d5a07acc79e4401926"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_ADDR_BIT_MAX</span></span></span><a class="headerlink" href="#_CPPv4N15i2c_addr_mode_t16I2C_ADDR_BIT_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv414i2c_ack_type_t">
<span id="_CPPv314i2c_ack_type_t"></span><span id="_CPPv214i2c_ack_type_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1aa98c4abc88201a0f3529b256f6f4b68e"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_ack_type_t</span></span></span><a class="headerlink" href="#_CPPv414i2c_ack_type_t" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N14i2c_ack_type_t14I2C_MASTER_ACKE">
<span id="_CPPv3N14i2c_ack_type_t14I2C_MASTER_ACKE"></span><span id="_CPPv2N14i2c_ack_type_t14I2C_MASTER_ACKE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1aa98c4abc88201a0f3529b256f6f4b68eaf0ad5fed6e9a1e6e117f1c360ce14fbd"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_ACK</span></span></span><a class="headerlink" href="#_CPPv4N14i2c_ack_type_t14I2C_MASTER_ACKE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C ack for each byte read </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N14i2c_ack_type_t15I2C_MASTER_NACKE">
<span id="_CPPv3N14i2c_ack_type_t15I2C_MASTER_NACKE"></span><span id="_CPPv2N14i2c_ack_type_t15I2C_MASTER_NACKE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1aa98c4abc88201a0f3529b256f6f4b68eab187e50c7e487bd1e233f47794b778f6"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_NACK</span></span></span><a class="headerlink" href="#_CPPv4N14i2c_ack_type_t15I2C_MASTER_NACKE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C nack for each byte read </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N14i2c_ack_type_t20I2C_MASTER_LAST_NACKE">
<span id="_CPPv3N14i2c_ack_type_t20I2C_MASTER_LAST_NACKE"></span><span id="_CPPv2N14i2c_ack_type_t20I2C_MASTER_LAST_NACKE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1aa98c4abc88201a0f3529b256f6f4b68ea4af11379ec57bc4c4fb650c5157355f1"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_LAST_NACK</span></span></span><a class="headerlink" href="#_CPPv4N14i2c_ack_type_t20I2C_MASTER_LAST_NACKE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C nack for the last byte </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N14i2c_ack_type_t18I2C_MASTER_ACK_MAXE">
<span id="_CPPv3N14i2c_ack_type_t18I2C_MASTER_ACK_MAXE"></span><span id="_CPPv2N14i2c_ack_type_t18I2C_MASTER_ACK_MAXE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1aa98c4abc88201a0f3529b256f6f4b68eaf2ca70044384f0411172ac5c0f8e3b5d"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_MASTER_ACK_MAX</span></span></span><a class="headerlink" href="#_CPPv4N14i2c_ack_type_t18I2C_MASTER_ACK_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv425i2c_slave_stretch_cause_t">
<span id="_CPPv325i2c_slave_stretch_cause_t"></span><span id="_CPPv225i2c_slave_stretch_cause_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a83c07d6a1df9cbb99c547c98f4f7202a"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_stretch_cause_t</span></span></span><a class="headerlink" href="#_CPPv425i2c_slave_stretch_cause_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enum for I2C slave stretch causes. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N25i2c_slave_stretch_cause_t37I2C_SLAVE_STRETCH_CAUSE_ADDRESS_MATCHE">
<span id="_CPPv3N25i2c_slave_stretch_cause_t37I2C_SLAVE_STRETCH_CAUSE_ADDRESS_MATCHE"></span><span id="_CPPv2N25i2c_slave_stretch_cause_t37I2C_SLAVE_STRETCH_CAUSE_ADDRESS_MATCHE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a83c07d6a1df9cbb99c547c98f4f7202aabbe215f05f1150098c730aef41426e04"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_SLAVE_STRETCH_CAUSE_ADDRESS_MATCH</span></span></span><a class="headerlink" href="#_CPPv4N25i2c_slave_stretch_cause_t37I2C_SLAVE_STRETCH_CAUSE_ADDRESS_MATCHE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stretching SCL low when the slave is read by the master and the address just matched </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N25i2c_slave_stretch_cause_t32I2C_SLAVE_STRETCH_CAUSE_TX_EMPTYE">
<span id="_CPPv3N25i2c_slave_stretch_cause_t32I2C_SLAVE_STRETCH_CAUSE_TX_EMPTYE"></span><span id="_CPPv2N25i2c_slave_stretch_cause_t32I2C_SLAVE_STRETCH_CAUSE_TX_EMPTYE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a83c07d6a1df9cbb99c547c98f4f7202aa75c307fb409198f8c2432ad89c48cc6b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_SLAVE_STRETCH_CAUSE_TX_EMPTY</span></span></span><a class="headerlink" href="#_CPPv4N25i2c_slave_stretch_cause_t32I2C_SLAVE_STRETCH_CAUSE_TX_EMPTYE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stretching SCL low when TX FIFO is empty in slave mode </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N25i2c_slave_stretch_cause_t31I2C_SLAVE_STRETCH_CAUSE_RX_FULLE">
<span id="_CPPv3N25i2c_slave_stretch_cause_t31I2C_SLAVE_STRETCH_CAUSE_RX_FULLE"></span><span id="_CPPv2N25i2c_slave_stretch_cause_t31I2C_SLAVE_STRETCH_CAUSE_RX_FULLE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a83c07d6a1df9cbb99c547c98f4f7202aa1fefd137a0f857f19e1fa26e393fe5fd"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_SLAVE_STRETCH_CAUSE_RX_FULL</span></span></span><a class="headerlink" href="#_CPPv4N25i2c_slave_stretch_cause_t31I2C_SLAVE_STRETCH_CAUSE_RX_FULLE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stretching SCL low when RX FIFO is full in slave mode </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N25i2c_slave_stretch_cause_t35I2C_SLAVE_STRETCH_CAUSE_SENDING_ACKE">
<span id="_CPPv3N25i2c_slave_stretch_cause_t35I2C_SLAVE_STRETCH_CAUSE_SENDING_ACKE"></span><span id="_CPPv2N25i2c_slave_stretch_cause_t35I2C_SLAVE_STRETCH_CAUSE_SENDING_ACKE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a83c07d6a1df9cbb99c547c98f4f7202aa5ab05438f01e24331a99ff7e40058c62"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_SLAVE_STRETCH_CAUSE_SENDING_ACK</span></span></span><a class="headerlink" href="#_CPPv4N25i2c_slave_stretch_cause_t35I2C_SLAVE_STRETCH_CAUSE_SENDING_ACKE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stretching SCL low when slave sending ACK </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv429i2c_slave_read_write_status_t">
<span id="_CPPv329i2c_slave_read_write_status_t"></span><span id="_CPPv229i2c_slave_read_write_status_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ab2174a485b913fec9b0f997d2dc0785b"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_slave_read_write_status_t</span></span></span><a class="headerlink" href="#_CPPv429i2c_slave_read_write_status_t" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N29i2c_slave_read_write_status_t25I2C_SLAVE_WRITE_BY_MASTERE">
<span id="_CPPv3N29i2c_slave_read_write_status_t25I2C_SLAVE_WRITE_BY_MASTERE"></span><span id="_CPPv2N29i2c_slave_read_write_status_t25I2C_SLAVE_WRITE_BY_MASTERE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ab2174a485b913fec9b0f997d2dc0785ba62baf5958af4f50d6099b25cb21cbf46"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_SLAVE_WRITE_BY_MASTER</span></span></span><a class="headerlink" href="#_CPPv4N29i2c_slave_read_write_status_t25I2C_SLAVE_WRITE_BY_MASTERE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N29i2c_slave_read_write_status_t24I2C_SLAVE_READ_BY_MASTERE">
<span id="_CPPv3N29i2c_slave_read_write_status_t24I2C_SLAVE_READ_BY_MASTERE"></span><span id="_CPPv2N29i2c_slave_read_write_status_t24I2C_SLAVE_READ_BY_MASTERE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1ab2174a485b913fec9b0f997d2dc0785ba1b118a2454297ff86752dc6f2e14077a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_SLAVE_READ_BY_MASTER</span></span></span><a class="headerlink" href="#_CPPv4N29i2c_slave_read_write_status_t24I2C_SLAVE_READ_BY_MASTERE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv414i2c_bus_mode_t">
<span id="_CPPv314i2c_bus_mode_t"></span><span id="_CPPv214i2c_bus_mode_t"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a29c4babffe5e9bdedc55f337d6a282e5"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i2c_bus_mode_t</span></span></span><a class="headerlink" href="#_CPPv414i2c_bus_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enum for i2c working modes. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N14i2c_bus_mode_t19I2C_BUS_MODE_MASTERE">
<span id="_CPPv3N14i2c_bus_mode_t19I2C_BUS_MODE_MASTERE"></span><span id="_CPPv2N14i2c_bus_mode_t19I2C_BUS_MODE_MASTERE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a29c4babffe5e9bdedc55f337d6a282e5af383621f90d040723497891a2ddae340"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_BUS_MODE_MASTER</span></span></span><a class="headerlink" href="#_CPPv4N14i2c_bus_mode_t19I2C_BUS_MODE_MASTERE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C works under master mode </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N14i2c_bus_mode_t18I2C_BUS_MODE_SLAVEE">
<span id="_CPPv3N14i2c_bus_mode_t18I2C_BUS_MODE_SLAVEE"></span><span id="_CPPv2N14i2c_bus_mode_t18I2C_BUS_MODE_SLAVEE"></span><span class="target" id="hal_2include_2hal_2i2c__types_8h_1a29c4babffe5e9bdedc55f337d6a282e5aad6f94028056cf0785daeec524e7618b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">I2C_BUS_MODE_SLAVE</span></span></span><a class="headerlink" href="#_CPPv4N14i2c_bus_mode_t18I2C_BUS_MODE_SLAVEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>I2C works under slave mode </p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Inter-Integrated Circuit (I2C) (api-reference/peripherals/i2c)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Inter-Integrated Circuit (I2C) (api-reference/peripherals/i2c)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="gptimer.html" class="btn btn-neutral float-left" title="General Purpose Timer (GPTimer)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="i2c_slave_v1.html" class="btn btn-neutral float-right" title="I2C Slave v1.0" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>