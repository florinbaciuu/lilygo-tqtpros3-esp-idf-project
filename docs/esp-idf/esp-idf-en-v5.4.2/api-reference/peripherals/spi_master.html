<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SPI Master Driver - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/peripherals/spi_master.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/peripherals/spi_master';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="SPI Slave Driver" href="spi_slave.html" />
    <link rel="prev" title="SPI Flash API ESP-IDF Version vs Chip-ROM Version" href="spi_flash/spi_flash_idf_vs_rom.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth® API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Peripherals API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="adc_oneshot.html">Analog to Digital Converter (ADC) Oneshot Mode Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="adc_continuous.html">Analog to Digital Converter (ADC) Continuous Mode Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="adc_calibration.html">Analog to Digital Converter (ADC) Calibration Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk_tree.html">Clock Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="dac.html">Digital To Analog Converter (DAC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio.html">GPIO &amp; RTC GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="gptimer.html">General Purpose Timer (GPTimer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">Inter-Integrated Circuit (I2C)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2s.html">Inter-IC Sound (I2S)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lcd/index.html">LCD</a></li>
<li class="toctree-l3"><a class="reference internal" href="ledc.html">LED Control (LEDC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mcpwm.html">Motor Control Pulse Width Modulator (MCPWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="pcnt.html">Pulse Counter (PCNT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rmt.html">Remote Control Transceiver (RMT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sd_pullup_requirements.html">SD Pull-up Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc_host.html">SDMMC Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdspi_host.html">SD SPI Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdio_slave.html">SDIO Card Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdm.html">Sigma-Delta Modulation (SDM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_flash/index.html">SPI Flash API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">SPI Master Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#terminology">Terminology</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-features">Driver Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-transactions">SPI Transactions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-usage">Driver Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transfer-speed-considerations">Transfer Speed Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#timing-considerations">Timing Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#known-issues">Known Issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-examples">Application Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference-spi-common">API Reference - SPI Common</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference-spi-master">API Reference - SPI Master</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="spi_slave.html">SPI Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="touch_pad.html">Touch Sensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="twai.html">Two-Wire Automotive Interface (TWAI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="uart.html">Universal Asynchronous Receiver/Transmitter (UART)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Project Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">System API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">Peripherals API</a></li>
      <li class="breadcrumb-item active">SPI Master Driver</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-reference/peripherals/spi_master.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="spi-master-driver">
<h1>SPI Master Driver<a class="headerlink" href="#spi-master-driver" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/v5.4.2/esp32/api-reference/peripherals/spi_master.html">[中文]</a></p>
<p>SPI Master driver is a program that controls ESP32's General Purpose SPI (GP-SPI) peripheral(s) when it functions as a master.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>SPI1 is not a GP-SPI. SPI Master driver also supports SPI1 but with quite a few limitations, see <a class="reference internal" href="#spi-master-on-spi1-bus"><span class="std std-ref">Notes on Using the SPI Master Driver on SPI1 Bus</span></a>.</p>
</div>
<p>For more hardware information about the GP-SPI peripheral(s), see <strong>ESP32 Technical Reference Manual</strong> &gt; <strong>SPI Controller</strong> [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#spi">PDF</a>].</p>
<section id="terminology">
<h2>Terminology<a class="headerlink" href="#terminology" title="Permalink to this heading"></a></h2>
<p>The terms used in relation to the SPI Master driver are given in the table below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30.0%" />
<col style="width: 70.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Term</p></th>
<th class="head"><p>Definition</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Host</p></td>
<td><p>The SPI controller peripheral inside ESP32 initiates SPI transmissions over the bus and acts as an SPI Master.</p></td>
</tr>
<tr class="row-odd"><td><p>Device</p></td>
<td><p>SPI slave Device. An SPI bus may be connected to one or more Devices. Each Device shares the MOSI, MISO, and SCLK signals but is only active on the bus when the Host asserts the Device's individual CS line.</p></td>
</tr>
<tr class="row-even"><td><p>Bus</p></td>
<td><p>A signal bus, common to all Devices connected to one Host. In general, a bus includes the following lines: MISO, MOSI, SCLK, one or more CS lines, and, optionally, QUADWP and QUADHD. So Devices are connected to the same lines, with the exception that each Device has its own CS line. Several Devices can also share one CS line if connected in a daisy-chain manner.</p></td>
</tr>
<tr class="row-odd"><td><p>MOSI</p></td>
<td><p>Master Out, Slave In, a.k.a. D. Data transmission from a Host to Device. Also data0 signal in Octal/OPI mode.</p></td>
</tr>
<tr class="row-even"><td><p>MISO</p></td>
<td><p>Master In, Slave Out, a.k.a. Q. Data transmission from a Device to Host. Also data1 signal in Octal/OPI mode.</p></td>
</tr>
<tr class="row-odd"><td><p>SCLK</p></td>
<td><p>Serial Clock. The oscillating signal generated by a Host keeps the transmission of data bits in sync.</p></td>
</tr>
<tr class="row-even"><td><p>CS</p></td>
<td><p>Chip Select. Allows a Host to select individual Device(s) connected to the bus in order to send or receive data.</p></td>
</tr>
<tr class="row-odd"><td><p>QUADWP</p></td>
<td><p>Write Protect signal. Used for 4-bit (qio/qout) transactions. Also for the data2 signal in Octal/OPI mode.</p></td>
</tr>
<tr class="row-even"><td><p>QUADHD</p></td>
<td><p>Hold signal. Used for 4-bit (qio/qout) transactions. Also for the data3 signal in Octal/OPI mode.</p></td>
</tr>
<tr class="row-odd"><td><p>DATA4</p></td>
<td><p>Data4 signal in Octal/OPI mode.</p></td>
</tr>
<tr class="row-even"><td><p>DATA5</p></td>
<td><p>Data5 signal in Octal/OPI mode.</p></td>
</tr>
<tr class="row-odd"><td><p>DATA6</p></td>
<td><p>Data6 signal in Octal/OPI mode.</p></td>
</tr>
<tr class="row-even"><td><p>DATA7</p></td>
<td><p>Data7 signal in Octal/OPI mode.</p></td>
</tr>
<tr class="row-odd"><td><p>Assertion</p></td>
<td><p>The action of activating a line.</p></td>
</tr>
<tr class="row-even"><td><p>De-assertion</p></td>
<td><p>The action of returning the line back to inactive (back to idle) status.</p></td>
</tr>
<tr class="row-odd"><td><p>Transaction</p></td>
<td><p>One instance of a Host asserting a CS line, transferring data to and from a Device, and de-asserting the CS line. Transactions are atomic, which means they can never be interrupted by another transaction.</p></td>
</tr>
<tr class="row-even"><td><p>Launch Edge</p></td>
<td><p>Edge of the clock at which the source register <strong>launches</strong> the signal onto the line.</p></td>
</tr>
<tr class="row-odd"><td><p>Latch Edge</p></td>
<td><p>Edge of the clock at which the destination register <strong>latches in</strong> the signal.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="driver-features">
<h2>Driver Features<a class="headerlink" href="#driver-features" title="Permalink to this heading"></a></h2>
<p>The SPI Master driver governs the communications between Hosts and Devices. The driver supports the following features:</p>
<ul class="simple">
<li><p>Multi-threaded environments</p></li>
<li><p>Transparent handling of DMA transfers while reading and writing data</p></li>
<li><p>Automatic time-division multiplexing of data coming from different Devices on the same signal bus, see <a class="reference internal" href="spi_features.html#spi-bus-lock"><span class="std std-ref">SPI Bus Lock</span></a>.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The SPI Master driver allows multiple Devices to be connected on a same SPI bus (sharing a single ESP32 SPI peripheral). As long as each Device is accessed by only one task, the driver is thread-safe. However, if multiple tasks try to access the same SPI Device, the driver is <strong>not thread-safe</strong>. In this case, it is recommended to either:</p>
<ul class="simple">
<li><p>Refactor your application so that each SPI peripheral is only accessed by a single task at a time. You can use <a class="reference internal" href="#_CPPv4N16spi_bus_config_t10isr_cpu_idE" title="spi_bus_config_t::isr_cpu_id"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_bus_config_t::isr_cpu_id</span></code></a> to register the SPI ISR to the same core as SPI peripheral-related tasks to ensure thread safety.</p></li>
<li><p>Add a mutex lock around the shared Device using <a class="reference internal" href="../system/freertos_idf.html#c.xSemaphoreCreateMutex" title="xSemaphoreCreateMutex"><code class="xref c c-macro docutils literal notranslate"><span class="pre">xSemaphoreCreateMutex</span></code></a>.</p></li>
</ul>
</div>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="spi-transactions">
<h2>SPI Transactions<a class="headerlink" href="#spi-transactions" title="Permalink to this heading"></a></h2>
<p>An SPI bus transaction consists of five phases which can be found in the table below. Any of these phases can be skipped.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30.0%" />
<col style="width: 70.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Phase</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Command</p></td>
<td><p>In this phase, a command (0-16 bit) is written to the bus by the Host.</p></td>
</tr>
<tr class="row-odd"><td><p>Address</p></td>
<td><p>In this phase, an address (0-64 bit) is transmitted over the bus by the Host.</p></td>
</tr>
<tr class="row-even"><td><p>Dummy</p></td>
<td><p>This phase is configurable and is used to meet the timing requirements.</p></td>
</tr>
<tr class="row-odd"><td><p>Write</p></td>
<td><p>Host sends data to a Device. This data follows the optional command and address phases and is indistinguishable from them at the electrical level.</p></td>
</tr>
<tr class="row-even"><td><p>Read</p></td>
<td><p>Device sends data to its Host.</p></td>
</tr>
</tbody>
</table>
<p>The attributes of a transaction are determined by the bus configuration structure <a class="reference internal" href="#_CPPv416spi_bus_config_t" title="spi_bus_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_bus_config_t</span></code></a>, Device configuration structure <a class="reference internal" href="#_CPPv429spi_device_interface_config_t" title="spi_device_interface_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_device_interface_config_t</span></code></a>, and transaction configuration structure <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_transaction_t</span></code></a>.</p>
<p>An SPI Host can send full-duplex transactions, during which the Read and Write phases occur simultaneously. The total transaction length is determined by the sum of the following members:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N29spi_device_interface_config_t12command_bitsE" title="spi_device_interface_config_t::command_bits"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_interface_config_t::command_bits</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv4N29spi_device_interface_config_t12address_bitsE" title="spi_device_interface_config_t::address_bits"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_interface_config_t::address_bits</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv4N17spi_transaction_t6lengthE" title="spi_transaction_t::length"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::length</span></code></a></p></li>
</ul>
<p>While the member <a class="reference internal" href="#_CPPv4N17spi_transaction_t8rxlengthE" title="spi_transaction_t::rxlength"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::rxlength</span></code></a> only determines the length of data received into the buffer.</p>
<p>In half-duplex transactions, the Read and Write phases are not simultaneous (one direction at a time). The lengths of the Write and Read phases are determined by <a class="reference internal" href="#_CPPv4N17spi_transaction_t6lengthE" title="spi_transaction_t::length"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::length</span></code></a> and <a class="reference internal" href="#_CPPv4N17spi_transaction_t8rxlengthE" title="spi_transaction_t::rxlength"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::rxlength</span></code></a> respectively.</p>
<p>The Command and Address phases are optional, as not every SPI Device requires a command and/or address. This is reflected in the Device's configuration: if <a class="reference internal" href="#_CPPv4N29spi_device_interface_config_t12command_bitsE" title="spi_device_interface_config_t::command_bits"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_interface_config_t::command_bits</span></code></a> and/or <a class="reference internal" href="#_CPPv4N29spi_device_interface_config_t12address_bitsE" title="spi_device_interface_config_t::address_bits"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_interface_config_t::address_bits</span></code></a> are set to zero, no Command or Address phase will occur.</p>
<p>The Read and Write phases can also be optional, as not every transaction requires both writing and reading data. If <a class="reference internal" href="#_CPPv4N17spi_transaction_t9rx_bufferE" title="spi_transaction_t::rx_buffer"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::rx_buffer</span></code></a> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and <a class="reference internal" href="#c.SPI_TRANS_USE_RXDATA" title="SPI_TRANS_USE_RXDATA"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_TRANS_USE_RXDATA</span></code></a> is not set, the Read phase is skipped. If <a class="reference internal" href="#_CPPv4N17spi_transaction_t9tx_bufferE" title="spi_transaction_t::tx_buffer"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::tx_buffer</span></code></a> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and <a class="reference internal" href="#c.SPI_TRANS_USE_TXDATA" title="SPI_TRANS_USE_TXDATA"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_TRANS_USE_TXDATA</span></code></a> is not set, the Write phase is skipped.</p>
<p>The driver supports two types of transactions: interrupt transactions and polling transactions. The programmer can choose to use a different transaction type per Device. If your Device requires both transaction types, see <a class="reference internal" href="#mixed-transactions"><span class="std std-ref">Notes on Sending Mixed Transactions to the Same Device</span></a>.</p>
<section id="interrupt-transactions">
<span id="id2"></span><h3>Interrupt Transactions<a class="headerlink" href="#interrupt-transactions" title="Permalink to this heading"></a></h3>
<p>Interrupt transactions blocks the transaction routine until the transaction completes, thus allowing the CPU to run other tasks.</p>
<p>An application task can queue multiple transactions, and the driver automatically handles them one by one in the interrupt service routine (ISR). It allows the task to switch to other procedures until all the transactions are complete.</p>
</section>
<section id="polling-transactions">
<span id="id3"></span><h3>Polling Transactions<a class="headerlink" href="#polling-transactions" title="Permalink to this heading"></a></h3>
<p>Polling transactions do not use interrupts. The routine keeps polling the SPI Host's status bit until the transaction is finished.</p>
<p>All the tasks that use interrupt transactions can be blocked by the queue. At this point, they need to wait for the ISR to run twice before the transaction is finished. Polling transactions save time otherwise spent on queue handling and context switching, which results in smaller transaction duration. The disadvantage is that the CPU is busy while these transactions are in progress.</p>
<p>The <a class="reference internal" href="#_CPPv422spi_device_polling_end19spi_device_handle_t10TickType_t" title="spi_device_polling_end"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_end()</span></code></a> routine needs an overhead of at least 1 µs to unblock other tasks when the transaction is finished. It is strongly recommended to wrap a series of polling transactions using the functions <a class="reference internal" href="#_CPPv422spi_device_acquire_bus19spi_device_handle_t10TickType_t" title="spi_device_acquire_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_acquire_bus()</span></code></a> and <a class="reference internal" href="#_CPPv422spi_device_release_bus19spi_device_handle_t" title="spi_device_release_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_release_bus()</span></code></a> to avoid the overhead. For more information, see <a class="reference internal" href="#bus-acquiring"><span class="std std-ref">Bus Acquiring</span></a>.</p>
</section>
<section id="transaction-line-mode">
<span id="id4"></span><h3>Transaction Line Mode<a class="headerlink" href="#transaction-line-mode" title="Permalink to this heading"></a></h3>
<p>Supported line modes for ESP32 are listed as follows, to make use of these modes, set the member <code class="docutils literal notranslate"><span class="pre">flags</span></code> in the struct <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_transaction_t</span></code></a> as shown in the <code class="docutils literal notranslate"><span class="pre">Transaction</span> <span class="pre">Flag</span></code> column. If you want to check if corresponding IO pins are set or not, set the member <code class="docutils literal notranslate"><span class="pre">flags</span></code> in the <a class="reference internal" href="#_CPPv416spi_bus_config_t" title="spi_bus_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_bus_config_t</span></code></a> as shown in the <code class="docutils literal notranslate"><span class="pre">Bus</span> <span class="pre">IO</span> <span class="pre">setting</span> <span class="pre">Flag</span></code> column.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12.0%" />
<col style="width: 16.0%" />
<col style="width: 16.0%" />
<col style="width: 16.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Mode name</p></th>
<th class="head"><p>Command Line Width</p></th>
<th class="head"><p>Address Line Width</p></th>
<th class="head"><p>Data Line Width</p></th>
<th class="head"><p>Transaction Flag</p></th>
<th class="head"><p>Bus IO Setting Flag</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Normal SPI</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>Dual Output</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>SPI_TRANS_MODE_DIO</p></td>
<td><p>SPICOMMON_BUSFLAG_DUAL</p></td>
</tr>
<tr class="row-even"><td><p>Dual I/O</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>SPI_TRANS_MODE_DIO
SPI_TRANS_MULTILINE_ADDR</p></td>
<td><p>SPICOMMON_BUSFLAG_DUAL</p></td>
</tr>
<tr class="row-odd"><td><p>Quad Output</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>4</p></td>
<td><p>SPI_TRANS_MODE_QIO</p></td>
<td><p>SPICOMMON_BUSFLAG_QUAD</p></td>
</tr>
<tr class="row-even"><td><p>Quad I/O</p></td>
<td><p>1</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
<td><p>SPI_TRANS_MODE_QIO
SPI_TRANS_MULTILINE_ADDR</p></td>
<td><p>SPICOMMON_BUSFLAG_QUAD</p></td>
</tr>
</tbody>
</table>
</section>
<section id="command-and-address-phases">
<h3>Command and Address Phases<a class="headerlink" href="#command-and-address-phases" title="Permalink to this heading"></a></h3>
<p>During the Command and Address phases, the members <a class="reference internal" href="#_CPPv4N17spi_transaction_t3cmdE" title="spi_transaction_t::cmd"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::cmd</span></code></a> and <a class="reference internal" href="#_CPPv4N17spi_transaction_t4addrE" title="spi_transaction_t::addr"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::addr</span></code></a> are sent to the bus, nothing is read at this time. The default lengths of the Command and Address phases are set in <a class="reference internal" href="#_CPPv429spi_device_interface_config_t" title="spi_device_interface_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_device_interface_config_t</span></code></a> by calling <a class="reference internal" href="#_CPPv418spi_bus_add_device17spi_host_device_tPK29spi_device_interface_config_tP19spi_device_handle_t" title="spi_bus_add_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_bus_add_device()</span></code></a>. If the flags <a class="reference internal" href="#c.SPI_TRANS_VARIABLE_CMD" title="SPI_TRANS_VARIABLE_CMD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_TRANS_VARIABLE_CMD</span></code></a> and <a class="reference internal" href="#c.SPI_TRANS_VARIABLE_ADDR" title="SPI_TRANS_VARIABLE_ADDR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_TRANS_VARIABLE_ADDR</span></code></a> in the member <a class="reference internal" href="#_CPPv4N17spi_transaction_t5flagsE" title="spi_transaction_t::flags"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::flags</span></code></a> are not set, the driver automatically sets the length of these phases to default values during Device initialization.</p>
<p>If the lengths of the Command and Address phases need to be variable, declare the struct <a class="reference internal" href="#_CPPv421spi_transaction_ext_t" title="spi_transaction_ext_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_transaction_ext_t</span></code></a>, set the flags <a class="reference internal" href="#c.SPI_TRANS_VARIABLE_CMD" title="SPI_TRANS_VARIABLE_CMD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_TRANS_VARIABLE_CMD</span></code></a> and/or <a class="reference internal" href="#c.SPI_TRANS_VARIABLE_ADDR" title="SPI_TRANS_VARIABLE_ADDR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_TRANS_VARIABLE_ADDR</span></code></a> in the member <a class="reference internal" href="#_CPPv4N21spi_transaction_ext_t4baseE" title="spi_transaction_ext_t::base"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_ext_t::base</span></code></a> and configure the rest of base as usual. Then the length of each phase will be equal to <a class="reference internal" href="#_CPPv4N21spi_transaction_ext_t12command_bitsE" title="spi_transaction_ext_t::command_bits"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_ext_t::command_bits</span></code></a> and <a class="reference internal" href="#_CPPv4N21spi_transaction_ext_t12address_bitsE" title="spi_transaction_ext_t::address_bits"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_ext_t::address_bits</span></code></a> set in the struct <a class="reference internal" href="#_CPPv421spi_transaction_ext_t" title="spi_transaction_ext_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_transaction_ext_t</span></code></a>.</p>
<p>If the Command and Address phase need to have the same number of lines as the data phase, you need to set <code class="docutils literal notranslate"><span class="pre">SPI_TRANS_MULTILINE_CMD</span></code> and/or <code class="docutils literal notranslate"><span class="pre">SPI_TRANS_MULTILINE_ADDR</span></code> to the <code class="docutils literal notranslate"><span class="pre">flags</span></code> member in the struct <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_transaction_t</span></code></a>. Also see <a class="reference internal" href="#transaction-line-mode"><span class="std std-ref">Transaction Line Mode</span></a>.</p>
</section>
<section id="write-and-read-phases">
<h3>Write and Read Phases<a class="headerlink" href="#write-and-read-phases" title="Permalink to this heading"></a></h3>
<p>Normally, the data that needs to be transferred to or from a Device is read from or written to a chunk of memory indicated by the members <a class="reference internal" href="#_CPPv4N17spi_transaction_t9rx_bufferE" title="spi_transaction_t::rx_buffer"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::rx_buffer</span></code></a> and <a class="reference internal" href="#_CPPv4N17spi_transaction_t9tx_bufferE" title="spi_transaction_t::tx_buffer"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::tx_buffer</span></code></a>. If DMA is enabled for transfers, the buffers are required to be:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Allocated in DMA-capable internal memory (MALLOC_CAP_DMA), see <a class="reference internal" href="../system/mem_alloc.html#dma-capable-memory"><span class="std std-ref">DMA-Capable Memory</span></a>.</p></li>
<li><p>32-bit aligned (starting from a 32-bit boundary and having a length of multiples of 4 bytes).</p></li>
</ol>
</div></blockquote>
<p>If these requirements are not satisfied, the transaction efficiency will be affected due to the allocation and copying of temporary buffers.</p>
<p>If using more than one data line to transmit, please set <code class="docutils literal notranslate"><span class="pre">SPI_DEVICE_HALFDUPLEX</span></code> flag for the member <code class="docutils literal notranslate"><span class="pre">flags</span></code> in the struct <a class="reference internal" href="#_CPPv429spi_device_interface_config_t" title="spi_device_interface_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_device_interface_config_t</span></code></a>. And the member <code class="docutils literal notranslate"><span class="pre">flags</span></code> in the struct <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_transaction_t</span></code></a> should be set as described in <a class="reference internal" href="#transaction-line-mode"><span class="std std-ref">Transaction Line Mode</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Half-duplex transactions with both Read and Write phases are not supported when using DMA. For details and workarounds, see <a class="reference internal" href="#spi-known-issues"><span class="std std-ref">Known Issues</span></a>.</p>
</div>
</section>
<section id="bus-acquiring">
<span id="id5"></span><h3>Bus Acquiring<a class="headerlink" href="#bus-acquiring" title="Permalink to this heading"></a></h3>
<p>Sometimes you might want to send SPI transactions exclusively and continuously so that it takes as little time as possible. For this, you can use bus acquiring, which helps to suspend transactions (both polling or interrupt) to other Devices until the bus is released. To acquire and release a bus, use the functions <a class="reference internal" href="#_CPPv422spi_device_acquire_bus19spi_device_handle_t10TickType_t" title="spi_device_acquire_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_acquire_bus()</span></code></a> and <a class="reference internal" href="#_CPPv422spi_device_release_bus19spi_device_handle_t" title="spi_device_release_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_release_bus()</span></code></a>.</p>
</section>
</section>
<section id="driver-usage">
<h2>Driver Usage<a class="headerlink" href="#driver-usage" title="Permalink to this heading"></a></h2>
<ul>
<li><p>Initialize an SPI bus by calling the function <a class="reference internal" href="#_CPPv418spi_bus_initialize17spi_host_device_tPK16spi_bus_config_t14spi_dma_chan_t" title="spi_bus_initialize"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_bus_initialize()</span></code></a>. Make sure to set the correct I/O pins in the struct <a class="reference internal" href="#_CPPv416spi_bus_config_t" title="spi_bus_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_bus_config_t</span></code></a>. Set the signals that are not needed to <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p></li>
<li><p>Register a Device connected to the bus with the driver by calling the function <a class="reference internal" href="#_CPPv418spi_bus_add_device17spi_host_device_tPK29spi_device_interface_config_tP19spi_device_handle_t" title="spi_bus_add_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_bus_add_device()</span></code></a>. Make sure to configure any timing requirements the Device might need with the parameter <code class="docutils literal notranslate"><span class="pre">dev_config</span></code>. You should now have obtained the Device's handle which will be used when sending a transaction to it.</p></li>
<li><p>To interact with the Device, fill one or more <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_transaction_t</span></code></a> structs with any transaction parameters required. Then send the structs either using a polling transaction or an interrupt transaction:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="#interrupt-transactions"><span class="std std-ref">Interrupt</span></a></dt><dd><p>Either queue all transactions by calling the function <a class="reference internal" href="#_CPPv422spi_device_queue_trans19spi_device_handle_tP17spi_transaction_t10TickType_t" title="spi_device_queue_trans"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_queue_trans()</span></code></a> and, at a later time, query the result using the function <a class="reference internal" href="#_CPPv427spi_device_get_trans_result19spi_device_handle_tPP17spi_transaction_t10TickType_t" title="spi_device_get_trans_result"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_get_trans_result()</span></code></a>, or handle all requests synchronously by feeding them into <a class="reference internal" href="#_CPPv419spi_device_transmit19spi_device_handle_tP17spi_transaction_t" title="spi_device_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_transmit()</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="#polling-transactions"><span class="std std-ref">Polling</span></a></dt><dd><p>Call the function <a class="reference internal" href="#_CPPv427spi_device_polling_transmit19spi_device_handle_tP17spi_transaction_t" title="spi_device_polling_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_transmit()</span></code></a> to send polling transactions. Alternatively, if you want to insert something in between, send the transactions by using <a class="reference internal" href="#_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t" title="spi_device_polling_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_start()</span></code></a> and <a class="reference internal" href="#_CPPv422spi_device_polling_end19spi_device_handle_t10TickType_t" title="spi_device_polling_end"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_end()</span></code></a>.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p>(Optional) To perform back-to-back transactions with a Device, call the function <a class="reference internal" href="#_CPPv422spi_device_acquire_bus19spi_device_handle_t10TickType_t" title="spi_device_acquire_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_acquire_bus()</span></code></a> before sending transactions and <a class="reference internal" href="#_CPPv422spi_device_release_bus19spi_device_handle_t" title="spi_device_release_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_release_bus()</span></code></a> after the transactions have been sent.</p></li>
<li><p>(Optional) To remove a certain Device from the bus, call <a class="reference internal" href="#_CPPv421spi_bus_remove_device19spi_device_handle_t" title="spi_bus_remove_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_bus_remove_device()</span></code></a> with the Device handle as an argument.</p></li>
<li><p>(Optional) To remove the driver from the bus, make sure no more devices are attached and call <a class="reference internal" href="#_CPPv412spi_bus_free17spi_host_device_t" title="spi_bus_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_bus_free()</span></code></a>.</p></li>
</ul>
<p>The example code for the SPI Master driver can be found in the <a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/spi_master">peripherals/spi_master</a> directory of ESP-IDF examples.</p>
<section id="transactions-with-data-not-exceeding-32-bits">
<h3>Transactions with Data Not Exceeding 32 Bits<a class="headerlink" href="#transactions-with-data-not-exceeding-32-bits" title="Permalink to this heading"></a></h3>
<p>When the transaction data size is equal to or less than 32 bits, it will be sub-optimal to allocate a buffer for the data. The data can be directly stored in the transaction struct instead. For transmitted data, it can be achieved by using the <a class="reference internal" href="#_CPPv4N17spi_transaction_t7tx_dataE" title="spi_transaction_t::tx_data"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::tx_data</span></code></a> member and setting the <a class="reference internal" href="#c.SPI_TRANS_USE_TXDATA" title="SPI_TRANS_USE_TXDATA"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_TRANS_USE_TXDATA</span></code></a> flag on the transmission. For received data, use <a class="reference internal" href="#_CPPv4N17spi_transaction_t7rx_dataE" title="spi_transaction_t::rx_data"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::rx_data</span></code></a> and set <a class="reference internal" href="#c.SPI_TRANS_USE_RXDATA" title="SPI_TRANS_USE_RXDATA"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_TRANS_USE_RXDATA</span></code></a>. In both cases, do not touch the <a class="reference internal" href="#_CPPv4N17spi_transaction_t9tx_bufferE" title="spi_transaction_t::tx_buffer"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::tx_buffer</span></code></a> or <a class="reference internal" href="#_CPPv4N17spi_transaction_t9rx_bufferE" title="spi_transaction_t::rx_buffer"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::rx_buffer</span></code></a> members, because they use the same memory locations as <a class="reference internal" href="#_CPPv4N17spi_transaction_t7tx_dataE" title="spi_transaction_t::tx_data"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::tx_data</span></code></a> and <a class="reference internal" href="#_CPPv4N17spi_transaction_t7rx_dataE" title="spi_transaction_t::rx_data"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_transaction_t::rx_data</span></code></a>.</p>
</section>
<section id="transactions-with-integers-other-than-uint8-t">
<h3>Transactions with Integers Other than <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code><a class="headerlink" href="#transactions-with-integers-other-than-uint8-t" title="Permalink to this heading"></a></h3>
<p>An SPI Host reads and writes data into memory byte by byte. By default, data is sent with the most significant bit (MSB) first, as LSB is first used in rare cases. If a value of fewer than 8 bits needs to be sent, the bits should be written into memory in the MSB first manner.</p>
<p>For example, if <code class="docutils literal notranslate"><span class="pre">0b00010</span></code> needs to be sent, it should be written into a <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code> variable, and the length for reading should be set to 5 bits. The Device will still receive 8 bits with 3 additional &quot;random&quot; bits, so the reading must be performed correctly.</p>
<p>On top of that, ESP32 is a little-endian chip, which means that the least significant byte of <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code> and <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> variables is stored at the smallest address. Hence, if <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code> is stored in memory, bits [7:0] are sent first, followed by bits [15:8].</p>
<p>For cases when the data to be transmitted has a size differing from <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code> arrays, the following macros can be used to transform data to the format that can be sent by the SPI driver directly:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.SPI_SWAP_DATA_TX" title="SPI_SWAP_DATA_TX"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_SWAP_DATA_TX</span></code></a> for data to be transmitted</p></li>
<li><p><a class="reference internal" href="#c.SPI_SWAP_DATA_RX" title="SPI_SWAP_DATA_RX"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SPI_SWAP_DATA_RX</span></code></a> for data received</p></li>
</ul>
</section>
<section id="notes-on-sending-mixed-transactions-to-the-same-device">
<span id="mixed-transactions"></span><h3>Notes on Sending Mixed Transactions to the Same Device<a class="headerlink" href="#notes-on-sending-mixed-transactions-to-the-same-device" title="Permalink to this heading"></a></h3>
<p>To reduce coding complexity, send only one type of transaction (interrupt or polling) to one Device. However, you still can send both interrupt and polling transactions alternately. The notes below explain how to do this.</p>
<p>The polling transactions should be initiated only after all the polling and interrupt transactions are finished.</p>
<p>Since an unfinished polling transaction blocks other transactions, please do not forget to call the function <a class="reference internal" href="#_CPPv422spi_device_polling_end19spi_device_handle_t10TickType_t" title="spi_device_polling_end"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_end()</span></code></a> after <a class="reference internal" href="#_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t" title="spi_device_polling_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_start()</span></code></a> to allow other transactions or to allow other Devices to use the bus. Remember that if there is no need to switch to other tasks during your polling transaction, you can initiate a transaction with <a class="reference internal" href="#_CPPv427spi_device_polling_transmit19spi_device_handle_tP17spi_transaction_t" title="spi_device_polling_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_transmit()</span></code></a> so that it will be ended automatically.</p>
<p>In-flight polling transactions are disturbed by the ISR operation to accommodate interrupt transactions. Always make sure that all the interrupt transactions sent to the ISR are finished before you call <a class="reference internal" href="#_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t" title="spi_device_polling_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_start()</span></code></a>. To do that, you can keep calling <a class="reference internal" href="#_CPPv427spi_device_get_trans_result19spi_device_handle_tPP17spi_transaction_t10TickType_t" title="spi_device_get_trans_result"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_get_trans_result()</span></code></a> until all the transactions are returned.</p>
<p>To have better control of the calling sequence of functions, send mixed transactions to the same Device only within a single task.</p>
</section>
<section id="notes-on-using-the-spi-master-driver-on-spi1-bus">
<span id="spi-master-on-spi1-bus"></span><h3>Notes on Using the SPI Master Driver on SPI1 Bus<a class="headerlink" href="#notes-on-using-the-spi-master-driver-on-spi1-bus" title="Permalink to this heading"></a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Though the <a class="reference internal" href="spi_features.html#spi-bus-lock"><span class="std std-ref">SPI Bus Lock</span></a> feature makes it possible to use SPI Master driver on the SPI1 bus, it is still tricky and needs a lot of special treatment. It is a feature for advanced developers.</p>
</div>
<p>To use SPI Master driver on SPI1 bus, you have to take care of two problems:</p>
<ol class="arabic">
<li><p>The code and data should be in the internal memory when the driver is operating on SPI1 bus.</p>
<p>SPI1 bus is shared among Devices and the cache for data (code) in the flash as well as the PSRAM. The cache should be disabled when other drivers are operating on the SPI1 bus. Hence the data (code) in the flash as well as the PSRAM cannot be fetched while the driver acquires the SPI1 bus by:</p>
<ul class="simple">
<li><p>Explicit bus acquiring between <a class="reference internal" href="#_CPPv422spi_device_acquire_bus19spi_device_handle_t10TickType_t" title="spi_device_acquire_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_acquire_bus()</span></code></a> and <a class="reference internal" href="#_CPPv422spi_device_release_bus19spi_device_handle_t" title="spi_device_release_bus"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_release_bus()</span></code></a>.</p></li>
<li><p>Implicit bus acquiring between <a class="reference internal" href="#_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t" title="spi_device_polling_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_start()</span></code></a> and <a class="reference internal" href="#_CPPv422spi_device_polling_end19spi_device_handle_t10TickType_t" title="spi_device_polling_end"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_end()</span></code></a> (or inside <a class="reference internal" href="#_CPPv427spi_device_polling_transmit19spi_device_handle_tP17spi_transaction_t" title="spi_device_polling_transmit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_polling_transmit()</span></code></a>).</p></li>
</ul>
<p>During the time above, all other tasks and most ISRs will be disabled (see <a class="reference internal" href="spi_flash/spi_flash_concurrency.html#iram-safe-interrupt-handlers"><span class="std std-ref">IRAM-Safe Interrupt Handlers</span></a>). Application code and data used by the current task should be placed in internal memory (DRAM or IRAM), or already in the ROM. Access to external memory (flash code, const data in the flash, and static/heap data in the PSRAM) will cause a <code class="docutils literal notranslate"><span class="pre">Cache</span> <span class="pre">disabled</span> <span class="pre">but</span> <span class="pre">cached</span> <span class="pre">memory</span> <span class="pre">region</span> <span class="pre">accessed</span></code> exception. For differences between IRAM, DRAM, and flash cache, please refer to the <a class="reference internal" href="../../api-guides/memory-types.html#memory-layout"><span class="std std-ref">application memory layout</span></a> documentation.</p>
<p>To place functions into the IRAM, you can either:</p>
<ol class="arabic">
<li><p>Add <code class="docutils literal notranslate"><span class="pre">IRAM_ATTR</span></code> (include <code class="docutils literal notranslate"><span class="pre">esp_attr.h</span></code>) to the function like:</p>
<blockquote>
<div><p>IRAM_ATTR void foo(void) { }</p>
</div></blockquote>
<p>Please note that when a function is inlined, it will follow its caller's segment, and the attribute will not take effect. You may need to use <code class="docutils literal notranslate"><span class="pre">NOLINE_ATTR</span></code> to avoid this. Please also note that the compiler may transform some code into a lookup table in the const data, so <code class="docutils literal notranslate"><span class="pre">noflash_text</span></code> is not safe.</p>
</li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">noflash</span></code> placement in the <code class="docutils literal notranslate"><span class="pre">linker.lf</span></code>. See more in <a class="reference internal" href="../../api-guides/linker-script-generation.html"><span class="doc">Linker Script Generation</span></a>. Please note that the compiler may transform some code into a lookup table in the const data, so <code class="docutils literal notranslate"><span class="pre">noflash_text</span></code> is not safe.</p></li>
</ol>
<p>Please do take care that the optimization level may affect the compiler behavior of inline, or transform some code into a lookup table in the const data, etc.</p>
<p>To place data into the DRAM, you can either:</p>
<ol class="arabic">
<li><p>Add <code class="docutils literal notranslate"><span class="pre">DRAM_ATTR</span></code> (include <code class="docutils literal notranslate"><span class="pre">esp_attr.h</span></code>) to the data definition like:</p>
<blockquote>
<div><p>DRAM_ATTR int g_foo = 3;</p>
</div></blockquote>
</li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">noflash</span></code> placement in the linker.lf. See more in <a class="reference internal" href="../../api-guides/linker-script-generation.html"><span class="doc">Linker Script Generation</span></a>.</p></li>
</ol>
</li>
</ol>
<p>Please also see the example <a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/spi_master/hd_eeprom">peripherals/spi_master/hd_eeprom</a>.</p>
</section>
<section id="gpio-matrix-and-io-mux">
<h3>GPIO Matrix and IO_MUX<a class="headerlink" href="#gpio-matrix-and-io-mux" title="Permalink to this heading"></a></h3>
<p>Most of ESP32's peripheral signals have a direct connection to their dedicated IO_MUX pins. However, the signals can also be routed to any other available pins using the less direct GPIO matrix. If at least one signal is routed through the GPIO matrix, then all signals will be routed through it.</p>
<p>The GPIO matrix introduces flexibility of routing but also brings the following disadvantages:</p>
<ul class="simple">
<li><p>Increases the input delay of the MISO signal, which makes MISO setup time violations more likely. If SPI needs to operate at high speeds, use dedicated IO_MUX pins.</p></li>
<li><p>Allows signals with clock frequencies only up to 40 MHz, as opposed to 80 MHz if IO_MUX pins are used.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For more details about the influence of the MISO input delay on the maximum clock frequency, see <a class="reference internal" href="#timing-considerations"><span class="std std-ref">Timing Considerations</span></a>.</p>
</div>
<p>The IO_MUX pins for SPI buses are given below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Pin Name</p></th>
<th class="head"><p>SPI 2 (GPIO Number)</p></th>
<th class="head"><p>SPI 3 (GPIO Number)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CS0 <a class="footnote-reference brackets" href="#id8" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>15</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>SCLK</p></td>
<td><p>14</p></td>
<td><p>18</p></td>
</tr>
<tr class="row-even"><td><p>MISO</p></td>
<td><p>12</p></td>
<td><p>19</p></td>
</tr>
<tr class="row-odd"><td><p>MOSI</p></td>
<td><p>13</p></td>
<td><p>23</p></td>
</tr>
<tr class="row-even"><td><p>QUADWP</p></td>
<td><p>2</p></td>
<td><p>22</p></td>
</tr>
<tr class="row-odd"><td><p>QUADHD</p></td>
<td><p>4</p></td>
<td><p>21</p></td>
</tr>
</tbody>
</table>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p>Only the first Device attached to the bus can use the CS0 pin.</p>
</aside>
</aside>
</section>
</section>
<section id="transfer-speed-considerations">
<span id="speed-considerations"></span><h2>Transfer Speed Considerations<a class="headerlink" href="#transfer-speed-considerations" title="Permalink to this heading"></a></h2>
<p>There are three factors limiting the transfer speed:</p>
<ul class="simple">
<li><p>Transaction interval</p></li>
<li><p>SPI clock frequency</p></li>
<li><p>Cache miss of SPI functions, including callbacks</p></li>
</ul>
<p>The main parameter that determines the transfer speed for large transactions is clock frequency. For multiple small transactions, the transfer speed is mostly determined by the length of transaction intervals.</p>
<section id="transaction-duration">
<h3>Transaction Duration<a class="headerlink" href="#transaction-duration" title="Permalink to this heading"></a></h3>
<p>Transaction duration includes setting up SPI peripheral registers, copying data to FIFOs or setting up DMA links, and the time for SPI transactions.</p>
<p>Interrupt transactions allow appending extra overhead to accommodate the cost of FreeRTOS queues and the time needed for switching between tasks and the ISR.</p>
<p>For <strong>interrupt transactions</strong>, the CPU can switch to other tasks when a transaction is in progress. This saves CPU time but increases the transaction duration. See <a class="reference internal" href="#interrupt-transactions"><span class="std std-ref">Interrupt Transactions</span></a>. For <strong>polling transactions</strong>, it does not block the task but allows to do polling when the transaction is in progress. For more information, see <a class="reference internal" href="#polling-transactions"><span class="std std-ref">Polling Transactions</span></a>.</p>
<p>If DMA is enabled, setting up the linked list requires about 2 µs per transaction. When a master is transferring data, it automatically reads the data from the linked list. If DMA is not enabled, the CPU has to write and read each byte from the FIFO by itself. Usually, this is faster than 2 µs, but the transaction length is limited to 64 bytes for both write and read.</p>
<p>The typical transaction duration for one byte of data is given below.</p>
<ul class="simple">
<li><p>Interrupt Transaction via DMA: 28 µs.</p></li>
<li><p>Interrupt Transaction via CPU: 25 µs.</p></li>
<li><p>Polling Transaction via DMA: 10 µs.</p></li>
<li><p>Polling Transaction via CPU: 8 µs.</p></li>
</ul>
<p>Note that these data are tested with <a class="reference internal" href="../kconfig.html#config-spi-master-isr-in-iram"><span class="std std-ref">CONFIG_SPI_MASTER_ISR_IN_IRAM</span></a> enabled. SPI transaction related code are placed in the internal memory. If this option is turned off (for example, for internal memory optimization), the transaction duration may be affected.</p>
</section>
<section id="spi-clock-frequency">
<h3>SPI Clock Frequency<a class="headerlink" href="#spi-clock-frequency" title="Permalink to this heading"></a></h3>
<p>The clock source of the GPSPI peripherals can be selected by setting <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_handle_t::cfg::clock_source</span></code>. You can refer to <a class="reference internal" href="#_CPPv418spi_clock_source_t" title="spi_clock_source_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_clock_source_t</span></code></a> to know the supported clock sources.</p>
<p>By default driver sets <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_handle_t::cfg::clock_source</span></code> to <code class="docutils literal notranslate"><span class="pre">SPI_CLK_SRC_DEFAULT</span></code>. This usually stands for the highest frequency among GPSPI clock sources. Its value is different among chips.</p>
<p>The actual clock frequency of a Device may not be exactly equal to the number you set, it is re-calculated by the driver to the nearest hardware-compatible number, and not larger than the clock frequency of the clock source. You can call <a class="reference internal" href="#_CPPv426spi_device_get_actual_freq19spi_device_handle_tPi" title="spi_device_get_actual_freq"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_device_get_actual_freq()</span></code></a> to know the actual frequency computed by the driver.</p>
<p>The theoretical maximum transfer speed of the Write or Read phase can be calculated according to the table below:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 57.1%" />
<col style="width: 42.9%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Line Width of Write/Read phase</p></th>
<th class="head"><p>Speed (Bps)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1-Line</p></td>
<td><p><em>SPI Frequency / 8</em></p></td>
</tr>
<tr class="row-odd"><td><p>2-Line</p></td>
<td><p><em>SPI Frequency / 4</em></p></td>
</tr>
<tr class="row-even"><td><p>4-Line</p></td>
<td><p><em>SPI Frequency / 2</em></p></td>
</tr>
</tbody>
</table>
<p>The transfer speed calculation of other phases (Command, Address, Dummy) is similar.</p>
<p>If the clock frequency is too high, the use of some functions might be limited. See <a class="reference internal" href="#timing-considerations"><span class="std std-ref">Timing Considerations</span></a>.</p>
</section>
<section id="cache-missing">
<h3>Cache Missing<a class="headerlink" href="#cache-missing" title="Permalink to this heading"></a></h3>
<p>The default config puts only the ISR into the IRAM. Other SPI-related functions, including the driver itself and the callback, might suffer from cache misses and need to wait until the code is read from flash. Select <a class="reference internal" href="../kconfig.html#config-spi-master-in-iram"><span class="std std-ref">CONFIG_SPI_MASTER_IN_IRAM</span></a> to put the whole SPI driver into IRAM and put the entire callback(s) and its callee functions into IRAM to prevent cache missing.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>SPI driver implementation is based on FreeRTOS APIs, to use <a class="reference internal" href="../kconfig.html#config-spi-master-in-iram"><span class="std std-ref">CONFIG_SPI_MASTER_IN_IRAM</span></a>, you should not enable <a class="reference internal" href="../kconfig.html#config-freertos-place-functions-into-flash"><span class="std std-ref">CONFIG_FREERTOS_PLACE_FUNCTIONS_INTO_FLASH</span></a>.</p>
</div>
<p>For an interrupt transaction, the overall cost is <strong>20+8n/Fspi[MHz]</strong> [µs] for n bytes transferred in one transaction. Hence, the transferring speed is: <strong>n/(20+8n/Fspi)</strong>. An example of transferring speed at 8 MHz clock speed is given in the following table.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17.1%" />
<col style="width: 25.7%" />
<col style="width: 22.9%" />
<col style="width: 17.1%" />
<col style="width: 17.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Frequency (MHz)</p></th>
<th class="head"><p>Transaction Interval (µs)</p></th>
<th class="head"><p>Transaction Length (bytes)</p></th>
<th class="head"><p>Total Time (µs)</p></th>
<th class="head"><p>Total Speed (KBps)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>8</p></td>
<td><p>25</p></td>
<td><p>1</p></td>
<td><p>26</p></td>
<td><p>38.5</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>25</p></td>
<td><p>8</p></td>
<td><p>33</p></td>
<td><p>242.4</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>25</p></td>
<td><p>16</p></td>
<td><p>41</p></td>
<td><p>490.2</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>25</p></td>
<td><p>64</p></td>
<td><p>89</p></td>
<td><p>719.1</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>25</p></td>
<td><p>128</p></td>
<td><p>153</p></td>
<td><p>836.6</p></td>
</tr>
</tbody>
</table>
<p>When a transaction length is short, the cost of the transaction interval is high. If possible, try to squash several short transactions into one transaction to achieve a higher transfer speed.</p>
<p>Please note that the ISR is disabled during flash operation by default. To keep sending transactions during flash operations, enable <a class="reference internal" href="../kconfig.html#config-spi-master-isr-in-iram"><span class="std std-ref">CONFIG_SPI_MASTER_ISR_IN_IRAM</span></a> and set <code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_INTR_FLAG_IRAM</span></code> in the member <a class="reference internal" href="#_CPPv4N16spi_bus_config_t10intr_flagsE" title="spi_bus_config_t::intr_flags"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_bus_config_t::intr_flags</span></code></a>. In this case, all the transactions queued before starting flash operations are handled by the ISR in parallel. Also note that the callback of each Device and their <code class="docutils literal notranslate"><span class="pre">callee</span></code> functions should be in IRAM, or your callback will crash due to cache missing. For more details, see <a class="reference internal" href="spi_flash/spi_flash_concurrency.html#iram-safe-interrupt-handlers"><span class="std std-ref">IRAM-Safe Interrupt Handlers</span></a>.</p>
</section>
</section>
<section id="timing-considerations">
<span id="id9"></span><h2>Timing Considerations<a class="headerlink" href="#timing-considerations" title="Permalink to this heading"></a></h2>
<p>As shown in the figure below, there is a delay on the MISO line after the SCLK launch edge and before the signal is latched by the internal register. As a result, the MISO pin setup time is the limiting factor for the SPI clock speed. When the delay is too long, the setup slack is &lt; 0, which means the setup timing requirement is violated and the reading might be incorrect.</p>
<a class="reference internal image-reference" href="../../_images/spi_miso.png"><img alt="../../_images/spi_miso.png" class="align-center" src="../../_images/spi_miso.png" style="width: 469.6px; height: 232.0px;" /></a>

<div style="overflow-x:auto">
<script type="WaveDrom">
{
  "signal": [
    {
      "name": "SCLK",
      "wave": "p...",
      "node": ".ad..."
    },
    {
      "name": "MISO",
      "wave": "x3x.",
      "node": ".b...",
      "phase": -1.8
    },
    {
      "name": "MISO delayed",
      "wave": "x3x.",
      "node": ".c.",
      "phase": -2.4
    }
  ],
  "edge": [
    "a|->b input delay",
    "b|->c gpio delay",
    "c-|>d setup slack"
  ],
  "config": {
    "hscale": 3
  }
}

</script>
</div>
<p>The maximum allowed frequency is dependent on:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N29spi_device_interface_config_t14input_delay_nsE" title="spi_device_interface_config_t::input_delay_ns"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_interface_config_t::input_delay_ns</span></code></a> - maximum data valid time on the MISO bus after a clock cycle on SCLK starts</p></li>
<li><p>If the IO_MUX pin or the GPIO Matrix is used</p></li>
</ul>
<p>When the GPIO matrix is used, the maximum allowed frequency is reduced to about 33 ~ 77% in comparison to the existing <strong>input delay</strong>. To retain a higher frequency, you have to use the IO_MUX pins or the <strong>dummy bit workaround</strong>. You can obtain the maximum reading frequency of the master by using the function <a class="reference internal" href="#_CPPv418spi_get_freq_limitbi" title="spi_get_freq_limit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_get_freq_limit()</span></code></a>.</p>
<p id="dummy-bit-workaround"><strong>Dummy bit workaround</strong>: Dummy clocks, during which the Host does not read data, can be inserted before the Read phase begins. The Device still sees the dummy clocks and sends out data, but the Host does not read until the Read phase comes. This compensates for the lack of the MISO setup time required by the Host and allows the Host to do reading at a higher frequency.</p>
<p>In the ideal case, if the Device is so fast that the input delay is shorter than an APB clock cycle - 12.5 ns - the maximum frequency at which the Host can read (or read and write) in different conditions is as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20.7%" />
<col style="width: 31.0%" />
<col style="width: 27.6%" />
<col style="width: 20.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Frequency Limit (MHz)</p></th>
<th class="head"><p>Frequency Limit (MHz)</p></th>
<th class="head"><p>Dummy Bits Used by Driver</p></th>
<th class="head"><p>Comments</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>GPIO Matrix</p></td>
<td><p>IO_MUX Pins</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>26.6</p></td>
<td><p>80</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>40</p></td>
<td><p>--</p></td>
<td><p>Yes</p></td>
<td><p>Half-duplex, no DMA allowed</p></td>
</tr>
</tbody>
</table>
<p>If the Host only writes data, the <strong>dummy bit workaround</strong> and the frequency check can be disabled by setting the bit <code class="docutils literal notranslate"><span class="pre">SPI_DEVICE_NO_DUMMY</span></code> in the member <a class="reference internal" href="#_CPPv4N29spi_device_interface_config_t5flagsE" title="spi_device_interface_config_t::flags"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_interface_config_t::flags</span></code></a>. When disabled, the output frequency can be 80 MHz, even if the GPIO matrix is used.</p>
<p><a class="reference internal" href="#_CPPv4N29spi_device_interface_config_t5flagsE" title="spi_device_interface_config_t::flags"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_interface_config_t::flags</span></code></a></p>
<p>The SPI Master driver still works even if the <a class="reference internal" href="#_CPPv4N29spi_device_interface_config_t14input_delay_nsE" title="spi_device_interface_config_t::input_delay_ns"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">spi_device_interface_config_t::input_delay_ns</span></code></a> in the structure <a class="reference internal" href="#_CPPv429spi_device_interface_config_t" title="spi_device_interface_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_device_interface_config_t</span></code></a> is set to 0. However, setting an accurate value helps to:</p>
<ul class="simple">
<li><p>Calculate the frequency limit for full-duplex transactions</p></li>
<li><p>Compensate the timing correctly with dummy bits for half-duplex transactions</p></li>
</ul>
<p>You can approximate the maximum data valid time after the launch edge of SPI clocks by checking the statistics in the AC characteristics chapter of your Device's specification or measure the time using an oscilloscope or logic analyzer.</p>
<p>Please note that the actual PCB layout design and excessive loads may increase the input delay. It means that non-optimal wiring and/or a load capacitor on the bus will most likely lead to input delay values exceeding the values given in the Device specification or measured while the bus is floating.</p>
<p>Some typical delay values are shown in the following table. These data are retrieved when the slave Device is on a different physical chip.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 66.7%" />
<col style="width: 33.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Device</p></th>
<th class="head"><p>Input Delay (ns)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Ideal Device</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>ESP32 slave using IO_MUX</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-even"><td><p>ESP32 slave using GPIO_MATRIX</p></td>
<td><p>75</p></td>
</tr>
</tbody>
</table>
<p>The MISO path delay (valid time) consists of a slave's <strong>input delay</strong> plus the master's <strong>GPIO matrix delay</strong>. The delay determines the above frequency limit for full-duplex transfers. Once exceeding, full-duplex transfers will not work as well as the half-duplex transactions that use dummy bits. The frequency limit is:</p>
<blockquote>
<div><p><em>Freq limit [MHz] = 80 / (floor(MISO delay[ns]/12.5) + 1)</em></p>
</div></blockquote>
<p>The figure below shows the relationship between frequency limit and input delay. Two extra APB clock cycle periods should be added to the MISO delay if the master uses the GPIO matrix.</p>
<img alt="../../_images/spi_master_freq_tv.png" src="../../_images/spi_master_freq_tv.png" />
<p>Corresponding frequency limits for different Devices with different <strong>input delay</strong> times are shown in the table below.</p>
<p>When the master is IO_MUX (0 ns):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20.0%" />
<col style="width: 40.0%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Input Delay (ns)</p></th>
<th class="head"><p>MISO Path Delay (ns)</p></th>
<th class="head"><p>Freq. Limit (MHz)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>80</p></td>
</tr>
<tr class="row-odd"><td><p>50</p></td>
<td><p>50</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-even"><td><p>75</p></td>
<td><p>75</p></td>
<td><p>11.43</p></td>
</tr>
</tbody>
</table>
<p>When the master is GPIO_MATRIX (25 ns):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20.0%" />
<col style="width: 40.0%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Input Delay (ns)</p></th>
<th class="head"><p>MISO Path Delay (ns)</p></th>
<th class="head"><p>Freq. Limit (MHz)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>25</p></td>
<td><p>26.67</p></td>
</tr>
<tr class="row-odd"><td><p>50</p></td>
<td><p>75</p></td>
<td><p>11.43</p></td>
</tr>
<tr class="row-even"><td><p>75</p></td>
<td><p>100</p></td>
<td><p>8.89</p></td>
</tr>
</tbody>
</table>
</section>
<section id="known-issues">
<span id="spi-known-issues"></span><h2>Known Issues<a class="headerlink" href="#known-issues" title="Permalink to this heading"></a></h2>
<ol class="arabic">
<li><p>Half-duplex transactions are not compatible with DMA when both the Write and Read phases are used.</p>
<blockquote>
<div><p>If such transactions are required, you have to use one of the alternative solutions:</p>
<ol class="arabic simple">
<li><p>Use full-duplex transactions instead.</p></li>
<li><dl class="simple">
<dt>Disable DMA by setting the bus initialization function's last parameter to 0 as follows:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">ret=spi_bus_initialize(VSPI_HOST,</span> <span class="pre">&amp;buscfg,</span> <span class="pre">0);</span></code></p>
</dd>
</dl>
</li>
</ol>
<p>This can prohibit you from transmitting and receiving data longer than 64 bytes.
3. Try using the command and address fields to replace the Write phase.</p>
</div></blockquote>
</li>
<li><p>Full-duplex transactions are not compatible with the <strong>dummy bit workaround</strong>, hence the frequency is limited. See <a class="reference internal" href="#dummy-bit-workaround"><span class="std std-ref">dummy bit speed-up workaround</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dummy_bits</span></code> in <a class="reference internal" href="#_CPPv429spi_device_interface_config_t" title="spi_device_interface_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_device_interface_config_t</span></code></a> and <a class="reference internal" href="#_CPPv421spi_transaction_ext_t" title="spi_transaction_ext_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">spi_transaction_ext_t</span></code></a> are not available when SPI Read and Write phases are both enabled (regardless of full duplex or half duplex mode).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cs_ena_pretrans</span></code> is not compatible with the Command and Address phases of full-duplex transactions.</p></li>
</ol>
</section>
<section id="application-examples">
<h2>Application Examples<a class="headerlink" href="#application-examples" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/spi_master/hd_eeprom">peripherals/spi_master/hd_eeprom</a> demonstrates how to use the SPI master half duplex mode to read/write an AT93C46D EEPROM (8-bit mode) on ESP32.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/spi_master/lcd">peripherals/spi_master/lcd</a> demonstrates how to use the SPI master driver to display an animation on the LCD. With the help of the DMA, we can do render and flush in parallel. This example also illustrates using the SPI transaction hook function to drive the D/C signal level.</p></li>
</ul>
</section>
<section id="api-reference-spi-common">
<h2>API Reference - SPI Common<a class="headerlink" href="#api-reference-spi-common" title="Permalink to this heading"></a></h2>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/hal/include/hal/spi_types.h">components/hal/include/hal/spi_types.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;hal/spi_types.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv415spi_line_mode_t">
<span id="_CPPv315spi_line_mode_t"></span><span id="_CPPv215spi_line_mode_t"></span><span id="spi_line_mode_t"></span><span class="target" id="structspi__line__mode__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_line_mode_t</span></span></span><a class="headerlink" href="#_CPPv415spi_line_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Line mode of SPI transaction phases: CMD, ADDR, DOUT/DIN. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N15spi_line_mode_t9cmd_linesE">
<span id="_CPPv3N15spi_line_mode_t9cmd_linesE"></span><span id="_CPPv2N15spi_line_mode_t9cmd_linesE"></span><span id="spi_line_mode_t::cmd_lines__uint8_t"></span><span class="target" id="structspi__line__mode__t_1a947a61073638a5f391615cabf782d7e1"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cmd_lines</span></span></span><a class="headerlink" href="#_CPPv4N15spi_line_mode_t9cmd_linesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The line width of command phase, e.g. 2-line-cmd-phase. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N15spi_line_mode_t10addr_linesE">
<span id="_CPPv3N15spi_line_mode_t10addr_linesE"></span><span id="_CPPv2N15spi_line_mode_t10addr_linesE"></span><span id="spi_line_mode_t::addr_lines__uint8_t"></span><span class="target" id="structspi__line__mode__t_1a572abacce091fa5d1f158d8868ae1add"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">addr_lines</span></span></span><a class="headerlink" href="#_CPPv4N15spi_line_mode_t10addr_linesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The line width of address phase, e.g. 1-line-addr-phase. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N15spi_line_mode_t10data_linesE">
<span id="_CPPv3N15spi_line_mode_t10data_linesE"></span><span id="_CPPv2N15spi_line_mode_t10data_linesE"></span><span id="spi_line_mode_t::data_lines__uint8_t"></span><span class="target" id="structspi__line__mode__t_1aed5a53120566b44fc99f25058bdcf4ce"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data_lines</span></span></span><a class="headerlink" href="#_CPPv4N15spi_line_mode_t10data_linesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The line width of data phase, e.g. 4-line-data-phase. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv418spi_clock_source_t">
<span id="_CPPv318spi_clock_source_t"></span><span id="_CPPv218spi_clock_source_t"></span><span id="spi_clock_source_t"></span><span class="target" id="spi__types_8h_1a2413c140ab910a6cecdfa070eee38e95"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="clk_tree.html#_CPPv424soc_periph_spi_clk_src_t" title="soc_periph_spi_clk_src_t"><span class="n"><span class="pre">soc_periph_spi_clk_src_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_clock_source_t</span></span></span><a class="headerlink" href="#_CPPv418spi_clock_source_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of SPI clock source. </p>
</dd></dl>

</section>
<section id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv417spi_host_device_t">
<span id="_CPPv317spi_host_device_t"></span><span id="_CPPv217spi_host_device_t"></span><span class="target" id="spi__types_8h_1aa196928ee9779318e49d008c00277957"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_host_device_t</span></span></span><a class="headerlink" href="#_CPPv417spi_host_device_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enum with the three SPI peripherals that are software-accessible in it. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_host_device_t9SPI1_HOSTE">
<span id="_CPPv3N17spi_host_device_t9SPI1_HOSTE"></span><span id="_CPPv2N17spi_host_device_t9SPI1_HOSTE"></span><span class="target" id="spi__types_8h_1aa196928ee9779318e49d008c00277957acef0912a11f1b6a8acc4a44161769ed1"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI1_HOST</span></span></span><a class="headerlink" href="#_CPPv4N17spi_host_device_t9SPI1_HOSTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI1. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_host_device_t9SPI2_HOSTE">
<span id="_CPPv3N17spi_host_device_t9SPI2_HOSTE"></span><span id="_CPPv2N17spi_host_device_t9SPI2_HOSTE"></span><span class="target" id="spi__types_8h_1aa196928ee9779318e49d008c00277957a729a6771ecd9ed5d633e273ff36e9aca"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI2_HOST</span></span></span><a class="headerlink" href="#_CPPv4N17spi_host_device_t9SPI2_HOSTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI2. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_host_device_t9SPI3_HOSTE">
<span id="_CPPv3N17spi_host_device_t9SPI3_HOSTE"></span><span id="_CPPv2N17spi_host_device_t9SPI3_HOSTE"></span><span class="target" id="spi__types_8h_1aa196928ee9779318e49d008c00277957a21f0274157cd0c5f89f22a6d58cba308"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI3_HOST</span></span></span><a class="headerlink" href="#_CPPv4N17spi_host_device_t9SPI3_HOSTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI3. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_host_device_t12SPI_HOST_MAXE">
<span id="_CPPv3N17spi_host_device_t12SPI_HOST_MAXE"></span><span id="_CPPv2N17spi_host_device_t12SPI_HOST_MAXE"></span><span class="target" id="spi__types_8h_1aa196928ee9779318e49d008c00277957acd0fa724efddca10e598dd369de362d0"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_HOST_MAX</span></span></span><a class="headerlink" href="#_CPPv4N17spi_host_device_t12SPI_HOST_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd><p>invalid host value </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv411spi_event_t">
<span id="_CPPv311spi_event_t"></span><span id="_CPPv211spi_event_t"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54c"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_event_t</span></span></span><a class="headerlink" href="#_CPPv411spi_event_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI Events. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11spi_event_t13SPI_EV_BUF_TXE">
<span id="_CPPv3N11spi_event_t13SPI_EV_BUF_TXE"></span><span id="_CPPv2N11spi_event_t13SPI_EV_BUF_TXE"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54cabba4d823328c6e43824ebee255365ec2"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_EV_BUF_TX</span></span></span><a class="headerlink" href="#_CPPv4N11spi_event_t13SPI_EV_BUF_TXE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The buffer has sent data to master. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11spi_event_t13SPI_EV_BUF_RXE">
<span id="_CPPv3N11spi_event_t13SPI_EV_BUF_RXE"></span><span id="_CPPv2N11spi_event_t13SPI_EV_BUF_RXE"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54caac8088da3ad4a667b277e213a1afa3ca"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_EV_BUF_RX</span></span></span><a class="headerlink" href="#_CPPv4N11spi_event_t13SPI_EV_BUF_RXE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The buffer has received data from master. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11spi_event_t21SPI_EV_SEND_DMA_READYE">
<span id="_CPPv3N11spi_event_t21SPI_EV_SEND_DMA_READYE"></span><span id="_CPPv2N11spi_event_t21SPI_EV_SEND_DMA_READYE"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54ca85767ac638a80978a03c66212e77b810"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_EV_SEND_DMA_READY</span></span></span><a class="headerlink" href="#_CPPv4N11spi_event_t21SPI_EV_SEND_DMA_READYE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Slave has loaded its TX data buffer to the hardware (DMA). </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11spi_event_t11SPI_EV_SENDE">
<span id="_CPPv3N11spi_event_t11SPI_EV_SENDE"></span><span id="_CPPv2N11spi_event_t11SPI_EV_SENDE"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54cad5b3f6e614b83708a56bd93a6574ddf7"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_EV_SEND</span></span></span><a class="headerlink" href="#_CPPv4N11spi_event_t11SPI_EV_SENDE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Master has received certain number of the data, the number is determined by Master. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11spi_event_t21SPI_EV_RECV_DMA_READYE">
<span id="_CPPv3N11spi_event_t21SPI_EV_RECV_DMA_READYE"></span><span id="_CPPv2N11spi_event_t21SPI_EV_RECV_DMA_READYE"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54caf6054e2b0cece60d0b5bf9eca04ef864"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_EV_RECV_DMA_READY</span></span></span><a class="headerlink" href="#_CPPv4N11spi_event_t21SPI_EV_RECV_DMA_READYE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Slave has loaded its RX data buffer to the hardware (DMA). </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11spi_event_t11SPI_EV_RECVE">
<span id="_CPPv3N11spi_event_t11SPI_EV_RECVE"></span><span id="_CPPv2N11spi_event_t11SPI_EV_RECVE"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54ca0311bdd2b9592cc112e5f05c12f37b20"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_EV_RECV</span></span></span><a class="headerlink" href="#_CPPv4N11spi_event_t11SPI_EV_RECVE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Slave has received certain number of data from master, the number is determined by Master. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11spi_event_t11SPI_EV_CMD9E">
<span id="_CPPv3N11spi_event_t11SPI_EV_CMD9E"></span><span id="_CPPv2N11spi_event_t11SPI_EV_CMD9E"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54ca75d41d8f6abcd16cc41c7ec60d7a4b5a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_EV_CMD9</span></span></span><a class="headerlink" href="#_CPPv4N11spi_event_t11SPI_EV_CMD9E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Received CMD9 from master. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11spi_event_t11SPI_EV_CMDAE">
<span id="_CPPv3N11spi_event_t11SPI_EV_CMDAE"></span><span id="_CPPv2N11spi_event_t11SPI_EV_CMDAE"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54cac27d0f89d9d661105c541e21dff1d4a2"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_EV_CMDA</span></span></span><a class="headerlink" href="#_CPPv4N11spi_event_t11SPI_EV_CMDAE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Received CMDA from master. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11spi_event_t12SPI_EV_TRANSE">
<span id="_CPPv3N11spi_event_t12SPI_EV_TRANSE"></span><span id="_CPPv2N11spi_event_t12SPI_EV_TRANSE"></span><span class="target" id="spi__types_8h_1a6e4960e8b344a8a8ec60f0c11d60f54cac5a06d4a565a96f568401eea14afab58"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_EV_TRANS</span></span></span><a class="headerlink" href="#_CPPv4N11spi_event_t12SPI_EV_TRANSE" title="Permalink to this definition"></a><br /></dt>
<dd><p>A transaction has done. </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv413spi_command_t">
<span id="_CPPv313spi_command_t"></span><span id="_CPPv213spi_command_t"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89c"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_command_t</span></span></span><a class="headerlink" href="#_CPPv413spi_command_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI command. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t16SPI_CMD_HD_WRBUFE">
<span id="_CPPv3N13spi_command_t16SPI_CMD_HD_WRBUFE"></span><span id="_CPPv2N13spi_command_t16SPI_CMD_HD_WRBUFE"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89cae5cf272a43b983e60dad3560d55dda98"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_WRBUF</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t16SPI_CMD_HD_WRBUFE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t16SPI_CMD_HD_RDBUFE">
<span id="_CPPv3N13spi_command_t16SPI_CMD_HD_RDBUFE"></span><span id="_CPPv2N13spi_command_t16SPI_CMD_HD_RDBUFE"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89ca73e9bf88dd21088fa4309b29499af647"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_RDBUF</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t16SPI_CMD_HD_RDBUFE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t16SPI_CMD_HD_WRDMAE">
<span id="_CPPv3N13spi_command_t16SPI_CMD_HD_WRDMAE"></span><span id="_CPPv2N13spi_command_t16SPI_CMD_HD_WRDMAE"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89cab2c436836458cb6049fc652c9704792d"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_WRDMA</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t16SPI_CMD_HD_WRDMAE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t16SPI_CMD_HD_RDDMAE">
<span id="_CPPv3N13spi_command_t16SPI_CMD_HD_RDDMAE"></span><span id="_CPPv2N13spi_command_t16SPI_CMD_HD_RDDMAE"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89cad8228b94db6725b0e4e13baf7aeda2f9"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_RDDMA</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t16SPI_CMD_HD_RDDMAE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t18SPI_CMD_HD_SEG_ENDE">
<span id="_CPPv3N13spi_command_t18SPI_CMD_HD_SEG_ENDE"></span><span id="_CPPv2N13spi_command_t18SPI_CMD_HD_SEG_ENDE"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89cac61053107f46a48b63c7097e60bae257"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_SEG_END</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t18SPI_CMD_HD_SEG_ENDE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t17SPI_CMD_HD_EN_QPIE">
<span id="_CPPv3N13spi_command_t17SPI_CMD_HD_EN_QPIE"></span><span id="_CPPv2N13spi_command_t17SPI_CMD_HD_EN_QPIE"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89caa0bf55e3af160cc090087434819ca45a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_EN_QPI</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t17SPI_CMD_HD_EN_QPIE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t17SPI_CMD_HD_WR_ENDE">
<span id="_CPPv3N13spi_command_t17SPI_CMD_HD_WR_ENDE"></span><span id="_CPPv2N13spi_command_t17SPI_CMD_HD_WR_ENDE"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89caffbf36c04773c796d40a90c383e62554"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_WR_END</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t17SPI_CMD_HD_WR_ENDE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t15SPI_CMD_HD_INT0E">
<span id="_CPPv3N13spi_command_t15SPI_CMD_HD_INT0E"></span><span id="_CPPv2N13spi_command_t15SPI_CMD_HD_INT0E"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89cae94e949edb73b416dfdd03815f506d5b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_INT0</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t15SPI_CMD_HD_INT0E" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t15SPI_CMD_HD_INT1E">
<span id="_CPPv3N13spi_command_t15SPI_CMD_HD_INT1E"></span><span id="_CPPv2N13spi_command_t15SPI_CMD_HD_INT1E"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89cadb92ff0aede1a2ff61c4a0347db82c2e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_INT1</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t15SPI_CMD_HD_INT1E" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13spi_command_t15SPI_CMD_HD_INT2E">
<span id="_CPPv3N13spi_command_t15SPI_CMD_HD_INT2E"></span><span id="_CPPv2N13spi_command_t15SPI_CMD_HD_INT2E"></span><span class="target" id="spi__types_8h_1a2d0cd2f78a0a02cd912bd3356849d89ca99a8b0aede388100658039d61768704c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_CMD_HD_INT2</span></span></span><a class="headerlink" href="#_CPPv4N13spi_command_t15SPI_CMD_HD_INT2E" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv420spi_sampling_point_t">
<span id="_CPPv320spi_sampling_point_t"></span><span id="_CPPv220spi_sampling_point_t"></span><span class="target" id="spi__types_8h_1ade282d86fda8f925dc5f6bcd14a2e067"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_sampling_point_t</span></span></span><a class="headerlink" href="#_CPPv420spi_sampling_point_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI master RX sample point mode configuration. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N20spi_sampling_point_t26SPI_SAMPLING_POINT_PHASE_0E">
<span id="_CPPv3N20spi_sampling_point_t26SPI_SAMPLING_POINT_PHASE_0E"></span><span id="_CPPv2N20spi_sampling_point_t26SPI_SAMPLING_POINT_PHASE_0E"></span><span class="target" id="spi__types_8h_1ade282d86fda8f925dc5f6bcd14a2e067a616d04c386a00abfce0e8ed042ec1922"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_SAMPLING_POINT_PHASE_0</span></span></span><a class="headerlink" href="#_CPPv4N20spi_sampling_point_t26SPI_SAMPLING_POINT_PHASE_0E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Data sampling point at 50% cycle delayed then standard timing, (default). </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N20spi_sampling_point_t26SPI_SAMPLING_POINT_PHASE_1E">
<span id="_CPPv3N20spi_sampling_point_t26SPI_SAMPLING_POINT_PHASE_1E"></span><span id="_CPPv2N20spi_sampling_point_t26SPI_SAMPLING_POINT_PHASE_1E"></span><span class="target" id="spi__types_8h_1ade282d86fda8f925dc5f6bcd14a2e067a34aded40521833da4fa024936d5def19"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_SAMPLING_POINT_PHASE_1</span></span></span><a class="headerlink" href="#_CPPv4N20spi_sampling_point_t26SPI_SAMPLING_POINT_PHASE_1E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Data sampling point follows standard SPI timing in master mode. </p>
</dd></dl>

</dd></dl>

</section>
<section id="id10">
<h3>Header File<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_spi/include/driver/spi_common.h">components/esp_driver_spi/include/driver/spi_common.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/spi_common.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_spi</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_spi</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_spi
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_spi
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418spi_bus_initialize17spi_host_device_tPK16spi_bus_config_t14spi_dma_chan_t">
<span id="_CPPv318spi_bus_initialize17spi_host_device_tPK16spi_bus_config_t14spi_dma_chan_t"></span><span id="_CPPv218spi_bus_initialize17spi_host_device_tPK16spi_bus_config_t14spi_dma_chan_t"></span><span id="spi_bus_initialize__spi_host_device_t.spi_bus_config_tCP.spi_dma_chan_t"></span><span class="target" id="spi__common_8h_1a073f1915373336b53c30adbc4046f615"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_bus_initialize</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417spi_host_device_t" title="spi_host_device_t"><span class="n"><span class="pre">spi_host_device_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">host_id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416spi_bus_config_t" title="spi_bus_config_t"><span class="n"><span class="pre">spi_bus_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">bus_config</span></span>, <a class="reference internal" href="#_CPPv414spi_dma_chan_t" title="spi_dma_chan_t"><span class="n"><span class="pre">spi_dma_chan_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">dma_chan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418spi_bus_initialize17spi_host_device_tPK16spi_bus_config_t14spi_dma_chan_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize a SPI bus. </p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>SPI0/1 is not supported</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If a DMA channel is selected, any transmit and receive buffer used should be allocated in DMA-capable memory.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The ISR of SPI is always executed on the core which calls this function. Never starve the ISR on this core or the SPI transactions will not be handled.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> -- SPI peripheral that controls this bus </p></li>
<li><p><strong>bus_config</strong> -- Pointer to a <a class="reference internal" href="#structspi__bus__config__t"><span class="std std-ref">spi_bus_config_t</span></a> struct specifying how the host should be initialized </p></li>
<li><p><strong>dma_chan</strong> -- - Selecting a DMA channel for an SPI bus allows transactions on the bus with size only limited by the amount of internal memory.<ul>
<li><p>Selecting SPI_DMA_DISABLED limits the size of transactions.</p></li>
<li><p>Set to SPI_DMA_DISABLED if only the SPI flash uses this bus.</p></li>
<li><p>Set to SPI_DMA_CH_AUTO to let the driver to allocate the DMA channel.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if configuration is invalid</p></li>
<li><p>ESP_ERR_INVALID_STATE if host already is in use</p></li>
<li><p>ESP_ERR_NOT_FOUND if there is no available DMA channel</p></li>
<li><p>ESP_ERR_NO_MEM if out of memory</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412spi_bus_free17spi_host_device_t">
<span id="_CPPv312spi_bus_free17spi_host_device_t"></span><span id="_CPPv212spi_bus_free17spi_host_device_t"></span><span id="spi_bus_free__spi_host_device_t"></span><span class="target" id="spi__common_8h_1a00aff593aec59b26ba0da3072d9f99a0"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_bus_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417spi_host_device_t" title="spi_host_device_t"><span class="n"><span class="pre">spi_host_device_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">host_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412spi_bus_free17spi_host_device_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Free a SPI bus. </p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In order for this to succeed, all devices have to be removed first.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>host_id</strong> -- SPI peripheral to free </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if parameter is invalid</p></li>
<li><p>ESP_ERR_INVALID_STATE if bus hasn't been initialized before, or not all devices on the bus are freed</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424spi_bus_dma_memory_alloc17spi_host_device_t6size_t8uint32_t">
<span id="_CPPv324spi_bus_dma_memory_alloc17spi_host_device_t6size_t8uint32_t"></span><span id="_CPPv224spi_bus_dma_memory_alloc17spi_host_device_t6size_t8uint32_t"></span><span id="spi_bus_dma_memory_alloc__spi_host_device_t.s.uint32_t"></span><span class="target" id="spi__common_8h_1aa3eee0326904feea263fe301c75d8ea8"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">spi_bus_dma_memory_alloc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417spi_host_device_t" title="spi_host_device_t"><span class="n"><span class="pre">spi_host_device_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">host_id</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">size</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">extra_heap_caps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424spi_bus_dma_memory_alloc17spi_host_device_t6size_t8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Helper function for malloc DMA capable memory for SPI driver. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This API will take care of the cache and hardware alignment internally. To free/release memory allocated by this helper function, simply calling <code class="docutils literal notranslate"><span class="pre">free()</span></code></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> -- <strong>[in]</strong> SPI peripheral who will using the memory </p></li>
<li><p><strong>size</strong> -- <strong>[in]</strong> Size in bytes, the amount of memory to allocate </p></li>
<li><p><strong>extra_heap_caps</strong> -- <strong>[in]</strong> Extra heap caps based on MALLOC_CAP_DMA</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to the memory if allocated successfully </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id11">
<h3>Structures<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv416spi_bus_config_t">
<span id="_CPPv316spi_bus_config_t"></span><span id="_CPPv216spi_bus_config_t"></span><span id="spi_bus_config_t"></span><span class="target" id="structspi__bus__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_bus_config_t</span></span></span><a class="headerlink" href="#_CPPv416spi_bus_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>This is a configuration structure for a SPI bus. </p>
<p>You can use this structure to specify the GPIO pins of the bus. Normally, the driver will use the GPIO matrix to route the signals. An exception is made when all signals either can be routed through the IO_MUX or are -1. In that case, the IO_MUX is used. On ESP32, using GPIO matrix will bring about 25ns of input delay, which may cause incorrect read for &gt;40MHz speeds.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be advised that the slave driver does not use the quadwp/quadhd lines and fields in <a class="reference internal" href="#structspi__bus__config__t"><span class="std std-ref">spi_bus_config_t</span></a> referring to these lines will be ignored and can thus safely be left uninitialized. </p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t11mosi_io_numE">
<span id="_CPPv3N16spi_bus_config_t11mosi_io_numE"></span><span id="_CPPv2N16spi_bus_config_t11mosi_io_numE"></span><span id="spi_bus_config_t::mosi_io_num__i"></span><span class="target" id="structspi__bus__config__t_1a82825092dbb29dd81a78ab7a706c5b37"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mosi_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t11mosi_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for Master Out Slave In (=spi_d) signal, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t12data0_io_numE">
<span id="_CPPv3N16spi_bus_config_t12data0_io_numE"></span><span id="_CPPv2N16spi_bus_config_t12data0_io_numE"></span><span id="spi_bus_config_t::data0_io_num__i"></span><span class="target" id="structspi__bus__config__t_1af1ca0216e6af1318427ce5df81cfe0d3"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data0_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t12data0_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for spi data0 signal in quad/octal mode, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t11miso_io_numE">
<span id="_CPPv3N16spi_bus_config_t11miso_io_numE"></span><span id="_CPPv2N16spi_bus_config_t11miso_io_numE"></span><span id="spi_bus_config_t::miso_io_num__i"></span><span class="target" id="structspi__bus__config__t_1ac37cd9e29476f602817964caff0dbbb0"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">miso_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t11miso_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for Master In Slave Out (=spi_q) signal, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t12data1_io_numE">
<span id="_CPPv3N16spi_bus_config_t12data1_io_numE"></span><span id="_CPPv2N16spi_bus_config_t12data1_io_numE"></span><span id="spi_bus_config_t::data1_io_num__i"></span><span class="target" id="structspi__bus__config__t_1a3324115a42aeb36be986c8cc2977caf3"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data1_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t12data1_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for spi data1 signal in quad/octal mode, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t11sclk_io_numE">
<span id="_CPPv3N16spi_bus_config_t11sclk_io_numE"></span><span id="_CPPv2N16spi_bus_config_t11sclk_io_numE"></span><span id="spi_bus_config_t::sclk_io_num__i"></span><span class="target" id="structspi__bus__config__t_1a7d1f0398744dece53cffb45a45a6b02f"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sclk_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t11sclk_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for SPI Clock signal, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t13quadwp_io_numE">
<span id="_CPPv3N16spi_bus_config_t13quadwp_io_numE"></span><span id="_CPPv2N16spi_bus_config_t13quadwp_io_numE"></span><span id="spi_bus_config_t::quadwp_io_num__i"></span><span class="target" id="structspi__bus__config__t_1a79206359c613c99a5a4935abe53fca96"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">quadwp_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t13quadwp_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for WP (Write Protect) signal, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t12data2_io_numE">
<span id="_CPPv3N16spi_bus_config_t12data2_io_numE"></span><span id="_CPPv2N16spi_bus_config_t12data2_io_numE"></span><span id="spi_bus_config_t::data2_io_num__i"></span><span class="target" id="structspi__bus__config__t_1a98ea623947ccaf9035fe1c72fca8be32"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data2_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t12data2_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for spi data2 signal in quad/octal mode, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t13quadhd_io_numE">
<span id="_CPPv3N16spi_bus_config_t13quadhd_io_numE"></span><span id="_CPPv2N16spi_bus_config_t13quadhd_io_numE"></span><span id="spi_bus_config_t::quadhd_io_num__i"></span><span class="target" id="structspi__bus__config__t_1a175e82d5d219072718241b40db6865a6"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">quadhd_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t13quadhd_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for HD (Hold) signal, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t12data3_io_numE">
<span id="_CPPv3N16spi_bus_config_t12data3_io_numE"></span><span id="_CPPv2N16spi_bus_config_t12data3_io_numE"></span><span id="spi_bus_config_t::data3_io_num__i"></span><span class="target" id="structspi__bus__config__t_1aa89924855816a2c2b7849862f70773f8"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data3_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t12data3_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for spi data3 signal in quad/octal mode, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t12data4_io_numE">
<span id="_CPPv3N16spi_bus_config_t12data4_io_numE"></span><span id="_CPPv2N16spi_bus_config_t12data4_io_numE"></span><span id="spi_bus_config_t::data4_io_num__i"></span><span class="target" id="structspi__bus__config__t_1a58679f5ecaf3c51c5f6aa5294f9e6015"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data4_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t12data4_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for spi data4 signal in octal mode, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t12data5_io_numE">
<span id="_CPPv3N16spi_bus_config_t12data5_io_numE"></span><span id="_CPPv2N16spi_bus_config_t12data5_io_numE"></span><span id="spi_bus_config_t::data5_io_num__i"></span><span class="target" id="structspi__bus__config__t_1a10967d851bada19914c2d17f6ba02aae"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data5_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t12data5_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for spi data5 signal in octal mode, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t12data6_io_numE">
<span id="_CPPv3N16spi_bus_config_t12data6_io_numE"></span><span id="_CPPv2N16spi_bus_config_t12data6_io_numE"></span><span id="spi_bus_config_t::data6_io_num__i"></span><span class="target" id="structspi__bus__config__t_1ac87a4ced185ddb25d676354b9782242e"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data6_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t12data6_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for spi data6 signal in octal mode, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t12data7_io_numE">
<span id="_CPPv3N16spi_bus_config_t12data7_io_numE"></span><span id="_CPPv2N16spi_bus_config_t12data7_io_numE"></span><span id="spi_bus_config_t::data7_io_num__i"></span><span class="target" id="structspi__bus__config__t_1ae918979b1ea67608e720d806cf8c0f9d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data7_io_num</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t12data7_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPIO pin for spi data7 signal in octal mode, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t21data_io_default_levelE">
<span id="_CPPv3N16spi_bus_config_t21data_io_default_levelE"></span><span id="_CPPv2N16spi_bus_config_t21data_io_default_levelE"></span><span id="spi_bus_config_t::data_io_default_level__b"></span><span class="target" id="structspi__bus__config__t_1a8f943ba2e8afc949e2386218673d0c20"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">data_io_default_level</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t21data_io_default_levelE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Output data IO default level when no transaction. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t15max_transfer_szE">
<span id="_CPPv3N16spi_bus_config_t15max_transfer_szE"></span><span id="_CPPv2N16spi_bus_config_t15max_transfer_szE"></span><span id="spi_bus_config_t::max_transfer_sz__i"></span><span class="target" id="structspi__bus__config__t_1aa410adc675cc48fdc0b0b7e4d49dff17"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_transfer_sz</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t15max_transfer_szE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Maximum transfer size, in bytes. Defaults to 4092 if 0 when DMA enabled, or to <code class="docutils literal notranslate"><span class="pre">SOC_SPI_MAXIMUM_BUFFER_SIZE</span></code> if DMA is disabled. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t5flagsE">
<span id="_CPPv3N16spi_bus_config_t5flagsE"></span><span id="_CPPv2N16spi_bus_config_t5flagsE"></span><span id="spi_bus_config_t::flags__uint32_t"></span><span class="target" id="structspi__bus__config__t_1abcfa56a7c8c40a1693ecd4e04b2974f6"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Abilities of bus to be checked by the driver. Or-ed value of <code class="docutils literal notranslate"><span class="pre">SPICOMMON_BUSFLAG_*</span></code> flags. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t10isr_cpu_idE">
<span id="_CPPv3N16spi_bus_config_t10isr_cpu_idE"></span><span id="_CPPv2N16spi_bus_config_t10isr_cpu_idE"></span><span id="spi_bus_config_t::isr_cpu_id__esp_intr_cpu_affinity_t"></span><span class="target" id="structspi__bus__config__t_1a1bb369bf34008f82421899f35558018d"></span><a class="reference internal" href="../system/intr_alloc.html#_CPPv423esp_intr_cpu_affinity_t" title="esp_intr_cpu_affinity_t"><span class="n"><span class="pre">esp_intr_cpu_affinity_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">isr_cpu_id</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t10isr_cpu_idE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Select cpu core to register SPI ISR. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_bus_config_t10intr_flagsE">
<span id="_CPPv3N16spi_bus_config_t10intr_flagsE"></span><span id="_CPPv2N16spi_bus_config_t10intr_flagsE"></span><span id="spi_bus_config_t::intr_flags__i"></span><span class="target" id="structspi__bus__config__t_1a896901a733f575ef23562b50e182ec7d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">intr_flags</span></span></span><a class="headerlink" href="#_CPPv4N16spi_bus_config_t10intr_flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Interrupt flag for the bus to set the priority, and IRAM attribute, see <code class="docutils literal notranslate"><span class="pre">esp_intr_alloc.h</span></code>. Note that the EDGE, INTRDISABLED attribute are ignored by the driver. Note that if ESP_INTR_FLAG_IRAM is set, ALL the callbacks of the driver, and their callee functions, should be put in the IRAM. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MAX_DMA_LEN">
<span class="target" id="spi__common_8h_1a28d038c3b926bf899d56d94445224e91"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MAX_DMA_LEN</span></span></span><a class="headerlink" href="#c.SPI_MAX_DMA_LEN" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_SWAP_DATA_TX">
<span class="target" id="spi__common_8h_1aa3c78ae3609eb7e6444ccaf746e386da"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_SWAP_DATA_TX</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">DATA</span></span>, <span class="n"><span class="pre">LEN</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.SPI_SWAP_DATA_TX" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transform unsigned integer of length &lt;= 32 bits to the format which can be sent by the SPI driver directly.</p>
<p>E.g. to send 9 bits of data, you can: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">uint16_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">SPI_SWAP_DATA_TX</span><span class="p">(</span><span class="mh">0x145</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</pre></div>
</div>
 Then points tx_buffer to <code class="docutils literal notranslate"><span class="pre">&amp;data</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>DATA</strong> -- Data to be sent, can be uint8_t, uint16_t or uint32_t. </p></li>
<li><p><strong>LEN</strong> -- Length of data to be sent, since the SPI peripheral sends from the MSB, this helps to shift the data to the MSB. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_SWAP_DATA_RX">
<span class="target" id="spi__common_8h_1a65c779521116d561f65aa045b9f70cdd"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_SWAP_DATA_RX</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">DATA</span></span>, <span class="n"><span class="pre">LEN</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.SPI_SWAP_DATA_RX" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transform received data of length &lt;= 32 bits to the format of an unsigned integer.</p>
<p>E.g. to transform the data of 15 bits placed in a 4-byte array to integer: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">uint16_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">SPI_SWAP_DATA_RX</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_data</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>DATA</strong> -- Data to be rearranged, can be uint8_t, uint16_t or uint32_t. </p></li>
<li><p><strong>LEN</strong> -- Length of data received, since the SPI peripheral writes from the MSB, this helps to shift the data to the LSB. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_SLAVE">
<span class="target" id="spi__common_8h_1a2cb9dc9f014fd2c11825dae982850cf3"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_SLAVE</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_SLAVE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize I/O in slave mode. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_MASTER">
<span class="target" id="spi__common_8h_1a91cd9add7317fe9841b76418aa125795"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_MASTER</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_MASTER" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize I/O in master mode. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_IOMUX_PINS">
<span class="target" id="spi__common_8h_1a4a909f13e14d68479cfc9fe1e72b720a"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_IOMUX_PINS</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_IOMUX_PINS" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check using iomux pins. Or indicates the pins are configured through the IO mux rather than GPIO matrix. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_GPIO_PINS">
<span class="target" id="spi__common_8h_1a56962d78a1133a7ccb26c72e13732979"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_GPIO_PINS</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_GPIO_PINS" title="Permalink to this definition"></a><br /></dt>
<dd><p>Force the signals to be routed through GPIO matrix. Or indicates the pins are routed through the GPIO matrix. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_SCLK">
<span class="target" id="spi__common_8h_1a8c323f6823f271b75cd9fcef3a1d8791"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_SCLK</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_SCLK" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check existing of SCLK pin. Or indicates CLK line initialized. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_MISO">
<span class="target" id="spi__common_8h_1add599b1e30e148e9f9134e9f1d704017"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_MISO</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_MISO" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check existing of MISO pin. Or indicates MISO line initialized. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_MOSI">
<span class="target" id="spi__common_8h_1a0ded8d1b02ab49b247710d5843d81c0c"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_MOSI</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_MOSI" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check existing of MOSI pin. Or indicates MOSI line initialized. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_DUAL">
<span class="target" id="spi__common_8h_1a8b37774386e68830a832006250a5818d"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_DUAL</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_DUAL" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check MOSI and MISO pins can output. Or indicates bus able to work under DIO mode. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_WPHD">
<span class="target" id="spi__common_8h_1a27b07b93e521053ceb90d0695be5ca55"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_WPHD</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_WPHD" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check existing of WP and HD pins. Or indicates WP &amp; HD pins initialized. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_QUAD">
<span class="target" id="spi__common_8h_1ab5cdeb953df2abf527e04d1ea5a5d7ec"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_QUAD</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_QUAD" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check existing of MOSI/MISO/WP/HD pins as output. Or indicates bus able to work under QIO mode. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_IO4_IO7">
<span class="target" id="spi__common_8h_1aa1d7a1ad01d1e4f9673e2103b6a2eeb6"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_IO4_IO7</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_IO4_IO7" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check existing of IO4~IO7 pins. Or indicates IO4~IO7 pins initialized. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_OCTAL">
<span class="target" id="spi__common_8h_1a10c743efce568f93a901b6107a9d2434"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_OCTAL</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_OCTAL" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check existing of MOSI/MISO/WP/HD/SPIIO4/SPIIO5/SPIIO6/SPIIO7 pins as output. Or indicates bus able to work under octal mode. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_NATIVE_PINS">
<span class="target" id="spi__common_8h_1ad53c465ea3c5884eddcad1e4949fde16"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_NATIVE_PINS</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_NATIVE_PINS" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPICOMMON_BUSFLAG_SLP_ALLOW_PD">
<span class="target" id="spi__common_8h_1af1bfd5304c8a9647d1fb7e65596080c9"></span><span class="sig-name descname"><span class="n"><span class="pre">SPICOMMON_BUSFLAG_SLP_ALLOW_PD</span></span></span><a class="headerlink" href="#c.SPICOMMON_BUSFLAG_SLP_ALLOW_PD" title="Permalink to this definition"></a><br /></dt>
<dd><p>Allow to power down the peripheral during light sleep, and auto recover then. </p>
</dd></dl>

</section>
<section id="id12">
<h3>Type Definitions<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv414spi_dma_chan_t">
<span id="_CPPv314spi_dma_chan_t"></span><span id="_CPPv214spi_dma_chan_t"></span><span id="spi_dma_chan_t"></span><span class="target" id="spi__common_8h_1aa5942c260f63ebd53a8be5a7f3ac1071"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416spi_common_dma_t" title="spi_common_dma_t"><span class="n"><span class="pre">spi_common_dma_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_dma_chan_t</span></span></span><a class="headerlink" href="#_CPPv414spi_dma_chan_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
<section id="id13">
<h3>Enumerations<a class="headerlink" href="#id13" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv416spi_common_dma_t">
<span id="_CPPv316spi_common_dma_t"></span><span id="_CPPv216spi_common_dma_t"></span><span class="target" id="spi__common_8h_1ae13ba981bbf5c6addf39022371092925"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_common_dma_t</span></span></span><a class="headerlink" href="#_CPPv416spi_common_dma_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI DMA channels. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_common_dma_t16SPI_DMA_DISABLEDE">
<span id="_CPPv3N16spi_common_dma_t16SPI_DMA_DISABLEDE"></span><span id="_CPPv2N16spi_common_dma_t16SPI_DMA_DISABLEDE"></span><span class="target" id="spi__common_8h_1ae13ba981bbf5c6addf39022371092925a31ebbb3a629772927ca11e50697a808a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DMA_DISABLED</span></span></span><a class="headerlink" href="#_CPPv4N16spi_common_dma_t16SPI_DMA_DISABLEDE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Do not enable DMA for SPI. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_common_dma_t11SPI_DMA_CH1E">
<span id="_CPPv3N16spi_common_dma_t11SPI_DMA_CH1E"></span><span id="_CPPv2N16spi_common_dma_t11SPI_DMA_CH1E"></span><span class="target" id="spi__common_8h_1ae13ba981bbf5c6addf39022371092925a124f9de080380fae8b16a04c75cea7a0"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DMA_CH1</span></span></span><a class="headerlink" href="#_CPPv4N16spi_common_dma_t11SPI_DMA_CH1E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enable DMA, select DMA Channel 1. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_common_dma_t11SPI_DMA_CH2E">
<span id="_CPPv3N16spi_common_dma_t11SPI_DMA_CH2E"></span><span id="_CPPv2N16spi_common_dma_t11SPI_DMA_CH2E"></span><span class="target" id="spi__common_8h_1ae13ba981bbf5c6addf39022371092925a2266305a03aaf7ba1317b10dbe456f3e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DMA_CH2</span></span></span><a class="headerlink" href="#_CPPv4N16spi_common_dma_t11SPI_DMA_CH2E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enable DMA, select DMA Channel 2. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16spi_common_dma_t15SPI_DMA_CH_AUTOE">
<span id="_CPPv3N16spi_common_dma_t15SPI_DMA_CH_AUTOE"></span><span id="_CPPv2N16spi_common_dma_t15SPI_DMA_CH_AUTOE"></span><span class="target" id="spi__common_8h_1ae13ba981bbf5c6addf39022371092925ac775c36a2680edb7f521fbb15eff25fa"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DMA_CH_AUTO</span></span></span><a class="headerlink" href="#_CPPv4N16spi_common_dma_t15SPI_DMA_CH_AUTOE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enable DMA, channel is automatically selected by driver. </p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="api-reference-spi-master">
<h2>API Reference - SPI Master<a class="headerlink" href="#api-reference-spi-master" title="Permalink to this heading"></a></h2>
<section id="id14">
<h3>Header File<a class="headerlink" href="#id14" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_driver_spi/include/driver/spi_master.h">components/esp_driver_spi/include/driver/spi_master.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/spi_master.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_spi</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_spi</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_spi
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_spi
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id15">
<h3>Functions<a class="headerlink" href="#id15" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418spi_bus_add_device17spi_host_device_tPK29spi_device_interface_config_tP19spi_device_handle_t">
<span id="_CPPv318spi_bus_add_device17spi_host_device_tPK29spi_device_interface_config_tP19spi_device_handle_t"></span><span id="_CPPv218spi_bus_add_device17spi_host_device_tPK29spi_device_interface_config_tP19spi_device_handle_t"></span><span id="spi_bus_add_device__spi_host_device_t.spi_device_interface_config_tCP.spi_device_handle_tP"></span><span class="target" id="spi__master_8h_1a217b2873b936017d83efc5d056ad1efb"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_bus_add_device</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417spi_host_device_t" title="spi_host_device_t"><span class="n"><span class="pre">spi_host_device_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">host_id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv429spi_device_interface_config_t" title="spi_device_interface_config_t"><span class="n"><span class="pre">spi_device_interface_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dev_config</span></span>, <a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418spi_bus_add_device17spi_host_device_tPK29spi_device_interface_config_tP19spi_device_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Allocate a device on a SPI bus. </p>
<p>This initializes the internal structures for a device, plus allocates a CS pin on the indicated SPI master peripheral and routes it to the indicated GPIO. All SPI master devices have three CS pins and can thus control up to three devices.</p>
<p>
There's no notable delay on chips other than ESP32.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On ESP32, due to the delay of GPIO matrix, the maximum frequency SPI Master can correctly samples the slave's output is lower than the case using IOMUX. Typical maximum frequency communicating with an ideal slave without data output delay: 80MHz (IOMUX pins) and 26MHz (GPIO matrix pins). With the help of extra dummy cycles in half-duplex mode, the delay can be compensated by setting <code class="docutils literal notranslate"><span class="pre">input_delay_ns</span></code> in <code class="docutils literal notranslate"><span class="pre">dev_config</span></code> structure correctly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> -- SPI peripheral to allocate device on </p></li>
<li><p><strong>dev_config</strong> -- SPI interface protocol config for the device </p></li>
<li><p><strong>handle</strong> -- Pointer to variable to hold the device handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if parameter is invalid or configuration combination is not supported (e.g. <code class="docutils literal notranslate"><span class="pre">dev_config-&gt;post_cb</span></code> isn't set while flag <code class="docutils literal notranslate"><span class="pre">SPI_DEVICE_NO_RETURN_RESULT</span></code> is enabled)</p></li>
<li><p>ESP_ERR_INVALID_STATE if selected clock source is unavailable or spi bus not initialized</p></li>
<li><p>ESP_ERR_NOT_FOUND if host doesn't have any free CS slots</p></li>
<li><p>ESP_ERR_NO_MEM if out of memory</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421spi_bus_remove_device19spi_device_handle_t">
<span id="_CPPv321spi_bus_remove_device19spi_device_handle_t"></span><span id="_CPPv221spi_bus_remove_device19spi_device_handle_t"></span><span id="spi_bus_remove_device__spi_device_handle_t"></span><span class="target" id="spi__master_8h_1ab069df1bd29bed4bb240db25b47b245d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_bus_remove_device</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421spi_bus_remove_device19spi_device_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Remove a device from the SPI bus. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- Device handle to free </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if parameter is invalid</p></li>
<li><p>ESP_ERR_INVALID_STATE if device already is freed</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422spi_device_queue_trans19spi_device_handle_tP17spi_transaction_t10TickType_t">
<span id="_CPPv322spi_device_queue_trans19spi_device_handle_tP17spi_transaction_t10TickType_t"></span><span id="_CPPv222spi_device_queue_trans19spi_device_handle_tP17spi_transaction_t10TickType_t"></span><span id="spi_device_queue_trans__spi_device_handle_t.spi_transaction_tP.TickType_t"></span><span class="target" id="spi__master_8h_1a99240e063510ed8cdf08c926a7f2ea3c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_queue_trans</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><span class="n"><span class="pre">spi_transaction_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">trans_desc</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ticks_to_wait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422spi_device_queue_trans19spi_device_handle_tP17spi_transaction_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queue a SPI transaction for interrupt transaction execution. Get the result by <code class="docutils literal notranslate"><span class="pre">spi_device_get_trans_result</span></code>. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Normally a device cannot start (queue) polling and interrupt transactions simultaneously.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- Device handle obtained using spi_host_add_dev </p></li>
<li><p><strong>trans_desc</strong> -- Description of transaction to execute </p></li>
<li><p><strong>ticks_to_wait</strong> -- Ticks to wait until there's room in the queue; use portMAX_DELAY to never time out. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if parameter is invalid. This can happen if SPI_TRANS_CS_KEEP_ACTIVE flag is specified while the bus was not acquired (<code class="docutils literal notranslate"><span class="pre">spi_device_acquire_bus()</span></code> should be called first) or set flag SPI_TRANS_DMA_BUFFER_ALIGN_MANUAL but tx or rx buffer not DMA-capable, or addr&amp;len not align to cache line size</p></li>
<li><p>ESP_ERR_TIMEOUT if there was no room in the queue before ticks_to_wait expired</p></li>
<li><p>ESP_ERR_NO_MEM if allocating DMA-capable temporary buffer failed</p></li>
<li><p>ESP_ERR_INVALID_STATE if previous transactions are not finished</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427spi_device_get_trans_result19spi_device_handle_tPP17spi_transaction_t10TickType_t">
<span id="_CPPv327spi_device_get_trans_result19spi_device_handle_tPP17spi_transaction_t10TickType_t"></span><span id="_CPPv227spi_device_get_trans_result19spi_device_handle_tPP17spi_transaction_t10TickType_t"></span><span id="spi_device_get_trans_result__spi_device_handle_t.spi_transaction_tPP.TickType_t"></span><span class="target" id="spi__master_8h_1a114e18c5514dfec3d1226affc1c10d61"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_get_trans_result</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><span class="n"><span class="pre">spi_transaction_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">trans_desc</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ticks_to_wait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427spi_device_get_trans_result19spi_device_handle_tPP17spi_transaction_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get the result of a SPI transaction queued earlier by <code class="docutils literal notranslate"><span class="pre">spi_device_queue_trans</span></code>. </p>
<p>This routine will wait until a transaction to the given device successfully completed. It will then return the description of the completed transaction so software can inspect the result and e.g. free the memory or reuse the buffers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- Device handle obtained using spi_host_add_dev </p></li>
<li><p><strong>trans_desc</strong> -- Pointer to variable able to contain a pointer to the description of the transaction that is executed. The descriptor should not be modified until the descriptor is returned by spi_device_get_trans_result. </p></li>
<li><p><strong>ticks_to_wait</strong> -- Ticks to wait until there's a returned item; use portMAX_DELAY to never time out. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if parameter is invalid</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED if flag <code class="docutils literal notranslate"><span class="pre">SPI_DEVICE_NO_RETURN_RESULT</span></code> is set</p></li>
<li><p>ESP_ERR_TIMEOUT if there was no completed transaction before ticks_to_wait expired</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419spi_device_transmit19spi_device_handle_tP17spi_transaction_t">
<span id="_CPPv319spi_device_transmit19spi_device_handle_tP17spi_transaction_t"></span><span id="_CPPv219spi_device_transmit19spi_device_handle_tP17spi_transaction_t"></span><span id="spi_device_transmit__spi_device_handle_t.spi_transaction_tP"></span><span class="target" id="spi__master_8h_1a14588d8a89c0b7331d89e154cb865722"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_transmit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><span class="n"><span class="pre">spi_transaction_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">trans_desc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419spi_device_transmit19spi_device_handle_tP17spi_transaction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Send a SPI transaction, wait for it to complete, and return the result. </p>
<p>This function is the equivalent of calling spi_device_queue_trans() followed by spi_device_get_trans_result(). Do not use this when there is still a transaction separately queued (started) from spi_device_queue_trans() or polling_start/transmit that hasn't been finalized.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is not thread safe when multiple tasks access the same SPI device. Normally a device cannot start (queue) polling and interrupt transactions simutanuously.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- Device handle obtained using spi_host_add_dev </p></li>
<li><p><strong>trans_desc</strong> -- Description of transaction to execute </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if parameter is invalid</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t">
<span id="_CPPv324spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t"></span><span id="_CPPv224spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t"></span><span id="spi_device_polling_start__spi_device_handle_t.spi_transaction_tP.TickType_t"></span><span class="target" id="spi__master_8h_1a6eef7f1ae45be0d57ddad3bea83a1523"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_polling_start</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><span class="n"><span class="pre">spi_transaction_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">trans_desc</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ticks_to_wait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Immediately start a polling transaction. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Normally a device cannot start (queue) polling and interrupt transactions simutanuously. Moreover, a device cannot start a new polling transaction if another polling transaction is not finished.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- Device handle obtained using spi_host_add_dev </p></li>
<li><p><strong>trans_desc</strong> -- Description of transaction to execute </p></li>
<li><p><strong>ticks_to_wait</strong> -- Ticks to wait until there's room in the queue; currently only portMAX_DELAY is supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if parameter is invalid. This can happen if SPI_TRANS_CS_KEEP_ACTIVE flag is specified while the bus was not acquired (<code class="docutils literal notranslate"><span class="pre">spi_device_acquire_bus()</span></code> should be called first) or set flag SPI_TRANS_DMA_BUFFER_ALIGN_MANUAL but tx or rx buffer not DMA-capable, or addr&amp;len not align to cache line size</p></li>
<li><p>ESP_ERR_TIMEOUT if the device cannot get control of the bus before <code class="docutils literal notranslate"><span class="pre">ticks_to_wait</span></code> expired</p></li>
<li><p>ESP_ERR_NO_MEM if allocating DMA-capable temporary buffer failed</p></li>
<li><p>ESP_ERR_INVALID_STATE if previous transactions are not finished</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422spi_device_polling_end19spi_device_handle_t10TickType_t">
<span id="_CPPv322spi_device_polling_end19spi_device_handle_t10TickType_t"></span><span id="_CPPv222spi_device_polling_end19spi_device_handle_t10TickType_t"></span><span id="spi_device_polling_end__spi_device_handle_t.TickType_t"></span><span class="target" id="spi__master_8h_1ab6731f3fcbc682f7ac9e7b0ad99e2dcb"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_polling_end</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ticks_to_wait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422spi_device_polling_end19spi_device_handle_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Poll until the polling transaction ends. </p>
<p>This routine will not return until the transaction to the given device has successfully completed. The task is not blocked, but actively busy-spins for the transaction to be completed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- Device handle obtained using spi_host_add_dev </p></li>
<li><p><strong>ticks_to_wait</strong> -- Ticks to wait until there's a returned item; use portMAX_DELAY to never time out. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if parameter is invalid</p></li>
<li><p>ESP_ERR_TIMEOUT if the transaction cannot finish before ticks_to_wait expired</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427spi_device_polling_transmit19spi_device_handle_tP17spi_transaction_t">
<span id="_CPPv327spi_device_polling_transmit19spi_device_handle_tP17spi_transaction_t"></span><span id="_CPPv227spi_device_polling_transmit19spi_device_handle_tP17spi_transaction_t"></span><span id="spi_device_polling_transmit__spi_device_handle_t.spi_transaction_tP"></span><span class="target" id="spi__master_8h_1a426bbc2907eb2da390f25d5889dbc0a5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_polling_transmit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><span class="n"><span class="pre">spi_transaction_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">trans_desc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427spi_device_polling_transmit19spi_device_handle_tP17spi_transaction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Send a polling transaction, wait for it to complete, and return the result. </p>
<p>This function is the equivalent of calling spi_device_polling_start() followed by spi_device_polling_end(). Do not use this when there is still a transaction that hasn't been finalized.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is not thread safe when multiple tasks access the same SPI device. Normally a device cannot start (queue) polling and interrupt transactions simutanuously.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- Device handle obtained using spi_host_add_dev </p></li>
<li><p><strong>trans_desc</strong> -- Description of transaction to execute </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG if parameter is invalid</p></li>
<li><p>ESP_ERR_TIMEOUT if the device cannot get control of the bus</p></li>
<li><p>ESP_ERR_NO_MEM if allocating DMA-capable temporary buffer failed</p></li>
<li><p>ESP_ERR_INVALID_STATE if previous transactions of same device are not finished</p></li>
<li><p>ESP_OK on success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422spi_device_acquire_bus19spi_device_handle_t10TickType_t">
<span id="_CPPv322spi_device_acquire_bus19spi_device_handle_t10TickType_t"></span><span id="_CPPv222spi_device_acquire_bus19spi_device_handle_t10TickType_t"></span><span id="spi_device_acquire_bus__spi_device_handle_t.TickType_t"></span><span class="target" id="spi__master_8h_1aba4d0d6d062d4d542d37cd4dfa18d915"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_acquire_bus</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">device</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">wait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422spi_device_acquire_bus19spi_device_handle_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Occupy the SPI bus for a device to do continuous transactions. </p>
<p>Transactions to all other devices will be put off until <code class="docutils literal notranslate"><span class="pre">spi_device_release_bus</span></code> is called.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function will wait until all the existing transactions have been sent.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>device</strong> -- The device to occupy the bus. </p></li>
<li><p><strong>wait</strong> -- Time to wait before the the bus is occupied by the device. Currently MUST set to portMAX_DELAY.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG : <code class="docutils literal notranslate"><span class="pre">wait</span></code> is not set to portMAX_DELAY.</p></li>
<li><p>ESP_OK : Success. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422spi_device_release_bus19spi_device_handle_t">
<span id="_CPPv322spi_device_release_bus19spi_device_handle_t"></span><span id="_CPPv222spi_device_release_bus19spi_device_handle_t"></span><span id="spi_device_release_bus__spi_device_handle_t"></span><span class="target" id="spi__master_8h_1a7921cf4e7e6c347eb3f76d1beda63293"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_release_bus</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422spi_device_release_bus19spi_device_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Release the SPI bus occupied by the device. All other devices can start sending transactions. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dev</strong> -- The device to release the bus. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426spi_device_get_actual_freq19spi_device_handle_tPi">
<span id="_CPPv326spi_device_get_actual_freq19spi_device_handle_tPi"></span><span id="_CPPv226spi_device_get_actual_freq19spi_device_handle_tPi"></span><span id="spi_device_get_actual_freq__spi_device_handle_t.iP"></span><span class="target" id="spi__master_8h_1a5c4eca523167981b263ab3430dfaa2c3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_get_actual_freq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419spi_device_handle_t" title="spi_device_handle_t"><span class="n"><span class="pre">spi_device_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">freq_khz</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426spi_device_get_actual_freq19spi_device_handle_tPi" title="Permalink to this definition"></a><br /></dt>
<dd><p>Calculate working frequency for specific device. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- SPI device handle </p></li>
<li><p><strong>freq_khz</strong> -- <strong>[out]</strong> output parameter to hold calculated frequency in kHz</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG : <code class="docutils literal notranslate"><span class="pre">handle</span></code> or <code class="docutils literal notranslate"><span class="pre">freq_khz</span></code> parameter is NULL</p></li>
<li><p>ESP_OK : Success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420spi_get_actual_clockiii">
<span id="_CPPv320spi_get_actual_clockiii"></span><span id="_CPPv220spi_get_actual_clockiii"></span><span id="spi_get_actual_clock__i.i.i"></span><span class="target" id="spi__master_8h_1abb29dbfe1eba9c9ff256d3b6bd7df2fe"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_get_actual_clock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">fapb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">hz</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">duty_cycle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420spi_get_actual_clockiii" title="Permalink to this definition"></a><br /></dt>
<dd><p>Calculate the working frequency that is most close to desired frequency. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fapb</strong> -- The frequency of apb clock, should be <code class="docutils literal notranslate"><span class="pre">APB_CLK_FREQ</span></code>. </p></li>
<li><p><strong>hz</strong> -- Desired working frequency </p></li>
<li><p><strong>duty_cycle</strong> -- Duty cycle of the spi clock</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Actual working frequency that most fit. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414spi_get_timingbiiPiPi">
<span id="_CPPv314spi_get_timingbiiPiPi"></span><span id="_CPPv214spi_get_timingbiiPiPi"></span><span id="spi_get_timing__b.i.i.iP.iP"></span><span class="target" id="spi__master_8h_1a4e5144109a31b96a2cbe3b94e882da2d"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_get_timing</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">gpio_is_used</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">input_delay_ns</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">eff_clk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dummy_o</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cycles_remain_o</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414spi_get_timingbiiPiPi" title="Permalink to this definition"></a><br /></dt>
<dd><p>Calculate the timing settings of specified frequency and settings. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If **dummy_o* is not zero, it means dummy bits should be applied in half duplex mode, and full duplex mode may not work. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gpio_is_used</strong> -- True if using GPIO matrix, or False if iomux pins are used. </p></li>
<li><p><strong>input_delay_ns</strong> -- Input delay from SCLK launch edge to MISO data valid. </p></li>
<li><p><strong>eff_clk</strong> -- Effective clock frequency (in Hz) from <code class="docutils literal notranslate"><span class="pre">spi_get_actual_clock()</span></code>. </p></li>
<li><p><strong>dummy_o</strong> -- Address of dummy bits used output. Set to NULL if not needed. </p></li>
<li><p><strong>cycles_remain_o</strong> -- Address of cycles remaining (after dummy bits are used) output.<ul>
<li><p>-1 If too many cycles remaining, suggest to compensate half a clock.</p></li>
<li><p>0 If no remaining cycles or dummy bits are not used.</p></li>
<li><p>positive value: cycles suggest to compensate.</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418spi_get_freq_limitbi">
<span id="_CPPv318spi_get_freq_limitbi"></span><span id="_CPPv218spi_get_freq_limitbi"></span><span id="spi_get_freq_limit__b.i"></span><span class="target" id="spi__master_8h_1ab1118a9b8328e61eb441ecd4cfec3566"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_get_freq_limit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">gpio_is_used</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">input_delay_ns</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418spi_get_freq_limitbi" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get the frequency limit of current configurations. SPI master working at this limit is OK, while above the limit, full duplex mode and DMA will not work, and dummy bits will be applied in the half duplex mode. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gpio_is_used</strong> -- True if using GPIO matrix, or False if native pins are used. </p></li>
<li><p><strong>input_delay_ns</strong> -- Input delay from SCLK launch edge to MISO data valid. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Frequency limit of current configurations. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431spi_bus_get_max_transaction_len17spi_host_device_tP6size_t">
<span id="_CPPv331spi_bus_get_max_transaction_len17spi_host_device_tP6size_t"></span><span id="_CPPv231spi_bus_get_max_transaction_len17spi_host_device_tP6size_t"></span><span id="spi_bus_get_max_transaction_len__spi_host_device_t.sP"></span><span class="target" id="spi__master_8h_1aa884ccaa466e1bce71b1251932e65b74"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_bus_get_max_transaction_len</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417spi_host_device_t" title="spi_host_device_t"><span class="n"><span class="pre">spi_host_device_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">host_id</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">max_bytes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431spi_bus_get_max_transaction_len17spi_host_device_tP6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get max length (in bytes) of one transaction. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> -- SPI peripheral </p></li>
<li><p><strong>max_bytes</strong> -- <strong>[out]</strong> Max length of one transaction, in bytes</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: On success</p></li>
<li><p>ESP_ERR_INVALID_ARG: Invalid argument </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id16">
<h3>Structures<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv429spi_device_interface_config_t">
<span id="_CPPv329spi_device_interface_config_t"></span><span id="_CPPv229spi_device_interface_config_t"></span><span id="spi_device_interface_config_t"></span><span class="target" id="structspi__device__interface__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_interface_config_t</span></span></span><a class="headerlink" href="#_CPPv429spi_device_interface_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>This is a configuration for a SPI slave device that is connected to one of the SPI buses. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t12command_bitsE">
<span id="_CPPv3N29spi_device_interface_config_t12command_bitsE"></span><span id="_CPPv2N29spi_device_interface_config_t12command_bitsE"></span><span id="spi_device_interface_config_t::command_bits__uint8_t"></span><span class="target" id="structspi__device__interface__config__t_1a85d8e76ff0693b13bba7e5384be85389"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">command_bits</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t12command_bitsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Default amount of bits in command phase (0-16), used when <code class="docutils literal notranslate"><span class="pre">SPI_TRANS_VARIABLE_CMD</span></code> is not used, otherwise ignored. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t12address_bitsE">
<span id="_CPPv3N29spi_device_interface_config_t12address_bitsE"></span><span id="_CPPv2N29spi_device_interface_config_t12address_bitsE"></span><span id="spi_device_interface_config_t::address_bits__uint8_t"></span><span class="target" id="structspi__device__interface__config__t_1a266f720ad824d7e71a295a1eb6b0e5e3"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">address_bits</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t12address_bitsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Default amount of bits in address phase (0-64), used when <code class="docutils literal notranslate"><span class="pre">SPI_TRANS_VARIABLE_ADDR</span></code> is not used, otherwise ignored. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t10dummy_bitsE">
<span id="_CPPv3N29spi_device_interface_config_t10dummy_bitsE"></span><span id="_CPPv2N29spi_device_interface_config_t10dummy_bitsE"></span><span id="spi_device_interface_config_t::dummy_bits__uint8_t"></span><span class="target" id="structspi__device__interface__config__t_1a5195c009a5ed045f48ec76130d649770"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dummy_bits</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t10dummy_bitsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Amount of dummy bits to insert between address and data phase. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t4modeE">
<span id="_CPPv3N29spi_device_interface_config_t4modeE"></span><span id="_CPPv2N29spi_device_interface_config_t4modeE"></span><span id="spi_device_interface_config_t::mode__uint8_t"></span><span class="target" id="structspi__device__interface__config__t_1a3614f6a8e10e639a14c26e8d917be5c4"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mode</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t4modeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI mode, representing a pair of (CPOL, CPHA) configuration:<ul class="simple">
<li><p>0: (0, 0)</p></li>
<li><p>1: (0, 1)</p></li>
<li><p>2: (1, 0)</p></li>
<li><p>3: (1, 1) </p></li>
</ul>
</p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t12clock_sourceE">
<span id="_CPPv3N29spi_device_interface_config_t12clock_sourceE"></span><span id="_CPPv2N29spi_device_interface_config_t12clock_sourceE"></span><span id="spi_device_interface_config_t::clock_source__spi_clock_source_t"></span><span class="target" id="structspi__device__interface__config__t_1a368438a3efceea7a0ddf5ec88a97783d"></span><a class="reference internal" href="#_CPPv418spi_clock_source_t" title="spi_clock_source_t"><span class="n"><span class="pre">spi_clock_source_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_source</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t12clock_sourceE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Select SPI clock source, <code class="docutils literal notranslate"><span class="pre">SPI_CLK_SRC_DEFAULT</span></code> by default. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t14duty_cycle_posE">
<span id="_CPPv3N29spi_device_interface_config_t14duty_cycle_posE"></span><span id="_CPPv2N29spi_device_interface_config_t14duty_cycle_posE"></span><span id="spi_device_interface_config_t::duty_cycle_pos__uint16_t"></span><span class="target" id="structspi__device__interface__config__t_1a2d172c4e4b6720b393d86e9964774e17"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">duty_cycle_pos</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t14duty_cycle_posE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Duty cycle of positive clock, in 1/256th increments (128 = 50%/50% duty). Setting this to 0 (=not setting it) is equivalent to setting this to 128. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t15cs_ena_pretransE">
<span id="_CPPv3N29spi_device_interface_config_t15cs_ena_pretransE"></span><span id="_CPPv2N29spi_device_interface_config_t15cs_ena_pretransE"></span><span id="spi_device_interface_config_t::cs_ena_pretrans__uint16_t"></span><span class="target" id="structspi__device__interface__config__t_1a37979b67f4f4254d286d03cc60092915"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cs_ena_pretrans</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t15cs_ena_pretransE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Amount of SPI bit-cycles the cs should be activated before the transmission (0-16). This only works on half-duplex transactions. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t16cs_ena_posttransE">
<span id="_CPPv3N29spi_device_interface_config_t16cs_ena_posttransE"></span><span id="_CPPv2N29spi_device_interface_config_t16cs_ena_posttransE"></span><span id="spi_device_interface_config_t::cs_ena_posttrans__uint8_t"></span><span class="target" id="structspi__device__interface__config__t_1a9a655c42678eaf8697817e9bcad47929"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cs_ena_posttrans</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t16cs_ena_posttransE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Amount of SPI bit-cycles the cs should stay active after the transmission (0-16) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t14clock_speed_hzE">
<span id="_CPPv3N29spi_device_interface_config_t14clock_speed_hzE"></span><span id="_CPPv2N29spi_device_interface_config_t14clock_speed_hzE"></span><span id="spi_device_interface_config_t::clock_speed_hz__i"></span><span class="target" id="structspi__device__interface__config__t_1a181e48de86d80d282e2c4a9019598c0f"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_speed_hz</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t14clock_speed_hzE" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI clock speed in Hz. Derived from <code class="docutils literal notranslate"><span class="pre">clock_source</span></code>. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t14input_delay_nsE">
<span id="_CPPv3N29spi_device_interface_config_t14input_delay_nsE"></span><span id="_CPPv2N29spi_device_interface_config_t14input_delay_nsE"></span><span id="spi_device_interface_config_t::input_delay_ns__i"></span><span class="target" id="structspi__device__interface__config__t_1af3f5b5403503b6e94cab75b43fd5af38"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">input_delay_ns</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t14input_delay_nsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Maximum data valid time of slave. The time required between SCLK and MISO valid, including the possible clock delay from slave to master. The driver uses this value to give an extra delay before the MISO is ready on the line. Leave at 0 unless you know you need a delay. For better timing performance at high frequency (over 8MHz), it's suggest to have the right value. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t12sample_pointE">
<span id="_CPPv3N29spi_device_interface_config_t12sample_pointE"></span><span id="_CPPv2N29spi_device_interface_config_t12sample_pointE"></span><span id="spi_device_interface_config_t::sample_point__spi_sampling_point_t"></span><span class="target" id="structspi__device__interface__config__t_1add26b8a692907225bd53274dd7b6ba60"></span><a class="reference internal" href="#_CPPv420spi_sampling_point_t" title="spi_sampling_point_t"><span class="n"><span class="pre">spi_sampling_point_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sample_point</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t12sample_pointE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sample point tuning of spi master receiving bit. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t12spics_io_numE">
<span id="_CPPv3N29spi_device_interface_config_t12spics_io_numE"></span><span id="_CPPv2N29spi_device_interface_config_t12spics_io_numE"></span><span id="spi_device_interface_config_t::spics_io_num__i"></span><span class="target" id="structspi__device__interface__config__t_1a125057d318b9467a5dd3f1b8a72342f6"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spics_io_num</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t12spics_io_numE" title="Permalink to this definition"></a><br /></dt>
<dd><p>CS GPIO pin for this device, or -1 if not used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t5flagsE">
<span id="_CPPv3N29spi_device_interface_config_t5flagsE"></span><span id="_CPPv2N29spi_device_interface_config_t5flagsE"></span><span id="spi_device_interface_config_t::flags__uint32_t"></span><span class="target" id="structspi__device__interface__config__t_1a992b96881ba3744a691c5024ed19f807"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Bitwise OR of SPI_DEVICE_* flags. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t10queue_sizeE">
<span id="_CPPv3N29spi_device_interface_config_t10queue_sizeE"></span><span id="_CPPv2N29spi_device_interface_config_t10queue_sizeE"></span><span id="spi_device_interface_config_t::queue_size__i"></span><span class="target" id="structspi__device__interface__config__t_1a36b391a7008efae8664f60ea8c8dc5e3"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">queue_size</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t10queue_sizeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transaction queue size. This sets how many transactions can be 'in the air' (queued using spi_device_queue_trans but not yet finished using spi_device_get_trans_result) at the same time. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t6pre_cbE">
<span id="_CPPv3N29spi_device_interface_config_t6pre_cbE"></span><span id="_CPPv2N29spi_device_interface_config_t6pre_cbE"></span><span id="spi_device_interface_config_t::pre_cb__transaction_cb_t"></span><span class="target" id="structspi__device__interface__config__t_1ab98766875246c59eb2dce1dcb8ed12ee"></span><a class="reference internal" href="#_CPPv416transaction_cb_t" title="transaction_cb_t"><span class="n"><span class="pre">transaction_cb_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pre_cb</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t6pre_cbE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback to be called before a transmission is started.</p>
<p>This callback is called within interrupt context should be in IRAM for best performance, see &quot;Transferring Speed&quot; section in the SPI Master documentation for full details. If not, the callback may crash during flash operation when the driver is initialized with ESP_INTR_FLAG_IRAM. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N29spi_device_interface_config_t7post_cbE">
<span id="_CPPv3N29spi_device_interface_config_t7post_cbE"></span><span id="_CPPv2N29spi_device_interface_config_t7post_cbE"></span><span id="spi_device_interface_config_t::post_cb__transaction_cb_t"></span><span class="target" id="structspi__device__interface__config__t_1ae0bb84767e1c28f52831db2c2a8922b9"></span><a class="reference internal" href="#_CPPv416transaction_cb_t" title="transaction_cb_t"><span class="n"><span class="pre">transaction_cb_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">post_cb</span></span></span><a class="headerlink" href="#_CPPv4N29spi_device_interface_config_t7post_cbE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback to be called after a transmission has completed.</p>
<p>This callback is called within interrupt context should be in IRAM for best performance, see &quot;Transferring Speed&quot; section in the SPI Master documentation for full details. If not, the callback may crash during flash operation when the driver is initialized with ESP_INTR_FLAG_IRAM. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv417spi_transaction_t">
<span id="_CPPv317spi_transaction_t"></span><span id="_CPPv217spi_transaction_t"></span><span id="spi_transaction_t"></span><span class="target" id="structspi__transaction__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_transaction_t</span></span></span><a class="headerlink" href="#_CPPv417spi_transaction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>This structure describes one SPI transaction. The descriptor should not be modified until the transaction finishes. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t5flagsE">
<span id="_CPPv3N17spi_transaction_t5flagsE"></span><span id="_CPPv2N17spi_transaction_t5flagsE"></span><span id="spi_transaction_t::flags__uint32_t"></span><span class="target" id="structspi__transaction__t_1af3c521c6a4bb6f22235d58e13acf4ba9"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Bitwise OR of SPI_TRANS_* flags. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t3cmdE">
<span id="_CPPv3N17spi_transaction_t3cmdE"></span><span id="_CPPv2N17spi_transaction_t3cmdE"></span><span id="spi_transaction_t::cmd__uint16_t"></span><span class="target" id="structspi__transaction__t_1a3c79123d92db99847ca818b8d2bb1ca9"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cmd</span></span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t3cmdE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Command data, of which the length is set in the <code class="docutils literal notranslate"><span class="pre">command_bits</span></code> of <a class="reference internal" href="#structspi__device__interface__config__t"><span class="std std-ref">spi_device_interface_config_t</span></a>.</p>
<p><strong>NOTE: this field, used to be &quot;command&quot; in ESP-IDF 2.1 and before, is re-written to be used in a new way in ESP-IDF 3.0.</strong></p>
<p>Example: write 0x0123 and command_bits=12 to send command 0x12, 0x3_ (in previous version, you may have to write 0x3_12). </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t4addrE">
<span id="_CPPv3N17spi_transaction_t4addrE"></span><span id="_CPPv2N17spi_transaction_t4addrE"></span><span id="spi_transaction_t::addr__uint64_t"></span><span class="target" id="structspi__transaction__t_1aa4898bbbe31a7819ac032cdaa5bae11d"></span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">addr</span></span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t4addrE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Address data, of which the length is set in the <code class="docutils literal notranslate"><span class="pre">address_bits</span></code> of <a class="reference internal" href="#structspi__device__interface__config__t"><span class="std std-ref">spi_device_interface_config_t</span></a>.</p>
<p><strong>NOTE: this field, used to be &quot;address&quot; in ESP-IDF 2.1 and before, is re-written to be used in a new way in ESP-IDF3.0.</strong></p>
<p>Example: write 0x123400 and address_bits=24 to send address of 0x12, 0x34, 0x00 (in previous version, you may have to write 0x12340000). </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t6lengthE">
<span id="_CPPv3N17spi_transaction_t6lengthE"></span><span id="_CPPv2N17spi_transaction_t6lengthE"></span><span id="spi_transaction_t::length__s"></span><span class="target" id="structspi__transaction__t_1a0265f1bab4aebceecf709e4af8c4d58b"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">length</span></span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t6lengthE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Total data length, in bits. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t8rxlengthE">
<span id="_CPPv3N17spi_transaction_t8rxlengthE"></span><span id="_CPPv2N17spi_transaction_t8rxlengthE"></span><span id="spi_transaction_t::rxlength__s"></span><span class="target" id="structspi__transaction__t_1a59234aff0e4dc8a319d64f0e5363b2d3"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rxlength</span></span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t8rxlengthE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Total data length received, should be not greater than <code class="docutils literal notranslate"><span class="pre">length</span></code> in full-duplex mode (0 defaults this to the value of <code class="docutils literal notranslate"><span class="pre">length</span></code>). </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t4userE">
<span id="_CPPv3N17spi_transaction_t4userE"></span><span id="_CPPv2N17spi_transaction_t4userE"></span><span id="spi_transaction_t::user__voidP"></span><span class="target" id="structspi__transaction__t_1a18ad90e27eff1d9ac63826c68ddde997"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">user</span></span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t4userE" title="Permalink to this definition"></a><br /></dt>
<dd><p>User-defined variable. Can be used to store eg transaction ID. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t9tx_bufferE">
<span id="_CPPv3N17spi_transaction_t9tx_bufferE"></span><span id="_CPPv2N17spi_transaction_t9tx_bufferE"></span><span id="spi_transaction_t::tx_buffer__voidCP"></span><span class="target" id="structspi__transaction__t_1a5ca7790355f9062174605aa76f5326c9"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">tx_buffer</span></span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t9tx_bufferE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to transmit buffer, or NULL for no MOSI phase. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t7tx_dataE">
<span id="_CPPv3N17spi_transaction_t7tx_dataE"></span><span id="_CPPv2N17spi_transaction_t7tx_dataE"></span><span id="spi_transaction_t::tx_data__uint8_tA"></span><span class="target" id="structspi__transaction__t_1abf1e2454ae2d68394f05954b20e300c0"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tx_data</span></span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t7tx_dataE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If SPI_TRANS_USE_TXDATA is set, data set here is sent directly from this variable. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t9rx_bufferE">
<span id="_CPPv3N17spi_transaction_t9rx_bufferE"></span><span id="_CPPv2N17spi_transaction_t9rx_bufferE"></span><span id="spi_transaction_t::rx_buffer__voidP"></span><span class="target" id="structspi__transaction__t_1abc1c39ea706c5c7f53473865e0bec47c"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">rx_buffer</span></span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t9rx_bufferE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to receive buffer, or NULL for no MISO phase. Written by 4 bytes-unit if DMA is used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17spi_transaction_t7rx_dataE">
<span id="_CPPv3N17spi_transaction_t7rx_dataE"></span><span id="_CPPv2N17spi_transaction_t7rx_dataE"></span><span id="spi_transaction_t::rx_data__uint8_tA"></span><span class="target" id="structspi__transaction__t_1a2f0574ba69fabc6cec8a6d87e31d5c06"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rx_data</span></span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N17spi_transaction_t7rx_dataE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If SPI_TRANS_USE_RXDATA is set, data is received directly to this variable. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv421spi_transaction_ext_t">
<span id="_CPPv321spi_transaction_ext_t"></span><span id="_CPPv221spi_transaction_ext_t"></span><span id="spi_transaction_ext_t"></span><span class="target" id="structspi__transaction__ext__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_transaction_ext_t</span></span></span><a class="headerlink" href="#_CPPv421spi_transaction_ext_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>This struct is for SPI transactions which may change their address and command length. Please do set the flags in base to <code class="docutils literal notranslate"><span class="pre">SPI_TRANS_VARIABLE_CMD_ADR</span></code> to use the bit length here. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21spi_transaction_ext_t4baseE">
<span id="_CPPv3N21spi_transaction_ext_t4baseE"></span><span id="_CPPv2N21spi_transaction_ext_t4baseE"></span><span id="spi_transaction_ext_t::base__spi_transaction_t"></span><span class="target" id="structspi__transaction__ext__t_1a921a7bb2158cef699e002d262c35da56"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><span class="n"><span class="pre">spi_transaction_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">base</span></span></span><a class="headerlink" href="#_CPPv4N21spi_transaction_ext_t4baseE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transaction data, so that pointer to <a class="reference internal" href="#structspi__transaction__t"><span class="std std-ref">spi_transaction_t</span></a> can be converted into <a class="reference internal" href="#structspi__transaction__ext__t"><span class="std std-ref">spi_transaction_ext_t</span></a>. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21spi_transaction_ext_t12command_bitsE">
<span id="_CPPv3N21spi_transaction_ext_t12command_bitsE"></span><span id="_CPPv2N21spi_transaction_ext_t12command_bitsE"></span><span id="spi_transaction_ext_t::command_bits__uint8_t"></span><span class="target" id="structspi__transaction__ext__t_1ac67443c5dc5ae78742ff2318ac6cad94"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">command_bits</span></span></span><a class="headerlink" href="#_CPPv4N21spi_transaction_ext_t12command_bitsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The command length in this transaction, in bits. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21spi_transaction_ext_t12address_bitsE">
<span id="_CPPv3N21spi_transaction_ext_t12address_bitsE"></span><span id="_CPPv2N21spi_transaction_ext_t12address_bitsE"></span><span id="spi_transaction_ext_t::address_bits__uint8_t"></span><span class="target" id="structspi__transaction__ext__t_1a49e7862b3ca3f50614ccc4b26c5c8d9f"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">address_bits</span></span></span><a class="headerlink" href="#_CPPv4N21spi_transaction_ext_t12address_bitsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The address length in this transaction, in bits. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21spi_transaction_ext_t10dummy_bitsE">
<span id="_CPPv3N21spi_transaction_ext_t10dummy_bitsE"></span><span id="_CPPv2N21spi_transaction_ext_t10dummy_bitsE"></span><span id="spi_transaction_ext_t::dummy_bits__uint8_t"></span><span class="target" id="structspi__transaction__ext__t_1ae237269d8309f7fd32b454550ccd5624"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dummy_bits</span></span></span><a class="headerlink" href="#_CPPv4N21spi_transaction_ext_t10dummy_bitsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The dummy length in this transaction, in bits. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id17">
<h3>Macros<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_8M">
<span class="target" id="spi__master_8h_1adea02d0dc171f8a9b9aebbfa7bdb30e2"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_8M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_8M" title="Permalink to this definition"></a><br /></dt>
<dd><p>SPI common used frequency (in Hz) </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>SPI peripheral only has an integer divider, and the default clock source can be different on other targets, so the actual frequency may be slightly different from the desired frequency. 8MHz </p>
</div>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_9M">
<span class="target" id="spi__master_8h_1a11db0c7429927f493c24a879a1e784c3"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_9M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_9M" title="Permalink to this definition"></a><br /></dt>
<dd><p>8.89MHz </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_10M">
<span class="target" id="spi__master_8h_1a06652ec126567a9c1317b04396984d50"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_10M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_10M" title="Permalink to this definition"></a><br /></dt>
<dd><p>10MHz </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_11M">
<span class="target" id="spi__master_8h_1a9dfdf26443edee66539aa0f80dad34d7"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_11M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_11M" title="Permalink to this definition"></a><br /></dt>
<dd><p>11.43MHz </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_13M">
<span class="target" id="spi__master_8h_1ad729438ea06c3d9eb5b9e7167790ff10"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_13M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_13M" title="Permalink to this definition"></a><br /></dt>
<dd><p>13.33MHz </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_16M">
<span class="target" id="spi__master_8h_1a422a58ac535271627a6de581499862a5"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_16M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_16M" title="Permalink to this definition"></a><br /></dt>
<dd><p>16MHz </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_20M">
<span class="target" id="spi__master_8h_1a2a66bdd910243a791d9656fefe3039b5"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_20M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_20M" title="Permalink to this definition"></a><br /></dt>
<dd><p>20MHz </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_26M">
<span class="target" id="spi__master_8h_1a0677c7ed0efb5359e7b6f6fa83bbbd02"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_26M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_26M" title="Permalink to this definition"></a><br /></dt>
<dd><p>26.67MHz </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_40M">
<span class="target" id="spi__master_8h_1a962face6fbbea67faa6ce89bdfb0ddf3"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_40M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_40M" title="Permalink to this definition"></a><br /></dt>
<dd><p>40MHz </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_MASTER_FREQ_80M">
<span class="target" id="spi__master_8h_1a1c50a9516f146003bb483400c2e5d624"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_MASTER_FREQ_80M</span></span></span><a class="headerlink" href="#c.SPI_MASTER_FREQ_80M" title="Permalink to this definition"></a><br /></dt>
<dd><p>80MHz </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_TXBIT_LSBFIRST">
<span class="target" id="spi__master_8h_1a8988816a1df67eb9b1193b9551423a7f"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_TXBIT_LSBFIRST</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_TXBIT_LSBFIRST" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit command/address/data LSB first instead of the default MSB first. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_RXBIT_LSBFIRST">
<span class="target" id="spi__master_8h_1a1c80635361c43d3e60786f9e3646d19c"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_RXBIT_LSBFIRST</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_RXBIT_LSBFIRST" title="Permalink to this definition"></a><br /></dt>
<dd><p>Receive data LSB first instead of the default MSB first. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_BIT_LSBFIRST">
<span class="target" id="spi__master_8h_1aa4a0b55bca0869f71f9a7f53018efb2c"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_BIT_LSBFIRST</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_BIT_LSBFIRST" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit and receive LSB first. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_3WIRE">
<span class="target" id="spi__master_8h_1a0bc45cf36a0eb48d33159257440c483e"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_3WIRE</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_3WIRE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Use MOSI (=spid) for both sending and receiving data. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_POSITIVE_CS">
<span class="target" id="spi__master_8h_1a94dc7e7689e6d66215886f0d4051508b"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_POSITIVE_CS</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_POSITIVE_CS" title="Permalink to this definition"></a><br /></dt>
<dd><p>Make CS positive during a transaction instead of negative. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_HALFDUPLEX">
<span class="target" id="spi__master_8h_1a32ddffedddff7b374bc084f63fb03377"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_HALFDUPLEX</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_HALFDUPLEX" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit data before receiving it, instead of simultaneously. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_CLK_AS_CS">
<span class="target" id="spi__master_8h_1ae86c08578138d84a5292c851f5a1f527"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_CLK_AS_CS</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_CLK_AS_CS" title="Permalink to this definition"></a><br /></dt>
<dd><p>Output clock on CS line if CS is active. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_NO_DUMMY">
<span class="target" id="spi__master_8h_1a02dd5057c1de66befe1eb84a1c638746"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_NO_DUMMY</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_NO_DUMMY" title="Permalink to this definition"></a><br /></dt>
<dd><p>There are timing issue when reading at high frequency (the frequency is related to whether iomux pins are used, valid time after slave sees the clock).<ul class="simple">
<li><p>In half-duplex mode, the driver automatically inserts dummy bits before reading phase to fix the timing issue. Set this flag to disable this feature.</p></li>
<li><p>In full-duplex mode, however, the hardware cannot use dummy bits, so there is no way to prevent data being read from getting corrupted. Set this flag to confirm that you're going to work with output only, or read without dummy bits at your own risk. </p></li>
</ul>
</p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_DDRCLK">
<span class="target" id="spi__master_8h_1a0956f9b3b3fc8d01f92f4892c8cac9d5"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_DDRCLK</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_DDRCLK" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_DEVICE_NO_RETURN_RESULT">
<span class="target" id="spi__master_8h_1a2680b3cde022ec8863cc5bfd0aa961bd"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_DEVICE_NO_RETURN_RESULT</span></span></span><a class="headerlink" href="#c.SPI_DEVICE_NO_RETURN_RESULT" title="Permalink to this definition"></a><br /></dt>
<dd><p>Don't return the descriptor to the host on completion (use post_cb to notify instead) </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_MODE_DIO">
<span class="target" id="spi__master_8h_1a53466d01d30e7844d8ed549fa3f42b6b"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_MODE_DIO</span></span></span><a class="headerlink" href="#c.SPI_TRANS_MODE_DIO" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit/receive data in 2-bit mode. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_MODE_QIO">
<span class="target" id="spi__master_8h_1a4b6c82296c80973ac9a3b1710bab9438"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_MODE_QIO</span></span></span><a class="headerlink" href="#c.SPI_TRANS_MODE_QIO" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit/receive data in 4-bit mode. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_USE_RXDATA">
<span class="target" id="spi__master_8h_1ae9c12dcb7994ba3e0eb502f7faa376e2"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_USE_RXDATA</span></span></span><a class="headerlink" href="#c.SPI_TRANS_USE_RXDATA" title="Permalink to this definition"></a><br /></dt>
<dd><p>Receive into rx_data member of <a class="reference internal" href="#structspi__transaction__t"><span class="std std-ref">spi_transaction_t</span></a> instead into memory at rx_buffer. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_USE_TXDATA">
<span class="target" id="spi__master_8h_1ae8a5f363fe787a05f82fd7ee2e7f5338"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_USE_TXDATA</span></span></span><a class="headerlink" href="#c.SPI_TRANS_USE_TXDATA" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit tx_data member of <a class="reference internal" href="#structspi__transaction__t"><span class="std std-ref">spi_transaction_t</span></a> instead of data at tx_buffer. Do not set tx_buffer when using this. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_MODE_DIOQIO_ADDR">
<span class="target" id="spi__master_8h_1aaea00fa6c88f713f3ccd5e6c552b0e6a"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_MODE_DIOQIO_ADDR</span></span></span><a class="headerlink" href="#c.SPI_TRANS_MODE_DIOQIO_ADDR" title="Permalink to this definition"></a><br /></dt>
<dd><p>Also transmit address in mode selected by SPI_MODE_DIO/SPI_MODE_QIO. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_VARIABLE_CMD">
<span class="target" id="spi__master_8h_1aee0b033b134a4a21dba78a36b0b71317"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_VARIABLE_CMD</span></span></span><a class="headerlink" href="#c.SPI_TRANS_VARIABLE_CMD" title="Permalink to this definition"></a><br /></dt>
<dd><p>Use the <code class="docutils literal notranslate"><span class="pre">command_bits</span></code> in <code class="docutils literal notranslate"><a class="reference internal" href="#structspi__transaction__ext__t"><span class="std std-ref"><span class="pre">spi_transaction_ext_t</span></span></a></code> rather than default value in <code class="docutils literal notranslate"><a class="reference internal" href="#structspi__device__interface__config__t"><span class="std std-ref"><span class="pre">spi_device_interface_config_t</span></span></a></code>. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_VARIABLE_ADDR">
<span class="target" id="spi__master_8h_1af56b50359065c92670d331d2a874664f"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_VARIABLE_ADDR</span></span></span><a class="headerlink" href="#c.SPI_TRANS_VARIABLE_ADDR" title="Permalink to this definition"></a><br /></dt>
<dd><p>Use the <code class="docutils literal notranslate"><span class="pre">address_bits</span></code> in <code class="docutils literal notranslate"><a class="reference internal" href="#structspi__transaction__ext__t"><span class="std std-ref"><span class="pre">spi_transaction_ext_t</span></span></a></code> rather than default value in <code class="docutils literal notranslate"><a class="reference internal" href="#structspi__device__interface__config__t"><span class="std std-ref"><span class="pre">spi_device_interface_config_t</span></span></a></code>. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_VARIABLE_DUMMY">
<span class="target" id="spi__master_8h_1a7eeea05a38015ca95699bd7f56d1f9cc"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_VARIABLE_DUMMY</span></span></span><a class="headerlink" href="#c.SPI_TRANS_VARIABLE_DUMMY" title="Permalink to this definition"></a><br /></dt>
<dd><p>Use the <code class="docutils literal notranslate"><span class="pre">dummy_bits</span></code> in <code class="docutils literal notranslate"><a class="reference internal" href="#structspi__transaction__ext__t"><span class="std std-ref"><span class="pre">spi_transaction_ext_t</span></span></a></code> rather than default value in <code class="docutils literal notranslate"><a class="reference internal" href="#structspi__device__interface__config__t"><span class="std std-ref"><span class="pre">spi_device_interface_config_t</span></span></a></code>. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_CS_KEEP_ACTIVE">
<span class="target" id="spi__master_8h_1ac672d7d981e9a1dedbc298fface9e788"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_CS_KEEP_ACTIVE</span></span></span><a class="headerlink" href="#c.SPI_TRANS_CS_KEEP_ACTIVE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Keep CS active after data transfer. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_MULTILINE_CMD">
<span class="target" id="spi__master_8h_1a4ee295aaad04f9a0bcd142bc84b4db24"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_MULTILINE_CMD</span></span></span><a class="headerlink" href="#c.SPI_TRANS_MULTILINE_CMD" title="Permalink to this definition"></a><br /></dt>
<dd><p>The data lines used at command phase is the same as data phase (otherwise, only one data line is used at command phase) </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_MODE_OCT">
<span class="target" id="spi__master_8h_1a1f7c82644b0ad4fd4e530562ecc88c1c"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_MODE_OCT</span></span></span><a class="headerlink" href="#c.SPI_TRANS_MODE_OCT" title="Permalink to this definition"></a><br /></dt>
<dd><p>Transmit/receive data in 8-bit mode. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_MULTILINE_ADDR">
<span class="target" id="spi__master_8h_1a7a7f49377cd606ff04d8a3f6956bc797"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_MULTILINE_ADDR</span></span></span><a class="headerlink" href="#c.SPI_TRANS_MULTILINE_ADDR" title="Permalink to this definition"></a><br /></dt>
<dd><p>The data lines used at address phase is the same as data phase (otherwise, only one data line is used at address phase) </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.SPI_TRANS_DMA_BUFFER_ALIGN_MANUAL">
<span class="target" id="spi__master_8h_1af65fb99cb01e18515626d18f660f41a5"></span><span class="sig-name descname"><span class="n"><span class="pre">SPI_TRANS_DMA_BUFFER_ALIGN_MANUAL</span></span></span><a class="headerlink" href="#c.SPI_TRANS_DMA_BUFFER_ALIGN_MANUAL" title="Permalink to this definition"></a><br /></dt>
<dd><p>By default driver will automatically re-alloc dma buffer if it doesn't meet hardware alignment or dma_capable requirements, this flag is for you to disable this feature, you will need to take care of the alignment otherwise driver will return you error ESP_ERR_INVALID_ARG. </p>
</dd></dl>

</section>
<section id="id18">
<h3>Type Definitions<a class="headerlink" href="#id18" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv416transaction_cb_t">
<span id="_CPPv316transaction_cb_t"></span><span id="_CPPv216transaction_cb_t"></span><span id="transaction_cb_t"></span><span class="target" id="spi__master_8h_1ac9ff702f3e8e8936642a2853985a1618"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">transaction_cb_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv417spi_transaction_t" title="spi_transaction_t"><span class="n"><span class="pre">spi_transaction_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">trans</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv416transaction_cb_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv419spi_device_handle_t">
<span id="_CPPv319spi_device_handle_t"></span><span id="_CPPv219spi_device_handle_t"></span><span id="spi_device_handle_t"></span><span class="target" id="spi__master_8h_1a7ce8be646715ad8b62840bde8f319659"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spi_device_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">spi_device_handle_t</span></span></span><a class="headerlink" href="#_CPPv419spi_device_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Handle for a device on a SPI bus. </p>
</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=SPI Master Driver (api-reference/peripherals/spi_master)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=SPI Master Driver (api-reference/peripherals/spi_master)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="spi_flash/spi_flash_idf_vs_rom.html" class="btn btn-neutral float-left" title="SPI Flash API ESP-IDF Version vs Chip-ROM Version" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="spi_slave.html" class="btn btn-neutral float-right" title="SPI Slave Driver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>