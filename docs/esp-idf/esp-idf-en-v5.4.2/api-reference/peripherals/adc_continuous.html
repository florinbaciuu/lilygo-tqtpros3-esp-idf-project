<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Analog to Digital Converter (ADC) Continuous Mode Driver - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/peripherals/adc_continuous.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/peripherals/adc_continuous';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Analog to Digital Converter (ADC) Calibration Driver" href="adc_calibration.html" />
    <link rel="prev" title="Analog to Digital Converter (ADC) Oneshot Mode Driver" href="adc_oneshot.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">BluetoothÂ® API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Peripherals API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="adc_oneshot.html">Analog to Digital Converter (ADC) Oneshot Mode Driver</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Analog to Digital Converter (ADC) Continuous Mode Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functional-overview">Functional Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-examples">Application Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="adc_calibration.html">Analog to Digital Converter (ADC) Calibration Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk_tree.html">Clock Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="dac.html">Digital To Analog Converter (DAC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio.html">GPIO &amp; RTC GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="gptimer.html">General Purpose Timer (GPTimer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">Inter-Integrated Circuit (I2C)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2s.html">Inter-IC Sound (I2S)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lcd/index.html">LCD</a></li>
<li class="toctree-l3"><a class="reference internal" href="ledc.html">LED Control (LEDC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mcpwm.html">Motor Control Pulse Width Modulator (MCPWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="pcnt.html">Pulse Counter (PCNT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rmt.html">Remote Control Transceiver (RMT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sd_pullup_requirements.html">SD Pull-up Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc_host.html">SDMMC Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdspi_host.html">SD SPI Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdio_slave.html">SDIO Card Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdm.html">Sigma-Delta Modulation (SDM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_flash/index.html">SPI Flash API</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_master.html">SPI Master Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_slave.html">SPI Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="touch_pad.html">Touch Sensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="twai.html">Two-Wire Automotive Interface (TWAI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="uart.html">Universal Asynchronous Receiver/Transmitter (UART)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Project Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">System API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">Peripherals API</a></li>
      <li class="breadcrumb-item active">Analog to Digital Converter (ADC) Continuous Mode Driver</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-reference/peripherals/adc_continuous.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="analog-to-digital-converter-adc-continuous-mode-driver">
<h1>Analog to Digital Converter (ADC) Continuous Mode Driver<a class="headerlink" href="#analog-to-digital-converter-adc-continuous-mode-driver" title="Permalink to this heading">ï</a></h1>
<p><a class="reference external" href="../../../../../zh_CN/v5.4.2/esp32/api-reference/peripherals/adc_continuous.html">[ä¸­æ]</a></p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">ï</a></h2>
<p>The Analog to Digital Converter is integrated on the chip and is capable of measuring analog signals from specific analog IO pads. Additionally, the Direct Memory Access (DMA) functionality is utilized to efficiently retrieve ADC conversion results.</p>
<p>ESP32 has two ADC unit(s), which can be used in scenarios like:</p>
<ul class="simple">
<li><p>Generate one-shot ADC conversion result</p></li>
<li><p>Generate continuous ADC conversion results</p></li>
</ul>
<p>This guide introduces ADC continuous mode conversion.</p>
<section id="driver-concepts">
<h3>Driver Concepts<a class="headerlink" href="#driver-concepts" title="Permalink to this heading">ï</a></h3>
<p>ADC continuous mode conversion is made up of multiple conversion frames.</p>
<ul class="simple">
<li><p>Conversion Frame: One conversion frame contains multiple conversion results. Conversion frame size is configured in <a class="reference internal" href="#_CPPv425adc_continuous_new_handlePK27adc_continuous_handle_cfg_tP23adc_continuous_handle_t" title="adc_continuous_new_handle"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_new_handle()</span></code></a> in bytes.</p></li>
<li><p>Conversion Result: One conversion result contains multiple bytes, see <a class="reference internal" href="../system/soc_caps.html#c.SOC_ADC_DIGI_RESULT_BYTES" title="SOC_ADC_DIGI_RESULT_BYTES"><code class="xref c c-macro docutils literal notranslate"><span class="pre">SOC_ADC_DIGI_RESULT_BYTES</span></code></a>. Its structure is <a class="reference internal" href="adc_oneshot.html#_CPPv422adc_digi_output_data_t" title="adc_digi_output_data_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">adc_digi_output_data_t</span></code></a>, including ADC unit, ADC channel, and raw data.</p></li>
</ul>
<a class="reference internal image-reference" href="../../_images/adc_conversion_frame.png"><img alt="../../_images/adc_conversion_frame.png" class="align-center" src="../../_images/adc_conversion_frame.png" style="width: 774.0px; height: 168.0px;" /></a>
</section>
</section>
<section id="functional-overview">
<h2>Functional Overview<a class="headerlink" href="#functional-overview" title="Permalink to this heading">ï</a></h2>
<p>The following sections of this document cover the typical steps to install the ADC continuous mode driver, and read ADC conversion results from a group of ADC channels continuously:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#adc-continuous-resource-allocation"><span class="std std-ref">Resource Allocation</span></a>: covers which parameters should be set up to initialize the ADC continuous mode driver and how to deinitialize it.</p></li>
<li><p><a class="reference internal" href="#adc-continuous-adc-configurations"><span class="std std-ref">ADC Configurations</span></a>: describes how to configure the ADC(s) to make it work under continuous mode.</p></li>
<li><p><a class="reference internal" href="#adc-continuous-adc-control"><span class="std std-ref">ADC Control</span></a>: describes ADC control functions.</p></li>
<li><p><a class="reference internal" href="#adc-continuous-register-event-callbacks"><span class="std std-ref">Register Event Callbacks</span></a>: describes how to hook user-specific code to an ADC continuous mode event callback function.</p></li>
<li><p><a class="reference internal" href="#adc-continuous-read-conversion-result"><span class="std std-ref">Read Conversion Result</span></a>: covers how to get ADC conversion result.</p></li>
<li><p><a class="reference internal" href="#adc-continuous-hardware-limitations"><span class="std std-ref">Hardware Limitations</span></a>: describes the ADC-related hardware limitations.</p></li>
<li><p><a class="reference internal" href="#adc-continuous-power-management"><span class="std std-ref">Power Management</span></a>: covers power management-related information.</p></li>
<li><p><a class="reference internal" href="#adc-continuous-iram-safe"><span class="std std-ref">IRAM Safe</span></a>: covers the IRAM safe functions.</p></li>
<li><p><a class="reference internal" href="#adc-continuous-thread-safety"><span class="std std-ref">Thread Safety</span></a>: lists which APIs are guaranteed to be thread-safe by the driver.</p></li>
</ul>
<section id="resource-allocation">
<span id="adc-continuous-resource-allocation"></span><h3>Resource Allocation<a class="headerlink" href="#resource-allocation" title="Permalink to this heading">ï</a></h3>
<p>The ADC continuous mode driver is implemented based on ESP32 SAR ADC module. Different ESP targets might have different numbers of independent ADCs.</p>
<p>To create an ADC continuous mode driver handle, set up the required configuration structure <a class="reference internal" href="#_CPPv427adc_continuous_handle_cfg_t" title="adc_continuous_handle_cfg_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">adc_continuous_handle_cfg_t</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N27adc_continuous_handle_cfg_t18max_store_buf_sizeE" title="adc_continuous_handle_cfg_t::max_store_buf_size"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_handle_cfg_t::max_store_buf_size</span></code></a>: set the maximum size of the pool in bytes, and the driver saves ADC conversion result into the pool. If this pool is full, new conversion results will be lost.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N27adc_continuous_handle_cfg_t15conv_frame_sizeE" title="adc_continuous_handle_cfg_t::conv_frame_size"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_handle_cfg_t::conv_frame_size</span></code></a>: set the size of the ADC conversion frame, in bytes.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N27adc_continuous_handle_cfg_t5flagsE" title="adc_continuous_handle_cfg_t::flags"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_handle_cfg_t::flags</span></code></a>: set the flags that can change the driver's behavior.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">flush_pool</span></code>: auto flush the pool when it's full.</p></li>
</ul>
</li>
</ul>
<p>After setting up the above configurations for the ADC, call <a class="reference internal" href="#_CPPv425adc_continuous_new_handlePK27adc_continuous_handle_cfg_tP23adc_continuous_handle_t" title="adc_continuous_new_handle"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_new_handle()</span></code></a> with the prepared <a class="reference internal" href="#_CPPv427adc_continuous_handle_cfg_t" title="adc_continuous_handle_cfg_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">adc_continuous_handle_cfg_t</span></code></a>. This function may fail due to various errors such as invalid arguments, insufficient memory, etc.</p>
<p>Especially, when this function returns <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_FOUND" title="ESP_ERR_NOT_FOUND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_FOUND</span></code></a>, this means the I2S0 peripheral is in use. See <a class="reference internal" href="#adc-continuous-hardware-limitations"><span class="std std-ref">Hardware Limitations</span></a> for more information.</p>
<p>If the ADC continuous mode driver is no longer used, you should deinitialize the driver by calling <a class="reference internal" href="#_CPPv421adc_continuous_deinit23adc_continuous_handle_t" title="adc_continuous_deinit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_deinit()</span></code></a>.</p>
<section id="initialize-the-adc-continuous-mode-driver">
<h4>Initialize the ADC Continuous Mode Driver<a class="headerlink" href="#initialize-the-adc-continuous-mode-driver" title="Permalink to this heading">ï</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">adc_continuous_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">adc_continuous_handle_cfg_t</span><span class="w"> </span><span class="n">adc_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">max_store_buf_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">conv_frame_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">adc_continuous_new_handle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adc_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="recycle-the-adc-unit">
<h4>Recycle the ADC Unit<a class="headerlink" href="#recycle-the-adc-unit" title="Permalink to this heading">ï</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">adc_continuous_deinit</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span>
</pre></div>
</div>
</section>
</section>
<section id="adc-configurations">
<span id="adc-continuous-adc-configurations"></span><h3>ADC Configurations<a class="headerlink" href="#adc-configurations" title="Permalink to this heading">ï</a></h3>
<p>After the ADC continuous mode driver is initialized, set up the <a class="reference internal" href="#_CPPv423adc_continuous_config_t" title="adc_continuous_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">adc_continuous_config_t</span></code></a> to configure ADC IOs to measure analog signal:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N23adc_continuous_config_t11pattern_numE" title="adc_continuous_config_t::pattern_num"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_config_t::pattern_num</span></code></a>: number of ADC channels that will be used.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23adc_continuous_config_t11adc_patternE" title="adc_continuous_config_t::adc_pattern"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_config_t::adc_pattern</span></code></a>: list of configs for each ADC channel that will be used, see the description below.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23adc_continuous_config_t14sample_freq_hzE" title="adc_continuous_config_t::sample_freq_hz"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_config_t::sample_freq_hz</span></code></a>: expected ADC sampling frequency in Hz.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23adc_continuous_config_t9conv_modeE" title="adc_continuous_config_t::conv_mode"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_config_t::conv_mode</span></code></a>: continuous conversion mode.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N23adc_continuous_config_t6formatE" title="adc_continuous_config_t::format"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_config_t::format</span></code></a>: conversion output format.</p></li>
</ul>
<p>Set <a class="reference internal" href="adc_oneshot.html#_CPPv425adc_digi_pattern_config_t" title="adc_digi_pattern_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">adc_digi_pattern_config_t</span></code></a> with the following process:</p>
<ul class="simple">
<li><p><a class="reference internal" href="adc_oneshot.html#_CPPv4N25adc_digi_pattern_config_t5attenE" title="adc_digi_pattern_config_t::atten"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_digi_pattern_config_t::atten</span></code></a>: ADC attenuation. Refer to the On-Chip Sensor and Analog Signal Processing chapter in <a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf">TRM</a>.</p></li>
<li><p><a class="reference internal" href="adc_oneshot.html#_CPPv4N25adc_digi_pattern_config_t7channelE" title="adc_digi_pattern_config_t::channel"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_digi_pattern_config_t::channel</span></code></a>: the IO corresponding ADC channel number. See the note below.</p></li>
<li><p><a class="reference internal" href="adc_oneshot.html#_CPPv4N25adc_digi_pattern_config_t4unitE" title="adc_digi_pattern_config_t::unit"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_digi_pattern_config_t::unit</span></code></a>: the ADC that the IO is subordinate to.</p></li>
<li><p><a class="reference internal" href="adc_oneshot.html#_CPPv4N25adc_digi_pattern_config_t9bit_widthE" title="adc_digi_pattern_config_t::bit_width"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_digi_pattern_config_t::bit_width</span></code></a>: the bitwidth of the raw conversion result.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the IO corresponding ADC channel number, check <a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#sensor">TRM</a> to acquire the ADC IOs. Besides, <a class="reference internal" href="#_CPPv428adc_continuous_io_to_channeliPC10adc_unit_tPC13adc_channel_t" title="adc_continuous_io_to_channel"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_io_to_channel()</span></code></a> and <a class="reference internal" href="#_CPPv428adc_continuous_channel_to_io10adc_unit_t13adc_channel_tPCi" title="adc_continuous_channel_to_io"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_channel_to_io()</span></code></a> can be used to acquire the ADC channels and ADC IOs.</p>
</div>
<p>To make these settings take effect, call <a class="reference internal" href="#_CPPv421adc_continuous_config23adc_continuous_handle_tPK23adc_continuous_config_t" title="adc_continuous_config"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_config()</span></code></a> with the configuration structure above. This API may fail due to reasons like <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_INVALID_ARG" title="ESP_ERR_INVALID_ARG"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_ARG</span></code></a>. When it returns <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_INVALID_STATE" title="ESP_ERR_INVALID_STATE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_STATE</span></code></a>, this means the ADC continuous mode driver is started, you should not call this API at this moment.</p>
<p>See ADC continuous mode example <a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/adc/continuous_read">peripherals/adc/continuous_read</a> to see configuration codes.</p>
</section>
<section id="adc-control">
<span id="adc-continuous-adc-control"></span><h3>ADC Control<a class="headerlink" href="#adc-control" title="Permalink to this heading">ï</a></h3>
<section id="start-and-stop">
<h4>Start and Stop<a class="headerlink" href="#start-and-stop" title="Permalink to this heading">ï</a></h4>
<p>Calling <a class="reference internal" href="#_CPPv420adc_continuous_start23adc_continuous_handle_t" title="adc_continuous_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_start()</span></code></a> makes the ADC start to measure analog signals from the configured ADC channels, and generate the conversion results.</p>
<p>On the contrary, calling <a class="reference internal" href="#_CPPv419adc_continuous_stop23adc_continuous_handle_t" title="adc_continuous_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_stop()</span></code></a> stops the ADC conversion.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">adc_continuous_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span>
</pre></div>
</div>
</section>
</section>
<section id="register-event-callbacks">
<span id="adc-continuous-register-event-callbacks"></span><h3>Register Event Callbacks<a class="headerlink" href="#register-event-callbacks" title="Permalink to this heading">ï</a></h3>
<p>By calling <a class="reference internal" href="#_CPPv439adc_continuous_register_event_callbacks23adc_continuous_handle_tPK24adc_continuous_evt_cbs_tPv" title="adc_continuous_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_register_event_callbacks()</span></code></a>, you can hook your own function to the driver ISR. Supported event callbacks are listed in <a class="reference internal" href="#_CPPv424adc_continuous_evt_cbs_t" title="adc_continuous_evt_cbs_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">adc_continuous_evt_cbs_t</span></code></a>.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N24adc_continuous_evt_cbs_t12on_conv_doneE" title="adc_continuous_evt_cbs_t::on_conv_done"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_evt_cbs_t::on_conv_done</span></code></a>: this is invoked when one conversion frame finishes.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N24adc_continuous_evt_cbs_t11on_pool_ovfE" title="adc_continuous_evt_cbs_t::on_pool_ovf"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_evt_cbs_t::on_pool_ovf</span></code></a>: this is invoked when the internal pool is full. Newer conversion results will be discarded.</p></li>
</ul>
<p>As the above callbacks are called in an ISR context, you should always ensure the callback function is suitable for an ISR context. Blocking logic should not appear in these callbacks. The callback function prototype is declared in <a class="reference internal" href="#_CPPv425adc_continuous_callback_t" title="adc_continuous_callback_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">adc_continuous_callback_t</span></code></a>.</p>
<p>You can also register your own context when calling <a class="reference internal" href="#_CPPv439adc_continuous_register_event_callbacks23adc_continuous_handle_tPK24adc_continuous_evt_cbs_tPv" title="adc_continuous_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_register_event_callbacks()</span></code></a> by the parameter <code class="docutils literal notranslate"><span class="pre">user_data</span></code>. This user data will be passed to the callback functions directly.</p>
<p>This function may fail due to reasons like <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_INVALID_ARG" title="ESP_ERR_INVALID_ARG"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_ARG</span></code></a>. Especially, when <a class="reference internal" href="../kconfig.html#config-adc-continuous-isr-iram-safe"><span class="std std-ref">CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE</span></a> is enabled, this error may indicate that the callback functions are not in the internal RAM. Check the error log for more details. Besides, when it fails due to <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_INVALID_STATE" title="ESP_ERR_INVALID_STATE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_STATE</span></code></a>, it indicates that the ADC continuous mode driver is started, and you should not add a callback at this moment.</p>
<section id="conversion-done-event">
<h4>Conversion Done Event<a class="headerlink" href="#conversion-done-event" title="Permalink to this heading">ï</a></h4>
<p>When the driver completes a conversion, it triggers the <a class="reference internal" href="#_CPPv4N24adc_continuous_evt_cbs_t12on_conv_doneE" title="adc_continuous_evt_cbs_t::on_conv_done"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_evt_cbs_t::on_conv_done</span></code></a> event and fills the event data. Event data contains a buffer pointer to a conversion frame buffer, together with the size. Refer to <a class="reference internal" href="#_CPPv425adc_continuous_evt_data_t" title="adc_continuous_evt_data_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">adc_continuous_evt_data_t</span></code></a> to know the event data structure.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is worth noting that, the data buffer <a class="reference internal" href="#_CPPv4N25adc_continuous_evt_data_t17conv_frame_bufferE" title="adc_continuous_evt_data_t::conv_frame_buffer"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_continuous_evt_data_t::conv_frame_buffer</span></code></a> is maintained by the driver itself. Therefore, never free this piece of memory.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the Kconfig option <a class="reference internal" href="../kconfig.html#config-adc-continuous-isr-iram-safe"><span class="std std-ref">CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE</span></a> is enabled, the registered callbacks and the functions called by the callbacks should be placed in IRAM. The involved variables should be placed in internal RAM as well.</p>
</div>
</section>
<section id="pool-overflow-event">
<h4>Pool Overflow Event<a class="headerlink" href="#pool-overflow-event" title="Permalink to this heading">ï</a></h4>
<p>The ADC continuous mode driver has an internal pool to save the conversion results. When the pool is full, a pool overflow event will emerge. Under this condition, the driver will not fill in the event data. This usually happens because the speed to read data from the pool by calling <a class="reference internal" href="#_CPPv419adc_continuous_read23adc_continuous_handle_tP7uint8_t8uint32_tP8uint32_t8uint32_t" title="adc_continuous_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_read()</span></code></a> is much slower than the ADC conversion speed.</p>
</section>
</section>
<section id="read-conversion-result">
<span id="adc-continuous-read-conversion-result"></span><h3>Read Conversion Result<a class="headerlink" href="#read-conversion-result" title="Permalink to this heading">ï</a></h3>
<p>After calling <a class="reference internal" href="#_CPPv420adc_continuous_start23adc_continuous_handle_t" title="adc_continuous_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_start()</span></code></a>, the ADC continuous conversion starts. Call <a class="reference internal" href="#_CPPv419adc_continuous_read23adc_continuous_handle_tP7uint8_t8uint32_tP8uint32_t8uint32_t" title="adc_continuous_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_read()</span></code></a> to get the conversion results of the ADC channels. You need to provide a buffer to get the raw results.</p>
<p>Function <a class="reference internal" href="#_CPPv419adc_continuous_read23adc_continuous_handle_tP7uint8_t8uint32_tP8uint32_t8uint32_t" title="adc_continuous_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_read()</span></code></a> tries to read the expected length of conversion results each time.</p>
<ul class="simple">
<li><p>When calling <a class="reference internal" href="#_CPPv419adc_continuous_read23adc_continuous_handle_tP7uint8_t8uint32_tP8uint32_t8uint32_t" title="adc_continuous_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_read()</span></code></a>, you can request to read a conversion result of the specified length. Sometimes, however, the actual available conversion results may be less than the requested length, in which case the function still moves the data from the internal pool into the buffer you provided. Therefore, to learn the number of conversion results actually moved into the buffer, please check the value of <code class="docutils literal notranslate"><span class="pre">out_length</span></code>.</p></li>
<li><p>If there is no conversion result generated in the internal pool, the function will block for <code class="docutils literal notranslate"><span class="pre">timeout_ms</span></code> until the conversion results are generated. If there are still no generated results, the function will return <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_TIMEOUT" title="ESP_ERR_TIMEOUT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_TIMEOUT</span></code></a>.</p></li>
<li><p>If the generated results fill up the internal pool, newly generated results will be lost. Next time when <a class="reference internal" href="#_CPPv419adc_continuous_read23adc_continuous_handle_tP7uint8_t8uint32_tP8uint32_t8uint32_t" title="adc_continuous_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_read()</span></code></a> is called, this function will return <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_INVALID_STATE" title="ESP_ERR_INVALID_STATE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_STATE</span></code></a> to indicate this situation.</p></li>
</ul>
<p>This API aims to give you a chance to read all the ADC continuous conversion results.</p>
<p>The ADC conversion results read from the above function are raw data. To calculate the voltage based on the ADC raw results, this formula can be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Vout</span> <span class="o">=</span> <span class="n">Dout</span> <span class="o">*</span> <span class="n">Vmax</span> <span class="o">/</span> <span class="n">Dmax</span>       <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>where:</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 20.0%" />
<col style="width: 80.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Vout</p></th>
<th class="head"><p>Digital output result, standing for the voltage.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Dout</p></td>
<td><p>ADC raw digital reading result.</p></td>
</tr>
<tr class="row-odd"><td><p>Vmax</p></td>
<td><p>Maximum measurable input analog voltage, this is related to the ADC attenuation, please refer to the On-Chip Sensor and Analog Signal Processing chapter in <a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf">Datasheet</a>.</p></td>
</tr>
<tr class="row-even"><td><p>Dmax</p></td>
<td><p>Maximum of the output ADC raw digital reading result, which is 2^bitwidth, where the bitwidth is the <a class="reference internal" href="adc_oneshot.html#_CPPv4N25adc_digi_pattern_config_t9bit_widthE" title="adc_digi_pattern_config_t::bit_width"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_digi_pattern_config_t::bit_width</span></code></a> configured before.</p></td>
</tr>
</tbody>
</table>
<p>To do further calibration to convert the ADC raw result to voltage in mV, please refer to <a class="reference internal" href="adc_calibration.html"><span class="doc">Analog to Digital Converter (ADC) Calibration Driver</span></a>.</p>
</section>
<section id="hardware-limitations">
<span id="hardware-limitations-adc-continuous"></span><span id="adc-continuous-hardware-limitations"></span><h3>Hardware Limitations<a class="headerlink" href="#hardware-limitations" title="Permalink to this heading">ï</a></h3>
<p><ul class="simple">
<li><p>A specific ADC unit can only work under one operating mode at any one time, either continuous mode or one-shot mode. <a class="reference internal" href="#_CPPv420adc_continuous_start23adc_continuous_handle_t" title="adc_continuous_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_start()</span></code></a> has provided the protection.</p></li>
<li><p>Random Number Generator (RNG) uses ADC as an input source. When ADC continuous mode driver works, the random number generated from RNG will be less random.</p></li>
<li><p>ADC2 is also used by Wi-Fi. <a class="reference internal" href="#_CPPv420adc_continuous_start23adc_continuous_handle_t" title="adc_continuous_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_start()</span></code></a> has provided the protection between Wi-Fi driver and ADC continuous mode driver.</p></li>
<li><p>ADC continuous mode driver uses I2S0 peripheral as hardware DMA FIFO. Therefore, if I2S0 is in use already, the <a class="reference internal" href="#_CPPv425adc_continuous_new_handlePK27adc_continuous_handle_cfg_tP23adc_continuous_handle_t" title="adc_continuous_new_handle"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_new_handle()</span></code></a> will return <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_FOUND" title="ESP_ERR_NOT_FOUND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_FOUND</span></code></a>.</p></li>
<li><p>ESP32 DevKitC: GPIO 0 cannot be used due to external auto program circuits.</p></li>
<li><p>ESP-WROVER-KIT: GPIO 0, 2, 4, and 15 cannot be used due to external connections for different purposes.</p></li>
</ul>
</p>
</section>
<section id="power-management">
<span id="adc-continuous-power-management"></span><h3>Power Management<a class="headerlink" href="#power-management" title="Permalink to this heading">ï</a></h3>
<p>When power management is enabled, i.e., <a class="reference internal" href="../kconfig.html#config-pm-enable"><span class="std std-ref">CONFIG_PM_ENABLE</span></a> is on, the APB clock frequency may be adjusted when the system is in an idle state, thus potentially changing the behavior of ADC continuous conversion.</p>
<p>However, the continuous mode driver can prevent this change by acquiring a power management lock of type <a class="reference internal" href="../system/power_management.html#_CPPv4N18esp_pm_lock_type_t19ESP_PM_APB_FREQ_MAXE" title="ESP_PM_APB_FREQ_MAX"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code></a>. The lock is acquired after the continuous conversion is started by <a class="reference internal" href="#_CPPv420adc_continuous_start23adc_continuous_handle_t" title="adc_continuous_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_start()</span></code></a>. Similarly, the lock will be released after <a class="reference internal" href="#_CPPv419adc_continuous_stop23adc_continuous_handle_t" title="adc_continuous_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_stop()</span></code></a>. Therefore, <a class="reference internal" href="#_CPPv420adc_continuous_start23adc_continuous_handle_t" title="adc_continuous_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_start()</span></code></a> and <a class="reference internal" href="#_CPPv419adc_continuous_stop23adc_continuous_handle_t" title="adc_continuous_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">adc_continuous_stop()</span></code></a> should appear in pairs, otherwise, the power management will be out of action.</p>
</section>
<section id="iram-safe">
<span id="adc-continuous-iram-safe"></span><h3>IRAM Safe<a class="headerlink" href="#iram-safe" title="Permalink to this heading">ï</a></h3>
<p>All the ADC continuous mode driver APIs are not IRAM-safe. They are not supposed to be run when the Cache is disabled. By enabling the Kconfig option <a class="reference internal" href="../kconfig.html#config-adc-continuous-isr-iram-safe"><span class="std std-ref">CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE</span></a>, the driver's internal ISR handler is IRAM-safe, which means even when the Cache is disabled, the driver will still save the conversion results into its internal pool.</p>
</section>
<section id="thread-safety">
<span id="adc-continuous-thread-safety"></span><h3>Thread Safety<a class="headerlink" href="#thread-safety" title="Permalink to this heading">ï</a></h3>
<p>ADC continuous mode driver APIs are not guaranteed to be thread-safe. However, the share hardware mutual exclusion is provided by the driver. See <a class="reference internal" href="#adc-continuous-hardware-limitations"><span class="std std-ref">Hardware Limitations</span></a> for more details.</p>
</section>
</section>
<section id="application-examples">
<h2>Application Examples<a class="headerlink" href="#application-examples" title="Permalink to this heading">ï</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/peripherals/adc/continuous_read">peripherals/adc/continuous_read</a> demonstrates how to use the ADC Continuous Read Mode (DMA Mode) on ESP32 development boards to read from GPIO pins via on-chip ADC modules.</p></li>
</ul>
</section>
<section id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this heading">ï</a></h2>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading">ï</a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_adc/include/esp_adc/adc_continuous.h">components/esp_adc/include/esp_adc/adc_continuous.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_adc/adc_continuous.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_adc</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_adc</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_adc
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_adc
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading">ï</a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425adc_continuous_new_handlePK27adc_continuous_handle_cfg_tP23adc_continuous_handle_t">
<span id="_CPPv325adc_continuous_new_handlePK27adc_continuous_handle_cfg_tP23adc_continuous_handle_t"></span><span id="_CPPv225adc_continuous_new_handlePK27adc_continuous_handle_cfg_tP23adc_continuous_handle_t"></span><span id="adc_continuous_new_handle__adc_continuous_handle_cfg_tCP.adc_continuous_handle_tP"></span><span class="target" id="adc__continuous_8h_1a91d12b347f001ae405951cfd95a7ccfa"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_new_handle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv427adc_continuous_handle_cfg_t" title="adc_continuous_handle_cfg_t"><span class="n"><span class="pre">adc_continuous_handle_cfg_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">hdl_config</span></span>, <a class="reference internal" href="#_CPPv423adc_continuous_handle_t" title="adc_continuous_handle_t"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425adc_continuous_new_handlePK27adc_continuous_handle_cfg_tP23adc_continuous_handle_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Initialize ADC continuous driver and get a handle to it. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdl_config</strong> -- <strong>[in]</strong> Pointer to ADC initialization config. Refer to <code class="docutils literal notranslate"><a class="reference internal" href="#structadc__continuous__handle__cfg__t"><span class="std std-ref"><span class="pre">adc_continuous_handle_cfg_t</span></span></a></code>. </p></li>
<li><p><strong>ret_handle</strong> -- <strong>[out]</strong> ADC continuous mode driver handle</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_ARG If the combination of arguments is invalid.</p></li>
<li><p>ESP_ERR_NOT_FOUND No free interrupt found with the specified flags</p></li>
<li><p>ESP_ERR_NO_MEM If out of memory</p></li>
<li><p>ESP_OK On success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421adc_continuous_config23adc_continuous_handle_tPK23adc_continuous_config_t">
<span id="_CPPv321adc_continuous_config23adc_continuous_handle_tPK23adc_continuous_config_t"></span><span id="_CPPv221adc_continuous_config23adc_continuous_handle_tPK23adc_continuous_config_t"></span><span id="adc_continuous_config__adc_continuous_handle_t.adc_continuous_config_tCP"></span><span class="target" id="adc__continuous_8h_1a6b4a14daf6b7606e8d02a3db7db620d7"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_config</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423adc_continuous_handle_t" title="adc_continuous_handle_t"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv423adc_continuous_config_t" title="adc_continuous_config_t"><span class="n"><span class="pre">adc_continuous_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421adc_continuous_config23adc_continuous_handle_tPK23adc_continuous_config_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Set ADC continuous mode required configurations. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> ADC continuous mode driver handle </p></li>
<li><p><strong>config</strong> -- <strong>[in]</strong> Refer to <code class="docutils literal notranslate"><span class="pre">adc_digi_config_t</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_STATE: Driver state is invalid, you shouldn't call this API at this moment</p></li>
<li><p>ESP_ERR_INVALID_ARG: If the combination of arguments is invalid.</p></li>
<li><p>ESP_OK: On success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv439adc_continuous_register_event_callbacks23adc_continuous_handle_tPK24adc_continuous_evt_cbs_tPv">
<span id="_CPPv339adc_continuous_register_event_callbacks23adc_continuous_handle_tPK24adc_continuous_evt_cbs_tPv"></span><span id="_CPPv239adc_continuous_register_event_callbacks23adc_continuous_handle_tPK24adc_continuous_evt_cbs_tPv"></span><span id="adc_continuous_register_event_callbacks__adc_continuous_handle_t.adc_continuous_evt_cbs_tCP.voidP"></span><span class="target" id="adc__continuous_8h_1ad131db5b07f8dcccc006d3f8dae6d8e9"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_register_event_callbacks</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423adc_continuous_handle_t" title="adc_continuous_handle_t"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv424adc_continuous_evt_cbs_t" title="adc_continuous_evt_cbs_t"><span class="n"><span class="pre">adc_continuous_evt_cbs_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cbs</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">user_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv439adc_continuous_register_event_callbacks23adc_continuous_handle_tPK24adc_continuous_evt_cbs_tPv" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Register callbacks. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>User can deregister a previously registered callback by calling this function and setting the to-be-deregistered callback member in the <code class="docutils literal notranslate"><span class="pre">cbs</span></code> structure to NULL. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. Involved variables (including <code class="docutils literal notranslate"><span class="pre">user_data</span></code>) should be in internal RAM as well. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You should only call this API when the ADC continuous mode driver isn't started. Check return value to know this.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> ADC continuous mode driver handle </p></li>
<li><p><strong>cbs</strong> -- <strong>[in]</strong> Group of callback functions </p></li>
<li><p><strong>user_data</strong> -- <strong>[in]</strong> User data, which will be delivered to the callback functions directly</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: On success</p></li>
<li><p>ESP_ERR_INVALID_ARG: Invalid arguments</p></li>
<li><p>ESP_ERR_INVALID_STATE: Driver state is invalid, you shouldn't call this API at this moment </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420adc_continuous_start23adc_continuous_handle_t">
<span id="_CPPv320adc_continuous_start23adc_continuous_handle_t"></span><span id="_CPPv220adc_continuous_start23adc_continuous_handle_t"></span><span id="adc_continuous_start__adc_continuous_handle_t"></span><span class="target" id="adc__continuous_8h_1a7b8534f9da6622952114fe92be0a7bb3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_start</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423adc_continuous_handle_t" title="adc_continuous_handle_t"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420adc_continuous_start23adc_continuous_handle_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Start the ADC under continuous mode. After this, the hardware starts working. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- <strong>[in]</strong> ADC continuous mode driver handle</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_STATE Driver state is invalid.</p></li>
<li><p>ESP_OK On success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419adc_continuous_read23adc_continuous_handle_tP7uint8_t8uint32_tP8uint32_t8uint32_t">
<span id="_CPPv319adc_continuous_read23adc_continuous_handle_tP7uint8_t8uint32_tP8uint32_t8uint32_t"></span><span id="_CPPv219adc_continuous_read23adc_continuous_handle_tP7uint8_t8uint32_tP8uint32_t8uint32_t"></span><span id="adc_continuous_read__adc_continuous_handle_t.uint8_tP.uint32_t.uint32_tP.uint32_t"></span><span class="target" id="adc__continuous_8h_1a3a84831623041619bdea548db20cadc1"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_read</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423adc_continuous_handle_t" title="adc_continuous_handle_t"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">buf</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">length_max</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_length</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">timeout_ms</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419adc_continuous_read23adc_continuous_handle_tP7uint8_t8uint32_tP8uint32_t8uint32_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Read bytes from ADC under continuous mode. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> ADC continuous mode driver handle </p></li>
<li><p><strong>buf</strong> -- <strong>[out]</strong> Conversion result buffer to read from ADC. Suggest convert to <code class="docutils literal notranslate"><a class="reference internal" href="adc_oneshot.html#structadc__digi__output__data__t"><span class="std std-ref"><span class="pre">adc_digi_output_data_t</span></span></a></code> for <code class="docutils literal notranslate"><span class="pre">ADC</span> <span class="pre">Conversion</span> <span class="pre">Results</span></code>. See the subsection <code class="docutils literal notranslate"><span class="pre">Driver</span> <span class="pre">Backgrounds</span></code> in this header file to learn about this concept. </p></li>
<li><p><strong>length_max</strong> -- <strong>[in]</strong> Expected length of the Conversion Results read from the ADC, in bytes. </p></li>
<li><p><strong>out_length</strong> -- <strong>[out]</strong> Real length of the Conversion Results read from the ADC via this API, in bytes. </p></li>
<li><p><strong>timeout_ms</strong> -- <strong>[in]</strong> Time to wait for data via this API, in millisecond.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_STATE Driver state is invalid. Usually it means the ADC sampling rate is faster than the task processing rate.</p></li>
<li><p>ESP_ERR_TIMEOUT Operation timed out</p></li>
<li><p>ESP_OK On success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419adc_continuous_stop23adc_continuous_handle_t">
<span id="_CPPv319adc_continuous_stop23adc_continuous_handle_t"></span><span id="_CPPv219adc_continuous_stop23adc_continuous_handle_t"></span><span id="adc_continuous_stop__adc_continuous_handle_t"></span><span class="target" id="adc__continuous_8h_1ab6640ad3981e8da939fc793f2cf3545e"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_stop</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423adc_continuous_handle_t" title="adc_continuous_handle_t"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419adc_continuous_stop23adc_continuous_handle_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Stop the ADC. After this, the hardware stops working. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- <strong>[in]</strong> ADC continuous mode driver handle</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_STATE Driver state is invalid.</p></li>
<li><p>ESP_OK On success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421adc_continuous_deinit23adc_continuous_handle_t">
<span id="_CPPv321adc_continuous_deinit23adc_continuous_handle_t"></span><span id="_CPPv221adc_continuous_deinit23adc_continuous_handle_t"></span><span id="adc_continuous_deinit__adc_continuous_handle_t"></span><span class="target" id="adc__continuous_8h_1abaf61425da0214ab7ce3a4d933f63527"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_deinit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423adc_continuous_handle_t" title="adc_continuous_handle_t"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421adc_continuous_deinit23adc_continuous_handle_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Deinitialize the ADC continuous driver. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- <strong>[in]</strong> ADC continuous mode driver handle</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_STATE Driver state is invalid.</p></li>
<li><p>ESP_OK On success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425adc_continuous_flush_pool23adc_continuous_handle_t">
<span id="_CPPv325adc_continuous_flush_pool23adc_continuous_handle_t"></span><span id="_CPPv225adc_continuous_flush_pool23adc_continuous_handle_t"></span><span id="adc_continuous_flush_pool__adc_continuous_handle_t"></span><span class="target" id="adc__continuous_8h_1afeefa193311707b028055f8b2f12f67d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_flush_pool</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423adc_continuous_handle_t" title="adc_continuous_handle_t"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425adc_continuous_flush_pool23adc_continuous_handle_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Flush the driver internal pool. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This API is not supposed to be called in an ISR context</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- <strong>[in]</strong> ADC continuous mode driver handle</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_STATE Driver state is invalid, you should call this API when it's in init state</p></li>
<li><p>ESP_ERR_INVALID_ARG: Invalid arguments</p></li>
<li><p>ESP_OK On success </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428adc_continuous_io_to_channeliPC10adc_unit_tPC13adc_channel_t">
<span id="_CPPv328adc_continuous_io_to_channeliPC10adc_unit_tPC13adc_channel_t"></span><span id="_CPPv228adc_continuous_io_to_channeliPC10adc_unit_tPC13adc_channel_t"></span><span id="adc_continuous_io_to_channel__i.adc_unit_tPC.adc_channel_tPC"></span><span class="target" id="adc__continuous_8h_1a78112cefff22d92afd419d860dc65687"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_io_to_channel</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">io_num</span></span>, <a class="reference internal" href="adc_oneshot.html#_CPPv410adc_unit_t" title="adc_unit_t"><span class="n"><span class="pre">adc_unit_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">unit_id</span></span>, <a class="reference internal" href="adc_oneshot.html#_CPPv413adc_channel_t" title="adc_channel_t"><span class="n"><span class="pre">adc_channel_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">channel</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428adc_continuous_io_to_channeliPC10adc_unit_tPC13adc_channel_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Get ADC channel from the given GPIO number. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>io_num</strong> -- <strong>[in]</strong> GPIO number </p></li>
<li><p><strong>unit_id</strong> -- <strong>[out]</strong> ADC unit </p></li>
<li><p><strong>channel</strong> -- <strong>[out]</strong> ADC channel</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: On success</p></li>
<li><p>ESP_ERR_INVALID_ARG: Invalid argument</p></li>
<li><p>ESP_ERR_NOT_FOUND: The IO is not a valid ADC pad </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428adc_continuous_channel_to_io10adc_unit_t13adc_channel_tPCi">
<span id="_CPPv328adc_continuous_channel_to_io10adc_unit_t13adc_channel_tPCi"></span><span id="_CPPv228adc_continuous_channel_to_io10adc_unit_t13adc_channel_tPCi"></span><span id="adc_continuous_channel_to_io__adc_unit_t.adc_channel_t.iPC"></span><span class="target" id="adc__continuous_8h_1a8de7cb3b4d848f1d13ed5c91fb2001e3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_channel_to_io</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="adc_oneshot.html#_CPPv410adc_unit_t" title="adc_unit_t"><span class="n"><span class="pre">adc_unit_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">unit_id</span></span>, <a class="reference internal" href="adc_oneshot.html#_CPPv413adc_channel_t" title="adc_channel_t"><span class="n"><span class="pre">adc_channel_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">channel</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">io_num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428adc_continuous_channel_to_io10adc_unit_t13adc_channel_tPCi" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Get GPIO number from the given ADC channel. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>unit_id</strong> -- <strong>[in]</strong> ADC unit </p></li>
<li><p><strong>channel</strong> -- <strong>[in]</strong> ADC channel </p></li>
<li><p><strong>io_num</strong> -- <strong>[out]</strong> GPIO number</p></li>
<li><p><strong>-</strong> -- ESP_OK: On success<ul>
<li><p>ESP_ERR_INVALID_ARG: Invalid argument </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading">ï</a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv427adc_continuous_handle_cfg_t">
<span id="_CPPv327adc_continuous_handle_cfg_t"></span><span id="_CPPv227adc_continuous_handle_cfg_t"></span><span id="adc_continuous_handle_cfg_t"></span><span class="target" id="structadc__continuous__handle__cfg__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_handle_cfg_t</span></span></span><a class="headerlink" href="#_CPPv427adc_continuous_handle_cfg_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>ADC continuous mode driver initial configurations. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N27adc_continuous_handle_cfg_t18max_store_buf_sizeE">
<span id="_CPPv3N27adc_continuous_handle_cfg_t18max_store_buf_sizeE"></span><span id="_CPPv2N27adc_continuous_handle_cfg_t18max_store_buf_sizeE"></span><span id="adc_continuous_handle_cfg_t::max_store_buf_size__uint32_t"></span><span class="target" id="structadc__continuous__handle__cfg__t_1a1890811a8800bf719ce3d4f5db2dc536"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_store_buf_size</span></span></span><a class="headerlink" href="#_CPPv4N27adc_continuous_handle_cfg_t18max_store_buf_sizeE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Max length of the conversion results that driver can store, in bytes. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N27adc_continuous_handle_cfg_t15conv_frame_sizeE">
<span id="_CPPv3N27adc_continuous_handle_cfg_t15conv_frame_sizeE"></span><span id="_CPPv2N27adc_continuous_handle_cfg_t15conv_frame_sizeE"></span><span id="adc_continuous_handle_cfg_t::conv_frame_size__uint32_t"></span><span class="target" id="structadc__continuous__handle__cfg__t_1a8679016a6063457c6ad0c916e2940561"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">conv_frame_size</span></span></span><a class="headerlink" href="#_CPPv4N27adc_continuous_handle_cfg_t15conv_frame_sizeE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Conversion frame size, in bytes. This should be in multiples of <code class="docutils literal notranslate"><span class="pre">SOC_ADC_DIGI_DATA_BYTES_PER_CONV</span></code>. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N27adc_continuous_handle_cfg_t10flush_poolE">
<span id="_CPPv3N27adc_continuous_handle_cfg_t10flush_poolE"></span><span id="_CPPv2N27adc_continuous_handle_cfg_t10flush_poolE"></span><span id="adc_continuous_handle_cfg_t::flush_pool__uint32_t"></span><span class="target" id="structadc__continuous__handle__cfg__t_1a06000e8291e06af3fde42a7f8ef45d40"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flush_pool</span></span></span><a class="headerlink" href="#_CPPv4N27adc_continuous_handle_cfg_t10flush_poolE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Flush the internal pool when the pool is full. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N27adc_continuous_handle_cfg_t5flagsE">
<span id="_CPPv3N27adc_continuous_handle_cfg_t5flagsE"></span><span id="_CPPv2N27adc_continuous_handle_cfg_t5flagsE"></span><span id="adc_continuous_handle_cfg_t::flags__adc_continuous_handle_cfg_t"></span><span class="target" id="structadc__continuous__handle__cfg__t_1a112755b20112daca6f3a7de1d94d5f8f"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv427adc_continuous_handle_cfg_t" title="adc_continuous_handle_cfg_t"><span class="n"><span class="pre">adc_continuous_handle_cfg_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N27adc_continuous_handle_cfg_t5flagsE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Driver flags. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv423adc_continuous_config_t">
<span id="_CPPv323adc_continuous_config_t"></span><span id="_CPPv223adc_continuous_config_t"></span><span id="adc_continuous_config_t"></span><span class="target" id="structadc__continuous__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_config_t</span></span></span><a class="headerlink" href="#_CPPv423adc_continuous_config_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>ADC continuous mode driver configurations. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23adc_continuous_config_t11pattern_numE">
<span id="_CPPv3N23adc_continuous_config_t11pattern_numE"></span><span id="_CPPv2N23adc_continuous_config_t11pattern_numE"></span><span id="adc_continuous_config_t::pattern_num__uint32_t"></span><span class="target" id="structadc__continuous__config__t_1aec14dc2b59a5784d4548f6145ad58add"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pattern_num</span></span></span><a class="headerlink" href="#_CPPv4N23adc_continuous_config_t11pattern_numE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Number of ADC channels that will be used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23adc_continuous_config_t11adc_patternE">
<span id="_CPPv3N23adc_continuous_config_t11adc_patternE"></span><span id="_CPPv2N23adc_continuous_config_t11adc_patternE"></span><span id="adc_continuous_config_t::adc_pattern__adc_digi_pattern_config_tP"></span><span class="target" id="structadc__continuous__config__t_1ac2c3e4fd3d21394e5afa2d76e6f6db2b"></span><a class="reference internal" href="adc_oneshot.html#_CPPv425adc_digi_pattern_config_t" title="adc_digi_pattern_config_t"><span class="n"><span class="pre">adc_digi_pattern_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">adc_pattern</span></span></span><a class="headerlink" href="#_CPPv4N23adc_continuous_config_t11adc_patternE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>List of configs for each ADC channel that will be used. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23adc_continuous_config_t14sample_freq_hzE">
<span id="_CPPv3N23adc_continuous_config_t14sample_freq_hzE"></span><span id="_CPPv2N23adc_continuous_config_t14sample_freq_hzE"></span><span id="adc_continuous_config_t::sample_freq_hz__uint32_t"></span><span class="target" id="structadc__continuous__config__t_1a86fdd48b78935fe1c080c228ce613ad1"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sample_freq_hz</span></span></span><a class="headerlink" href="#_CPPv4N23adc_continuous_config_t14sample_freq_hzE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>The expected ADC sampling frequency in Hz. Please refer to <code class="docutils literal notranslate"><span class="pre">soc/soc_caps.h</span></code> to know available sampling frequency range </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23adc_continuous_config_t9conv_modeE">
<span id="_CPPv3N23adc_continuous_config_t9conv_modeE"></span><span id="_CPPv2N23adc_continuous_config_t9conv_modeE"></span><span id="adc_continuous_config_t::conv_mode__adc_digi_convert_mode_t"></span><span class="target" id="structadc__continuous__config__t_1aa98c2b74a15430bef7eb4bc6e4e4fbc2"></span><a class="reference internal" href="adc_oneshot.html#_CPPv423adc_digi_convert_mode_t" title="adc_digi_convert_mode_t"><span class="n"><span class="pre">adc_digi_convert_mode_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">conv_mode</span></span></span><a class="headerlink" href="#_CPPv4N23adc_continuous_config_t9conv_modeE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>ADC DMA conversion mode, see <code class="docutils literal notranslate"><span class="pre">adc_digi_convert_mode_t</span></code>. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23adc_continuous_config_t6formatE">
<span id="_CPPv3N23adc_continuous_config_t6formatE"></span><span id="_CPPv2N23adc_continuous_config_t6formatE"></span><span id="adc_continuous_config_t::format__adc_digi_output_format_t"></span><span class="target" id="structadc__continuous__config__t_1a6de254a11c803050b7f1d329a55bca23"></span><a class="reference internal" href="adc_oneshot.html#_CPPv424adc_digi_output_format_t" title="adc_digi_output_format_t"><span class="n"><span class="pre">adc_digi_output_format_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">format</span></span></span><a class="headerlink" href="#_CPPv4N23adc_continuous_config_t6formatE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>ADC DMA conversion output format, see <code class="docutils literal notranslate"><span class="pre">adc_digi_output_format_t</span></code>. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv425adc_continuous_evt_data_t">
<span id="_CPPv325adc_continuous_evt_data_t"></span><span id="_CPPv225adc_continuous_evt_data_t"></span><span id="adc_continuous_evt_data_t"></span><span class="target" id="structadc__continuous__evt__data__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_evt_data_t</span></span></span><a class="headerlink" href="#_CPPv425adc_continuous_evt_data_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Event data structure. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">conv_frame_buffer</span></code> is maintained by the driver itself, so never free this piece of memory. </p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N25adc_continuous_evt_data_t17conv_frame_bufferE">
<span id="_CPPv3N25adc_continuous_evt_data_t17conv_frame_bufferE"></span><span id="_CPPv2N25adc_continuous_evt_data_t17conv_frame_bufferE"></span><span id="adc_continuous_evt_data_t::conv_frame_buffer__uint8_tP"></span><span class="target" id="structadc__continuous__evt__data__t_1a7159af10825f22b5ffb347eb3f50777e"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">conv_frame_buffer</span></span></span><a class="headerlink" href="#_CPPv4N25adc_continuous_evt_data_t17conv_frame_bufferE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Pointer to conversion result buffer for one conversion frame. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N25adc_continuous_evt_data_t4sizeE">
<span id="_CPPv3N25adc_continuous_evt_data_t4sizeE"></span><span id="_CPPv2N25adc_continuous_evt_data_t4sizeE"></span><span id="adc_continuous_evt_data_t::size__uint32_t"></span><span class="target" id="structadc__continuous__evt__data__t_1a791284482868672aeea75f8f38aa757d"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><a class="headerlink" href="#_CPPv4N25adc_continuous_evt_data_t4sizeE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Conversion frame size. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv424adc_continuous_evt_cbs_t">
<span id="_CPPv324adc_continuous_evt_cbs_t"></span><span id="_CPPv224adc_continuous_evt_cbs_t"></span><span id="adc_continuous_evt_cbs_t"></span><span class="target" id="structadc__continuous__evt__cbs__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_evt_cbs_t</span></span></span><a class="headerlink" href="#_CPPv424adc_continuous_evt_cbs_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Group of ADC continuous mode callbacks. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These callbacks are all running in an ISR environment. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. Involved variables should be in internal RAM as well. </p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N24adc_continuous_evt_cbs_t12on_conv_doneE">
<span id="_CPPv3N24adc_continuous_evt_cbs_t12on_conv_doneE"></span><span id="_CPPv2N24adc_continuous_evt_cbs_t12on_conv_doneE"></span><span id="adc_continuous_evt_cbs_t::on_conv_done__adc_continuous_callback_t"></span><span class="target" id="structadc__continuous__evt__cbs__t_1a9c8bc8b8588b85a2e9ea58f6235f5292"></span><a class="reference internal" href="#_CPPv425adc_continuous_callback_t" title="adc_continuous_callback_t"><span class="n"><span class="pre">adc_continuous_callback_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">on_conv_done</span></span></span><a class="headerlink" href="#_CPPv4N24adc_continuous_evt_cbs_t12on_conv_doneE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Event callback, invoked when one conversion frame is done. See the subsection <code class="docutils literal notranslate"><span class="pre">Driver</span> <span class="pre">Backgrounds</span></code> in this header file to learn about the <code class="docutils literal notranslate"><span class="pre">conversion</span> <span class="pre">frame</span></code> concept. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N24adc_continuous_evt_cbs_t11on_pool_ovfE">
<span id="_CPPv3N24adc_continuous_evt_cbs_t11on_pool_ovfE"></span><span id="_CPPv2N24adc_continuous_evt_cbs_t11on_pool_ovfE"></span><span id="adc_continuous_evt_cbs_t::on_pool_ovf__adc_continuous_callback_t"></span><span class="target" id="structadc__continuous__evt__cbs__t_1a5cc7865e2d407c31a86e076fde67822a"></span><a class="reference internal" href="#_CPPv425adc_continuous_callback_t" title="adc_continuous_callback_t"><span class="n"><span class="pre">adc_continuous_callback_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">on_pool_ovf</span></span></span><a class="headerlink" href="#_CPPv4N24adc_continuous_evt_cbs_t11on_pool_ovfE" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Event callback, invoked when the internal pool is full. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this heading">ï</a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ADC_MAX_DELAY">
<span class="target" id="adc__continuous_8h_1a0092dbc22dba2974ad3db91bf3fe41e2"></span><span class="sig-name descname"><span class="n"><span class="pre">ADC_MAX_DELAY</span></span></span><a class="headerlink" href="#c.ADC_MAX_DELAY" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>ADC read max timeout value, it may make the <code class="docutils literal notranslate"><span class="pre">adc_continuous_read</span></code> block forever if the OS supports. </p>
</dd></dl>

</section>
<section id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this heading">ï</a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv423adc_continuous_handle_t">
<span id="_CPPv323adc_continuous_handle_t"></span><span id="_CPPv223adc_continuous_handle_t"></span><span id="adc_continuous_handle_t"></span><span class="target" id="adc__continuous_8h_1a915d8f9379887629a878767dcfdb8029"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">adc_continuous_ctx_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></span><a class="headerlink" href="#_CPPv423adc_continuous_handle_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Type of adc continuous mode driver handle. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv425adc_continuous_callback_t">
<span id="_CPPv325adc_continuous_callback_t"></span><span id="_CPPv225adc_continuous_callback_t"></span><span id="adc_continuous_callback_t"></span><span class="target" id="adc__continuous_8h_1a388655183b706c0cf96101bb1d3e1fd8"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">adc_continuous_callback_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv423adc_continuous_handle_t" title="adc_continuous_handle_t"><span class="n"><span class="pre">adc_continuous_handle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">handle</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv425adc_continuous_evt_data_t" title="adc_continuous_evt_data_t"><span class="n"><span class="pre">adc_continuous_evt_data_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edata</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">user_data</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv425adc_continuous_callback_t" title="Permalink to this definition">ï</a><br /></dt>
<dd><p>Prototype of ADC continuous mode event callback. </p>
<dl class="field-list simple">
<dt class="field-odd">Param handle<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> ADC continuous mode driver handle </p>
</dd>
<dt class="field-even">Param edata<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[in]</strong> Pointer to ADC continuous mode event data </p>
</dd>
<dt class="field-odd">Param user_data<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> User registered context, registered when in <code class="docutils literal notranslate"><span class="pre">adc_continuous_register_event_callbacks()</span></code></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether a high priority task is woken up by this function </p>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Analog to Digital Converter (ADC) Continuous Mode Driver (api-reference/peripherals/adc_continuous)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Analog to Digital Converter (ADC) Continuous Mode Driver (api-reference/peripherals/adc_continuous)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="adc_oneshot.html" class="btn btn-neutral float-left" title="Analog to Digital Converter (ADC) Oneshot Mode Driver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="adc_calibration.html" class="btn btn-neutral float-right" title="Analog to Digital Converter (ADC) Calibration Driver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>