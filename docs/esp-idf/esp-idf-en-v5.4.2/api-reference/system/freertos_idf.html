<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FreeRTOS (IDF) - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/freertos_idf.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/system/freertos_idf';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="FreeRTOS (Supplemental Features)" href="freertos_additions.html" />
    <link rel="prev" title="FreeRTOS Overview" href="freertos.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth® API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Project Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">System API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">App Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="bootloader_image_format.html">Bootloader Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">Application Level Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_function_with_shared_stack.html">Call Function with External Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="chip_revision.html">Chip Revision</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console</a></li>
<li class="toctree-l3"><a class="reference internal" href="efuse.html">eFuse Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">Error Code and Helper Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">Event Loop Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos.html">FreeRTOS Overview</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">FreeRTOS (IDF)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#symmetric-multiprocessing">Symmetric Multiprocessing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tasks">Tasks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#smp-scheduler">SMP Scheduler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#critical-sections">Critical Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="#misc">Misc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#single-core-mode">Single-Core Mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="freertos_additions.html">FreeRTOS (Supplemental Features)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mem_alloc.html">Heap Memory Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm.html">Memory Management for MMU Supported Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="heap_debug.html">Heap Memory Debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">ESP Timer (High Resolution Timer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="internal-unstable.html">Internal and Unstable APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">Inter-Processor Call (IPC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">Interrupt Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">Logging library</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_system_api.html">Miscellaneous System APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">Over The Air Updates (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">Performance Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="pthread.html">POSIX Support (Including POSIX Threads Support)</a></li>
<li class="toctree-l3"><a class="reference internal" href="random.html">Random Number Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">Sleep Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="soc_caps.html">SoC Capabilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">System Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ulp.html">ULP Coprocessor Programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">Watchdogs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">System API</a></li>
      <li class="breadcrumb-item active">FreeRTOS (IDF)</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-reference/system/freertos_idf.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="freertos-idf">
<h1><a class="toc-backref" href="#id23" role="doc-backlink">FreeRTOS (IDF)</a><a class="headerlink" href="#freertos-idf" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/v5.4.2/esp32/api-reference/system/freertos_idf.html">[中文]</a></p>
<p>This document provides information regarding the dual-core SMP implementation of FreeRTOS inside ESP-IDF. This document is split into the following sections:</p>
<nav class="contents" id="sections">
<p class="topic-title">Sections</p>
<ul class="simple">
<li><p><a class="reference internal" href="#freertos-idf" id="id23">FreeRTOS (IDF)</a></p>
<ul>
<li><p><a class="reference internal" href="#overview" id="id24">Overview</a></p></li>
<li><p><a class="reference internal" href="#symmetric-multiprocessing" id="id25">Symmetric Multiprocessing</a></p></li>
<li><p><a class="reference internal" href="#tasks" id="id26">Tasks</a></p></li>
<li><p><a class="reference internal" href="#smp-scheduler" id="id27">SMP Scheduler</a></p></li>
<li><p><a class="reference internal" href="#critical-sections" id="id28">Critical Sections</a></p></li>
<li><p><a class="reference internal" href="#misc" id="id29">Misc</a></p></li>
<li><p><a class="reference internal" href="#single-core-mode" id="id30">Single-Core Mode</a></p></li>
<li><p><a class="reference internal" href="#api-reference" id="id31">API Reference</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="overview">
<h2><a class="toc-backref" href="#id24" role="doc-backlink">Overview</a><a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>The original FreeRTOS (hereinafter referred to as <strong>Vanilla FreeRTOS</strong>) is a compact and efficient real-time operating system supported on numerous single-core MCUs and SoCs. However, to support dual-core ESP targets, such as ESP32, ESP32-S3, and ESP32-P4, ESP-IDF provides a unique implementation of FreeRTOS with dual-core symmetric multiprocessing (SMP) capabilities (hereinafter referred to as <strong>IDF FreeRTOS</strong>).</p>
<p>IDF FreeRTOS source code is based on Vanilla FreeRTOS v10.5.1 but contains significant modifications to both kernel behavior and API in order to support dual-core SMP. However, IDF FreeRTOS can also be configured for single-core by enabling the <a class="reference internal" href="../kconfig.html#config-freertos-unicore"><span class="std std-ref">CONFIG_FREERTOS_UNICORE</span></a> option (see <a class="reference internal" href="#freertos-idf-single-core"><span class="std std-ref">Single-Core Mode</span></a> for more details).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This document assumes that the reader has a requisite understanding of Vanilla FreeRTOS, i.e., its features, behavior, and API usage. Refer to the <a class="reference external" href="https://www.freertos.org/index.html">Vanilla FreeRTOS documentation</a> for more details.</p>
</div>
</section>
<section id="symmetric-multiprocessing">
<h2><a class="toc-backref" href="#id25" role="doc-backlink">Symmetric Multiprocessing</a><a class="headerlink" href="#symmetric-multiprocessing" title="Permalink to this heading"></a></h2>
<section id="basic-concepts">
<h3>Basic Concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this heading"></a></h3>
<p>Symmetric multiprocessing is a computing architecture where two or more identical CPU cores are connected to a single shared main memory and controlled by a single operating system. In general, an SMP system:</p>
<ul class="simple">
<li><p>has multiple cores running independently. Each core has its own register file, interrupts, and interrupt handling.</p></li>
<li><p>presents an identical view of memory to each core. Thus, a piece of code that accesses a particular memory address has the same effect regardless of which core it runs on.</p></li>
</ul>
<p>The main advantages of an SMP system compared to single-core or asymmetric multiprocessing systems are that:</p>
<ul class="simple">
<li><p>the presence of multiple cores allows for multiple hardware threads, thus increasing overall processing throughput.</p></li>
<li><p>having symmetric memory means that threads can switch cores during execution. This, in general, can lead to better CPU utilization.</p></li>
</ul>
<p>Although an SMP system allows threads to switch cores, there are scenarios where a thread must/should only run on a particular core. Therefore, threads in an SMP system also have a core affinity that specifies which particular core the thread is allowed to run on.</p>
<ul class="simple">
<li><p>A thread that is pinned to a particular core is only able to run on that core.</p></li>
<li><p>A thread that is unpinned will be allowed to switch between cores during execution instead of being pinned to a particular core.</p></li>
</ul>
</section>
<section id="smp-on-an-esp-target">
<h3>SMP on an ESP Target<a class="headerlink" href="#smp-on-an-esp-target" title="Permalink to this heading"></a></h3>
<p>ESP targets such as ESP32, ESP32-S3, and ESP32-P4 are dual-core SMP SoCs. These targets have the following hardware features that make them SMP-capable:</p>
<ul class="simple">
<li><p>Two identical cores are known as Core 0 and Core 1. This means that the execution of a piece of code is identical regardless of which core it runs on.</p></li>
<li><p>Symmetric memory (with some small exceptions).</p>
<ul>
<li><p>If multiple cores access the same memory address simultaneously, their access will be serialized by the memory bus.</p></li>
<li><p>True atomic access to the same memory address is achieved via an atomic compare-and-swap instruction provided by the ISA.</p></li>
</ul>
</li>
<li><p>Cross-core interrupts that allow one core to trigger an interrupt on the other core. This allows cores to signal events to each other (such as requesting a context switch on the other core).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Within ESP-IDF, Core 0 and Core 1 are sometimes referred to as <code class="docutils literal notranslate"><span class="pre">PRO_CPU</span></code> and <code class="docutils literal notranslate"><span class="pre">APP_CPU</span></code> respectively. The aliases exist in ESP-IDF as they reflect how typical ESP-IDF applications utilize the two cores. Typically, the tasks responsible for handling protocol related processing such as Wi-Fi or Bluetooth are pinned to Core 0 (thus the name <code class="docutils literal notranslate"><span class="pre">PRO_CPU</span></code>), where as the tasks handling the remainder of the application are pinned to Core 1, (thus the name <code class="docutils literal notranslate"><span class="pre">APP_CPU</span></code>).</p>
</div>
</section>
</section>
<section id="tasks">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">Tasks</a><a class="headerlink" href="#tasks" title="Permalink to this heading"></a></h2>
<section id="creation">
<h3>Creation<a class="headerlink" href="#creation" title="Permalink to this heading"></a></h3>
<p>Vanilla FreeRTOS provides the following functions to create a task:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv411xTaskCreate14TaskFunction_tPCKcK22configSTACK_DEPTH_TYPEPCv11UBaseType_tPC12TaskHandle_t" title="xTaskCreate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xTaskCreate()</span></code></a> creates a task. The task's memory is dynamically allocated.</p></li>
<li><p><a class="reference internal" href="#_CPPv417xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t" title="xTaskCreateStatic"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xTaskCreateStatic()</span></code></a> creates a task. The task's memory is statically allocated, i.e., provided by the user.</p></li>
</ul>
<p>However, in an SMP system, tasks need to be assigned a particular affinity. Therefore, ESP-IDF provides a <code class="docutils literal notranslate"><span class="pre">...PinnedToCore()</span></code> version of Vanilla FreeRTOS's task creation functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="freertos_additions.html#_CPPv423xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t" title="xTaskCreatePinnedToCore"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xTaskCreatePinnedToCore()</span></code></a> creates a task with a particular core affinity. The task's memory is dynamically allocated.</p></li>
<li><p><a class="reference internal" href="freertos_additions.html#_CPPv429xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t" title="xTaskCreateStaticPinnedToCore"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xTaskCreateStaticPinnedToCore()</span></code></a> creates a task with a particular core affinity. The task's memory is statically allocated, i.e., provided by the user.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">...PinnedToCore()</span></code> versions of the task creation function API differ from their vanilla counterparts by having an extra <code class="docutils literal notranslate"><span class="pre">xCoreID</span></code> parameter that is used to specify the created task's core affinity. The valid values for core affinity are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, which pins the created task to Core 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>, which pins the created task to Core 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tskNO_AFFINITY</span></code>, which allows the task to be run on both cores</p></li>
</ul>
<p>Note that IDF FreeRTOS still supports the vanilla versions of the task creation functions. However, these standard functions have been modified to essentially invoke their respective <code class="docutils literal notranslate"><span class="pre">...PinnedToCore()</span></code> counterparts while setting the core affinity to <code class="docutils literal notranslate"><span class="pre">tskNO_AFFINITY</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>IDF FreeRTOS also changes the units of <code class="docutils literal notranslate"><span class="pre">ulStackDepth</span></code> in the task creation functions. Task stack sizes in Vanilla FreeRTOS are specified in a number of words, whereas in IDF FreeRTOS, the task stack sizes are specified in bytes.</p>
</div>
</section>
<section id="execution">
<h3>Execution<a class="headerlink" href="#execution" title="Permalink to this heading"></a></h3>
<p>The anatomy of a task in IDF FreeRTOS is the same as in Vanilla FreeRTOS. More specifically, IDF FreeRTOS tasks:</p>
<ul class="simple">
<li><p>Can only be in one of the following states: Running, Ready, Blocked, or Suspended.</p></li>
<li><p>Task functions are typically implemented as an infinite loop.</p></li>
<li><p>Task functions should never return.</p></li>
</ul>
</section>
<section id="deletion">
<h3>Deletion<a class="headerlink" href="#deletion" title="Permalink to this heading"></a></h3>
<p>Task deletion in Vanilla FreeRTOS is called via <a class="reference internal" href="#_CPPv411vTaskDelete12TaskHandle_t" title="vTaskDelete"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskDelete()</span></code></a>. The function allows deletion of another task or the currently running task if the provided task handle is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. The actual freeing of the task's memory is sometimes delegated to the idle task if the task being deleted is the currently running task.</p>
<p>IDF FreeRTOS provides the same <a class="reference internal" href="#_CPPv411vTaskDelete12TaskHandle_t" title="vTaskDelete"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskDelete()</span></code></a> function. However, due to the dual-core nature, there are some behavioral differences when calling <a class="reference internal" href="#_CPPv411vTaskDelete12TaskHandle_t" title="vTaskDelete"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskDelete()</span></code></a> in IDF FreeRTOS:</p>
<ul class="simple">
<li><p>When deleting a task that is currently running on the other core, a yield is triggered on the other core, and the task's memory is freed by one of the idle tasks.</p></li>
<li><p>A deleted task's memory is freed immediately if it is not running on either core.</p></li>
</ul>
<p>Please avoid deleting a task that is running on another core as it is difficult to determine what the task is performing, which may lead to unpredictable behavior such as:</p>
<ul class="simple">
<li><p>Deleting a task that is holding a mutex.</p></li>
<li><p>Deleting a task that has yet to free memory it previously allocated.</p></li>
</ul>
<p>Where possible, please design your own application so that when calling <a class="reference internal" href="#_CPPv411vTaskDelete12TaskHandle_t" title="vTaskDelete"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskDelete()</span></code></a>, the deleted task is in a known state. For example:</p>
<ul class="simple">
<li><p>Tasks self-deleting via <code class="docutils literal notranslate"><span class="pre">vTaskDelete(NULL)</span></code> when their execution is complete and have also cleaned up all resources used within the task.</p></li>
<li><p>Tasks placing themselves in the suspend state via <a class="reference internal" href="#_CPPv412vTaskSuspend12TaskHandle_t" title="vTaskSuspend"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskSuspend()</span></code></a> before being deleted by another task.</p></li>
</ul>
</section>
</section>
<section id="smp-scheduler">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">SMP Scheduler</a><a class="headerlink" href="#smp-scheduler" title="Permalink to this heading"></a></h2>
<p>The Vanilla FreeRTOS scheduler is best described as a <strong>fixed priority preemptive scheduler with time slicing</strong> meaning that:</p>
<ul class="simple">
<li><p>Each task is given a constant priority upon creation. The scheduler executes the highest priority ready-state task.</p></li>
<li><p>The scheduler can switch execution to another task without the cooperation of the currently running task.</p></li>
<li><p>The scheduler periodically switches execution between ready-state tasks of the same priority in a round-robin fashion. Time slicing is governed by a tick interrupt.</p></li>
</ul>
<p>The IDF FreeRTOS scheduler supports the same scheduling features, i.e., Fixed Priority, Preemption, and Time Slicing, albeit with some small behavioral differences.</p>
<section id="fixed-priority">
<h3>Fixed Priority<a class="headerlink" href="#fixed-priority" title="Permalink to this heading"></a></h3>
<p>In Vanilla FreeRTOS, when the scheduler selects a new task to run, it always selects the current highest priority ready-state task. In IDF FreeRTOS, each core independently schedules tasks to run. When a particular core selects a task, the core will select the highest priority ready-state task that can be run by the core. A task can be run by the core if:</p>
<ul class="simple">
<li><p>The task has a compatible affinity, i.e., is either pinned to that core or is unpinned.</p></li>
<li><p>The task is not currently being run by another core.</p></li>
</ul>
<p>However, please do not assume that the two highest priority ready-state tasks are always run by the scheduler, as a task's core affinity must also be accounted for. For example, given the following tasks:</p>
<ul class="simple">
<li><p>Task A of priority 10 pinned to Core 0</p></li>
<li><p>Task B of priority 9 pinned to Core 0</p></li>
<li><p>Task C of priority 8 pinned to Core 1</p></li>
</ul>
<p>The resulting schedule will have Task A running on Core 0 and Task C running on Core 1. Task B is not run even though it is the second-highest priority task.</p>
</section>
<section id="preemption">
<h3>Preemption<a class="headerlink" href="#preemption" title="Permalink to this heading"></a></h3>
<p>In Vanilla FreeRTOS, the scheduler can preempt the currently running task if a higher priority task becomes ready to execute. Likewise in IDF FreeRTOS, each core can be individually preempted by the scheduler if the scheduler determines that a higher-priority task can run on that core.</p>
<p>However, there are some instances where a higher-priority task that becomes ready can be run on multiple cores. In this case, the scheduler only preempts one core. The scheduler always gives preference to the current core when multiple cores can be preempted. In other words, if the higher priority ready task is unpinned and has a higher priority than the current priority of both cores, the scheduler will always choose to preempt the current core. For example, given the following tasks:</p>
<ul class="simple">
<li><p>Task A of priority 8 currently running on Core 0</p></li>
<li><p>Task B of priority 9 currently running on Core 1</p></li>
<li><p>Task C of priority 10 that is unpinned and was unblocked by Task B</p></li>
</ul>
<p>The resulting schedule will have Task A running on Core 0 and Task C preempting Task B given that the scheduler always gives preference to the current core.</p>
</section>
<section id="time-slicing">
<h3>Time Slicing<a class="headerlink" href="#time-slicing" title="Permalink to this heading"></a></h3>
<p>The Vanilla FreeRTOS scheduler implements time slicing, which means that if the current highest ready priority contains multiple ready tasks, the scheduler will switch between those tasks periodically in a round-robin fashion.</p>
<p>However, in IDF FreeRTOS, it is not possible to implement perfect Round Robin time slicing due to the fact that a particular task may not be able to run on a particular core due to the following reasons:</p>
<ul class="simple">
<li><p>The task is pinned to another core.</p></li>
<li><p>For unpinned tasks, the task is already being run by another core.</p></li>
</ul>
<p>Therefore, when a core searches the ready-state task list for a task to run, the core may need to skip over a few tasks in the same priority list or drop to a lower priority in order to find a ready-state task that the core can run.</p>
<p>The IDF FreeRTOS scheduler implements a Best Effort Round Robin time slicing for ready-state tasks of the same priority by ensuring that tasks that have been selected to run are placed at the back of the list, thus giving unselected tasks a higher priority on the next scheduling iteration (i.e., the next tick interrupt or yield).</p>
<p>The following example demonstrates the Best Effort Round Robin time slicing in action. Assume that:</p>
<ul class="simple">
<li><p>There are four ready-state tasks of the same priority <code class="docutils literal notranslate"><span class="pre">AX</span></code>, <code class="docutils literal notranslate"><span class="pre">B0</span></code>, <code class="docutils literal notranslate"><span class="pre">C1</span></code>, and <code class="docutils literal notranslate"><span class="pre">D1</span></code> where:</p>
<ul>
<li><p>The priority is the current highest priority with ready-state .</p></li>
<li><p>The first character represents the task's name, i.e., <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p></li>
<li><p>The second character represents the task's core pinning, and <code class="docutils literal notranslate"><span class="pre">X</span></code> means unpinned.</p></li>
</ul>
</li>
<li><p>The task list is always searched from the head.</p></li>
</ul>
<ol class="arabic">
<li><p>Starting state. None of the ready-state tasks have been selected to run.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Head [ AX , B0 , C1 , D0 ] Tail
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Core 0 has a tick interrupt and searches for a task to run. Task A is selected and moved to the back of the list.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Core 0 ─┐
        ▼
Head [ AX , B0 , C1 , D0 ] Tail

                      [0]
Head [ B0 , C1 , D0 , AX ] Tail
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Core 1 has a tick interrupt and searches for a task to run. Task B cannot be run due to incompatible affinity, so Core 1 skips to Task C. Task C is selected and moved to the back of the list.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Core 1 ──────┐
             ▼        [0]
Head [ B0 , C1 , D0 , AX ] Tail

                 [0]  [1]
Head [ B0 , D0 , AX , C1 ] Tail
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Core 0 has another tick interrupt and searches for a task to run. Task B is selected and moved to the back of the list.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Core 0 ─┐
        ▼             [1]
Head [ B0 , D0 , AX , C1 ] Tail

                 [1]  [0]
Head [ D0 , AX , C1 , B0 ] Tail
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Core 1 has another tick and searches for a task to run. Task D cannot be run due to incompatible affinity, so Core 1 skips to Task A. Task A is selected and moved to the back of the list.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Core 1 ──────┐
             ▼        [0]
Head [ D0 , AX , C1 , B0 ] Tail

                 [0]  [1]
Head [ D0 , C1 , B0 , AX ] Tail
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
<p>The implications to users regarding the Best Effort Round Robin time slicing:</p>
<ul class="simple">
<li><p>Users cannot expect multiple ready-state tasks of the same priority to run sequentially as is the case in Vanilla FreeRTOS. As demonstrated in the example above, a core may need to skip over tasks.</p></li>
<li><p>However, given enough ticks, a task will eventually be given some processing time.</p></li>
<li><p>If a core cannot find a task runnable task at the highest ready-state priority, it will drop to a lower priority to search for tasks.</p></li>
<li><p>To achieve ideal round-robin time slicing, users should ensure that all tasks of a particular priority are pinned to the same core.</p></li>
</ul>
</section>
<section id="tick-interrupts">
<h3>Tick Interrupts<a class="headerlink" href="#tick-interrupts" title="Permalink to this heading"></a></h3>
<p>Vanilla FreeRTOS requires that a periodic tick interrupt occurs. The tick interrupt is responsible for:</p>
<ul class="simple">
<li><p>Incrementing the scheduler's tick count</p></li>
<li><p>Unblocking any blocked tasks that have timed out</p></li>
<li><p>Checking if time slicing is required, i.e., triggering a context switch</p></li>
<li><p>Executing the application tick hook</p></li>
</ul>
<p>In IDF FreeRTOS, each core receives a periodic interrupt and independently runs the tick interrupt. The tick interrupts on each core are of the same period but can be out of phase. However, the tick responsibilities listed above are not run by all cores:</p>
<ul class="simple">
<li><p>Core 0 executes all of the tick interrupt responsibilities listed above</p></li>
<li><p>Core 1 only checks for time slicing and executes the application tick hook</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Core 0 is solely responsible for keeping time in IDF FreeRTOS. Therefore, anything that prevents Core 0 from incrementing the tick count, such as suspending the scheduler on Core 0, will cause the entire scheduler's timekeeping to lag behind.</p>
</div>
</section>
<section id="idle-tasks">
<h3>Idle Tasks<a class="headerlink" href="#idle-tasks" title="Permalink to this heading"></a></h3>
<p>Vanilla FreeRTOS will implicitly create an idle task of priority 0 when the scheduler is started. The idle task runs when no other task is ready to run, and it has the following responsibilities:</p>
<ul class="simple">
<li><p>Freeing the memory of deleted tasks</p></li>
<li><p>Executing the application idle hook</p></li>
</ul>
<p>In IDF FreeRTOS, a separate pinned idle task is created for each core. The idle tasks on each core have the same responsibilities as their vanilla counterparts.</p>
</section>
<section id="scheduler-suspension">
<h3>Scheduler Suspension<a class="headerlink" href="#scheduler-suspension" title="Permalink to this heading"></a></h3>
<p>Vanilla FreeRTOS allows the scheduler to be suspended/resumed by calling <a class="reference internal" href="#_CPPv415vTaskSuspendAllv" title="vTaskSuspendAll"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskSuspendAll()</span></code></a> and <a class="reference internal" href="#_CPPv414xTaskResumeAllv" title="xTaskResumeAll"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xTaskResumeAll()</span></code></a> respectively. While the scheduler is suspended:</p>
<ul class="simple">
<li><p>Task switching is disabled but interrupts are left enabled.</p></li>
<li><p>Calling any blocking/yielding function is forbidden, and time slicing is disabled.</p></li>
<li><p>The tick count is frozen, but the tick interrupt still occurs to execute the application tick hook.</p></li>
</ul>
<p>On scheduler resumption, <a class="reference internal" href="#_CPPv414xTaskResumeAllv" title="xTaskResumeAll"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xTaskResumeAll()</span></code></a> catches up all of the lost ticks and unblock any timed-out tasks.</p>
<p>In IDF FreeRTOS, suspending the scheduler across multiple cores is not possible. Therefore when <a class="reference internal" href="#_CPPv415vTaskSuspendAllv" title="vTaskSuspendAll"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskSuspendAll()</span></code></a> is called on a particular core (e.g., core A):</p>
<ul class="simple">
<li><p>Task switching is disabled only on core A but interrupts for core A are left enabled.</p></li>
<li><p>Calling any blocking/yielding function on core A is forbidden. Time slicing is disabled on core A.</p></li>
<li><p>If an interrupt on core A unblocks any tasks, tasks with affinity to core A will go into core A's own pending ready task list. Unpinned tasks or tasks with affinity to other cores can be scheduled on cores with the scheduler running.</p></li>
<li><p>If the scheduler is suspended on all cores, tasks unblocked by an interrupt will be directed to the pending ready task lists of their pinned cores. For unpinned tasks, they will be placed in the pending ready list of the core where the interrupt occurred.</p></li>
<li><p>If core A is on Core 0, the tick count is frozen, and a pended tick count is incremented instead. However, the tick interrupt will still occur in order to execute the application tick hook.</p></li>
</ul>
<p>When <a class="reference internal" href="#_CPPv414xTaskResumeAllv" title="xTaskResumeAll"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xTaskResumeAll()</span></code></a> is called on a particular core (e.g., core A):</p>
<ul class="simple">
<li><p>Any tasks added to core A's pending ready task list will be resumed.</p></li>
<li><p>If core A is Core 0, the pended tick count is unwound to catch up with the lost ticks.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Given that scheduler suspension on IDF FreeRTOS only suspends scheduling on a particular core, scheduler suspension is <strong>NOT</strong> a valid method of ensuring mutual exclusion between tasks when accessing shared data. Users should use proper locking primitives such as mutexes or spinlocks if they require mutual exclusion.</p>
</div>
</section>
</section>
<section id="critical-sections">
<h2><a class="toc-backref" href="#id28" role="doc-backlink">Critical Sections</a><a class="headerlink" href="#critical-sections" title="Permalink to this heading"></a></h2>
<section id="disabling-interrupts">
<h3>Disabling Interrupts<a class="headerlink" href="#disabling-interrupts" title="Permalink to this heading"></a></h3>
<p>Vanilla FreeRTOS allows interrupts to be disabled and enabled by calling <a class="reference internal" href="#c.taskDISABLE_INTERRUPTS" title="taskDISABLE_INTERRUPTS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">taskDISABLE_INTERRUPTS</span></code></a> and <a class="reference internal" href="#c.taskENABLE_INTERRUPTS" title="taskENABLE_INTERRUPTS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">taskENABLE_INTERRUPTS</span></code></a> respectively. IDF FreeRTOS provides the same API. However, interrupts are only disabled or enabled on the current core.</p>
<p>Disabling interrupts is a valid method of achieving mutual exclusion in Vanilla FreeRTOS (and single-core systems in general). <strong>However, in an SMP system, disabling interrupts is not a valid method of ensuring mutual exclusion</strong>. Critical sections that utilize a spinlock should be used instead.</p>
</section>
<section id="api-changes">
<h3>API Changes<a class="headerlink" href="#api-changes" title="Permalink to this heading"></a></h3>
<p>Vanilla FreeRTOS implements critical sections by disabling interrupts, which prevents preemptive context switches and the servicing of ISRs during a critical section. Thus a task/ISR that enters a critical section is guaranteed to be the sole entity to access a shared resource. Critical sections in Vanilla FreeRTOS have the following API:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">taskENTER_CRITICAL()</span></code> enters a critical section by disabling interrupts</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskEXIT_CRITICAL()</span></code> exits a critical section by reenabling interrupts</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskENTER_CRITICAL_FROM_ISR()</span></code> enters a critical section from an ISR by disabling interrupt nesting</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskEXIT_CRITICAL_FROM_ISR()</span></code> exits a critical section from an ISR by reenabling interrupt nesting</p></li>
</ul>
<p>However, in an SMP system, merely disabling interrupts does not constitute a critical section as the presence of other cores means that a shared resource can still be concurrently accessed. Therefore, critical sections in IDF FreeRTOS are implemented using spinlocks. To accommodate the spinlocks, the IDF FreeRTOS critical section APIs contain an additional spinlock parameter as shown below:</p>
<ul class="simple">
<li><p>Spinlocks are of <code class="docutils literal notranslate"><span class="pre">portMUX_TYPE</span></code> (<strong>not to be confused to FreeRTOS mutexes</strong>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskENTER_CRITICAL(&amp;spinlock)</span></code> enters a critical from a task context</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskEXIT_CRITICAL(&amp;spinlock)</span></code> exits a critical section from a task context</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskENTER_CRITICAL_ISR(&amp;spinlock)</span></code> enters a critical section from an interrupt context</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">taskEXIT_CRITICAL_ISR(&amp;spinlock)</span></code> exits a critical section from an interrupt context</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The critical section API can be called recursively, i.e., nested critical sections. Entering a critical section multiple times recursively is valid so long as the critical section is exited the same number of times it was entered. However, given that critical sections can target different spinlocks, users should take care to avoid deadlocking when entering critical sections recursively.</p>
</div>
<p>Spinlocks can be allocated statically or dynamically. As such, macros are provided for both static and dynamic initialization of spinlocks, as demonstrated by the following code snippets.</p>
<ul>
<li><p>Allocating a static spinlock and initializing it using <code class="docutils literal notranslate"><span class="pre">portMUX_INITIALIZER_UNLOCKED</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Statically allocate and initialize the spinlock</span>
<span class="k">static</span><span class="w"> </span><span class="n">portMUX_TYPE</span><span class="w"> </span><span class="n">my_spinlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portMUX_INITIALIZER_UNLOCKED</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">some_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">taskENTER_CRITICAL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_spinlock</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// We are now in a critical section</span>
<span class="w">    </span><span class="n">taskEXIT_CRITICAL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_spinlock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Allocating a dynamic spinlock and initializing it using <code class="docutils literal notranslate"><span class="pre">portMUX_INITIALIZE()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate the spinlock dynamically</span>
<span class="n">portMUX_TYPE</span><span class="w"> </span><span class="o">*</span><span class="n">my_spinlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">portMUX_TYPE</span><span class="p">));</span>
<span class="c1">// Initialize the spinlock dynamically</span>
<span class="n">portMUX_INITIALIZE</span><span class="p">(</span><span class="n">my_spinlock</span><span class="p">);</span>

<span class="p">...</span>

<span class="n">taskENTER_CRITICAL</span><span class="p">(</span><span class="n">my_spinlock</span><span class="p">);</span>
<span class="c1">// Access the resource</span>
<span class="n">taskEXIT_CRITICAL</span><span class="p">(</span><span class="n">my_spinlock</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading"></a></h3>
<p>In IDF FreeRTOS, the process of a particular core entering and exiting a critical section is as follows:</p>
<ul class="simple">
<li><p>For <code class="docutils literal notranslate"><span class="pre">taskENTER_CRITICAL(&amp;spinlock)</span></code> or <code class="docutils literal notranslate"><span class="pre">taskENTER_CRITICAL_ISR(&amp;spinlock)</span></code></p>
<ol class="arabic simple">
<li><p>The core disables its interrupts or interrupt nesting up to <code class="docutils literal notranslate"><span class="pre">configMAX_SYSCALL_INTERRUPT_PRIORITY</span></code>.</p></li>
<li><p>The core then spins on the spinlock using an atomic compare-and-set instruction until it acquires the lock. A lock is acquired when the core is able to set the lock's owner value to the core's ID.</p></li>
<li><p>Once the spinlock is acquired, the function returns. The remainder of the critical section runs with interrupts or interrupt nesting disabled.</p></li>
</ol>
</li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">taskEXIT_CRITICAL(&amp;spinlock)</span></code> or <code class="docutils literal notranslate"><span class="pre">taskEXIT_CRITICAL_ISR(&amp;spinlock)</span></code></p>
<ol class="arabic simple">
<li><p>The core releases the spinlock by clearing the spinlock's owner value.</p></li>
<li><p>The core re-enables interrupts or interrupt nesting.</p></li>
</ol>
</li>
</ul>
</section>
<section id="restrictions-and-considerations">
<h3>Restrictions and Considerations<a class="headerlink" href="#restrictions-and-considerations" title="Permalink to this heading"></a></h3>
<p>Given that interrupts (or interrupt nesting) are disabled during a critical section, there are multiple restrictions regarding what can be done within critical sections. During a critical section, users should keep the following restrictions and considerations in mind:</p>
<ul class="simple">
<li><p>Critical sections should be kept as short as possible</p>
<ul>
<li><p>The longer the critical section lasts, the longer a pending interrupt can be delayed.</p></li>
<li><p>A typical critical section should only access a few data structures and/or hardware registers.</p></li>
<li><p>If possible, defer as much processing and/or event handling to the outside of critical sections.</p></li>
</ul>
</li>
<li><p>FreeRTOS API should not be called from within a critical section</p></li>
<li><p>Users should never call any blocking or yielding functions within a critical section</p></li>
</ul>
</section>
</section>
<section id="misc">
<h2><a class="toc-backref" href="#id29" role="doc-backlink">Misc</a><a class="headerlink" href="#misc" title="Permalink to this heading"></a></h2>
<section id="floating-point-usage">
<h3>Floating Point Usage<a class="headerlink" href="#floating-point-usage" title="Permalink to this heading"></a></h3>
<p>Usually, when a context switch occurs:</p>
<ul class="simple">
<li><p>the current state of a core's registers are saved to the stack of the task being switched out</p></li>
<li><p>the previously saved state of the core's registers is loaded from the stack of the task being switched in</p></li>
</ul>
<p>However, IDF FreeRTOS implements Lazy Context Switching for the Floating Point Unit (FPU) registers of a core. In other words, when a context switch occurs on a particular core (e.g., Core 0), the state of the core's FPU registers is not immediately saved to the stack of the task getting switched out (e.g., Task A). The FPU registers are left untouched until:</p>
<ul class="simple">
<li><p>A different task (e.g., Task B) runs on the same core and uses FPU. This will trigger an exception that saves the FPU registers to Task A's stack.</p></li>
<li><p>Task A gets scheduled to the same core and continues execution. Saving and restoring the FPU registers is not necessary in this case.</p></li>
</ul>
<p>However, given that tasks can be unpinned and thus can be scheduled on different cores (e.g., Task A switches to Core 1), it is unfeasible to copy and restore the FPU registers across cores. Therefore, when a task utilizes FPU by using a <code class="docutils literal notranslate"><span class="pre">float</span></code> type in its call flow, IDF FreeRTOS will automatically pin the task to the current core it is running on. This ensures that all tasks that use FPU are always pinned to a particular core.</p>
<p>Furthermore, IDF FreeRTOS by default does not support the usage of FPU within an interrupt context given that the FPU register state is tied to a particular task.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Users that require the use of the <code class="docutils literal notranslate"><span class="pre">float</span></code> type in an ISR routine should refer to the <a class="reference internal" href="../kconfig.html#config-freertos-fpu-in-isr"><span class="std std-ref">CONFIG_FREERTOS_FPU_IN_ISR</span></a> configuration option.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>ESP targets that contain an FPU do not support hardware acceleration for double precision floating point arithmetic (<code class="docutils literal notranslate"><span class="pre">double</span></code>). Instead, <code class="docutils literal notranslate"><span class="pre">double</span></code> is implemented via software, hence the behavioral restrictions regarding the <code class="docutils literal notranslate"><span class="pre">float</span></code> type do not apply to <code class="docutils literal notranslate"><span class="pre">double</span></code>. Note that due to the lack of hardware acceleration, <code class="docutils literal notranslate"><span class="pre">double</span></code> operations may consume significantly more CPU time in comparison to <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
</div>
</section>
</section>
<section id="single-core-mode">
<span id="freertos-idf-single-core"></span><h2><a class="toc-backref" href="#id30" role="doc-backlink">Single-Core Mode</a><a class="headerlink" href="#single-core-mode" title="Permalink to this heading"></a></h2>
<p>Although IDF FreeRTOS is modified for dual-core SMP, IDF FreeRTOS can also be built for single-core by enabling the <a class="reference internal" href="../kconfig.html#config-freertos-unicore"><span class="std std-ref">CONFIG_FREERTOS_UNICORE</span></a> option.</p>
<p>For single-core targets (such as ESP32-S2 and ESP32-C3), the <a class="reference internal" href="../kconfig.html#config-freertos-unicore"><span class="std std-ref">CONFIG_FREERTOS_UNICORE</span></a> option is always enabled. For multi-core targets (such as ESP32 and ESP32-S3), <a class="reference internal" href="../kconfig.html#config-freertos-unicore"><span class="std std-ref">CONFIG_FREERTOS_UNICORE</span></a> can also be set, but will result in the application only running Core 0.</p>
<p>When building in single-core mode, IDF FreeRTOS is designed to be identical to Vanilla FreeRTOS, thus all aforementioned SMP changes to kernel behavior are removed. As a result, building IDF FreeRTOS in single-core mode has the following characteristics:</p>
<ul class="simple">
<li><p>All operations performed by the kernel inside critical sections are now deterministic (i.e., no walking of linked lists inside critical sections).</p></li>
<li><p>Vanilla FreeRTOS scheduling algorithm is restored (including perfect Round Robin time slicing).</p></li>
<li><p>All SMP specific data is removed from single-core builds.</p></li>
</ul>
<p>SMP APIs can still be called in single-core mode. These APIs remain exposed to allow source code to be built for single-core and multi-core, without needing to call a different set of APIs. However, SMP APIs will not exhibit any SMP behavior in single-core mode, thus becoming equivalent to their single-core counterparts. For example:</p>
<ul class="simple">
<li><p>any <code class="docutils literal notranslate"><span class="pre">...ForCore(...,</span> <span class="pre">BaseType_t</span> <span class="pre">xCoreID)</span></code> SMP API will only accept <code class="docutils literal notranslate"><span class="pre">0</span></code> as a valid value for <code class="docutils literal notranslate"><span class="pre">xCoreID</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">...PinnedToCore()</span></code> task creation APIs will simply ignore the <code class="docutils literal notranslate"><span class="pre">xCoreID</span></code> core affinity argument.</p></li>
<li><p>Critical section APIs will still require a spinlock argument, but no spinlock will be taken and critical sections revert to simply disabling/enabling interrupts.</p></li>
</ul>
</section>
<section id="api-reference">
<h2><a class="toc-backref" href="#id31" role="doc-backlink">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h2>
<p>This section introduces FreeRTOS types, functions, and macros. It is automatically generated from FreeRTOS header files.</p>
<section id="task-api">
<h3>Task API<a class="headerlink" href="#task-api" title="Permalink to this heading"></a></h3>
</section>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/freertos/FreeRTOS-Kernel/include/freertos/task.h">components/freertos/FreeRTOS-Kernel/include/freertos/task.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/task.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411xTaskCreate14TaskFunction_tPCKcK22configSTACK_DEPTH_TYPEPCv11UBaseType_tPC12TaskHandle_t">
<span id="_CPPv311xTaskCreate14TaskFunction_tPCKcK22configSTACK_DEPTH_TYPEPCv11UBaseType_tPC12TaskHandle_t"></span><span id="_CPPv211xTaskCreate14TaskFunction_tPCKcK22configSTACK_DEPTH_TYPEPCv11UBaseType_tPC12TaskHandle_t"></span><span id="xTaskCreate__TaskFunction_t.cCPC.configSTACK_DEPTH_TYPEC.voidPC.UBaseType_t.TaskHandle_tPC"></span><span class="target" id="task_8h_1a5489235b8b4658d05fc45e3cccd41ba0"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskCreate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TaskFunction_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTaskCode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pcName</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">configSTACK_DEPTH_TYPE</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">usStackDepth</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvParameters</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxPriority</span></span>, <a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxCreatedTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411xTaskCreate14TaskFunction_tPCKcK22configSTACK_DEPTH_TYPEPCv11UBaseType_tPC12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a new task and add it to the list of tasks that are ready to run.</p>
<p>Internally, within the FreeRTOS implementation, tasks use two blocks of memory. The first block is used to hold the task's data structures. The second block is used by the task as its stack. If a task is created using xTaskCreate() then both blocks of memory are automatically dynamically allocated inside the xTaskCreate() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a task is created using xTaskCreateStatic() then the application writer must provide the required memory. xTaskCreateStatic() therefore allows a task to be created without using any dynamic memory allocation.</p>
<p>See xTaskCreateStatic() for a version that does not use any dynamic memory allocation.</p>
<p>xTaskCreate() can only be used to create a task that has unrestricted access to the entire microcontroller memory map. Systems that include MPU support can alternatively create an MPU constrained task using xTaskCreateRestricted().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Task to be created.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskCode</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Task code goes here.</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Function that creates a task.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vOtherFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucParameterToPass</span><span class="p">;</span>
<span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Create the task, storing the handle.  Note that the passed parameter ucParameterToPass</span>
<span class="w">  </span><span class="c1">// must exist for the lifetime of the task, so in this case is declared static.  If it was just an</span>
<span class="w">  </span><span class="c1">// an automatic stack variable it might no longer exist, or at least have been corrupted, by the time</span>
<span class="w">  </span><span class="c1">// the new task attempts to access it.</span>
<span class="w">  </span><span class="n">xTaskCreate</span><span class="p">(</span><span class="w"> </span><span class="n">vTaskCode</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NAME&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ucParameterToPass</span><span class="p">,</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Use the handle to delete the task.</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">     </span><span class="n">vTaskDelete</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If configNUMBER_OF_CORES &gt; 1, this function will create an unpinned task (see tskNO_AFFINITY for more details).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If program uses thread local variables (ones specified with &quot;__thread&quot; keyword) then storage for them will be allocated on the task's stack.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxTaskCode</strong> -- Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</p></li>
<li><p><strong>pcName</strong> -- A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN - default is 16.</p></li>
<li><p><strong>usStackDepth</strong> -- The size of the task stack specified as the NUMBER OF BYTES. Note that this differs from vanilla FreeRTOS.</p></li>
<li><p><strong>pvParameters</strong> -- Pointer that will be used as the parameter for the task being created.</p></li>
<li><p><strong>uxPriority</strong> -- The priority at which the task should run. Systems that include MPU support can optionally create tasks in a privileged (system) mode by setting bit portPRIVILEGE_BIT of the priority parameter. For example, to create a privileged task at priority 2 the uxPriority parameter should be set to ( 2 | portPRIVILEGE_BIT ).</p></li>
<li><p><strong>pxCreatedTask</strong> -- Used to pass back a handle by which the created task can be referenced.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t">
<span id="_CPPv317xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t"></span><span id="_CPPv217xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t"></span><span id="xTaskCreateStatic__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.StackType_tPC.StaticTask_tPC"></span><span class="target" id="task_8h_1a5b77b292821a13d5e119d43dfbab18aa"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskCreateStatic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TaskFunction_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTaskCode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pcName</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ulStackDepth</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvParameters</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxPriority</span></span>, <span class="n"><span class="pre">StackType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">puxStackBuffer</span></span>, <span class="n"><span class="pre">StaticTask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTaskBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a new task and add it to the list of tasks that are ready to run.</p>
<p>Internally, within the FreeRTOS implementation, tasks use two blocks of memory. The first block is used to hold the task's data structures. The second block is used by the task as its stack. If a task is created using xTaskCreate() then both blocks of memory are automatically dynamically allocated inside the xTaskCreate() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a task is created using xTaskCreateStatic() then the application writer must provide the required memory. xTaskCreateStatic() therefore allows a task to be created without using any dynamic memory allocation.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="c1">// Dimensions the buffer that the task being created will use as its stack.</span>
<span class="w">   </span><span class="c1">// NOTE:  This is the number of bytes the stack will hold, not the number of</span>
<span class="w">   </span><span class="c1">// words as found in vanilla FreeRTOS.</span>
<span class="cp">#define STACK_SIZE 200</span>
<span class="w"> </span>
<span class="w">   </span><span class="c1">// Structure that will hold the TCB of the task being created.</span>
<span class="w">   </span><span class="n">StaticTask_t</span><span class="w"> </span><span class="n">xTaskBuffer</span><span class="p">;</span>
<span class="w"> </span>
<span class="w">   </span><span class="c1">// Buffer that the task being created will use as its stack.  Note this is</span>
<span class="w">   </span><span class="c1">// an array of StackType_t variables.  The size of StackType_t is dependent on</span>
<span class="w">   </span><span class="c1">// the RTOS port.</span>
<span class="w">   </span><span class="n">StackType_t</span><span class="w"> </span><span class="n">xStack</span><span class="p">[</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="w"> </span><span class="p">];</span>
<span class="w"> </span>
<span class="w">   </span><span class="c1">// Function that implements the task being created.</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskCode</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">       </span><span class="c1">// The parameter value is expected to be 1 as 1 is passed in the</span>
<span class="w">       </span><span class="c1">// pvParameters value in the call to xTaskCreateStatic().</span>
<span class="w">       </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1UL</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span>
<span class="w">       </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">       </span><span class="p">{</span>
<span class="w">           </span><span class="c1">// Task code goes here.</span>
<span class="w">       </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>
<span class="w"> </span>
<span class="w">   </span><span class="c1">// Function that creates a task.</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="nf">vOtherFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">       </span><span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w"> </span>
<span class="w">       </span><span class="c1">// Create the task without using any dynamic memory allocation.</span>
<span class="w">       </span><span class="n">xHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskCreateStatic</span><span class="p">(</span>
<span class="w">                     </span><span class="n">vTaskCode</span><span class="p">,</span><span class="w">       </span><span class="c1">// Function that implements the task.</span>
<span class="w">                     </span><span class="s">&quot;NAME&quot;</span><span class="p">,</span><span class="w">          </span><span class="c1">// Text name for the task.</span>
<span class="w">                     </span><span class="n">STACK_SIZE</span><span class="p">,</span><span class="w">      </span><span class="c1">// Stack size in bytes.</span>
<span class="w">                     </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="c1">// Parameter passed into the task.</span>
<span class="w">                     </span><span class="n">tskIDLE_PRIORITY</span><span class="p">,</span><span class="c1">// Priority at which the task is created.</span>
<span class="w">                     </span><span class="n">xStack</span><span class="p">,</span><span class="w">          </span><span class="c1">// Array to use as the task&#39;s stack.</span>
<span class="w">                     </span><span class="o">&amp;</span><span class="n">xTaskBuffer</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// Variable to hold the task&#39;s data structure.</span>
<span class="w"> </span>
<span class="w">       </span><span class="c1">// puxStackBuffer and pxTaskBuffer were not NULL, so the task will have</span>
<span class="w">       </span><span class="c1">// been created, and xHandle will be the task&#39;s handle.  Use the handle</span>
<span class="w">       </span><span class="c1">// to suspend the task.</span>
<span class="w">       </span><span class="n">vTaskSuspend</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
</pre></div>
</div>
 </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If configNUMBER_OF_CORES &gt; 1, this function will create an unpinned task (see tskNO_AFFINITY for more details).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If program uses thread local variables (ones specified with &quot;__thread&quot; keyword) then storage for them will be allocated on the task's stack.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxTaskCode</strong> -- Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</p></li>
<li><p><strong>pcName</strong> -- A descriptive name for the task. This is mainly used to facilitate debugging. The maximum length of the string is defined by configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.</p></li>
<li><p><strong>ulStackDepth</strong> -- The size of the task stack specified as the NUMBER OF BYTES. Note that this differs from vanilla FreeRTOS.</p></li>
<li><p><strong>pvParameters</strong> -- Pointer that will be used as the parameter for the task being created.</p></li>
<li><p><strong>uxPriority</strong> -- The priority at which the task will run.</p></li>
<li><p><strong>puxStackBuffer</strong> -- Must point to a StackType_t array that has at least ulStackDepth indexes - the array will then be used as the task's stack, removing the need for the stack to be allocated dynamically.</p></li>
<li><p><strong>pxTaskBuffer</strong> -- Must point to a variable of type StaticTask_t, which will then be used to hold the task's data structures, removing the need for the memory to be allocated dynamically.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If neither puxStackBuffer nor pxTaskBuffer are NULL, then the task will be created and a handle to the created task is returned. If either puxStackBuffer or pxTaskBuffer are NULL then the task will not be created and NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423vTaskAllocateMPURegions12TaskHandle_tPCK14MemoryRegion_t">
<span id="_CPPv323vTaskAllocateMPURegions12TaskHandle_tPCK14MemoryRegion_t"></span><span id="_CPPv223vTaskAllocateMPURegions12TaskHandle_tPCK14MemoryRegion_t"></span><span id="vTaskAllocateMPURegions__TaskHandle_t.MemoryRegion_tCPC"></span><span class="target" id="task_8h_1af1e1fe7d9ccf4b85a99d1014f4fd647c"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskAllocateMPURegions</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">MemoryRegion_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxRegions</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423vTaskAllocateMPURegions12TaskHandle_tPCK14MemoryRegion_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Memory regions are assigned to a restricted task when the task is created by a call to xTaskCreateRestricted(). These regions can be redefined using vTaskAllocateMPURegions().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define an array of MemoryRegion_t structures that configures an MPU region</span>
<span class="c1">// allowing read/write access for 1024 bytes starting at the beginning of the</span>
<span class="c1">// ucOneKByte array.  The other two of the maximum 3 definable regions are</span>
<span class="c1">// unused so set to zero.</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MemoryRegion_t</span><span class="w"> </span><span class="n">xAltRegions</span><span class="p">[</span><span class="w"> </span><span class="n">portNUM_CONFIGURABLE_REGIONS</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Base address     Length      Parameters</span>
<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ucOneKByte</span><span class="p">,</span><span class="w">       </span><span class="mi">1024</span><span class="p">,</span><span class="w">       </span><span class="n">portMPU_REGION_READ_WRITE</span><span class="w"> </span><span class="p">},</span>
<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">                </span><span class="mi">0</span><span class="p">,</span><span class="w">          </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">                </span><span class="mi">0</span><span class="p">,</span><span class="w">          </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// This task was created such that it has access to certain regions of</span>
<span class="w"> </span><span class="c1">// memory as defined by the MPU configuration.  At some point it is</span>
<span class="w"> </span><span class="c1">// desired that these MPU regions are replaced with that defined in the</span>
<span class="w"> </span><span class="c1">// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()</span>
<span class="w"> </span><span class="c1">// for this purpose.  NULL is used as the task handle to indicate that this</span>
<span class="w"> </span><span class="c1">// function should modify the MPU regions of the calling task.</span>
<span class="w"> </span><span class="n">vTaskAllocateMPURegions</span><span class="p">(</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">xAltRegions</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Now the task can continue its function, but from this point on can only</span>
<span class="w"> </span><span class="c1">// access its stack and the ucOneKByte array (unless any other statically</span>
<span class="w"> </span><span class="c1">// defined or shared regions have been declared elsewhere).</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTask</strong> -- The handle of the task being updated.</p></li>
<li><p><strong>pxRegions</strong> -- A pointer to a MemoryRegion_t structure that contains the new memory region definitions.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411vTaskDelete12TaskHandle_t">
<span id="_CPPv311vTaskDelete12TaskHandle_t"></span><span id="_CPPv211vTaskDelete12TaskHandle_t"></span><span id="vTaskDelete__TaskHandle_t"></span><span class="target" id="task_8h_1af9cf8dedc1248f4351d3cb5910e33d7a"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskDelete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToDelete</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411vTaskDelete12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_vTaskDelete must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Remove a task from the RTOS real time kernel's management. The task being deleted will be removed from all ready, blocked, suspended and event lists.</p>
<p>NOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.</p>
<p>See the demo application file death.c for sample code that utilises vTaskDelete ().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vOtherFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Create the task, storing the handle.</span>
<span class="w">  </span><span class="n">xTaskCreate</span><span class="p">(</span><span class="w"> </span><span class="n">vTaskCode</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NAME&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Use the handle to delete the task.</span>
<span class="w">  </span><span class="n">vTaskDelete</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTaskToDelete</strong> -- The handle of the task to be deleted. Passing NULL will cause the calling task to be deleted.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410vTaskDelayK10TickType_t">
<span id="_CPPv310vTaskDelayK10TickType_t"></span><span id="_CPPv210vTaskDelayK10TickType_t"></span><span id="vTaskDelay__TickType_tC"></span><span class="target" id="task_8h_1a9917b05abb77e75e959151ae67065dce"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskDelay</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToDelay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410vTaskDelayK10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the tick rate. The constant portTICK_PERIOD_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.</p>
<p>INCLUDE_vTaskDelay must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a periodic task as the path taken through the code, as well as other task and interrupt activity, will affect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See xTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// Block for 500ms.</span>
<span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xDelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">portTICK_PERIOD_MS</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Simply toggle the LED every 500ms, blocking between each toggle.</span>
<span class="w">      </span><span class="n">vToggleLED</span><span class="p">();</span>
<span class="w">      </span><span class="n">vTaskDelay</span><span class="p">(</span><span class="w"> </span><span class="n">xDelay</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTicksToDelay</strong> -- The amount of time, in tick periods, that the calling task should block.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415xTaskDelayUntilPC10TickType_tK10TickType_t">
<span id="_CPPv315xTaskDelayUntilPC10TickType_tK10TickType_t"></span><span id="_CPPv215xTaskDelayUntilPC10TickType_tK10TickType_t"></span><span id="xTaskDelayUntil__TickType_tPC.TickType_tC"></span><span class="target" id="task_8h_1ab54935adc9c298a4a2109debab1f5541"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskDelayUntil</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxPreviousWakeTime</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTimeIncrement</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xTaskDelayUntilPC10TickType_tK10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Delay a task until a specified time. This function can be used by periodic tasks to ensure a constant execution frequency.</p>
<p>This function differs from vTaskDelay () in one important aspect: vTaskDelay () will cause a task to block for the specified number of ticks from the time vTaskDelay () is called. It is therefore difficult to use vTaskDelay () by itself to generate a fixed execution frequency as the time between a task starting to execute and that task calling vTaskDelay () may not be fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a different number of times each time it executes].</p>
<p>Whereas vTaskDelay () specifies a wake time relative to the time at which the function is called, xTaskDelayUntil () specifies the absolute (exact) time at which it wishes to unblock.</p>
<p>The macro pdMS_TO_TICKS() can be used to calculate the number of ticks from a time specified in milliseconds with a resolution of one tick period.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Perform an action every 10 ticks.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vTaskFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TickType_t</span><span class="w"> </span><span class="n">xLastWakeTime</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xFrequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xWasDelayed</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Initialise the xLastWakeTime variable with the current time.</span>
<span class="w">    </span><span class="n">xLastWakeTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskGetTickCount</span><span class="w"> </span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Wait for the next cycle.</span>
<span class="w">        </span><span class="n">xWasDelayed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskDelayUntil</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xLastWakeTime</span><span class="p">,</span><span class="w"> </span><span class="n">xFrequency</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Perform action here. xWasDelayed value can be used to determine</span>
<span class="w">        </span><span class="c1">// whether a deadline was missed if the code here took too long.</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxPreviousWakeTime</strong> -- Pointer to a variable that holds the time at which the task was last unblocked. The variable must be initialised with the current time prior to its first use (see the example below). Following this the variable is automatically updated within xTaskDelayUntil ().</p></li>
<li><p><strong>xTimeIncrement</strong> -- The cycle time period. The task will be unblocked at time *pxPreviousWakeTime + xTimeIncrement. Calling xTaskDelayUntil with the same xTimeIncrement parameter value will cause the task to execute with a fixed interface period.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Value which can be used to check whether the task was actually delayed. Will be pdTRUE if the task way delayed and pdFALSE otherwise. A task will not be delayed if the next expected wake time is in the past.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415xTaskAbortDelay12TaskHandle_t">
<span id="_CPPv315xTaskAbortDelay12TaskHandle_t"></span><span id="_CPPv215xTaskAbortDelay12TaskHandle_t"></span><span id="xTaskAbortDelay__TaskHandle_t"></span><span class="target" id="task_8h_1a0da407ac67c6c2e88605567aaf208276"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskAbortDelay</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xTaskAbortDelay12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this function to be available.</p>
<p>A task will enter the Blocked state when it is waiting for an event. The event it is waiting for can be a temporal event (waiting for a time), such as when vTaskDelay() is called, or an event on an object, such as when xQueueReceive() or ulTaskNotifyTake() is called. If the handle of a task that is in the Blocked state is used in a call to xTaskAbortDelay() then the task will leave the Blocked state, and return from whichever function call placed the task into the Blocked state.</p>
<p>There is no 'FromISR' version of this function as an interrupt would need to know which object a task was blocked on in order to know which actions to take. For example, if the task was blocked on a queue the interrupt handler would then need to know if the queue was locked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTask</strong> -- The handle of the task to remove from the Blocked state.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the task referenced by xTask was not in the Blocked state then pdFAIL is returned. Otherwise pdPASS is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417uxTaskPriorityGetK12TaskHandle_t">
<span id="_CPPv317uxTaskPriorityGetK12TaskHandle_t"></span><span id="_CPPv217uxTaskPriorityGetK12TaskHandle_t"></span><span id="uxTaskPriorityGet__TaskHandle_tC"></span><span class="target" id="task_8h_1a30334556d57da4f2bc8faf60dfa5b63b"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxTaskPriorityGet</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417uxTaskPriorityGetK12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Obtain the priority of any task.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Create a task, storing the handle.</span>
<span class="w">  </span><span class="n">xTaskCreate</span><span class="p">(</span><span class="w"> </span><span class="n">vTaskCode</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NAME&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="c1">// Use the handle to obtain the priority of the created task.</span>
<span class="w">  </span><span class="c1">// It was created with tskIDLE_PRIORITY, but may have changed</span>
<span class="w">  </span><span class="c1">// it itself.</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxTaskPriorityGet</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// The task has changed it&#39;s priority.</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="c1">// Is our priority higher than the created task?</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">uxTaskPriorityGet</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">uxTaskPriorityGet</span><span class="p">(</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Our priority (obtained using NULL handle) is higher.</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTask</strong> -- Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The priority of xTask.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424uxTaskPriorityGetFromISRK12TaskHandle_t">
<span id="_CPPv324uxTaskPriorityGetFromISRK12TaskHandle_t"></span><span id="_CPPv224uxTaskPriorityGetFromISRK12TaskHandle_t"></span><span id="uxTaskPriorityGetFromISR__TaskHandle_tC"></span><span class="target" id="task_8h_1af4197dbd93e7f8c4a715c9d9829d4d60"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxTaskPriorityGetFromISR</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424uxTaskPriorityGetFromISRK12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of uxTaskPriorityGet() that can be used from an ISR. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413eTaskGetState12TaskHandle_t">
<span id="_CPPv313eTaskGetState12TaskHandle_t"></span><span id="_CPPv213eTaskGetState12TaskHandle_t"></span><span id="eTaskGetState__TaskHandle_t"></span><span class="target" id="task_8h_1aab948efa7e3b657465cd06196b259ed7"></span><a class="reference internal" href="#_CPPv410eTaskState" title="eTaskState"><span class="n"><span class="pre">eTaskState</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eTaskGetState</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413eTaskGetState12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_eTaskGetState must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Obtain the state of any task. States are encoded by the eTaskState enumerated type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTask</strong> -- Handle of the task to be queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The state of xTask at the time the function was called. Note the state of the task might change between the function being called, and the functions return value being tested by the calling task. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412vTaskGetInfo12TaskHandle_tP12TaskStatus_t10BaseType_t10eTaskState">
<span id="_CPPv312vTaskGetInfo12TaskHandle_tP12TaskStatus_t10BaseType_t10eTaskState"></span><span id="_CPPv212vTaskGetInfo12TaskHandle_tP12TaskStatus_t10BaseType_t10eTaskState"></span><span id="vTaskGetInfo__TaskHandle_t.TaskStatus_tP.BaseType_t.eTaskState"></span><span class="target" id="task_8h_1a24b033eee266bdc8c3de63171a543f65"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskGetInfo</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span>, <a class="reference internal" href="#_CPPv412TaskStatus_t" title="TaskStatus_t"><span class="n"><span class="pre">TaskStatus_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxTaskStatus</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xGetFreeStackSpace</span></span>, <a class="reference internal" href="#_CPPv410eTaskState" title="eTaskState"><span class="n"><span class="pre">eTaskState</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">eState</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412vTaskGetInfo12TaskHandle_tP12TaskStatus_t10BaseType_t10eTaskState" title="Permalink to this definition"></a><br /></dt>
<dd><p>configUSE_TRACE_FACILITY must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Populates a TaskStatus_t structure with information about a task.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>
<span class="n">TaskStatus_t</span><span class="w"> </span><span class="n">xTaskDetails</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Obtain the handle of a task from its name.</span>
<span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xTaskGetHandle</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Task_Name&quot;</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Check the handle is not NULL.</span>
<span class="w"> </span><span class="n">configASSERT</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Use the handle to obtain further information about the task.</span>
<span class="w"> </span><span class="n">vTaskGetInfo</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="p">,</span>
<span class="w">               </span><span class="o">&amp;</span><span class="n">xTaskDetails</span><span class="p">,</span>
<span class="w">               </span><span class="n">pdTRUE</span><span class="p">,</span><span class="w"> </span><span class="c1">// Include the high water mark in xTaskDetails.</span>
<span class="w">               </span><span class="n">eInvalid</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Include the task state in xTaskDetails.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTask</strong> -- Handle of the task being queried. If xTask is NULL then information will be returned about the calling task.</p></li>
<li><p><strong>pxTaskStatus</strong> -- A pointer to the TaskStatus_t structure that will be filled with information about the task referenced by the handle passed using the xTask parameter.</p></li>
<li><p><strong>xGetFreeStackSpace</strong> -- The TaskStatus_t structure contains a member to report the stack high water mark of the task being queried. Calculating the stack high water mark takes a relatively long time, and can make the system temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to allow the high water mark checking to be skipped. The high watermark value will only be written to the TaskStatus_t structure if xGetFreeStackSpace is not set to pdFALSE;</p></li>
<li><p><strong>eState</strong> -- The TaskStatus_t structure contains a member to report the state of the task being queried. Obtaining the task state is not as fast as a simple assignment - so the eState parameter is provided to allow the state information to be omitted from the TaskStatus_t structure. To obtain state information then set eState to eInvalid - otherwise the value passed in eState will be reported as the task state in the TaskStatus_t structure.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416vTaskPrioritySet12TaskHandle_t11UBaseType_t">
<span id="_CPPv316vTaskPrioritySet12TaskHandle_t11UBaseType_t"></span><span id="_CPPv216vTaskPrioritySet12TaskHandle_t11UBaseType_t"></span><span id="vTaskPrioritySet__TaskHandle_t.UBaseType_t"></span><span class="target" id="task_8h_1a364e424f7bf8efced5738f44803f6580"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskPrioritySet</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxNewPriority</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416vTaskPrioritySet12TaskHandle_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Set the priority of any task.</p>
<p>A context switch will occur before the function returns if the priority being set is higher than the currently executing task.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Create a task, storing the handle.</span>
<span class="w">  </span><span class="n">xTaskCreate</span><span class="p">(</span><span class="w"> </span><span class="n">vTaskCode</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NAME&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="c1">// Use the handle to raise the priority of the created task.</span>
<span class="w">  </span><span class="n">vTaskPrioritySet</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="p">,</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="c1">// Use a NULL handle to raise our priority to the same value.</span>
<span class="w">  </span><span class="n">vTaskPrioritySet</span><span class="p">(</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTask</strong> -- Handle to the task for which the priority is being set. Passing a NULL handle results in the priority of the calling task being set.</p></li>
<li><p><strong>uxNewPriority</strong> -- The priority to which the task will be set.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412vTaskSuspend12TaskHandle_t">
<span id="_CPPv312vTaskSuspend12TaskHandle_t"></span><span id="_CPPv212vTaskSuspend12TaskHandle_t"></span><span id="vTaskSuspend__TaskHandle_t"></span><span class="target" id="task_8h_1a7fa54417f854974ae4a2b38729b60f12"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskSuspend</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToSuspend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412vTaskSuspend12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Suspend any task. When suspended a task will never get any microcontroller processing time, no matter what its priority.</p>
<p>Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend () twice on the same task still only requires one call to vTaskResume () to ready the suspended task.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Create a task, storing the handle.</span>
<span class="w">  </span><span class="n">xTaskCreate</span><span class="p">(</span><span class="w"> </span><span class="n">vTaskCode</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NAME&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="c1">// Use the handle to suspend the created task.</span>
<span class="w">  </span><span class="n">vTaskSuspend</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="c1">// The created task will not run during this period, unless</span>
<span class="w">  </span><span class="c1">// another task calls vTaskResume( xHandle ).</span>

<span class="w">  </span><span class="c1">//...</span>


<span class="w">  </span><span class="c1">// Suspend ourselves.</span>
<span class="w">  </span><span class="n">vTaskSuspend</span><span class="p">(</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// We cannot get here unless another task calls vTaskResume</span>
<span class="w">  </span><span class="c1">// with our handle as the parameter.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTaskToSuspend</strong> -- Handle to the task being suspended. Passing a NULL handle will cause the calling task to be suspended.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411vTaskResume12TaskHandle_t">
<span id="_CPPv311vTaskResume12TaskHandle_t"></span><span id="_CPPv211vTaskResume12TaskHandle_t"></span><span id="vTaskResume__TaskHandle_t"></span><span class="target" id="task_8h_1ad8abaa814e2cfc4830c276415d0935bb"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskResume</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToResume</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411vTaskResume12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Resumes a suspended task.</p>
<p>A task that has been suspended by one or more calls to vTaskSuspend () will be made available for running again by a single call to vTaskResume ().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span><span class="w"> </span><span class="n">xHandle</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Create a task, storing the handle.</span>
<span class="w">  </span><span class="n">xTaskCreate</span><span class="p">(</span><span class="w"> </span><span class="n">vTaskCode</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NAME&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">tskIDLE_PRIORITY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="c1">// Use the handle to suspend the created task.</span>
<span class="w">  </span><span class="n">vTaskSuspend</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="c1">// The created task will not run during this period, unless</span>
<span class="w">  </span><span class="c1">// another task calls vTaskResume( xHandle ).</span>

<span class="w">  </span><span class="c1">//...</span>


<span class="w">  </span><span class="c1">// Resume the suspended task ourselves.</span>
<span class="w">  </span><span class="n">vTaskResume</span><span class="p">(</span><span class="w"> </span><span class="n">xHandle</span><span class="w"> </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// The created task will once again get microcontroller processing</span>
<span class="w">  </span><span class="c1">// time in accordance with its priority within the system.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTaskToResume</strong> -- Handle to the task being readied.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418xTaskResumeFromISR12TaskHandle_t">
<span id="_CPPv318xTaskResumeFromISR12TaskHandle_t"></span><span id="_CPPv218xTaskResumeFromISR12TaskHandle_t"></span><span id="xTaskResumeFromISR__TaskHandle_t"></span><span class="target" id="task_8h_1a17fb13e7325d9dee9dec76f4a736138b"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskResumeFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToResume</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xTaskResumeFromISR12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>An implementation of vTaskResume() that can be called from within an ISR.</p>
<p>A task that has been suspended by one or more calls to vTaskSuspend () will be made available for running again by a single call to xTaskResumeFromISR ().</p>
<p>xTaskResumeFromISR() should not be used to synchronise a task with an interrupt if there is a chance that the interrupt could arrive prior to the task being suspended - as this can lead to interrupts being missed. Use of a semaphore as a synchronisation mechanism would avoid this eventuality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTaskToResume</strong> -- Handle to the task being readied.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if resuming the task should result in a context switch, otherwise pdFALSE. This is used by the ISR to determine if a context switch may be required following the ISR. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415vTaskSuspendAllv">
<span id="_CPPv315vTaskSuspendAllv"></span><span id="_CPPv215vTaskSuspendAllv"></span><span id="vTaskSuspendAll__void"></span><span class="target" id="task_8h_1a084d232640bd1d04bcac0b8784417015"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskSuspendAll</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415vTaskSuspendAllv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Suspends the scheduler without disabling interrupts. Context switches will not occur while the scheduler is suspended.</p>
<p>After calling vTaskSuspendAll () the calling task will continue to execute without risk of being swapped out until a call to xTaskResumeAll () has been made.</p>
<p>API functions that have the potential to cause a context switch (for example, xTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler is suspended.</p>
<p>Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vTask1</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Task code goes here.</span>

<span class="w">      </span><span class="c1">// ...</span>

<span class="w">      </span><span class="c1">// At some point the task wants to perform a long operation during</span>
<span class="w">      </span><span class="c1">// which it does not want to get swapped out.  It cannot use</span>
<span class="w">      </span><span class="c1">// taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the</span>
<span class="w">      </span><span class="c1">// operation may cause interrupts to be missed - including the</span>
<span class="w">      </span><span class="c1">// ticks.</span>

<span class="w">      </span><span class="c1">// Prevent the real time kernel swapping out the task.</span>
<span class="w">      </span><span class="n">vTaskSuspendAll</span><span class="w"> </span><span class="p">();</span>

<span class="w">      </span><span class="c1">// Perform the operation here.  There is no need to use critical</span>
<span class="w">      </span><span class="c1">// sections as we have all the microcontroller processing time.</span>
<span class="w">      </span><span class="c1">// During this time interrupts will still operate and the kernel</span>
<span class="w">      </span><span class="c1">// tick count will be maintained.</span>

<span class="w">      </span><span class="c1">// ...</span>

<span class="w">      </span><span class="c1">// The operation is complete.  Restart the kernel.</span>
<span class="w">      </span><span class="n">xTaskResumeAll</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414xTaskResumeAllv">
<span id="_CPPv314xTaskResumeAllv"></span><span id="_CPPv214xTaskResumeAllv"></span><span id="xTaskResumeAll__void"></span><span class="target" id="task_8h_1adf830ea0f150fcdfdaa944667137f080"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskResumeAll</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414xTaskResumeAllv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Resumes scheduler activity after it was suspended by a call to vTaskSuspendAll().</p>
<p>xTaskResumeAll() only resumes the scheduler. It does not unsuspend tasks that were previously suspended by a call to vTaskSuspend().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vTask1</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Task code goes here.</span>

<span class="w">      </span><span class="c1">// ...</span>

<span class="w">      </span><span class="c1">// At some point the task wants to perform a long operation during</span>
<span class="w">      </span><span class="c1">// which it does not want to get swapped out.  It cannot use</span>
<span class="w">      </span><span class="c1">// taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the</span>
<span class="w">      </span><span class="c1">// operation may cause interrupts to be missed - including the</span>
<span class="w">      </span><span class="c1">// ticks.</span>

<span class="w">      </span><span class="c1">// Prevent the real time kernel swapping out the task.</span>
<span class="w">      </span><span class="n">vTaskSuspendAll</span><span class="w"> </span><span class="p">();</span>

<span class="w">      </span><span class="c1">// Perform the operation here.  There is no need to use critical</span>
<span class="w">      </span><span class="c1">// sections as we have all the microcontroller processing time.</span>
<span class="w">      </span><span class="c1">// During this time interrupts will still operate and the real</span>
<span class="w">      </span><span class="c1">// time kernel tick count will be maintained.</span>

<span class="w">      </span><span class="c1">// ...</span>

<span class="w">      </span><span class="c1">// The operation is complete.  Restart the kernel.  We want to force</span>
<span class="w">      </span><span class="c1">// a context switch - but there is no point if resuming the scheduler</span>
<span class="w">      </span><span class="c1">// caused a context switch already.</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">xTaskResumeAll</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">)</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">           </span><span class="n">taskYIELD</span><span class="w"> </span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417xTaskGetTickCountv">
<span id="_CPPv317xTaskGetTickCountv"></span><span id="_CPPv217xTaskGetTickCountv"></span><span id="xTaskGetTickCount__void"></span><span class="target" id="task_8h_1a5fa24e36d5e1eeb57f5b73b72ea048e7"></span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGetTickCount</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xTaskGetTickCountv" title="Permalink to this definition"></a><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The count of ticks since vTaskStartScheduler was called. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424xTaskGetTickCountFromISRv">
<span id="_CPPv324xTaskGetTickCountFromISRv"></span><span id="_CPPv224xTaskGetTickCountFromISRv"></span><span id="xTaskGetTickCountFromISR__void"></span><span class="target" id="task_8h_1ad58fd766b8f438b5703276f585738762"></span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGetTickCountFromISR</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424xTaskGetTickCountFromISRv" title="Permalink to this definition"></a><br /></dt>
<dd><p>
This is a version of xTaskGetTickCount() that is safe to be called from an ISR - provided that TickType_t is the natural word size of the microcontroller being used or interrupt nesting is either not supported or not being used. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The count of ticks since vTaskStartScheduler was called.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422uxTaskGetNumberOfTasksv">
<span id="_CPPv322uxTaskGetNumberOfTasksv"></span><span id="_CPPv222uxTaskGetNumberOfTasksv"></span><span id="uxTaskGetNumberOfTasks__void"></span><span class="target" id="task_8h_1a4b660446c721df74158dddb9fc189c1e"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxTaskGetNumberOfTasks</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422uxTaskGetNumberOfTasksv" title="Permalink to this definition"></a><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of tasks that the real time kernel is currently managing. This includes all ready, blocked and suspended tasks. A task that has been deleted but not yet freed by the idle task will also be included in the count. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413pcTaskGetName12TaskHandle_t">
<span id="_CPPv313pcTaskGetName12TaskHandle_t"></span><span id="_CPPv213pcTaskGetName12TaskHandle_t"></span><span id="pcTaskGetName__TaskHandle_t"></span><span class="target" id="task_8h_1acb1be57d03f6f1a3161b69e98df6ccb9"></span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcTaskGetName</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToQuery</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413pcTaskGetName12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The text (human readable) name of the task referenced by the handle xTaskToQuery. A task can query its own name by either passing in its own handle, or by setting xTaskToQuery to NULL. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414xTaskGetHandlePKc">
<span id="_CPPv314xTaskGetHandlePKc"></span><span id="_CPPv214xTaskGetHandlePKc"></span><span id="xTaskGetHandle__cCP"></span><span class="target" id="task_8h_1a86e945a322943dca5023dc49d1458b0c"></span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGetHandle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pcNameToQuery</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414xTaskGetHandlePKc" title="Permalink to this definition"></a><br /></dt>
<dd><p>NOTE: This function takes a relatively long time to complete and should be used sparingly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The handle of the task that has the human readable name pcNameToQuery. NULL is returned if no matching name is found. INCLUDE_xTaskGetHandle must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421xTaskGetStaticBuffers12TaskHandle_tPP11StackType_tPP12StaticTask_t">
<span id="_CPPv321xTaskGetStaticBuffers12TaskHandle_tPP11StackType_tPP12StaticTask_t"></span><span id="_CPPv221xTaskGetStaticBuffers12TaskHandle_tPP11StackType_tPP12StaticTask_t"></span><span id="xTaskGetStaticBuffers__TaskHandle_t.StackType_tPP.StaticTask_tPP"></span><span class="target" id="task_8h_1aadeb8a25f4d07815fe940d2679621e14"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGetStaticBuffers</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span>, <span class="n"><span class="pre">StackType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppuxStackBuffer</span></span>, <span class="n"><span class="pre">StaticTask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppxTaskBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421xTaskGetStaticBuffers12TaskHandle_tPP11StackType_tPP12StaticTask_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve pointers to a statically created task's data structure buffer and stack buffer. These are the same buffers that are supplied at the time of creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTask</strong> -- The task for which to retrieve the buffers.</p></li>
<li><p><strong>ppuxStackBuffer</strong> -- Used to return a pointer to the task's stack buffer.</p></li>
<li><p><strong>ppxTaskBuffer</strong> -- Used to return a pointer to the task's data structure buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if buffers were retrieved, pdFALSE otherwise. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427uxTaskGetStackHighWaterMark12TaskHandle_t">
<span id="_CPPv327uxTaskGetStackHighWaterMark12TaskHandle_t"></span><span id="_CPPv227uxTaskGetStackHighWaterMark12TaskHandle_t"></span><span id="uxTaskGetStackHighWaterMark__TaskHandle_t"></span><span class="target" id="task_8h_1a906b3904161aec4874d0fae26c00bf86"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxTaskGetStackHighWaterMark</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427uxTaskGetStackHighWaterMark12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.</p>
<p>Returns the high water mark of the stack associated with xTask. That is, the minimum free stack space there has been (in words, so on a 32 bit machine a value of 1 means 4 bytes) since the task started. The smaller the returned number the closer the task has come to overflowing its stack.</p>
<p>uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the same except for their return type. Using configSTACK_DEPTH_TYPE allows the user to determine the return type. It gets around the problem of the value overflowing on 8-bit types without breaking backward compatibility for applications that expect an 8-bit return type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTask</strong> -- Handle of the task associated with the stack to be checked. Set xTask to NULL to check the stack of the calling task.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The smallest amount of free stack space there has been (in words, so actual spaces on the stack rather than bytes) since the task referenced by xTask was created. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428uxTaskGetStackHighWaterMark212TaskHandle_t">
<span id="_CPPv328uxTaskGetStackHighWaterMark212TaskHandle_t"></span><span id="_CPPv228uxTaskGetStackHighWaterMark212TaskHandle_t"></span><span id="uxTaskGetStackHighWaterMark2__TaskHandle_t"></span><span class="target" id="task_8h_1a4b2d5f76adcc169e6a0eca6800fe77ec"></span><span class="n"><span class="pre">configSTACK_DEPTH_TYPE</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxTaskGetStackHighWaterMark2</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428uxTaskGetStackHighWaterMark212TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for this function to be available.</p>
<p>Returns the high water mark of the stack associated with xTask. That is, the minimum free stack space there has been (in words, so on a 32 bit machine a value of 1 means 4 bytes) since the task started. The smaller the returned number the closer the task has come to overflowing its stack.</p>
<p>uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the same except for their return type. Using configSTACK_DEPTH_TYPE allows the user to determine the return type. It gets around the problem of the value overflowing on 8-bit types without breaking backward compatibility for applications that expect an 8-bit return type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTask</strong> -- Handle of the task associated with the stack to be checked. Set xTask to NULL to check the stack of the calling task.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The smallest amount of free stack space there has been (in words, so actual spaces on the stack rather than bytes) since the task referenced by xTask was created. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t">
<span id="_CPPv326vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t"></span><span id="_CPPv226vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t"></span><span id="vTaskSetApplicationTaskTag__TaskHandle_t.TaskHookFunction_t"></span><span class="target" id="task_8h_1a15c15ee4d0a4506b255e9f675907d7e6"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskSetApplicationTaskTag</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span>, <a class="reference internal" href="#_CPPv418TaskHookFunction_t" title="TaskHookFunction_t"><span class="n"><span class="pre">TaskHookFunction_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pxHookFunction</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sets pxHookFunction to be the task hook function used by the task xTask. Passing xTask as NULL has the effect of setting the calling tasks hook function. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426xTaskGetApplicationTaskTag12TaskHandle_t">
<span id="_CPPv326xTaskGetApplicationTaskTag12TaskHandle_t"></span><span id="_CPPv226xTaskGetApplicationTaskTag12TaskHandle_t"></span><span id="xTaskGetApplicationTaskTag__TaskHandle_t"></span><span class="target" id="task_8h_1a27b04ae636370aba7400d0f8cf32886c"></span><a class="reference internal" href="#_CPPv418TaskHookFunction_t" title="TaskHookFunction_t"><span class="n"><span class="pre">TaskHookFunction_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGetApplicationTaskTag</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426xTaskGetApplicationTaskTag12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the pxHookFunction value assigned to the task xTask. Do not call from an interrupt service routine - call xTaskGetApplicationTaskTagFromISR() instead. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv433xTaskGetApplicationTaskTagFromISR12TaskHandle_t">
<span id="_CPPv333xTaskGetApplicationTaskTagFromISR12TaskHandle_t"></span><span id="_CPPv233xTaskGetApplicationTaskTagFromISR12TaskHandle_t"></span><span id="xTaskGetApplicationTaskTagFromISR__TaskHandle_t"></span><span class="target" id="task_8h_1a81118ccc9b82cfb86a6ea71dfd67309a"></span><a class="reference internal" href="#_CPPv418TaskHookFunction_t" title="TaskHookFunction_t"><span class="n"><span class="pre">TaskHookFunction_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGetApplicationTaskTagFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433xTaskGetApplicationTaskTagFromISR12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the pxHookFunction value assigned to the task xTask. Can be called from an interrupt service routine. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv433vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv">
<span id="_CPPv333vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv"></span><span id="_CPPv233vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv"></span><span id="vTaskSetThreadLocalStoragePointer__TaskHandle_t.BaseType_t.voidP"></span><span class="target" id="task_8h_1a8b1132bc3b01220a1b949c8006af0943"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskSetThreadLocalStoragePointer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToSet</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xIndex</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvValue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Each task contains an array of pointers that is dimensioned by the configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h. The kernel does not use the pointers itself, so the application writer can use the pointers for any purpose they wish. The following two functions are used to set and query a pointer respectively. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv434pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t">
<span id="_CPPv334pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t"></span><span id="_CPPv234pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t"></span><span id="pvTaskGetThreadLocalStoragePointer__TaskHandle_t.BaseType_t"></span><span class="target" id="task_8h_1a7c95aced700fe8d9cc12326a3eb0e916"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pvTaskGetThreadLocalStoragePointer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToQuery</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xIndex</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429vApplicationGetIdleTaskMemoryPP12StaticTask_tPP11StackType_tP8uint32_t">
<span id="_CPPv329vApplicationGetIdleTaskMemoryPP12StaticTask_tPP11StackType_tP8uint32_t"></span><span id="_CPPv229vApplicationGetIdleTaskMemoryPP12StaticTask_tPP11StackType_tP8uint32_t"></span><span id="vApplicationGetIdleTaskMemory__StaticTask_tPP.StackType_tPP.uint32_tP"></span><span class="target" id="task_8h_1a1988aa923b19fa6f31c93afa7773f793"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vApplicationGetIdleTaskMemory</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">StaticTask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppxIdleTaskTCBBuffer</span></span>, <span class="n"><span class="pre">StackType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppxIdleTaskStackBuffer</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulIdleTaskStackSize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429vApplicationGetIdleTaskMemoryPP12StaticTask_tPP11StackType_tP8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Idle Task TCB. This function is required when configSUPPORT_STATIC_ALLOCATION is set. For more information see this URI: <a class="reference external" href="https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION">https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ppxIdleTaskTCBBuffer</strong> -- A handle to a statically allocated TCB buffer </p></li>
<li><p><strong>ppxIdleTaskStackBuffer</strong> -- A handle to a statically allocated Stack buffer for the idle task </p></li>
<li><p><strong>pulIdleTaskStackSize</strong> -- A pointer to the number of elements that will fit in the allocated stack buffer </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428xTaskCallApplicationTaskHook12TaskHandle_tPv">
<span id="_CPPv328xTaskCallApplicationTaskHook12TaskHandle_tPv"></span><span id="_CPPv228xTaskCallApplicationTaskHook12TaskHandle_tPv"></span><span id="xTaskCallApplicationTaskHook__TaskHandle_t.voidP"></span><span class="target" id="task_8h_1a1dded6b85b84a6f2874c54f78ce0d030"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskCallApplicationTaskHook</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvParameter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428xTaskCallApplicationTaskHook12TaskHandle_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Calls the hook function associated with xTask. Passing xTask as NULL has the effect of calling the Running tasks (the calling task) hook function.</p>
<p>pvParameter is passed to the hook function for the task to interpret as it wants. The return value is the value returned by the task hook function registered by the user. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422xTaskGetIdleTaskHandlev">
<span id="_CPPv322xTaskGetIdleTaskHandlev"></span><span id="_CPPv222xTaskGetIdleTaskHandlev"></span><span id="xTaskGetIdleTaskHandle__void"></span><span class="target" id="task_8h_1a38e3c3df6fc5b28c14459e32474917fb"></span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGetIdleTaskHandle</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422xTaskGetIdleTaskHandlev" title="Permalink to this definition"></a><br /></dt>
<dd><p>xTaskGetIdleTaskHandle() is only available if INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.</p>
<p>Simply returns the handle of the idle task of the current core. It is not valid to call xTaskGetIdleTaskHandle() before the scheduler has been started. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC27configRUN_TIME_COUNTER_TYPE">
<span id="_CPPv320uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC27configRUN_TIME_COUNTER_TYPE"></span><span id="_CPPv220uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC27configRUN_TIME_COUNTER_TYPE"></span><span id="uxTaskGetSystemState__TaskStatus_tPC.UBaseType_tC.configRUN_TIME_COUNTER_TYPEPC"></span><span class="target" id="task_8h_1a5efedd9260670f73bae7fcbcd22d6c4e"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxTaskGetSystemState</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskStatus_t" title="TaskStatus_t"><span class="n"><span class="pre">TaskStatus_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTaskStatusArray</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxArraySize</span></span>, <span class="n"><span class="pre">configRUN_TIME_COUNTER_TYPE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pulTotalRunTime</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC27configRUN_TIME_COUNTER_TYPE" title="Permalink to this definition"></a><br /></dt>
<dd><p>configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for uxTaskGetSystemState() to be available.</p>
<p>uxTaskGetSystemState() populates an TaskStatus_t structure for each task in the system. TaskStatus_t structures contain, among other things, members for the task handle, task name, task priority, task state, and total amount of run time consumed by the task. See the TaskStatus_t structure definition in this file for the full member list.</p>
<p>NOTE: This function is intended for debugging use only as its use results in the scheduler remaining suspended for an extended period.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="c1">// This example demonstrates how a human readable table of run time stats</span>
<span class="w"> </span><span class="c1">// information is generated from raw data provided by uxTaskGetSystemState().</span>
<span class="w"> </span><span class="c1">// The human readable table is written to pcWriteBuffer</span>
<span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">vTaskGetRunTimeStats</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="o">*</span><span class="n">pxTaskStatusArray</span><span class="p">;</span>
<span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w"> </span><span class="n">configRUN_TIME_COUNTER_TYPE</span><span class="w"> </span><span class="n">ulTotalRunTime</span><span class="p">,</span><span class="w"> </span><span class="n">ulStatsAsPercentage</span><span class="p">;</span>

<span class="w">     </span><span class="c1">// Make sure the write buffer does not contain a string.</span>
<span class="n">pcWriteBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span>

<span class="w">     </span><span class="c1">// Take a snapshot of the number of tasks in case it changes while this</span>
<span class="w">     </span><span class="c1">// function is executing.</span>
<span class="w">     </span><span class="n">uxArraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxTaskGetNumberOfTasks</span><span class="p">();</span>

<span class="w">     </span><span class="c1">// Allocate a TaskStatus_t structure for each task.  An array could be</span>
<span class="w">     </span><span class="c1">// allocated statically at compile time.</span>
<span class="w">     </span><span class="n">pxTaskStatusArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="w"> </span><span class="n">uxArraySize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">TaskStatus_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Generate raw status information about each task.</span>
<span class="w">         </span><span class="n">uxArraySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uxTaskGetSystemState</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">,</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulTotalRunTime</span><span class="w"> </span><span class="p">);</span>

<span class="w">         </span><span class="c1">// For percentage calculations.</span>
<span class="w">         </span><span class="n">ulTotalRunTime</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">100UL</span><span class="p">;</span>

<span class="w">         </span><span class="c1">// Avoid divide by zero errors.</span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ulTotalRunTime</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">         </span><span class="p">{</span>
<span class="w">             </span><span class="c1">// For each populated position in the pxTaskStatusArray array,</span>
<span class="w">             </span><span class="c1">// format the raw data as human readable ASCII data</span>
<span class="w">             </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">uxArraySize</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">             </span><span class="p">{</span>
<span class="w">                 </span><span class="c1">// What percentage of the total run time has the task used?</span>
<span class="w">                 </span><span class="c1">// This will always be rounded down to the nearest integer.</span>
<span class="w">                 </span><span class="c1">// ulTotalRunTimeDiv100 has already been divided by 100.</span>
<span class="w">                 </span><span class="n">ulStatsAsPercentage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">ulRunTimeCounter</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">ulTotalRunTime</span><span class="p">;</span>

<span class="w">                 </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ulStatsAsPercentage</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0UL</span><span class="w"> </span><span class="p">)</span>
<span class="w">                 </span><span class="p">{</span>
<span class="w">                     </span><span class="n">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s</span><span class="se">\t\t</span><span class="s">%lu</span><span class="se">\t\t</span><span class="s">%lu%%</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">pcTaskName</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">ulRunTimeCounter</span><span class="p">,</span><span class="w"> </span><span class="n">ulStatsAsPercentage</span><span class="w"> </span><span class="p">);</span>
<span class="w">                 </span><span class="p">}</span>
<span class="w">                 </span><span class="k">else</span>
<span class="w">                 </span><span class="p">{</span>
<span class="w">                     </span><span class="c1">// If the percentage is zero here then the task has</span>
<span class="w">                     </span><span class="c1">// consumed less than 1% of the total run time.</span>
<span class="w">                     </span><span class="n">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s</span><span class="se">\t\t</span><span class="s">%lu</span><span class="se">\t\t</span><span class="s">&lt;1%%</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">pcTaskName</span><span class="p">,</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="p">[</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">].</span><span class="n">ulRunTimeCounter</span><span class="w"> </span><span class="p">);</span>
<span class="w">                 </span><span class="p">}</span>

<span class="w">                 </span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pcWriteBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="w">             </span><span class="p">}</span>
<span class="w">         </span><span class="p">}</span>

<span class="w">         </span><span class="c1">// The array is no longer needed, free the memory it consumes.</span>
<span class="w">         </span><span class="n">vPortFree</span><span class="p">(</span><span class="w"> </span><span class="n">pxTaskStatusArray</span><span class="w"> </span><span class="p">);</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxTaskStatusArray</strong> -- A pointer to an array of TaskStatus_t structures. The array must contain at least one TaskStatus_t structure for each task that is under the control of the RTOS. The number of tasks under the control of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.</p></li>
<li><p><strong>uxArraySize</strong> -- The size of the array pointed to by the pxTaskStatusArray parameter. The size is specified as the number of indexes in the array, or the number of TaskStatus_t structures contained in the array, not by the number of bytes in the array.</p></li>
<li><p><strong>pulTotalRunTime</strong> -- If configGENERATE_RUN_TIME_STATS is set to 1 in FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the total run time (as defined by the run time stats clock, see <a class="reference external" href="https://www.FreeRTOS.org/rtos-run-time-stats.html">https://www.FreeRTOS.org/rtos-run-time-stats.html</a>) since the target booted. pulTotalRunTime can be set to NULL to omit the total run time information.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of TaskStatus_t structures that were populated by uxTaskGetSystemState(). This should equal the number returned by the uxTaskGetNumberOfTasks() API function, but will be zero if the value passed in the uxArraySize parameter was too small.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv49vTaskListPc">
<span id="_CPPv39vTaskListPc"></span><span id="_CPPv29vTaskListPc"></span><span id="vTaskList__cP"></span><span class="target" id="task_8h_1a9d231e1f7edb54d7672683381a3992e1"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskList</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pcWriteBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49vTaskListPc" title="Permalink to this definition"></a><br /></dt>
<dd><p>configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must both be defined as 1 for this function to be available. See the configuration section of the FreeRTOS.org website for more information.</p>
<p>NOTE 1: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.</p>
<p>Lists all the current tasks, along with their current state and stack usage high water mark.</p>
<p>Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').</p>
<p>PLEASE NOTE:</p>
<p>This function is provided for convenience only, and is used by many of the demo applications. Do not consider it to be part of the scheduler.</p>
<p>vTaskList() calls uxTaskGetSystemState(), then formats part of the uxTaskGetSystemState() output into a human readable table that displays task: names, states, priority, stack usage and task number. Stack usage specified as the number of unused StackType_t words stack can hold on top of stack - not the number of bytes.</p>
<p>vTaskList() has a dependency on the sprintf() C library function that might bloat the code size, use a lot of stack, and provide different results on different platforms. An alternative, tiny, third party, and limited functionality implementation of sprintf() is provided in many of the FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note printf-stdarg.c does not provide a full snprintf() implementation!).</p>
<p>It is recommended that production systems call uxTaskGetSystemState() directly to get access to raw stats data, rather than indirectly through a call to vTaskList().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pcWriteBuffer</strong> -- A buffer into which the above mentioned details will be written, in ASCII form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420vTaskGetRunTimeStatsPc">
<span id="_CPPv320vTaskGetRunTimeStatsPc"></span><span id="_CPPv220vTaskGetRunTimeStatsPc"></span><span id="vTaskGetRunTimeStats__cP"></span><span class="target" id="task_8h_1ae8f50ac9cf0a81365199c328aaedba87"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskGetRunTimeStats</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pcWriteBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420vTaskGetRunTimeStatsPc" title="Permalink to this definition"></a><br /></dt>
<dd><p>configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS must both be defined as 1 for this function to be available. The application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE() to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.</p>
<p>NOTE 1: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.</p>
<p>Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. Calling vTaskGetRunTimeStats() writes the total execution time of each task into a buffer, both as an absolute count value and as a percentage of the total system execution time.</p>
<p>NOTE 2:</p>
<p>This function is provided for convenience only, and is used by many of the demo applications. Do not consider it to be part of the scheduler.</p>
<p>vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the uxTaskGetSystemState() output into a human readable table that displays the amount of time each task has spent in the Running state in both absolute and percentage terms.</p>
<p>vTaskGetRunTimeStats() has a dependency on the sprintf() C library function that might bloat the code size, use a lot of stack, and provide different results on different platforms. An alternative, tiny, third party, and limited functionality implementation of sprintf() is provided in many of the FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note printf-stdarg.c does not provide a full snprintf() implementation!).</p>
<p>It is recommended that production systems call uxTaskGetSystemState() directly to get access to raw stats data, rather than indirectly through a call to vTaskGetRunTimeStats().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pcWriteBuffer</strong> -- A buffer into which the execution times will be written, in ASCII form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427ulTaskGetIdleRunTimeCounterv">
<span id="_CPPv327ulTaskGetIdleRunTimeCounterv"></span><span id="_CPPv227ulTaskGetIdleRunTimeCounterv"></span><span id="ulTaskGetIdleRunTimeCounter__void"></span><span class="target" id="task_8h_1a1b45b912b1920af4ae19be1e53df9204"></span><span class="n"><span class="pre">configRUN_TIME_COUNTER_TYPE</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ulTaskGetIdleRunTimeCounter</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427ulTaskGetIdleRunTimeCounterv" title="Permalink to this definition"></a><br /></dt>
<dd><p>configGENERATE_RUN_TIME_STATS, configUSE_STATS_FORMATTING_FUNCTIONS and INCLUDE_xTaskGetIdleTaskHandle must all be defined as 1 for these functions to be available. The application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE() to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.</p>
<p>Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. While uxTaskGetSystemState() and vTaskGetRunTimeStats() writes the total execution time of each task into a buffer, ulTaskGetIdleRunTimeCounter() returns the total execution time of just the idle task and ulTaskGetIdleRunTimePercent() returns the percentage of the CPU time used by just the idle task.</p>
<p>Note the amount of idle time is only a good measure of the slack time in a system if there are no other tasks executing at the idle priority, tickless idle is not used, and configIDLE_SHOULD_YIELD is set to 0.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If configNUMBER_OF_CORES &gt; 1, calling this function will query the idle task of the current core.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The total run time of the idle task or the percentage of the total run time consumed by the idle task. This is the amount of time the idle task has actually been executing. The unit of time is dependent on the frequency configured using the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE() macros. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427ulTaskGetIdleRunTimePercentv">
<span id="_CPPv327ulTaskGetIdleRunTimePercentv"></span><span id="_CPPv227ulTaskGetIdleRunTimePercentv"></span><span id="ulTaskGetIdleRunTimePercent__void"></span><span class="target" id="task_8h_1ad314822aa9c824b2e8059778f4b9c3ae"></span><span class="n"><span class="pre">configRUN_TIME_COUNTER_TYPE</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ulTaskGetIdleRunTimePercent</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427ulTaskGetIdleRunTimePercentv" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422xTaskGenericNotifyWait11UBaseType_t8uint32_t8uint32_tP8uint32_t10TickType_t">
<span id="_CPPv322xTaskGenericNotifyWait11UBaseType_t8uint32_t8uint32_tP8uint32_t10TickType_t"></span><span id="_CPPv222xTaskGenericNotifyWait11UBaseType_t8uint32_t8uint32_tP8uint32_t10TickType_t"></span><span id="xTaskGenericNotifyWait__UBaseType_t.uint32_t.uint32_t.uint32_tP.TickType_t"></span><span class="target" id="task_8h_1ad477b86616a24c10c8700347ce4e4fbb"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGenericNotifyWait</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxIndexToWaitOn</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ulBitsToClearOnEntry</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ulBitsToClearOnExit</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulNotificationValue</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422xTaskGenericNotifyWait11UBaseType_t8uint32_t8uint32_tP8uint32_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Waits for a direct to task notification to be pending at a given index within an array of direct to task notifications.</p>
<p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p>
<p>Each task has a private array of &quot;notification values&quot; (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment one of the task's notification values. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their un-indexed equivalents). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p>
<p>A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block to wait for a notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.</p>
<p><strong>NOTE</strong> Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</p>
<p>Backward compatibility information: Prior to FreeRTOS V10.4.0 each task had a single &quot;notification value&quot;, and all task notification API functions operated on that value. Replacing the single notification value with an array of notification values necessitated a new set of API functions that could address specific notifications within the array. xTaskNotifyWait() is the original API function, and remains backward compatible by always operating on the notification value at index 0 in the array. Calling xTaskNotifyWait() is equivalent to calling xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uxIndexToWaitOn</strong> -- The index within the calling task's array of notification values on which the calling task will wait for a notification to be received. uxIndexToWaitOn must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES. xTaskNotifyWait() does not have this parameter and always waits for notifications on index 0.</p></li>
<li><p><strong>ulBitsToClearOnEntry</strong> -- Bits that are set in ulBitsToClearOnEntry value will be cleared in the calling task's notification value before the task checks to see if any notifications are pending, and optionally blocks if no notifications are pending. Setting ulBitsToClearOnEntry to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task's notification value to 0. Setting ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.</p></li>
<li><p><strong>ulBitsToClearOnExit</strong> -- If a notification is pending or received before the calling task exits the xTaskNotifyWait() function then the task's notification value (see the xTaskNotify() API function) is passed out using the pulNotificationValue parameter. Then any bits that are set in ulBitsToClearOnExit will be cleared in the task's notification value (note *pulNotificationValue is set before any bits are cleared). Setting ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task's notification value to 0 before the function exits. Setting ulBitsToClearOnExit to 0 will leave the task's notification value unchanged when the function exits (in which case the value passed out in pulNotificationValue will match the task's notification value).</p></li>
<li><p><strong>pulNotificationValue</strong> -- Used to pass the task's notification value out of the function. Note the value passed out will not be effected by the clearing of any bits caused by ulBitsToClearOnExit being non-zero.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time that the task should wait in the Blocked state for a notification to be received, should a notification not already be pending when xTaskNotifyWait() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If a notification was received (including notifications that were already pending when xTaskNotifyWait was called) then pdPASS is returned. Otherwise pdFAIL is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429vTaskGenericNotifyGiveFromISR12TaskHandle_t11UBaseType_tP10BaseType_t">
<span id="_CPPv329vTaskGenericNotifyGiveFromISR12TaskHandle_t11UBaseType_tP10BaseType_t"></span><span id="_CPPv229vTaskGenericNotifyGiveFromISR12TaskHandle_t11UBaseType_tP10BaseType_t"></span><span id="vTaskGenericNotifyGiveFromISR__TaskHandle_t.UBaseType_t.BaseType_tP"></span><span class="target" id="task_8h_1a33d2b0e244233f8b5d6ba6b7655cbe61"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskGenericNotifyGiveFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToNotify</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxIndexToNotify</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429vTaskGenericNotifyGiveFromISR12TaskHandle_t11UBaseType_tP10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xTaskNotifyGiveIndexed() that can be called from an interrupt service routine (ISR).</p>
<p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for more details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro to be available.</p>
<p>Each task has a private array of &quot;notification values&quot; (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment one of the task's notification values. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications are used as light weight and faster binary or counting semaphore equivalents. Actual FreeRTOS semaphores are given from an ISR using the xSemaphoreGiveFromISR() API function, the equivalent action that instead uses a task notification is vTaskNotifyGiveIndexedFromISR().</p>
<p>When task notifications are being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the ulTaskNotifyTakeIndexed() API function rather than the xTaskNotifyWaitIndexed() API function.</p>
<p><strong>NOTE</strong> Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</p>
<p>Backward compatibility information: Prior to FreeRTOS V10.4.0 each task had a single &quot;notification value&quot;, and all task notification API functions operated on that value. Replacing the single notification value with an array of notification values necessitated a new set of API functions that could address specific notifications within the array. xTaskNotifyFromISR() is the original API function, and remains backward compatible by always operating on the notification value at index 0 within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTaskToNotify</strong> -- The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</p></li>
<li><p><strong>uxIndexToNotify</strong> -- The index within the target task's array of notification values to which the notification is to be sent. uxIndexToNotify must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES. xTaskNotifyGiveFromISR() does not have this parameter and always sends notifications to index 0.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- vTaskNotifyGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the task to which the notification was sent to leave the Blocked state, and the unblocked task has a priority higher than the currently running task. If vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. How a context switch is requested from an ISR is dependent on the port - see the documentation page for the port in use. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428xTaskGenericNotifyStateClear12TaskHandle_t11UBaseType_t">
<span id="_CPPv328xTaskGenericNotifyStateClear12TaskHandle_t11UBaseType_t"></span><span id="_CPPv228xTaskGenericNotifyStateClear12TaskHandle_t11UBaseType_t"></span><span id="xTaskGenericNotifyStateClear__TaskHandle_t.UBaseType_t"></span><span class="target" id="task_8h_1a8450a95f9f588543b042aacebf86702a"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGenericNotifyStateClear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxIndexToClear</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428xTaskGenericNotifyStateClear12TaskHandle_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>Each task has a private array of &quot;notification values&quot; (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>If a notification is sent to an index within the array of notifications then the notification at that index is said to be 'pending' until it is read or explicitly cleared by the receiving task. xTaskNotifyStateClearIndexed() is the function that clears a pending notification without reading the notification value. The notification value at the same array index is not altered. Set xTask to NULL to clear the notification state of the calling task.</p>
<p>Backward compatibility information: Prior to FreeRTOS V10.4.0 each task had a single &quot;notification value&quot;, and all task notification API functions operated on that value. Replacing the single notification value with an array of notification values necessitated a new set of API functions that could address specific notifications within the array. xTaskNotifyStateClear() is the original API function, and remains backward compatible by always operating on the notification value at index 0 within the array. Calling xTaskNotifyStateClear() is equivalent to calling xTaskNotifyStateClearIndexed() with the uxIndexToNotify parameter set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTask</strong> -- The handle of the RTOS task that will have a notification state cleared. Set xTask to NULL to clear a notification state in the calling task. To obtain a task's handle create the task using xTaskCreate() and make use of the pxCreatedTask parameter, or create the task using xTaskCreateStatic() and store the returned value, or use the task's name in a call to xTaskGetHandle().</p></li>
<li><p><strong>uxIndexToClear</strong> -- The index within the target task's array of notification values to act upon. For example, setting uxIndexToClear to 1 will clear the state of the notification at index 1 within the array. uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES. ulTaskNotifyStateClear() does not have this parameter and always acts on the notification at index 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the task's notification state was set to eNotWaitingNotification, otherwise pdFALSE. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429ulTaskGenericNotifyValueClear12TaskHandle_t11UBaseType_t8uint32_t">
<span id="_CPPv329ulTaskGenericNotifyValueClear12TaskHandle_t11UBaseType_t8uint32_t"></span><span id="_CPPv229ulTaskGenericNotifyValueClear12TaskHandle_t11UBaseType_t8uint32_t"></span><span id="ulTaskGenericNotifyValueClear__TaskHandle_t.UBaseType_t.uint32_t"></span><span class="target" id="task_8h_1ad150c601154fe55984401b852fbe6cca"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ulTaskGenericNotifyValueClear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxIndexToClear</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ulBitsToClear</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429ulTaskGenericNotifyValueClear12TaskHandle_t11UBaseType_t8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>Each task has a private array of &quot;notification values&quot; (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>ulTaskNotifyValueClearIndexed() clears the bits specified by the ulBitsToClear bit mask in the notification value at array index uxIndexToClear of the task referenced by xTask.</p>
<p>Backward compatibility information: Prior to FreeRTOS V10.4.0 each task had a single &quot;notification value&quot;, and all task notification API functions operated on that value. Replacing the single notification value with an array of notification values necessitated a new set of API functions that could address specific notifications within the array. ulTaskNotifyValueClear() is the original API function, and remains backward compatible by always operating on the notification value at index 0 within the array. Calling ulTaskNotifyValueClear() is equivalent to calling ulTaskNotifyValueClearIndexed() with the uxIndexToClear parameter set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTask</strong> -- The handle of the RTOS task that will have bits in one of its notification values cleared. Set xTask to NULL to clear bits in a notification value of the calling task. To obtain a task's handle create the task using xTaskCreate() and make use of the pxCreatedTask parameter, or create the task using xTaskCreateStatic() and store the returned value, or use the task's name in a call to xTaskGetHandle().</p></li>
<li><p><strong>uxIndexToClear</strong> -- The index within the target task's array of notification values in which to clear the bits. uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES. ulTaskNotifyValueClear() does not have this parameter and always clears bits in the notification value at index 0.</p></li>
<li><p><strong>ulBitsToClear</strong> -- Bit mask of the bits to clear in the notification value of xTask. Set a bit to 1 to clear the corresponding bits in the task's notification value. Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear the notification value to 0. Set ulBitsToClear to 0 to query the task's notification value without clearing any bits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the target task's notification value before the bits specified by ulBitsToClear were cleared. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420vTaskSetTimeOutStatePC9TimeOut_t">
<span id="_CPPv320vTaskSetTimeOutStatePC9TimeOut_t"></span><span id="_CPPv220vTaskSetTimeOutStatePC9TimeOut_t"></span><span id="vTaskSetTimeOutState__TimeOut_tPC"></span><span class="target" id="task_8h_1a5dfb2b9e41fb002318d9c55452a91c83"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskSetTimeOutState</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TimeOut_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTimeOut</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420vTaskSetTimeOutStatePC9TimeOut_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Capture the current time for future use with xTaskCheckForTimeOut().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pxTimeOut</strong> -- Pointer to a timeout object into which the current time is to be captured. The captured time includes the tick count and the number of times the tick count has overflowed since the system first booted. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420xTaskCheckForTimeOutPC9TimeOut_tPC10TickType_t">
<span id="_CPPv320xTaskCheckForTimeOutPC9TimeOut_tPC10TickType_t"></span><span id="_CPPv220xTaskCheckForTimeOutPC9TimeOut_tPC10TickType_t"></span><span id="xTaskCheckForTimeOut__TimeOut_tPC.TickType_tPC"></span><span class="target" id="task_8h_1acfc8de487c86355713d0e8546506d9e4"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskCheckForTimeOut</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TimeOut_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTimeOut</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xTaskCheckForTimeOutPC9TimeOut_tPC10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Determines if pxTicksToWait ticks has passed since a time was captured using a call to vTaskSetTimeOutState(). The captured time includes the tick count and the number of times the tick count has overflowed.</p>
<p>
Example Usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Driver library function used to receive uxWantedBytes from an Rx buffer</span>
<span class="c1">// that is filled by a UART interrupt. If there are not enough bytes in the</span>
<span class="c1">// Rx buffer then the task enters the Blocked state until it is notified that</span>
<span class="c1">// more data has been placed into the buffer. If there is still not enough</span>
<span class="c1">// data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()</span>
<span class="c1">// is used to re-calculate the Block time to ensure the total amount of time</span>
<span class="c1">// spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This</span>
<span class="c1">// continues until either the buffer contains at least uxWantedBytes bytes,</span>
<span class="c1">// or the total amount of time spent in the Blocked state reaches</span>
<span class="c1">// MAX_TIME_TO_WAIT - at which point the task reads however many bytes are</span>
<span class="c1">// available up to a maximum of uxWantedBytes.</span>

<span class="kt">size_t</span><span class="w"> </span><span class="nf">xUART_Receive</span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">pucBuffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">uxWantedBytes</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">uxReceived</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_TIME_TO_WAIT</span><span class="p">;</span>
<span class="n">TimeOut_t</span><span class="w"> </span><span class="n">xTimeOut</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Initialize xTimeOut.  This records the time at which this function</span>
<span class="w">    </span><span class="c1">// was entered.</span>
<span class="w">    </span><span class="n">vTaskSetTimeOutState</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Loop until the buffer contains the wanted number of bytes, or a</span>
<span class="w">    </span><span class="c1">// timeout occurs.</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">UART_bytes_in_rx_buffer</span><span class="p">(</span><span class="w"> </span><span class="n">pxUARTInstance</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">uxWantedBytes</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The buffer didn&#39;t contain enough data so this task is going to</span>
<span class="w">        </span><span class="c1">// enter the Blocked state. Adjusting xTicksToWait to account for</span>
<span class="w">        </span><span class="c1">// any time that has been spent in the Blocked state within this</span>
<span class="w">        </span><span class="c1">// function so far to ensure the total amount of time spent in the</span>
<span class="w">        </span><span class="c1">// Blocked state does not exceed MAX_TIME_TO_WAIT.</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskCheckForTimeOut</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTimeOut</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">//Timed out before the wanted number of bytes were available,</span>
<span class="w">            </span><span class="c1">// exit the loop.</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Wait for a maximum of xTicksToWait ticks to be notified that the</span>
<span class="w">        </span><span class="c1">// receive interrupt has placed more data into the buffer.</span>
<span class="w">        </span><span class="n">ulTaskNotifyTake</span><span class="p">(</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">,</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Attempt to read uxWantedBytes from the receive buffer into pucBuffer.</span>
<span class="w">    </span><span class="c1">// The actual number of bytes read (which might be less than</span>
<span class="w">    </span><span class="c1">// uxWantedBytes) is returned.</span>
<span class="w">    </span><span class="n">uxReceived</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UART_read_from_receive_buffer</span><span class="p">(</span><span class="w"> </span><span class="n">pxUARTInstance</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">pucBuffer</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">uxWantedBytes</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">uxReceived</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
 <div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://www.FreeRTOS.org/xTaskCheckForTimeOut.html">https://www.FreeRTOS.org/xTaskCheckForTimeOut.html</a></p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxTimeOut</strong> -- The time status as captured previously using vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated to reflect the current time status. </p></li>
<li><p><strong>pxTicksToWait</strong> -- The number of ticks to check for timeout i.e. if pxTicksToWait ticks have passed since pxTimeOut was last updated (either by vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred. If the timeout has not occurred, pxTicksToWait is updated to reflect the number of remaining ticks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is returned and pxTicksToWait is updated to reflect the number of remaining ticks.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417xTaskCatchUpTicks10TickType_t">
<span id="_CPPv317xTaskCatchUpTicks10TickType_t"></span><span id="_CPPv217xTaskCatchUpTicks10TickType_t"></span><span id="xTaskCatchUpTicks__TickType_t"></span><span class="target" id="task_8h_1aea7126047f4a766a28f579a0027f00c3"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskCatchUpTicks</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToCatchUp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xTaskCatchUpTicks10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>This function corrects the tick count value after the application code has held interrupts disabled for an extended period resulting in tick interrupts having been missed.</p>
<p>This function is similar to vTaskStepTick(), however, unlike vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a time at which a task should be removed from the blocked state. That means tasks may have to be removed from the blocked state as the tick count is moved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTicksToCatchUp</strong> -- The number of tick interrupts that have been missed due to interrupts being disabled. Its value is not computed automatically, so must be computed by the application writer.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if moving the tick count forward resulted in a task leaving the blocked state and a context switch being performed. Otherwise pdFALSE. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv412xTASK_STATUS">
<span id="_CPPv312xTASK_STATUS"></span><span id="_CPPv212xTASK_STATUS"></span><span id="xTASK_STATUS"></span><span class="target" id="structxTASK__STATUS"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTASK_STATUS</span></span></span><a class="headerlink" href="#_CPPv412xTASK_STATUS" title="Permalink to this definition"></a><br /></dt>
<dd><p>Used with the uxTaskGetSystemState() function to return the state of each task in the system. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS7xHandleE">
<span id="_CPPv3N12xTASK_STATUS7xHandleE"></span><span id="_CPPv2N12xTASK_STATUS7xHandleE"></span><span id="xTASK_STATUS::xHandle__TaskHandle_t"></span><span class="target" id="structxTASK__STATUS_1ac57f825f365c3c64bba827285fe3c2a0"></span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xHandle</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS7xHandleE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The handle of the task to which the rest of the information in the structure relates. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS10pcTaskNameE">
<span id="_CPPv3N12xTASK_STATUS10pcTaskNameE"></span><span id="_CPPv2N12xTASK_STATUS10pcTaskNameE"></span><span id="xTASK_STATUS::pcTaskName__cCP"></span><span class="target" id="structxTASK__STATUS_1ad272663e2560bd9ea088384a39ba6192"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcTaskName</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS10pcTaskNameE" title="Permalink to this definition"></a><br /></dt>
<dd><p>A pointer to the task's name. This value will be invalid if the task was deleted since the structure was populated! </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS11xTaskNumberE">
<span id="_CPPv3N12xTASK_STATUS11xTaskNumberE"></span><span id="_CPPv2N12xTASK_STATUS11xTaskNumberE"></span><span id="xTASK_STATUS::xTaskNumber__UBaseType_t"></span><span class="target" id="structxTASK__STATUS_1acd44468ba37270b04f83d0833c098057"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNumber</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS11xTaskNumberE" title="Permalink to this definition"></a><br /></dt>
<dd><p>A number unique to the task. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS13eCurrentStateE">
<span id="_CPPv3N12xTASK_STATUS13eCurrentStateE"></span><span id="_CPPv2N12xTASK_STATUS13eCurrentStateE"></span><span id="xTASK_STATUS::eCurrentState__eTaskState"></span><span class="target" id="structxTASK__STATUS_1a727e904e3afe49472b0fc6a4e96439cb"></span><a class="reference internal" href="#_CPPv410eTaskState" title="eTaskState"><span class="n"><span class="pre">eTaskState</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eCurrentState</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS13eCurrentStateE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The state in which the task existed when the structure was populated. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS17uxCurrentPriorityE">
<span id="_CPPv3N12xTASK_STATUS17uxCurrentPriorityE"></span><span id="_CPPv2N12xTASK_STATUS17uxCurrentPriorityE"></span><span id="xTASK_STATUS::uxCurrentPriority__UBaseType_t"></span><span class="target" id="structxTASK__STATUS_1a39df647234fc0d6de5852042a2741a94"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxCurrentPriority</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS17uxCurrentPriorityE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The priority at which the task was running (may be inherited) when the structure was populated. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS14uxBasePriorityE">
<span id="_CPPv3N12xTASK_STATUS14uxBasePriorityE"></span><span id="_CPPv2N12xTASK_STATUS14uxBasePriorityE"></span><span id="xTASK_STATUS::uxBasePriority__UBaseType_t"></span><span class="target" id="structxTASK__STATUS_1a692f4c8957b7270f1579cdee63ff287e"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxBasePriority</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS14uxBasePriorityE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex. Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS16ulRunTimeCounterE">
<span id="_CPPv3N12xTASK_STATUS16ulRunTimeCounterE"></span><span id="_CPPv2N12xTASK_STATUS16ulRunTimeCounterE"></span><span id="xTASK_STATUS::ulRunTimeCounter__configRUN_TIME_COUNTER_TYPE"></span><span class="target" id="structxTASK__STATUS_1a94915091d92efd017afb3dbdb5595da9"></span><span class="n"><span class="pre">configRUN_TIME_COUNTER_TYPE</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ulRunTimeCounter</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS16ulRunTimeCounterE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The total run time allocated to the task so far, as defined by the run time stats clock. See <a class="reference external" href="https://www.FreeRTOS.org/rtos-run-time-stats.html">https://www.FreeRTOS.org/rtos-run-time-stats.html</a>. Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS11pxStackBaseE">
<span id="_CPPv3N12xTASK_STATUS11pxStackBaseE"></span><span id="_CPPv2N12xTASK_STATUS11pxStackBaseE"></span><span id="xTASK_STATUS::pxStackBase__StackType_tP"></span><span class="target" id="structxTASK__STATUS_1a0ee59674d2cc57d3a5a29c777d5452ed"></span><span class="n"><span class="pre">StackType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pxStackBase</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS11pxStackBaseE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Points to the lowest address of the task's stack area. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS20usStackHighWaterMarkE">
<span id="_CPPv3N12xTASK_STATUS20usStackHighWaterMarkE"></span><span id="_CPPv2N12xTASK_STATUS20usStackHighWaterMarkE"></span><span id="xTASK_STATUS::usStackHighWaterMark__configSTACK_DEPTH_TYPE"></span><span class="target" id="structxTASK__STATUS_1aaad57afd4a629d2404e1cff97891c571"></span><span class="n"><span class="pre">configSTACK_DEPTH_TYPE</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">usStackHighWaterMark</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS20usStackHighWaterMarkE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The minimum amount of stack space that has remained for the task since the task was created. The closer this value is to zero the closer the task has come to overflowing its stack. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N12xTASK_STATUS7xCoreIDE">
<span id="_CPPv3N12xTASK_STATUS7xCoreIDE"></span><span id="_CPPv2N12xTASK_STATUS7xCoreIDE"></span><span id="xTASK_STATUS::xCoreID__BaseType_t"></span><span class="target" id="structxTASK__STATUS_1a43dafa875f1490a8adfa4d588ead2f31"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xCoreID</span></span></span><a class="headerlink" href="#_CPPv4N12xTASK_STATUS7xCoreIDE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Core this task is pinned to (0, 1, or tskNO_AFFINITY). If configNUMBER_OF_CORES == 1, this will always be 0. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.tskIDLE_PRIORITY">
<span class="target" id="task_8h_1a94ed0b9b3b4e8ccc859c322f18583e67"></span><span class="sig-name descname"><span class="n"><span class="pre">tskIDLE_PRIORITY</span></span></span><a class="headerlink" href="#c.tskIDLE_PRIORITY" title="Permalink to this definition"></a><br /></dt>
<dd><p>Defines the priority used by the idle task. This must not be modified. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.tskNO_AFFINITY">
<span class="target" id="task_8h_1aaef304a55bdc7162666e9bedcf9182a3"></span><span class="sig-name descname"><span class="n"><span class="pre">tskNO_AFFINITY</span></span></span><a class="headerlink" href="#c.tskNO_AFFINITY" title="Permalink to this definition"></a><br /></dt>
<dd><p>Macro representing and unpinned (i.e., &quot;no affinity&quot;) task in xCoreID parameters </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskVALID_CORE_ID">
<span class="target" id="task_8h_1aed3c0afc5d5ae4afed5e027f26bbdeed"></span><span class="sig-name descname"><span class="n"><span class="pre">taskVALID_CORE_ID</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xCoreID</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskVALID_CORE_ID" title="Permalink to this definition"></a><br /></dt>
<dd><p>Macro to check if an xCoreID value is valid</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>pdTRUE if valid, pdFALSE otherwise. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskYIELD">
<span class="target" id="task_8h_1a767e474430db1e60056e9678763f9202"></span><span class="sig-name descname"><span class="n"><span class="pre">taskYIELD</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskYIELD" title="Permalink to this definition"></a><br /></dt>
<dd><p>Macro for forcing a context switch. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskENTER_CRITICAL">
<span class="target" id="task_8h_1a6354b56a0ba6a770b48ce4955ee920d7"></span><span class="sig-name descname"><span class="n"><span class="pre">taskENTER_CRITICAL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskENTER_CRITICAL" title="Permalink to this definition"></a><br /></dt>
<dd><p>Macro to mark the start of a critical code region. Preemptive context switches cannot occur when in a critical region.</p>
<p>NOTE: This may alter the stack (depending on the portable implementation) so must be used with care! </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskENTER_CRITICAL_FROM_ISR">
<span class="target" id="task_8h_1acb27098fc27d117f720d96bfdcd2b4c8"></span><span class="sig-name descname"><span class="n"><span class="pre">taskENTER_CRITICAL_FROM_ISR</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskENTER_CRITICAL_FROM_ISR" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskENTER_CRITICAL_ISR">
<span class="target" id="task_8h_1a36e18e319150006b1713bd5a6e793138"></span><span class="sig-name descname"><span class="n"><span class="pre">taskENTER_CRITICAL_ISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskENTER_CRITICAL_ISR" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskEXIT_CRITICAL">
<span class="target" id="task_8h_1ae306fd6bee69a3d6c8e086f5c754513c"></span><span class="sig-name descname"><span class="n"><span class="pre">taskEXIT_CRITICAL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskEXIT_CRITICAL" title="Permalink to this definition"></a><br /></dt>
<dd><p>Macro to mark the end of a critical code region. Preemptive context switches cannot occur when in a critical region.</p>
<p>NOTE: This may alter the stack (depending on the portable implementation) so must be used with care! </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskEXIT_CRITICAL_FROM_ISR">
<span class="target" id="task_8h_1afa2f5acc3c925b6542ecca1acf67a234"></span><span class="sig-name descname"><span class="n"><span class="pre">taskEXIT_CRITICAL_FROM_ISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskEXIT_CRITICAL_FROM_ISR" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskEXIT_CRITICAL_ISR">
<span class="target" id="task_8h_1af96dae3845cf2a7116680fadbbfe01e7"></span><span class="sig-name descname"><span class="n"><span class="pre">taskEXIT_CRITICAL_ISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskEXIT_CRITICAL_ISR" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskDISABLE_INTERRUPTS">
<span class="target" id="task_8h_1aa455a648c2224964ee57758b8794198e"></span><span class="sig-name descname"><span class="n"><span class="pre">taskDISABLE_INTERRUPTS</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskDISABLE_INTERRUPTS" title="Permalink to this definition"></a><br /></dt>
<dd><p>Macro to disable all maskable interrupts. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskENABLE_INTERRUPTS">
<span class="target" id="task_8h_1a04361ba499e91eb35324e4cba6feea17"></span><span class="sig-name descname"><span class="n"><span class="pre">taskENABLE_INTERRUPTS</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskENABLE_INTERRUPTS" title="Permalink to this definition"></a><br /></dt>
<dd><p>Macro to enable microcontroller interrupts. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskSCHEDULER_SUSPENDED">
<span class="target" id="task_8h_1a0cad071ca127a35df93166e9ed5b6ada"></span><span class="sig-name descname"><span class="n"><span class="pre">taskSCHEDULER_SUSPENDED</span></span></span><a class="headerlink" href="#c.taskSCHEDULER_SUSPENDED" title="Permalink to this definition"></a><br /></dt>
<dd><p>Definitions returned by xTaskGetSchedulerState(). taskSCHEDULER_SUSPENDED is 0 to generate more optimal code when configASSERT() is defined as the constant is used in assert() statements. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskSCHEDULER_NOT_STARTED">
<span class="target" id="task_8h_1a0923fdaae1bfe42ac5cccd9e9ddca9ed"></span><span class="sig-name descname"><span class="n"><span class="pre">taskSCHEDULER_NOT_STARTED</span></span></span><a class="headerlink" href="#c.taskSCHEDULER_NOT_STARTED" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.taskSCHEDULER_RUNNING">
<span class="target" id="task_8h_1acbb675035741787d29da475b5a887545"></span><span class="sig-name descname"><span class="n"><span class="pre">taskSCHEDULER_RUNNING</span></span></span><a class="headerlink" href="#c.taskSCHEDULER_RUNNING" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTaskNotifyIndexed">
<span class="target" id="task_8h_1a0261e3cca34893bdfccbca1be2de93d5"></span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNotifyIndexed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTaskToNotify</span></span>, <span class="n"><span class="pre">uxIndexToNotify</span></span>, <span class="n"><span class="pre">ulValue</span></span>, <span class="n"><span class="pre">eAction</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyIndexed" title="Permalink to this definition"></a><br /></dt>
<dd><p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>Sends a direct to task notification to a task, with an optional value and action.</p>
<p>Each task has a private array of &quot;notification values&quot; (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment one of the task's notification values. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>A task can use xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() to [optionally] block to wait for a notification to be pending. The task does not consume any CPU time while it is in the Blocked state.</p>
<p>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their un-indexed equivalents). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p>
<p><strong>NOTE</strong> Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</p>
<p>Backward compatibility information: Prior to FreeRTOS V10.4.0 each task had a single &quot;notification value&quot;, and all task notification API functions operated on that value. Replacing the single notification value with an array of notification values necessitated a new set of API functions that could address specific notifications within the array. xTaskNotify() is the original API function, and remains backward compatible by always operating on the notification value at index 0 in the array. Calling xTaskNotify() is equivalent to calling xTaskNotifyIndexed() with the uxIndexToNotify parameter set to 0.</p>
<p>
eSetBits - The target notification value is bitwise ORed with ulValue. xTaskNotifyIndexed() always returns pdPASS in this case.</p>
<p>eIncrement - The target notification value is incremented. ulValue is not used and xTaskNotifyIndexed() always returns pdPASS in this case.</p>
<p>eSetValueWithOverwrite - The target notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification at the same array index (the task already had a notification pending at that index). xTaskNotifyIndexed() always returns pdPASS in this case.</p>
<p>eSetValueWithoutOverwrite - If the task being notified did not already have a notification pending at the same array index then the target notification value is set to ulValue and xTaskNotifyIndexed() will return pdPASS. If the task being notified already had a notification pending at the same array index then no action is performed and pdFAIL is returned.</p>
<p>eNoAction - The task receives a notification at the specified array index without the notification value at that index being updated. ulValue is not used and xTaskNotifyIndexed() always returns pdPASS in this case.</p>
<p>pulPreviousNotificationValue - Can be used to pass out the subject task's notification value before any bits are modified by the notify function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTaskToNotify</strong> -- The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</p></li>
<li><p><strong>uxIndexToNotify</strong> -- The index within the target task's array of notification values to which the notification is to be sent. uxIndexToNotify must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES. xTaskNotify() does not have this parameter and always sends notifications to index 0.</p></li>
<li><p><strong>ulValue</strong> -- Data that can be sent with the notification. How the data is used depends on the value of the eAction parameter.</p></li>
<li><p><strong>eAction</strong> -- Specifies how the notification updates the task's notification value, if at all. Valid values for eAction are as follows:</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dependent on the value of eAction. See the description of the eAction parameter. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTaskNotifyAndQueryIndexed">
<span class="target" id="task_8h_1abe38b2577f0de26942659a3a742fb7a4"></span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNotifyAndQueryIndexed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTaskToNotify</span></span>, <span class="n"><span class="pre">uxIndexToNotify</span></span>, <span class="n"><span class="pre">ulValue</span></span>, <span class="n"><span class="pre">eAction</span></span>, <span class="n"><span class="pre">pulPreviousNotifyValue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyAndQueryIndexed" title="Permalink to this definition"></a><br /></dt>
<dd><p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p>xTaskNotifyAndQueryIndexed() performs the same operation as xTaskNotifyIndexed() with the addition that it also returns the subject task's prior notification value (the notification value at the time the function is called rather than when the function returns) in the additional pulPreviousNotifyValue parameter.</p>
<p>xTaskNotifyAndQuery() performs the same operation as xTaskNotify() with the addition that it also returns the subject task's prior notification value (the notification value as it was at the time the function is called, rather than when the function returns) in the additional pulPreviousNotifyValue parameter. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTaskNotifyIndexedFromISR">
<span class="target" id="task_8h_1ab86169cb5493142a9e247e2cf2e583e2"></span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNotifyIndexedFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTaskToNotify</span></span>, <span class="n"><span class="pre">uxIndexToNotify</span></span>, <span class="n"><span class="pre">ulValue</span></span>, <span class="n"><span class="pre">eAction</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyIndexedFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>A version of xTaskNotifyIndexed() that can be used from an interrupt service routine (ISR).</p>
<p>Each task has a private array of &quot;notification values&quot; (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment one of the task's notification values. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block to wait for a notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.</p>
<p>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their un-indexed equivalents). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p>
<p><strong>NOTE</strong> Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</p>
<p>Backward compatibility information: Prior to FreeRTOS V10.4.0 each task had a single &quot;notification value&quot;, and all task notification API functions operated on that value. Replacing the single notification value with an array of notification values necessitated a new set of API functions that could address specific notifications within the array. xTaskNotifyFromISR() is the original API function, and remains backward compatible by always operating on the notification value at index 0 within the array. Calling xTaskNotifyFromISR() is equivalent to calling xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0.</p>
<p>
eSetBits - The task's notification value is bitwise ORed with ulValue. xTaskNotify() always returns pdPASS in this case.</p>
<p>eIncrement - The task's notification value is incremented. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</p>
<p>eSetValueWithOverwrite - The task's notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification (the task already had a notification pending). xTaskNotify() always returns pdPASS in this case.</p>
<p>eSetValueWithoutOverwrite - If the task being notified did not already have a notification pending then the task's notification value is set to ulValue and xTaskNotify() will return pdPASS. If the task being notified already had a notification pending then no action is performed and pdFAIL is returned.</p>
<p>eNoAction - The task receives a notification without its notification value being updated. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uxIndexToNotify</strong> -- The index within the target task's array of notification values to which the notification is to be sent. uxIndexToNotify must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES. xTaskNotifyFromISR() does not have this parameter and always sends notifications to index 0.</p></li>
<li><p><strong>xTaskToNotify</strong> -- The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</p></li>
<li><p><strong>ulValue</strong> -- Data that can be sent with the notification. How the data is used depends on the value of the eAction parameter.</p></li>
<li><p><strong>eAction</strong> -- Specifies how the notification updates the task's notification value, if at all. Valid values for eAction are as follows:</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- xTaskNotifyFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the task to which the notification was sent to leave the Blocked state, and the unblocked task has a priority higher than the currently running task. If xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. How a context switch is requested from an ISR is dependent on the port - see the documentation page for the port in use.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dependent on the value of eAction. See the description of the eAction parameter. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTaskNotifyAndQueryIndexedFromISR">
<span class="target" id="task_8h_1a310ee091fef5bf31f23e06bc2a71cfab"></span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNotifyAndQueryIndexedFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTaskToNotify</span></span>, <span class="n"><span class="pre">uxIndexToNotify</span></span>, <span class="n"><span class="pre">ulValue</span></span>, <span class="n"><span class="pre">eAction</span></span>, <span class="n"><span class="pre">pulPreviousNotificationValue</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyAndQueryIndexedFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p>xTaskNotifyAndQueryIndexedFromISR() performs the same operation as xTaskNotifyIndexedFromISR() with the addition that it also returns the subject task's prior notification value (the notification value at the time the function is called rather than at the time the function returns) in the additional pulPreviousNotifyValue parameter.</p>
<p>xTaskNotifyAndQueryFromISR() performs the same operation as xTaskNotifyFromISR() with the addition that it also returns the subject task's prior notification value (the notification value at the time the function is called rather than at the time the function returns) in the additional pulPreviousNotifyValue parameter. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTaskNotifyWait">
<span class="target" id="task_8h_1a212928744c3d5e0ccc56f1324a3c26f3"></span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNotifyWait</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulBitsToClearOnEntry</span></span>, <span class="n"><span class="pre">ulBitsToClearOnExit</span></span>, <span class="n"><span class="pre">pulNotificationValue</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyWait" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTaskNotifyWaitIndexed">
<span class="target" id="task_8h_1a5bcd5a5b7d7c41dd782a38093be1b7c9"></span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNotifyWaitIndexed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uxIndexToWaitOn</span></span>, <span class="n"><span class="pre">ulBitsToClearOnEntry</span></span>, <span class="n"><span class="pre">ulBitsToClearOnExit</span></span>, <span class="n"><span class="pre">pulNotificationValue</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyWaitIndexed" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTaskNotifyGiveIndexed">
<span class="target" id="task_8h_1a53ec0c8b6b8281a3055747813570193c"></span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNotifyGiveIndexed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTaskToNotify</span></span>, <span class="n"><span class="pre">uxIndexToNotify</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyGiveIndexed" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sends a direct to task notification to a particular index in the target task's notification array in a manner similar to giving a counting semaphore.</p>
<p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for more details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these macros to be available.</p>
<p>Each task has a private array of &quot;notification values&quot; (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment one of the task's notification values. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>xTaskNotifyGiveIndexed() is a helper macro intended for use when task notifications are used as light weight and faster binary or counting semaphore equivalents. Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function, the equivalent action that instead uses a task notification is xTaskNotifyGiveIndexed().</p>
<p>When task notifications are being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the ulTaskNotifyTakeIndexed() API function rather than the xTaskNotifyWaitIndexed() API function.</p>
<p><strong>NOTE</strong> Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</p>
<p>Backward compatibility information: Prior to FreeRTOS V10.4.0 each task had a single &quot;notification value&quot;, and all task notification API functions operated on that value. Replacing the single notification value with an array of notification values necessitated a new set of API functions that could address specific notifications within the array. xTaskNotifyGive() is the original API function, and remains backward compatible by always operating on the notification value at index 0 in the array. Calling xTaskNotifyGive() is equivalent to calling xTaskNotifyGiveIndexed() with the uxIndexToNotify parameter set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTaskToNotify</strong> -- The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</p></li>
<li><p><strong>uxIndexToNotify</strong> -- The index within the target task's array of notification values to which the notification is to be sent. uxIndexToNotify must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES. xTaskNotifyGive() does not have this parameter and always sends notifications to index 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>xTaskNotifyGive() is a macro that calls xTaskNotify() with the eAction parameter set to eIncrement - so pdPASS is always returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.vTaskNotifyGiveFromISR">
<span class="target" id="task_8h_1a1add9ef24d3763e34603b18802fae9d7"></span><span class="sig-name descname"><span class="n"><span class="pre">vTaskNotifyGiveFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTaskToNotify</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vTaskNotifyGiveFromISR" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.vTaskNotifyGiveIndexedFromISR">
<span class="target" id="task_8h_1a756fe3c4656aaaa8ef6d309e0078e132"></span><span class="sig-name descname"><span class="n"><span class="pre">vTaskNotifyGiveIndexedFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTaskToNotify</span></span>, <span class="n"><span class="pre">uxIndexToNotify</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vTaskNotifyGiveIndexedFromISR" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ulTaskNotifyTakeIndexed">
<span class="target" id="task_8h_1a4f42982425f3b106e1a9f19b41ba4124"></span><span class="sig-name descname"><span class="n"><span class="pre">ulTaskNotifyTakeIndexed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uxIndexToWaitOn</span></span>, <span class="n"><span class="pre">xClearCountOnExit</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ulTaskNotifyTakeIndexed" title="Permalink to this definition"></a><br /></dt>
<dd><p>Waits for a direct to task notification on a particular index in the calling task's notification array in a manner similar to taking a counting semaphore.</p>
<p>See <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p>
<p>Each task has a private array of &quot;notification values&quot; (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment one of the task's notification values. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>ulTaskNotifyTakeIndexed() is intended for use when a task notification is used as a faster and lighter weight binary or counting semaphore alternative. Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the equivalent action that instead uses a task notification is ulTaskNotifyTakeIndexed().</p>
<p>When a task is using its notification value as a binary or counting semaphore other tasks should send notifications to it using the xTaskNotifyGiveIndexed() macro, or xTaskNotifyIndex() function with the eAction parameter set to eIncrement.</p>
<p>ulTaskNotifyTakeIndexed() can either clear the task's notification value at the array index specified by the uxIndexToWaitOn parameter to zero on exit, in which case the notification value acts like a binary semaphore, or decrement the notification value on exit, in which case the notification value acts like a counting semaphore.</p>
<p>A task can use ulTaskNotifyTakeIndexed() to [optionally] block to wait for a notification. The task does not consume any CPU time while it is in the Blocked state.</p>
<p>Where as xTaskNotifyWaitIndexed() will return when a notification is pending, ulTaskNotifyTakeIndexed() will return when the task's notification value is not zero.</p>
<p><strong>NOTE</strong> Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</p>
<p>Backward compatibility information: Prior to FreeRTOS V10.4.0 each task had a single &quot;notification value&quot;, and all task notification API functions operated on that value. Replacing the single notification value with an array of notification values necessitated a new set of API functions that could address specific notifications within the array. ulTaskNotifyTake() is the original API function, and remains backward compatible by always operating on the notification value at index 0 in the array. Calling ulTaskNotifyTake() is equivalent to calling ulTaskNotifyTakeIndexed() with the uxIndexToWaitOn parameter set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uxIndexToWaitOn</strong> -- The index within the calling task's array of notification values on which the calling task will wait for a notification to be non-zero. uxIndexToWaitOn must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES. xTaskNotifyTake() does not have this parameter and always waits for notifications on index 0.</p></li>
<li><p><strong>xClearCountOnExit</strong> -- if xClearCountOnExit is pdFALSE then the task's notification value is decremented when the function exits. In this way the notification value acts like a counting semaphore. If xClearCountOnExit is not pdFALSE then the task's notification value is cleared to zero when the function exits. In this way the notification value acts like a binary semaphore.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time that the task should wait in the Blocked state for the task's notification value to be greater than zero, should the count not already be greater than zero when ulTaskNotifyTake() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The task's notification count before it is either cleared to zero or decremented (see the xClearCountOnExit parameter). </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTaskNotifyStateClear">
<span class="target" id="task_8h_1ad4a465a489d7c2b22130ec2cc68b3284"></span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNotifyStateClear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyStateClear" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTaskNotifyStateClearIndexed">
<span class="target" id="task_8h_1ad7fc12476fa032389e0b3dd52ecb709f"></span><span class="sig-name descname"><span class="n"><span class="pre">xTaskNotifyStateClearIndexed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTask</span></span>, <span class="n"><span class="pre">uxIndexToClear</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyStateClearIndexed" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ulTaskNotifyValueClear">
<span class="target" id="task_8h_1a3b7cf88f6c77b78a01fcf4b0d624d573"></span><span class="sig-name descname"><span class="n"><span class="pre">ulTaskNotifyValueClear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTask</span></span>, <span class="n"><span class="pre">ulBitsToClear</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ulTaskNotifyValueClear" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ulTaskNotifyValueClearIndexed">
<span class="target" id="task_8h_1a2ddeedf4178bc20d8eb2addd461cdc49"></span><span class="sig-name descname"><span class="n"><span class="pre">ulTaskNotifyValueClearIndexed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTask</span></span>, <span class="n"><span class="pre">uxIndexToClear</span></span>, <span class="n"><span class="pre">ulBitsToClear</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ulTaskNotifyValueClearIndexed" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
<section id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv412TaskHandle_t">
<span id="_CPPv312TaskHandle_t"></span><span id="_CPPv212TaskHandle_t"></span><span id="TaskHandle_t"></span><span class="target" id="task_8h_1a25b35e6e19ecf894173e7ff95edb96ef"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">tskTaskControlBlock</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">TaskHandle_t</span></span></span><a class="headerlink" href="#_CPPv412TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv418TaskHookFunction_t">
<span id="_CPPv318TaskHookFunction_t"></span><span id="_CPPv218TaskHookFunction_t"></span><span id="TaskHookFunction_t"></span><span class="target" id="task_8h_1af984026250bf8fece2e0068874d4661d"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">TaskHookFunction_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv418TaskHookFunction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Defines the prototype to which the application task hook function must conform. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv412TaskStatus_t">
<span id="_CPPv312TaskStatus_t"></span><span id="_CPPv212TaskStatus_t"></span><span id="TaskStatus_t"></span><span class="target" id="task_8h_1ae5c0c4b9b2c8af5836583b2984ef5b6e"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412xTASK_STATUS" title="xTASK_STATUS"><span class="n"><span class="pre">xTASK_STATUS</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TaskStatus_t</span></span></span><a class="headerlink" href="#_CPPv412TaskStatus_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Used with the uxTaskGetSystemState() function to return the state of each task in the system. </p>
</dd></dl>

</section>
<section id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv410eTaskState">
<span id="_CPPv310eTaskState"></span><span id="_CPPv210eTaskState"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892c"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eTaskState</span></span></span><a class="headerlink" href="#_CPPv410eTaskState" title="Permalink to this definition"></a><br /></dt>
<dd><p>Task states returned by eTaskGetState. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10eTaskState8eRunningE">
<span id="_CPPv3N10eTaskState8eRunningE"></span><span id="_CPPv2N10eTaskState8eRunningE"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892ca83318c0d58e6b2bafaefa1be597fb8b6"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eRunning</span></span></span><a class="headerlink" href="#_CPPv4N10eTaskState8eRunningE" title="Permalink to this definition"></a><br /></dt>
<dd><p>A task is querying the state of itself, so must be running. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10eTaskState6eReadyE">
<span id="_CPPv3N10eTaskState6eReadyE"></span><span id="_CPPv2N10eTaskState6eReadyE"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892ca8570b65f331057b2cf92c504f0a2bc83"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eReady</span></span></span><a class="headerlink" href="#_CPPv4N10eTaskState6eReadyE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The task being queried is in a ready or pending ready list. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10eTaskState8eBlockedE">
<span id="_CPPv3N10eTaskState8eBlockedE"></span><span id="_CPPv2N10eTaskState8eBlockedE"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892cad23d72c68f43b6fff4962ad4154766af"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eBlocked</span></span></span><a class="headerlink" href="#_CPPv4N10eTaskState8eBlockedE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The task being queried is in the Blocked state. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10eTaskState10eSuspendedE">
<span id="_CPPv3N10eTaskState10eSuspendedE"></span><span id="_CPPv2N10eTaskState10eSuspendedE"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892caf35a900d49fdfc2502eefc68fdb70f72"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eSuspended</span></span></span><a class="headerlink" href="#_CPPv4N10eTaskState10eSuspendedE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10eTaskState8eDeletedE">
<span id="_CPPv3N10eTaskState8eDeletedE"></span><span id="_CPPv2N10eTaskState8eDeletedE"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892cacef5c6e771d3a07f656e07a13a20ba35"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eDeleted</span></span></span><a class="headerlink" href="#_CPPv4N10eTaskState8eDeletedE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The task being queried has been deleted, but its TCB has not yet been freed. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10eTaskState8eInvalidE">
<span id="_CPPv3N10eTaskState8eInvalidE"></span><span id="_CPPv2N10eTaskState8eInvalidE"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892cab32c771bb60dc8b502f65b81eef3bd86"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eInvalid</span></span></span><a class="headerlink" href="#_CPPv4N10eTaskState8eInvalidE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Used as an 'invalid state' value. </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv413eNotifyAction">
<span id="_CPPv313eNotifyAction"></span><span id="_CPPv213eNotifyAction"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eNotifyAction</span></span></span><a class="headerlink" href="#_CPPv413eNotifyAction" title="Permalink to this definition"></a><br /></dt>
<dd><p>Actions that can be performed when vTaskNotify() is called. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13eNotifyAction9eNoActionE">
<span id="_CPPv3N13eNotifyAction9eNoActionE"></span><span id="_CPPv2N13eNotifyAction9eNoActionE"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233abac2b17ab15444724b6f35d47cd0a64a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eNoAction</span></span></span><a class="headerlink" href="#_CPPv4N13eNotifyAction9eNoActionE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Notify the task without updating its notify value. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13eNotifyAction8eSetBitsE">
<span id="_CPPv3N13eNotifyAction8eSetBitsE"></span><span id="_CPPv2N13eNotifyAction8eSetBitsE"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233ab7b1af2eeee53ae78eeff37c1cb6f79b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eSetBits</span></span></span><a class="headerlink" href="#_CPPv4N13eNotifyAction8eSetBitsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set bits in the task's notification value. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13eNotifyAction10eIncrementE">
<span id="_CPPv3N13eNotifyAction10eIncrementE"></span><span id="_CPPv2N13eNotifyAction10eIncrementE"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233a04fb0e98d2400e4cd28f1593bc868822"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eIncrement</span></span></span><a class="headerlink" href="#_CPPv4N13eNotifyAction10eIncrementE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Increment the task's notification value. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13eNotifyAction22eSetValueWithOverwriteE">
<span id="_CPPv3N13eNotifyAction22eSetValueWithOverwriteE"></span><span id="_CPPv2N13eNotifyAction22eSetValueWithOverwriteE"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233ab61fc296ef909186b5824c823b33e130"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eSetValueWithOverwrite</span></span></span><a class="headerlink" href="#_CPPv4N13eNotifyAction22eSetValueWithOverwriteE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set the task's notification value to a specific value even if the previous value has not yet been read by the task. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N13eNotifyAction25eSetValueWithoutOverwriteE">
<span id="_CPPv3N13eNotifyAction25eSetValueWithoutOverwriteE"></span><span id="_CPPv2N13eNotifyAction25eSetValueWithoutOverwriteE"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233acc4dd3fe71b62c751187a2c4c515abac"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eSetValueWithoutOverwrite</span></span></span><a class="headerlink" href="#_CPPv4N13eNotifyAction25eSetValueWithoutOverwriteE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set the task's notification value if the previous value has been read by the task. </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv416eSleepModeStatus">
<span id="_CPPv316eSleepModeStatus"></span><span id="_CPPv216eSleepModeStatus"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178e"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eSleepModeStatus</span></span></span><a class="headerlink" href="#_CPPv416eSleepModeStatus" title="Permalink to this definition"></a><br /></dt>
<dd><p>Possible return values for eTaskConfirmSleepModeStatus(). </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16eSleepModeStatus11eAbortSleepE">
<span id="_CPPv3N16eSleepModeStatus11eAbortSleepE"></span><span id="_CPPv2N16eSleepModeStatus11eAbortSleepE"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178eaba7b1a394c63faa14a85dbb191f1c6f9"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eAbortSleep</span></span></span><a class="headerlink" href="#_CPPv4N16eSleepModeStatus11eAbortSleepE" title="Permalink to this definition"></a><br /></dt>
<dd><p>A task has been made ready or a context switch pended since portSUPPRESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16eSleepModeStatus14eStandardSleepE">
<span id="_CPPv3N16eSleepModeStatus14eStandardSleepE"></span><span id="_CPPv2N16eSleepModeStatus14eStandardSleepE"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178ea2c539add8104402c6336bc33a660d1d1"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eStandardSleep</span></span></span><a class="headerlink" href="#_CPPv4N16eSleepModeStatus14eStandardSleepE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enter a sleep mode that will not last any longer than the expected idle time. </p>
</dd></dl>

</dd></dl>

</section>
<section id="queue-api">
<h3>Queue API<a class="headerlink" href="#queue-api" title="Permalink to this heading"></a></h3>
</section>
<section id="id1">
<h3>Header File<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/freertos/FreeRTOS-Kernel/include/freertos/queue.h">components/freertos/FreeRTOS-Kernel/include/freertos/queue.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/queue.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id2">
<h3>Functions<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t">
<span id="_CPPv317xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t"></span><span id="_CPPv217xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t"></span><span id="xQueueGenericSend__QueueHandle_t.voidCPC.TickType_t.BaseType_tC"></span><span class="target" id="queue_8h_1acb67c81366c00896b21cd826e07d885d"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueGenericSend</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvItemToQueue</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xCopyPosition</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>It is preferred that the macros xQueueSend(), xQueueSendToFront() and xQueueSendToBack() are used in place of calling this function directly.</p>
<p>Post an item on a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span>
<span class="p">{</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucMessageID</span><span class="p">;</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10UL</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">,</span><span class="w"> </span><span class="n">xQueue2</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 uint32_t values.</span>
<span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 pointers to AMessage structures.</span>
<span class="w"> </span><span class="c1">// These should be passed by pointer as they contain a lot of data.</span>
<span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// ...</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Send an uint32_t.  Wait for 10 ticks for space to become</span>
<span class="w">     </span><span class="c1">// available if necessary.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueueGenericSend</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEND_TO_BACK</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdPASS</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Failed to post the message, even after 10 ticks.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Send a pointer to a struct AMessage object.  Don&#39;t block if the</span>
<span class="w">     </span><span class="c1">// queue is already full.</span>
<span class="w">     </span><span class="n">pxMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>
<span class="w">     </span><span class="n">xQueueGenericSend</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue2</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEND_TO_BACK</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue on which the item is to be posted.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</p></li>
<li><p><strong>xCopyPosition</strong> -- Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410xQueuePeek13QueueHandle_tPCv10TickType_t">
<span id="_CPPv310xQueuePeek13QueueHandle_tPCv10TickType_t"></span><span id="_CPPv210xQueuePeek13QueueHandle_tPCv10TickType_t"></span><span id="xQueuePeek__QueueHandle_t.voidPC.TickType_t"></span><span class="target" id="queue_8h_1a8f68e37e931bbf95440c8845f512e090"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueuePeek</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvBuffer</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410xQueuePeek13QueueHandle_tPCv10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Receive an item from a queue without removing the item from the queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p>
<p>Successfully received items remain on the queue so will be returned again by the next call, or a call to xQueueReceive().</p>
<p>This macro must not be used in an interrupt service routine. See xQueuePeekFromISR() for an alternative that can be called from an interrupt service routine.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span>
<span class="p">{</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucMessageID</span><span class="p">;</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>

<span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="c1">// Task to create a queue and post a value.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 pointers to AMessage structures.</span>
<span class="w"> </span><span class="c1">// These should be passed by pointer as they contain a lot of data.</span>
<span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Failed to create the queue.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ...</span>

<span class="w"> </span><span class="c1">// Send a pointer to a struct AMessage object.  Don&#39;t block if the</span>
<span class="w"> </span><span class="c1">// queue is already full.</span>
<span class="w"> </span><span class="n">pxMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueueSend</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>

<span class="c1">// Task to peek the data from the queue.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vADifferentTask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="n">pxRxedMessage</span><span class="p">;</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Peek a message on the created queue.  Block for 10 ticks if a</span>
<span class="w">     </span><span class="c1">// message is not immediately available.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueuePeek</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxRxedMessage</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// pcRxedMessage now points to the struct AMessage variable posted</span>
<span class="w">         </span><span class="c1">// by vATask, but the item still remains on the queue.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue from which the item is to be received.</p></li>
<li><p><strong>pvBuffer</strong> -- Pointer to the buffer into which the received item will be copied.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required. xQueuePeek() will return immediately if xTicksToWait is 0 and the queue is empty.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417xQueuePeekFromISR13QueueHandle_tPCv">
<span id="_CPPv317xQueuePeekFromISR13QueueHandle_tPCv"></span><span id="_CPPv217xQueuePeekFromISR13QueueHandle_tPCv"></span><span id="xQueuePeekFromISR__QueueHandle_t.voidPC"></span><span class="target" id="queue_8h_1af67763957452955ac663c374d71278ce"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueuePeekFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xQueuePeekFromISR13QueueHandle_tPCv" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xQueuePeek() that can be called from an interrupt service routine (ISR).</p>
<p>Receive an item from a queue without removing the item from the queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p>
<p>Successfully received items remain on the queue so will be returned again by the next call, or a call to xQueueReceive().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue from which the item is to be received.</p></li>
<li><p><strong>pvBuffer</strong> -- Pointer to the buffer into which the received item will be copied.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413xQueueReceive13QueueHandle_tPCv10TickType_t">
<span id="_CPPv313xQueueReceive13QueueHandle_tPCv10TickType_t"></span><span id="_CPPv213xQueueReceive13QueueHandle_tPCv10TickType_t"></span><span id="xQueueReceive__QueueHandle_t.voidPC.TickType_t"></span><span class="target" id="queue_8h_1ad0a166f3b1219a5e37e31f8090d4800d"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueReceive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvBuffer</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413xQueueReceive13QueueHandle_tPCv10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Receive an item from a queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p>
<p>Successfully received items are removed from the queue.</p>
<p>This function must not be used in an interrupt service routine. See xQueueReceiveFromISR for an alternative that can.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span>
<span class="p">{</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucMessageID</span><span class="p">;</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>

<span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="c1">// Task to create a queue and post a value.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 pointers to AMessage structures.</span>
<span class="w"> </span><span class="c1">// These should be passed by pointer as they contain a lot of data.</span>
<span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Failed to create the queue.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ...</span>

<span class="w"> </span><span class="c1">// Send a pointer to a struct AMessage object.  Don&#39;t block if the</span>
<span class="w"> </span><span class="c1">// queue is already full.</span>
<span class="w"> </span><span class="n">pxMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueueSend</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>

<span class="c1">// Task to receive from the queue.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vADifferentTask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="n">pxRxedMessage</span><span class="p">;</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Receive a message on the created queue.  Block for 10 ticks if a</span>
<span class="w">     </span><span class="c1">// message is not immediately available.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueueReceive</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">pxRxedMessage</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// pcRxedMessage now points to the struct AMessage variable posted</span>
<span class="w">         </span><span class="c1">// by vATask.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue from which the item is to be received.</p></li>
<li><p><strong>pvBuffer</strong> -- Pointer to the buffer into which the received item will be copied.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. xQueueReceive() will return immediately if xTicksToWait is zero and the queue is empty. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422uxQueueMessagesWaitingK13QueueHandle_t">
<span id="_CPPv322uxQueueMessagesWaitingK13QueueHandle_t"></span><span id="_CPPv222uxQueueMessagesWaitingK13QueueHandle_t"></span><span id="uxQueueMessagesWaiting__QueueHandle_tC"></span><span class="target" id="queue_8h_1a4158a6134c9d1c60ffdb18d279d475b1"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxQueueMessagesWaiting</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422uxQueueMessagesWaitingK13QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return the number of messages stored in a queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xQueue</strong> -- A handle to the queue being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of messages available in the queue. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422uxQueueSpacesAvailableK13QueueHandle_t">
<span id="_CPPv322uxQueueSpacesAvailableK13QueueHandle_t"></span><span id="_CPPv222uxQueueSpacesAvailableK13QueueHandle_t"></span><span id="uxQueueSpacesAvailable__QueueHandle_tC"></span><span class="target" id="queue_8h_1a27d6fb77ce7a0b5a16f6471730d33201"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxQueueSpacesAvailable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422uxQueueSpacesAvailableK13QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return the number of free spaces available in a queue. This is equal to the number of items that can be sent to the queue before the queue becomes full if no items are removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xQueue</strong> -- A handle to the queue being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of spaces available in the queue. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412vQueueDelete13QueueHandle_t">
<span id="_CPPv312vQueueDelete13QueueHandle_t"></span><span id="_CPPv212vQueueDelete13QueueHandle_t"></span><span id="vQueueDelete__QueueHandle_t"></span><span class="target" id="queue_8h_1a35c0b4f9a0e940cb3a86ca4c5e84c41c"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vQueueDelete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412vQueueDelete13QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delete a queue - freeing all the memory allocated for storing of items placed on the queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xQueue</strong> -- A handle to the queue to be deleted. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t">
<span id="_CPPv324xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t"></span><span id="_CPPv224xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t"></span><span id="xQueueGenericSendFromISR__QueueHandle_t.voidCPC.BaseType_tPC.BaseType_tC"></span><span class="target" id="queue_8h_1a0fb58b25eb396a5cf8e1688b7e1a56cb"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueGenericSendFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvItemToQueue</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xCopyPosition</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>It is preferred that the macros xQueueSendFromISR(), xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place of calling this function directly. xQueueGiveFromISR() is an equivalent for use by semaphores that don't actually copy any data.</p>
<p>Post an item on a queue. It is safe to use this function from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<p>
Example usage for buffered IO (where the ISR can obtain more than one value per call): <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vBufferISR</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">char</span><span class="w"> </span><span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWokenByPost</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// We have not woken a task at the start of the ISR.</span>
<span class="w"> </span><span class="n">xHigherPriorityTaskWokenByPost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Loop until the buffer is empty.</span>
<span class="w"> </span><span class="k">do</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Obtain a byte from the buffer.</span>
<span class="w">     </span><span class="n">cIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portINPUT_BYTE</span><span class="p">(</span><span class="w"> </span><span class="n">RX_REGISTER_ADDRESS</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="c1">// Post each byte.</span>
<span class="w">     </span><span class="n">xQueueGenericSendFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xRxQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWokenByPost</span><span class="p">,</span><span class="w"> </span><span class="n">queueSEND_TO_BACK</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">portINPUT_BYTE</span><span class="p">(</span><span class="w"> </span><span class="n">BUFFER_COUNT</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Now the buffer is empty we can switch context if necessary.  Note that the</span>
<span class="w"> </span><span class="c1">// name of the yield function required is port specific.</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWokenByPost</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">portYIELD_FROM_ISR</span><span class="p">();</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue on which the item is to be posted.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- xQueueGenericSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueGenericSendFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</p></li>
<li><p><strong>xCopyPosition</strong> -- Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417xQueueGiveFromISR13QueueHandle_tPC10BaseType_t">
<span id="_CPPv317xQueueGiveFromISR13QueueHandle_tPC10BaseType_t"></span><span id="_CPPv217xQueueGiveFromISR13QueueHandle_tPC10BaseType_t"></span><span id="xQueueGiveFromISR__QueueHandle_t.BaseType_tPC"></span><span class="target" id="queue_8h_1a4df49fafb6ba4400ede6f2d07a40865f"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueGiveFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xQueueGiveFromISR13QueueHandle_tPC10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t">
<span id="_CPPv320xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t"></span><span id="_CPPv220xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t"></span><span id="xQueueReceiveFromISR__QueueHandle_t.voidPC.BaseType_tPC"></span><span class="target" id="queue_8h_1ac61ec62828e70ed35d18559a35550462"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueReceiveFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvBuffer</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Receive an item from a queue. It is safe to use this function from within an interrupt service routine.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="c1">// Function to create a queue and post some values.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">char</span><span class="w"> </span><span class="n">cValueToPost</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="mh">0xff</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 characters.</span>
<span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Failed to create the queue.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ...</span>

<span class="w"> </span><span class="c1">// Post some characters that will be used within an ISR.  If the queue</span>
<span class="w"> </span><span class="c1">// is full then this task will block for xTicksToWait ticks.</span>
<span class="w"> </span><span class="n">cValueToPost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueueSend</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cValueToPost</span><span class="p">,</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="n">cValueToPost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueueSend</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cValueToPost</span><span class="p">,</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// ... keep posting characters ... this task may block when the queue</span>
<span class="w"> </span><span class="c1">// becomes full.</span>

<span class="w"> </span><span class="n">cValueToPost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueueSend</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cValueToPost</span><span class="p">,</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ISR that outputs all the characters received on the queue.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vISR_Routine</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xTaskWokenByReceive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">cRxedChar</span><span class="p">;</span>

<span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">xQueueReceiveFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cRxedChar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xTaskWokenByReceive</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// A character was received.  Output the character now.</span>
<span class="w">     </span><span class="n">vOutputCharacter</span><span class="p">(</span><span class="w"> </span><span class="n">cRxedChar</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="c1">// If removing the character from the queue woke the task that was</span>
<span class="w">     </span><span class="c1">// posting onto the queue xTaskWokenByReceive will have been set to</span>
<span class="w">     </span><span class="c1">// pdTRUE.  No matter how many times this loop iterates only one</span>
<span class="w">     </span><span class="c1">// task will be woken.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xTaskWokenByReceive</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">taskYIELD</span><span class="w"> </span><span class="p">();</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue from which the item is to be received.</p></li>
<li><p><strong>pvBuffer</strong> -- Pointer to the buffer into which the received item will be copied.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- A task may be blocked waiting for space to become available on the queue. If xQueueReceiveFromISR causes such a task to unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will remain unchanged.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425xQueueIsQueueEmptyFromISRK13QueueHandle_t">
<span id="_CPPv325xQueueIsQueueEmptyFromISRK13QueueHandle_t"></span><span id="_CPPv225xQueueIsQueueEmptyFromISRK13QueueHandle_t"></span><span id="xQueueIsQueueEmptyFromISR__QueueHandle_tC"></span><span class="target" id="queue_8h_1a7d076f57a56ef50315418f8bbfba96fd"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueIsQueueEmptyFromISR</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xQueueIsQueueEmptyFromISRK13QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queries a queue to determine if the queue is empty. This function should only be used in an ISR.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xQueue</strong> -- The handle of the queue being queried </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFALSE if the queue is not empty, or pdTRUE if the queue is empty. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424xQueueIsQueueFullFromISRK13QueueHandle_t">
<span id="_CPPv324xQueueIsQueueFullFromISRK13QueueHandle_t"></span><span id="_CPPv224xQueueIsQueueFullFromISRK13QueueHandle_t"></span><span id="xQueueIsQueueFullFromISR__QueueHandle_tC"></span><span class="target" id="queue_8h_1a76bbe8ebd21b3e89784e865d06f1058c"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueIsQueueFullFromISR</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424xQueueIsQueueFullFromISRK13QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queries a queue to determine if the queue is full. This function should only be used in an ISR.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xQueue</strong> -- The handle of the queue being queried </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFALSE if the queue is not full, or pdTRUE if the queue is full. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429uxQueueMessagesWaitingFromISRK13QueueHandle_t">
<span id="_CPPv329uxQueueMessagesWaitingFromISRK13QueueHandle_t"></span><span id="_CPPv229uxQueueMessagesWaitingFromISRK13QueueHandle_t"></span><span id="uxQueueMessagesWaitingFromISR__QueueHandle_tC"></span><span class="target" id="queue_8h_1ad5d110bc27c691ff8da238e0116bf92a"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxQueueMessagesWaitingFromISR</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429uxQueueMessagesWaitingFromISRK13QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of uxQueueMessagesWaiting() that can be called from an ISR. Return the number of messages stored in a queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xQueue</strong> -- A handle to the queue being queried. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of messages available in the queue. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419vQueueAddToRegistry13QueueHandle_tPKc">
<span id="_CPPv319vQueueAddToRegistry13QueueHandle_tPKc"></span><span id="_CPPv219vQueueAddToRegistry13QueueHandle_tPKc"></span><span id="vQueueAddToRegistry__QueueHandle_t.cCP"></span><span class="target" id="queue_8h_1a1d5e2402c801e7a0ab079f6944b97f93"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vQueueAddToRegistry</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pcQueueName</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419vQueueAddToRegistry13QueueHandle_tPKc" title="Permalink to this definition"></a><br /></dt>
<dd><p>The registry is provided as a means for kernel aware debuggers to locate queues, semaphores and mutexes. Call vQueueAddToRegistry() add a queue, semaphore or mutex handle to the registry if you want the handle to be available to a kernel aware debugger. If you are not using a kernel aware debugger then this function can be ignored.</p>
<p>configQUEUE_REGISTRY_SIZE defines the maximum number of handles the registry can hold. configQUEUE_REGISTRY_SIZE must be greater than 0 within FreeRTOSConfig.h for the registry to be available. Its value does not affect the number of queues, semaphores and mutexes that can be created - just the number that the registry can hold.</p>
<p>If vQueueAddToRegistry is called more than once with the same xQueue parameter, the registry will store the pcQueueName parameter from the most recent call to vQueueAddToRegistry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle of the queue being added to the registry. This is the handle returned by a call to xQueueCreate(). Semaphore and mutex handles can also be passed in here.</p></li>
<li><p><strong>pcQueueName</strong> -- The name to be associated with the handle. This is the name that the kernel aware debugger will display. The queue registry only stores a pointer to the string - so the string must be persistent (global or preferably in ROM/Flash), not on the stack. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421vQueueUnregisterQueue13QueueHandle_t">
<span id="_CPPv321vQueueUnregisterQueue13QueueHandle_t"></span><span id="_CPPv221vQueueUnregisterQueue13QueueHandle_t"></span><span id="vQueueUnregisterQueue__QueueHandle_t"></span><span class="target" id="queue_8h_1ac695c7cde3c32b32a1db4689239603ed"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vQueueUnregisterQueue</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421vQueueUnregisterQueue13QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>The registry is provided as a means for kernel aware debuggers to locate queues, semaphores and mutexes. Call vQueueAddToRegistry() add a queue, semaphore or mutex handle to the registry if you want the handle to be available to a kernel aware debugger, and vQueueUnregisterQueue() to remove the queue, semaphore or mutex from the register. If you are not using a kernel aware debugger then this function can be ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xQueue</strong> -- The handle of the queue being removed from the registry. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414pcQueueGetName13QueueHandle_t">
<span id="_CPPv314pcQueueGetName13QueueHandle_t"></span><span id="_CPPv214pcQueueGetName13QueueHandle_t"></span><span id="pcQueueGetName__QueueHandle_t"></span><span class="target" id="queue_8h_1a6cd1431e6d0f46927d6260d49f0d6df3"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcQueueGetName</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414pcQueueGetName13QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>The queue registry is provided as a means for kernel aware debuggers to locate queues, semaphores and mutexes. Call pcQueueGetName() to look up and return the name of a queue in the queue registry from the queue's handle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xQueue</strong> -- The handle of the queue the name of which will be returned. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the queue is in the registry then a pointer to the name of the queue is returned. If the queue is not in the registry then NULL is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415xQueueCreateSetK11UBaseType_t">
<span id="_CPPv315xQueueCreateSetK11UBaseType_t"></span><span id="_CPPv215xQueueCreateSetK11UBaseType_t"></span><span id="xQueueCreateSet__UBaseType_tC"></span><span class="target" id="queue_8h_1a91bd42d88130401acb3da565bf92253c"></span><a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t"><span class="n"><span class="pre">QueueSetHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueCreateSet</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxEventQueueLength</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xQueueCreateSetK11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queue sets provide a mechanism to allow a task to block (pend) on a read operation from multiple queues or semaphores simultaneously.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p>A queue set must be explicitly created using a call to xQueueCreateSet() before it can be used. Once created, standard FreeRTOS queues and semaphores can be added to the set using calls to xQueueAddToSet(). xQueueSelectFromSet() is then used to determine which, if any, of the queues or semaphores contained in the set is in a state where a queue read or semaphore take operation would be successful.</p>
<p>Note 1: See the documentation on <a class="reference external" href="https://www.FreeRTOS.org/RTOS-queue-sets.html">https://www.FreeRTOS.org/RTOS-queue-sets.html</a> for reasons why queue sets are very rarely needed in practice as there are simpler methods of blocking on multiple objects.</p>
<p>Note 2: Blocking on a queue set that contains a mutex will not cause the mutex holder to inherit the priority of the blocked task.</p>
<p>Note 3: An additional 4 bytes of RAM is required for each space in a every queue added to a queue set. Therefore counting semaphores that have a high maximum count value should not be added to a queue set.</p>
<p>Note 4: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to xQueueSelectFromSet() has first returned a handle to that set member.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>uxEventQueueLength</strong> -- Queue sets store events that occur on the queues and semaphores contained in the set. uxEventQueueLength specifies the maximum number of events that can be queued at once. To be absolutely certain that events are not lost uxEventQueueLength should be set to the total sum of the length of the queues added to the set, where binary semaphores and mutexes have a length of 1, and counting semaphores have a length set by their maximum count value. Examples:<ul class="simple">
<li><p>If a queue set is to hold a queue of length 5, another queue of length 12, and a binary semaphore, then uxEventQueueLength should be set to (5 + 12 + 1), or 18.</p></li>
<li><p>If a queue set is to hold three binary semaphores then uxEventQueueLength should be set to (1 + 1 + 1 ), or 3.</p></li>
<li><p>If a queue set is to hold a counting semaphore that has a maximum count of 5, and a counting semaphore that has a maximum count of 3, then uxEventQueueLength should be set to (5 + 3), or 8.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the queue set is created successfully then a handle to the created queue set is returned. Otherwise NULL is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t">
<span id="_CPPv314xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="_CPPv214xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="xQueueAddToSet__QueueSetMemberHandle_t.QueueSetHandle_t"></span><span class="target" id="queue_8h_1a8c1d293c0149b9ee657bc00ce9fdadfc"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueAddToSet</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t"><span class="n"><span class="pre">QueueSetMemberHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueueOrSemaphore</span></span>, <a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t"><span class="n"><span class="pre">QueueSetHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueueSet</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Adds a queue or semaphore to a queue set that was previously created by a call to xQueueCreateSet().</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p>Note 1: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to xQueueSelectFromSet() has first returned a handle to that set member.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueueOrSemaphore</strong> -- The handle of the queue or semaphore being added to the queue set (cast to an QueueSetMemberHandle_t type).</p></li>
<li><p><strong>xQueueSet</strong> -- The handle of the queue set to which the queue or semaphore is being added.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the queue or semaphore was successfully added to the queue set then pdPASS is returned. If the queue could not be successfully added to the queue set because it is already a member of a different queue set then pdFAIL is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t">
<span id="_CPPv319xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="_CPPv219xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="xQueueRemoveFromSet__QueueSetMemberHandle_t.QueueSetHandle_t"></span><span class="target" id="queue_8h_1a80b44fbc3b403bfac5a2892d98bdcccc"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueRemoveFromSet</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t"><span class="n"><span class="pre">QueueSetMemberHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueueOrSemaphore</span></span>, <a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t"><span class="n"><span class="pre">QueueSetHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueueSet</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Removes a queue or semaphore from a queue set. A queue or semaphore can only be removed from a set if the queue or semaphore is empty.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueueOrSemaphore</strong> -- The handle of the queue or semaphore being removed from the queue set (cast to an QueueSetMemberHandle_t type).</p></li>
<li><p><strong>xQueueSet</strong> -- The handle of the queue set in which the queue or semaphore is included.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the queue or semaphore was successfully removed from the queue set then pdPASS is returned. If the queue was not in the queue set, or the queue (or semaphore) was not empty, then pdFAIL is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419xQueueSelectFromSet16QueueSetHandle_tK10TickType_t">
<span id="_CPPv319xQueueSelectFromSet16QueueSetHandle_tK10TickType_t"></span><span id="_CPPv219xQueueSelectFromSet16QueueSetHandle_tK10TickType_t"></span><span id="xQueueSelectFromSet__QueueSetHandle_t.TickType_tC"></span><span class="target" id="queue_8h_1af9aaa7cfe384e00698b61a80ac787929"></span><a class="reference internal" href="#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t"><span class="n"><span class="pre">QueueSetMemberHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueSelectFromSet</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t"><span class="n"><span class="pre">QueueSetHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueueSet</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xQueueSelectFromSet16QueueSetHandle_tK10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>xQueueSelectFromSet() selects from the members of a queue set a queue or semaphore that either contains data (in the case of a queue) or is available to take (in the case of a semaphore). xQueueSelectFromSet() effectively allows a task to block (pend) on a read operation on all the queues and semaphores in a queue set simultaneously.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p>Note 1: See the documentation on <a class="reference external" href="https://www.FreeRTOS.org/RTOS-queue-sets.html">https://www.FreeRTOS.org/RTOS-queue-sets.html</a> for reasons why queue sets are very rarely needed in practice as there are simpler methods of blocking on multiple objects.</p>
<p>Note 2: Blocking on a queue set that contains a mutex will not cause the mutex holder to inherit the priority of the blocked task.</p>
<p>Note 3: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to xQueueSelectFromSet() has first returned a handle to that set member.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueueSet</strong> -- The queue set on which the task will (potentially) block.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum time, in ticks, that the calling task will remain in the Blocked state (with other tasks executing) to wait for a member of the queue set to be ready for a successful queue read or semaphore take operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>xQueueSelectFromSet() will return the handle of a queue (cast to a QueueSetMemberHandle_t type) contained in the queue set that contains data, or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426xQueueSelectFromSetFromISR16QueueSetHandle_t">
<span id="_CPPv326xQueueSelectFromSetFromISR16QueueSetHandle_t"></span><span id="_CPPv226xQueueSelectFromSetFromISR16QueueSetHandle_t"></span><span id="xQueueSelectFromSetFromISR__QueueSetHandle_t"></span><span class="target" id="queue_8h_1a2625570b9fa59be450bb1c4b663a1478"></span><a class="reference internal" href="#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t"><span class="n"><span class="pre">QueueSetMemberHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueSelectFromSetFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t"><span class="n"><span class="pre">QueueSetHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueueSet</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426xQueueSelectFromSetFromISR16QueueSetHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xQueueSelectFromSet() that can be used from an ISR. </p>
</dd></dl>

</section>
<section id="id3">
<h3>Macros<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueCreate">
<span class="target" id="queue_8h_1aeb858b824bd74a934ea7ebb81af2a6bb"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueCreate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uxQueueLength</span></span>, <span class="n"><span class="pre">uxItemSize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueCreate" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new queue instance, and returns a handle by which the new queue can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, queues use two blocks of memory. The first block is used to hold the queue's data structures. The second block is used to hold items placed into the queue. If a queue is created using xQueueCreate() then both blocks of memory are automatically dynamically allocated inside the xQueueCreate() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a queue is created using xQueueCreateStatic() then the application writer must provide the memory that will get used by the queue. xQueueCreateStatic() therefore allows a queue to be created without using any dynamic memory allocation.</p>
<p><a class="reference external" href="https://www.FreeRTOS.org/Embedded-RTOS-Queues.html">https://www.FreeRTOS.org/Embedded-RTOS-Queues.html</a></p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span>
<span class="p">{</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucMessageID</span><span class="p">;</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">,</span><span class="w"> </span><span class="n">xQueue2</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 uint32_t values.</span>
<span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Queue was not created and must not be used.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 pointers to AMessage structures.</span>
<span class="w"> </span><span class="c1">// These should be passed by pointer as they contain a lot of data.</span>
<span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Queue was not created and must not be used.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uxQueueLength</strong> -- The maximum number of items that the queue can contain.</p></li>
<li><p><strong>uxItemSize</strong> -- The number of bytes each item in the queue will require. Items are queued by copy, not by reference, so this is the number of bytes that will be copied for each posted item. Each item on the queue must be the same size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the queue is successfully create then a handle to the newly created queue is returned. If the queue cannot be created then 0 is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueCreateStatic">
<span class="target" id="queue_8h_1a867bd68852e9eea7206d364a7e165e57"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueCreateStatic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uxQueueLength</span></span>, <span class="n"><span class="pre">uxItemSize</span></span>, <span class="n"><span class="pre">pucQueueStorage</span></span>, <span class="n"><span class="pre">pxQueueBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueCreateStatic" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new queue instance, and returns a handle by which the new queue can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, queues use two blocks of memory. The first block is used to hold the queue's data structures. The second block is used to hold items placed into the queue. If a queue is created using xQueueCreate() then both blocks of memory are automatically dynamically allocated inside the xQueueCreate() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a queue is created using xQueueCreateStatic() then the application writer must provide the memory that will get used by the queue. xQueueCreateStatic() therefore allows a queue to be created without using any dynamic memory allocation.</p>
<p><a class="reference external" href="https://www.FreeRTOS.org/Embedded-RTOS-Queues.html">https://www.FreeRTOS.org/Embedded-RTOS-Queues.html</a></p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span>
<span class="p">{</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucMessageID</span><span class="p">;</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define QUEUE_LENGTH 10</span>
<span class="cp">#define ITEM_SIZE sizeof( uint32_t )</span>

<span class="c1">// xQueueBuffer will hold the queue structure.</span>
<span class="n">StaticQueue_t</span><span class="w"> </span><span class="n">xQueueBuffer</span><span class="p">;</span>

<span class="c1">// ucQueueStorage will hold the items posted to the queue.  Must be at least</span>
<span class="c1">// [(queue length) * ( queue item size)] bytes long.</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucQueueStorage</span><span class="p">[</span><span class="w"> </span><span class="n">QUEUE_LENGTH</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ITEM_SIZE</span><span class="w"> </span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 uint32_t values.</span>
<span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="n">QUEUE_LENGTH</span><span class="p">,</span><span class="w"> </span><span class="c1">// The number of items the queue can hold.</span>
<span class="w">                         </span><span class="n">ITEM_SIZE</span><span class="w">     </span><span class="c1">// The size of each item in the queue</span>
<span class="w">                         </span><span class="o">&amp;</span><span class="p">(</span><span class="w"> </span><span class="n">ucQueueStorage</span><span class="p">[</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="c1">// The buffer that will hold the items in the queue.</span>
<span class="w">                         </span><span class="o">&amp;</span><span class="n">xQueueBuffer</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// The buffer that will hold the queue structure.</span>

<span class="w"> </span><span class="c1">// The queue is guaranteed to be created successfully as no dynamic memory</span>
<span class="w"> </span><span class="c1">// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uxQueueLength</strong> -- The maximum number of items that the queue can contain.</p></li>
<li><p><strong>uxItemSize</strong> -- The number of bytes each item in the queue will require. Items are queued by copy, not by reference, so this is the number of bytes that will be copied for each posted item. Each item on the queue must be the same size.</p></li>
<li><p><strong>pucQueueStorage</strong> -- If uxItemSize is not zero then pucQueueStorage must point to a uint8_t array that is at least large enough to hold the maximum number of items that can be in the queue at any one time - which is ( uxQueueLength * uxItemsSize ) bytes. If uxItemSize is zero then pucQueueStorage can be NULL.</p></li>
<li><p><strong>pxQueueBuffer</strong> -- Must point to a variable of type StaticQueue_t, which will be used to hold the queue's data structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the queue is created then a handle to the created queue is returned. If pxQueueBuffer is NULL then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueGetStaticBuffers">
<span class="target" id="queue_8h_1a51d0a50a9907cfea3a1b78a2f8af2a76"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueGetStaticBuffers</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">ppucQueueStorage</span></span>, <span class="n"><span class="pre">ppxStaticQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueGetStaticBuffers" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve pointers to a statically created queue's data structure buffer and storage area buffer. These are the same buffers that are supplied at the time of creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The queue for which to retrieve the buffers.</p></li>
<li><p><strong>ppucQueueStorage</strong> -- Used to return a pointer to the queue's storage area buffer.</p></li>
<li><p><strong>ppxStaticQueue</strong> -- Used to return a pointer to the queue's data structure buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if buffers were retrieved, pdFALSE otherwise. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueSendToFront">
<span class="target" id="queue_8h_1aa612fcc2b1ceee0200f34b942e300b41"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueSendToFront</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">pvItemToQueue</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendToFront" title="Permalink to this definition"></a><br /></dt>
<dd><p>Post an item to the front of a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span>
<span class="p">{</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucMessageID</span><span class="p">;</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10UL</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">,</span><span class="w"> </span><span class="n">xQueue2</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 uint32_t values.</span>
<span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 pointers to AMessage structures.</span>
<span class="w"> </span><span class="c1">// These should be passed by pointer as they contain a lot of data.</span>
<span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// ...</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Send an uint32_t.  Wait for 10 ticks for space to become</span>
<span class="w">     </span><span class="c1">// available if necessary.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueueSendToFront</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdPASS</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Failed to post the message, even after 10 ticks.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Send a pointer to a struct AMessage object.  Don&#39;t block if the</span>
<span class="w">     </span><span class="c1">// queue is already full.</span>
<span class="w">     </span><span class="n">pxMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>
<span class="w">     </span><span class="n">xQueueSendToFront</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue2</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue on which the item is to be posted.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueSendToBack">
<span class="target" id="queue_8h_1a81d24a2c1199d58efb76fbee15853112"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueSendToBack</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">pvItemToQueue</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendToBack" title="Permalink to this definition"></a><br /></dt>
<dd><p>This is a macro that calls xQueueGenericSend().</p>
<p>Post an item to the back of a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span>
<span class="p">{</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucMessageID</span><span class="p">;</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10UL</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">,</span><span class="w"> </span><span class="n">xQueue2</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 uint32_t values.</span>
<span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 pointers to AMessage structures.</span>
<span class="w"> </span><span class="c1">// These should be passed by pointer as they contain a lot of data.</span>
<span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// ...</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Send an uint32_t.  Wait for 10 ticks for space to become</span>
<span class="w">     </span><span class="c1">// available if necessary.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueueSendToBack</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdPASS</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Failed to post the message, even after 10 ticks.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Send a pointer to a struct AMessage object.  Don&#39;t block if the</span>
<span class="w">     </span><span class="c1">// queue is already full.</span>
<span class="w">     </span><span class="n">pxMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>
<span class="w">     </span><span class="n">xQueueSendToBack</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue2</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue on which the item is to be posted.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueSend">
<span class="target" id="queue_8h_1af7eb49d3249351176992950d9185abe9"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueSend</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">pvItemToQueue</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSend" title="Permalink to this definition"></a><br /></dt>
<dd><p>This is a macro that calls xQueueGenericSend(). It is included for backward compatibility with versions of FreeRTOS.org that did not include the xQueueSendToFront() and xQueueSendToBack() macros. It is equivalent to xQueueSendToBack().</p>
<p>Post an item on a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span>
<span class="p">{</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucMessageID</span><span class="p">;</span>
<span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ucData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10UL</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">,</span><span class="w"> </span><span class="n">xQueue2</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 uint32_t values.</span>
<span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Create a queue capable of containing 10 pointers to AMessage structures.</span>
<span class="w"> </span><span class="c1">// These should be passed by pointer as they contain a lot of data.</span>
<span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AMessage</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// ...</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Send an uint32_t.  Wait for 10 ticks for space to become</span>
<span class="w">     </span><span class="c1">// available if necessary.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueueSend</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdPASS</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Failed to post the message, even after 10 ticks.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Send a pointer to a struct AMessage object.  Don&#39;t block if the</span>
<span class="w">     </span><span class="c1">// queue is already full.</span>
<span class="w">     </span><span class="n">pxMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">xMessage</span><span class="p">;</span>
<span class="w">     </span><span class="n">xQueueSend</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue2</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ... Rest of task code.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue on which the item is to be posted.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueOverwrite">
<span class="target" id="queue_8h_1a8e9ced123b5a0e37a36d3bbdb2e56b4e"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueOverwrite</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">pvItemToQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueOverwrite" title="Permalink to this definition"></a><br /></dt>
<dd><p>Only for use with queues that have a length of one - so the queue is either empty or full.</p>
<p>Post an item on a queue. If the queue is already full then overwrite the value held in the queue. The item is queued by copy, not by reference.</p>
<p>This function must not be called from an interrupt service routine. See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulVarToSend</span><span class="p">,</span><span class="w"> </span><span class="n">ulValReceived</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a queue to hold one uint32_t value.  It is strongly</span>
<span class="w"> </span><span class="c1">// recommended *not* to use xQueueOverwrite() on queues that can</span>
<span class="w"> </span><span class="c1">// contain more than one value, and doing so will trigger an assertion</span>
<span class="w"> </span><span class="c1">// if configASSERT() is defined.</span>
<span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Write the value 10 to the queue using xQueueOverwrite().</span>
<span class="w"> </span><span class="n">ulVarToSend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueueOverwrite</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulVarToSend</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Peeking the queue should now return 10, but leave the value 10 in</span>
<span class="w"> </span><span class="c1">// the queue.  A block time of zero is used as it is known that the</span>
<span class="w"> </span><span class="c1">// queue holds a value.</span>
<span class="w"> </span><span class="n">ulValReceived</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueuePeek</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulValReceived</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ulValReceived</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Error unless the item was removed by a different task.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// The queue is still full.  Use xQueueOverwrite() to overwrite the</span>
<span class="w"> </span><span class="c1">// value held in the queue with 100.</span>
<span class="w"> </span><span class="n">ulVarToSend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueueOverwrite</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulVarToSend</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// This time read from the queue, leaving the queue empty once more.</span>
<span class="w"> </span><span class="c1">// A block time of 0 is used again.</span>
<span class="w"> </span><span class="n">xQueueReceive</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulValReceived</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// The value read should be the last value written, even though the</span>
<span class="w"> </span><span class="c1">// queue was already full when the value was written.</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ulValReceived</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Error!</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle of the queue to which the data is being sent.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>xQueueOverwrite() is a macro that calls xQueueGenericSend(), and therefore has the same return values as xQueueSendToFront(). However, pdPASS is the only value that can be returned because xQueueOverwrite() will write to the queue even when the queue is already full.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueSendToFrontFromISR">
<span class="target" id="queue_8h_1af03b83396462affe9e28302660e7b9c6"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueSendToFrontFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">pvItemToQueue</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendToFrontFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>This is a macro that calls xQueueGenericSendFromISR().</p>
<p>Post an item to the front of a queue. It is safe to use this macro from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<p>
Example usage for buffered IO (where the ISR can obtain more than one value per call): <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vBufferISR</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">char</span><span class="w"> </span><span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// We have not woken a task at the start of the ISR.</span>
<span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Loop until the buffer is empty.</span>
<span class="w"> </span><span class="k">do</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Obtain a byte from the buffer.</span>
<span class="w">     </span><span class="n">cIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portINPUT_BYTE</span><span class="p">(</span><span class="w"> </span><span class="n">RX_REGISTER_ADDRESS</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="c1">// Post the byte.</span>
<span class="w">     </span><span class="n">xQueueSendToFrontFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xRxQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">portINPUT_BYTE</span><span class="p">(</span><span class="w"> </span><span class="n">BUFFER_COUNT</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Now the buffer is empty we can switch context if necessary.</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">taskYIELD</span><span class="w"> </span><span class="p">();</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue on which the item is to be posted.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- xQueueSendToFrontFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToFromFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueSendToBackFromISR">
<span class="target" id="queue_8h_1a51e9f73417b11441a181cdc4f33a68e9"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueSendToBackFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">pvItemToQueue</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendToBackFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>This is a macro that calls xQueueGenericSendFromISR().</p>
<p>Post an item to the back of a queue. It is safe to use this macro from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<p>
Example usage for buffered IO (where the ISR can obtain more than one value per call): <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vBufferISR</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">char</span><span class="w"> </span><span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// We have not woken a task at the start of the ISR.</span>
<span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Loop until the buffer is empty.</span>
<span class="w"> </span><span class="k">do</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Obtain a byte from the buffer.</span>
<span class="w">     </span><span class="n">cIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portINPUT_BYTE</span><span class="p">(</span><span class="w"> </span><span class="n">RX_REGISTER_ADDRESS</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="c1">// Post the byte.</span>
<span class="w">     </span><span class="n">xQueueSendToBackFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xRxQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">portINPUT_BYTE</span><span class="p">(</span><span class="w"> </span><span class="n">BUFFER_COUNT</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Now the buffer is empty we can switch context if necessary.</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">taskYIELD</span><span class="w"> </span><span class="p">();</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue on which the item is to be posted.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- xQueueSendToBackFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToBackFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueOverwriteFromISR">
<span class="target" id="queue_8h_1abdcd6a86ef82034d002193e79cfd3ce8"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueOverwriteFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">pvItemToQueue</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueOverwriteFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xQueueOverwrite() that can be used in an interrupt service routine (ISR).</p>
<p>Only for use with queues that can hold a single item - so the queue is either empty or full.</p>
<p>Post an item on a queue. If the queue is already full then overwrite the value held in the queue. The item is queued by copy, not by reference.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">QueueHandle_t</span><span class="w"> </span><span class="n">xQueue</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Create a queue to hold one uint32_t value.  It is strongly</span>
<span class="w"> </span><span class="c1">// recommended *not* to use xQueueOverwriteFromISR() on queues that can</span>
<span class="w"> </span><span class="c1">// contain more than one value, and doing so will trigger an assertion</span>
<span class="w"> </span><span class="c1">// if configASSERT() is defined.</span>
<span class="w"> </span><span class="n">xQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreate</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vAnInterruptHandler</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">ulVarToSend</span><span class="p">,</span><span class="w"> </span><span class="n">ulValReceived</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Write the value 10 to the queue using xQueueOverwriteFromISR().</span>
<span class="w"> </span><span class="n">ulVarToSend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueueOverwriteFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulVarToSend</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// The queue is full, but calling xQueueOverwriteFromISR() again will still</span>
<span class="w"> </span><span class="c1">// pass because the value held in the queue will be overwritten with the</span>
<span class="w"> </span><span class="c1">// new value.</span>
<span class="w"> </span><span class="n">ulVarToSend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w"> </span><span class="n">xQueueOverwriteFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ulVarToSend</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Reading from the queue will now return 100.</span>

<span class="w"> </span><span class="c1">// ...</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPrioritytaskWoken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Writing to the queue caused a task to unblock and the unblocked task</span>
<span class="w">     </span><span class="c1">// has a priority higher than or equal to the priority of the currently</span>
<span class="w">     </span><span class="c1">// executing task (the task this interrupt interrupted).  Perform a context</span>
<span class="w">     </span><span class="c1">// switch so this interrupt returns directly to the unblocked task.</span>
<span class="w">     </span><span class="n">portYIELD_FROM_ISR</span><span class="p">();</span><span class="w"> </span><span class="c1">// or portEND_SWITCHING_ISR() depending on the port.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue on which the item is to be posted.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- xQueueOverwriteFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueOverwriteFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>xQueueOverwriteFromISR() is a macro that calls xQueueGenericSendFromISR(), and therefore has the same return values as xQueueSendToFrontFromISR(). However, pdPASS is the only value that can be returned because xQueueOverwriteFromISR() will write to the queue even when the queue is already full.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueSendFromISR">
<span class="target" id="queue_8h_1a21d5919ed26c21d121df4a4debeb643c"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueSendFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span>, <span class="n"><span class="pre">pvItemToQueue</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>This is a macro that calls xQueueGenericSendFromISR(). It is included for backward compatibility with versions of FreeRTOS.org that did not include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR() macros.</p>
<p>Post an item to the back of a queue. It is safe to use this function from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<p>
Example usage for buffered IO (where the ISR can obtain more than one value per call): <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vBufferISR</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">char</span><span class="w"> </span><span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// We have not woken a task at the start of the ISR.</span>
<span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Loop until the buffer is empty.</span>
<span class="w"> </span><span class="k">do</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Obtain a byte from the buffer.</span>
<span class="w">     </span><span class="n">cIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">portINPUT_BYTE</span><span class="p">(</span><span class="w"> </span><span class="n">RX_REGISTER_ADDRESS</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="c1">// Post the byte.</span>
<span class="w">     </span><span class="n">xQueueSendFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xRxQueue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">portINPUT_BYTE</span><span class="p">(</span><span class="w"> </span><span class="n">BUFFER_COUNT</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Now the buffer is empty we can switch context if necessary.</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Actual macro used here is port specific.</span>
<span class="w">     </span><span class="n">portYIELD_FROM_ISR</span><span class="w"> </span><span class="p">();</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xQueue</strong> -- The handle to the queue on which the item is to be posted.</p></li>
<li><p><strong>pvItemToQueue</strong> -- A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xQueueReset">
<span class="target" id="queue_8h_1a94df8d8bc938424151f8196db2f1177b"></span><span class="sig-name descname"><span class="n"><span class="pre">xQueueReset</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueReset" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reset a queue back to its original empty state. The return value is now obsolete and is always set to pdPASS. </p>
</dd></dl>

</section>
<section id="id4">
<h3>Type Definitions<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv413QueueHandle_t">
<span id="_CPPv313QueueHandle_t"></span><span id="_CPPv213QueueHandle_t"></span><span id="QueueHandle_t"></span><span class="target" id="queue_8h_1a57349603001f8ddf51c888c49e2804d7"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">QueueDefinition</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">QueueHandle_t</span></span></span><a class="headerlink" href="#_CPPv413QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv416QueueSetHandle_t">
<span id="_CPPv316QueueSetHandle_t"></span><span id="_CPPv216QueueSetHandle_t"></span><span id="QueueSetHandle_t"></span><span class="target" id="queue_8h_1a1ae056fb02b2467993003b85111dde16"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">QueueDefinition</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">QueueSetHandle_t</span></span></span><a class="headerlink" href="#_CPPv416QueueSetHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type by which queue sets are referenced. For example, a call to xQueueCreateSet() returns an xQueueSet variable that can then be used as a parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv422QueueSetMemberHandle_t">
<span id="_CPPv322QueueSetMemberHandle_t"></span><span id="_CPPv222QueueSetMemberHandle_t"></span><span id="QueueSetMemberHandle_t"></span><span class="target" id="queue_8h_1afac7ec7649e5c57381315eb011c36ef5"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">QueueDefinition</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">QueueSetMemberHandle_t</span></span></span><a class="headerlink" href="#_CPPv422QueueSetMemberHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queue sets can contain both queues and semaphores, so the QueueSetMemberHandle_t is defined as a type to be used where a parameter or return value can be either an QueueHandle_t or an SemaphoreHandle_t. </p>
</dd></dl>

</section>
<section id="semaphore-api">
<h3>Semaphore API<a class="headerlink" href="#semaphore-api" title="Permalink to this heading"></a></h3>
</section>
<section id="id5">
<h3>Header File<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/freertos/FreeRTOS-Kernel/include/freertos/semphr.h">components/freertos/FreeRTOS-Kernel/include/freertos/semphr.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/semphr.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id6">
<h3>Macros<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.semBINARY_SEMAPHORE_QUEUE_LENGTH">
<span class="target" id="semphr_8h_1a73cfd14cf25a13f8dd4dc1d74b7fc04a"></span><span class="sig-name descname"><span class="n"><span class="pre">semBINARY_SEMAPHORE_QUEUE_LENGTH</span></span></span><a class="headerlink" href="#c.semBINARY_SEMAPHORE_QUEUE_LENGTH" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.semSEMAPHORE_QUEUE_ITEM_LENGTH">
<span class="target" id="semphr_8h_1a93bd07e28aed3084bdafa1f4e99700b2"></span><span class="sig-name descname"><span class="n"><span class="pre">semSEMAPHORE_QUEUE_ITEM_LENGTH</span></span></span><a class="headerlink" href="#c.semSEMAPHORE_QUEUE_ITEM_LENGTH" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.semGIVE_BLOCK_TIME">
<span class="target" id="semphr_8h_1a124bb5bd7805baa06fbd3239840d6803"></span><span class="sig-name descname"><span class="n"><span class="pre">semGIVE_BLOCK_TIME</span></span></span><a class="headerlink" href="#c.semGIVE_BLOCK_TIME" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.vSemaphoreCreateBinary">
<span class="target" id="semphr_8h_1ae10bffadd26fbd5bcce76bf33a83ef30"></span><span class="sig-name descname"><span class="n"><span class="pre">vSemaphoreCreateBinary</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vSemaphoreCreateBinary" title="Permalink to this definition"></a><br /></dt>
<dd><p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a binary semaphore! <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a></p>
<p>This old vSemaphoreCreateBinary() macro is now deprecated in favour of the xSemaphoreCreateBinary() function. Note that binary semaphores created using the vSemaphoreCreateBinary() macro are created in a state such that the first call to 'take' the semaphore would pass, whereas binary semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first be 'given' before it can be 'taken'.</p>
<p><em>Macro</em> that implements a semaphore by using the existing queue mechanism. The queue length is 1 as this is a binary semaphore. The data size is 0 as we don't want to actually store any data - we just want to know if the queue is empty or full.</p>
<p>This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task. The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore while another continuously 'takes' the semaphore. For this reason this type of semaphore does not use a priority inheritance mechanism. For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Semaphore cannot be used before a call to vSemaphoreCreateBinary ().</span>
<span class="w"> </span><span class="c1">// This is a macro so pass the variable in directly.</span>
<span class="w"> </span><span class="n">vSemaphoreCreateBinary</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The semaphore was created successfully.</span>
<span class="w">     </span><span class="c1">// The semaphore can now be used.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xSemaphore</strong> -- Handle to the created semaphore. Should be of type SemaphoreHandle_t.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreCreateBinary">
<span class="target" id="semphr_8h_1acba963695e4f159d9bfa2394cae5badc"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateBinary</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateBinary" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new binary semaphore instance, and returns a handle by which the new semaphore can be referenced.</p>
<p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a binary semaphore! <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a></p>
<p>Internally, within the FreeRTOS implementation, binary semaphores use a block of memory, in which the semaphore structure is stored. If a binary semaphore is created using xSemaphoreCreateBinary() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateBinary() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a binary semaphore is created using xSemaphoreCreateBinaryStatic() then the application writer must provide the memory. xSemaphoreCreateBinaryStatic() therefore allows a binary semaphore to be created without using any dynamic memory allocation.</p>
<p>The old vSemaphoreCreateBinary() macro is now deprecated in favour of this xSemaphoreCreateBinary() function. Note that binary semaphores created using the vSemaphoreCreateBinary() macro are created in a state such that the first call to 'take' the semaphore would pass, whereas binary semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first be 'given' before it can be 'taken'.</p>
<p>This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task. The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore while another continuously 'takes' the semaphore. For this reason this type of semaphore does not use a priority inheritance mechanism. For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Semaphore cannot be used before a call to xSemaphoreCreateBinary().</span>
<span class="w"> </span><span class="c1">// This is a macro so pass the variable in directly.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateBinary</span><span class="p">();</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The semaphore was created successfully.</span>
<span class="w">     </span><span class="c1">// The semaphore can now be used.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Handle to the created semaphore, or NULL if the memory required to hold the semaphore's data structures could not be allocated.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreCreateBinaryStatic">
<span class="target" id="semphr_8h_1a1a8fb8e7922ce5ced3b36f0c963393f1"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateBinaryStatic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pxStaticSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateBinaryStatic" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new binary semaphore instance, and returns a handle by which the new semaphore can be referenced.</p>
<p>NOTE: In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a binary semaphore! <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a></p>
<p>Internally, within the FreeRTOS implementation, binary semaphores use a block of memory, in which the semaphore structure is stored. If a binary semaphore is created using xSemaphoreCreateBinary() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateBinary() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a binary semaphore is created using xSemaphoreCreateBinaryStatic() then the application writer must provide the memory. xSemaphoreCreateBinaryStatic() therefore allows a binary semaphore to be created without using any dynamic memory allocation.</p>
<p>This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task. The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore while another continuously 'takes' the semaphore. For this reason this type of semaphore does not use a priority inheritance mechanism. For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span><span class="w"> </span><span class="n">xSemaphoreBuffer</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Semaphore cannot be used before a call to xSemaphoreCreateBinary().</span>
<span class="w"> </span><span class="c1">// The semaphore&#39;s data structures will be placed in the xSemaphoreBuffer</span>
<span class="w"> </span><span class="c1">// variable, the address of which is passed into the function.  The</span>
<span class="w"> </span><span class="c1">// function&#39;s parameter is not NULL, so the function will not attempt any</span>
<span class="w"> </span><span class="c1">// dynamic memory allocation, and therefore the function will not return</span>
<span class="w"> </span><span class="c1">// return NULL.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateBinary</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSemaphoreBuffer</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Rest of task code goes here.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxStaticSemaphore</strong> -- Must point to a variable of type StaticSemaphore_t, which will then be used to hold the semaphore's data structure, removing the need for the memory to be allocated dynamically.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the semaphore is created then a handle to the created semaphore is returned. If pxSemaphoreBuffer is NULL then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreTake">
<span class="target" id="semphr_8h_1af116e436d2a5ae5bd72dbade2b5ea930"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreTake</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span>, <span class="n"><span class="pre">xBlockTime</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreTake" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Macro</em> to obtain a semaphore. The semaphore must have previously been created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="c1">// A task that creates a semaphore.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Create the semaphore to guard a shared resource.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateBinary</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// A task that uses the semaphore.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vAnotherTask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// ... Do other things.</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// See if we can obtain the semaphore.  If the semaphore is not available</span>
<span class="w">     </span><span class="c1">// wait 10 ticks to see if it becomes free.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphoreTake</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// We were able to obtain the semaphore and can now access the</span>
<span class="w">         </span><span class="c1">// shared resource.</span>

<span class="w">         </span><span class="c1">// ...</span>

<span class="w">         </span><span class="c1">// We have finished accessing the shared resource.  Release the</span>
<span class="w">         </span><span class="c1">// semaphore.</span>
<span class="w">         </span><span class="n">xSemaphoreGive</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">);</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// We could not obtain the semaphore and can therefore not access</span>
<span class="w">         </span><span class="c1">// the shared resource safely.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xSemaphore</strong> -- A handle to the semaphore being taken - obtained when the semaphore was created.</p></li>
<li><p><strong>xBlockTime</strong> -- The time in ticks to wait for the semaphore to become available. The macro portTICK_PERIOD_MS can be used to convert this to a real time. A block time of zero can be used to poll the semaphore. A block time of portMAX_DELAY can be used to block indefinitely (provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the semaphore was obtained. pdFALSE if xBlockTime expired without the semaphore becoming available.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreTakeRecursive">
<span class="target" id="semphr_8h_1ad395f4bba51eea6af3397d72bc079e4d"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreTakeRecursive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMutex</span></span>, <span class="n"><span class="pre">xBlockTime</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreTakeRecursive" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Macro</em> to recursively obtain, or 'take', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();</p>
<p>configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this macro to be available.</p>
<p>This macro must not be used on mutexes created using xSemaphoreCreateMutex().</p>
<p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="c1">// A task that creates a mutex.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Create the mutex to guard a shared resource.</span>
<span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateRecursiveMutex</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// A task that uses the mutex.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vAnotherTask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// ... Do other things.</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// See if we can obtain the mutex.  If the mutex is not available</span>
<span class="w">     </span><span class="c1">// wait 10 ticks to see if it becomes free.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// We were able to obtain the mutex and can now access the</span>
<span class="w">         </span><span class="c1">// shared resource.</span>

<span class="w">         </span><span class="c1">// ...</span>
<span class="w">         </span><span class="c1">// For some reason due to the nature of the code further calls to</span>
<span class="w">         </span><span class="c1">// xSemaphoreTakeRecursive() are made on the same mutex.  In real</span>
<span class="w">         </span><span class="c1">// code these would not be just sequential calls as this would make</span>
<span class="w">         </span><span class="c1">// no sense.  Instead the calls are likely to be buried inside</span>
<span class="w">         </span><span class="c1">// a more complex call structure.</span>
<span class="w">         </span><span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span>
<span class="w">         </span><span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span>

<span class="w">         </span><span class="c1">// The mutex has now been &#39;taken&#39; three times, so will not be</span>
<span class="w">         </span><span class="c1">// available to another task until it has also been given back</span>
<span class="w">         </span><span class="c1">// three times.  Again it is unlikely that real code would have</span>
<span class="w">         </span><span class="c1">// these calls sequentially, but instead buried in a more complex</span>
<span class="w">         </span><span class="c1">// call structure.  This is just for illustrative purposes.</span>
<span class="w">         </span><span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="p">);</span>
<span class="w">         </span><span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="p">);</span>
<span class="w">         </span><span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="p">);</span>

<span class="w">         </span><span class="c1">// Now the mutex can be taken by other tasks.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// We could not obtain the mutex and can therefore not access</span>
<span class="w">         </span><span class="c1">// the shared resource safely.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMutex</strong> -- A handle to the mutex being obtained. This is the handle returned by xSemaphoreCreateRecursiveMutex();</p></li>
<li><p><strong>xBlockTime</strong> -- The time in ticks to wait for the semaphore to become available. The macro portTICK_PERIOD_MS can be used to convert this to a real time. A block time of zero can be used to poll the semaphore. If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the semaphore was obtained. pdFALSE if xBlockTime expired without the semaphore becoming available.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreGive">
<span class="target" id="semphr_8h_1aae55761cabfa9bf85c8f4430f78c0953"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreGive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGive" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Macro</em> to release a semaphore. The semaphore must have previously been created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().</p>
<p>This macro must not be used from an ISR. See xSemaphoreGiveFromISR () for an alternative which can be used from an ISR.</p>
<p>This macro must also not be used on semaphores created using xSemaphoreCreateRecursiveMutex().</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Create the semaphore to guard a shared resource.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vSemaphoreCreateBinary</span><span class="p">();</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphoreGive</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// We would expect this call to fail because we cannot give</span>
<span class="w">         </span><span class="c1">// a semaphore without first &quot;taking&quot; it!</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="c1">// Obtain the semaphore - don&#39;t block if the semaphore is not</span>
<span class="w">     </span><span class="c1">// immediately available.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphoreTake</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// We now have the semaphore and can access the shared resource.</span>

<span class="w">         </span><span class="c1">// ...</span>

<span class="w">         </span><span class="c1">// We have finished accessing the shared resource so can free the</span>
<span class="w">         </span><span class="c1">// semaphore.</span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphoreGive</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">)</span>
<span class="w">         </span><span class="p">{</span>
<span class="w">             </span><span class="c1">// We would not expect this call to fail because we must have</span>
<span class="w">             </span><span class="c1">// obtained the semaphore to get here.</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xSemaphore</strong> -- A handle to the semaphore being released. This is the handle returned when the semaphore was created.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the semaphore was released. pdFALSE if an error occurred. Semaphores are implemented using queues. An error can occur if there is no space on the queue to post a message - indicating that the semaphore was not first obtained correctly.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreGiveRecursive">
<span class="target" id="semphr_8h_1a398d66b17856c22dd49d39aaac42f105"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreGiveRecursive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMutex</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGiveRecursive" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Macro</em> to recursively release, or 'give', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();</p>
<p>configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this macro to be available.</p>
<p>This macro must not be used on mutexes created using xSemaphoreCreateMutex().</p>
<p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="c1">// A task that creates a mutex.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Create the mutex to guard a shared resource.</span>
<span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateRecursiveMutex</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// A task that uses the mutex.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vAnotherTask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// ... Do other things.</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// See if we can obtain the mutex.  If the mutex is not available</span>
<span class="w">     </span><span class="c1">// wait 10 ticks to see if it becomes free.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// We were able to obtain the mutex and can now access the</span>
<span class="w">         </span><span class="c1">// shared resource.</span>

<span class="w">         </span><span class="c1">// ...</span>
<span class="w">         </span><span class="c1">// For some reason due to the nature of the code further calls to</span>
<span class="w">         </span><span class="c1">// xSemaphoreTakeRecursive() are made on the same mutex.  In real</span>
<span class="w">         </span><span class="c1">// code these would not be just sequential calls as this would make</span>
<span class="w">         </span><span class="c1">// no sense.  Instead the calls are likely to be buried inside</span>
<span class="w">         </span><span class="c1">// a more complex call structure.</span>
<span class="w">         </span><span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span>
<span class="w">         </span><span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span>

<span class="w">         </span><span class="c1">// The mutex has now been &#39;taken&#39; three times, so will not be</span>
<span class="w">         </span><span class="c1">// available to another task until it has also been given back</span>
<span class="w">         </span><span class="c1">// three times.  Again it is unlikely that real code would have</span>
<span class="w">         </span><span class="c1">// these calls sequentially, it would be more likely that the calls</span>
<span class="w">         </span><span class="c1">// to xSemaphoreGiveRecursive() would be called as a call stack</span>
<span class="w">         </span><span class="c1">// unwound.  This is just for demonstrative purposes.</span>
<span class="w">         </span><span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="p">);</span>
<span class="w">         </span><span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="p">);</span>
<span class="w">         </span><span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span><span class="w"> </span><span class="n">xMutex</span><span class="w"> </span><span class="p">);</span>

<span class="w">         </span><span class="c1">// Now the mutex can be taken by other tasks.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// We could not obtain the mutex and can therefore not access</span>
<span class="w">         </span><span class="c1">// the shared resource safely.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMutex</strong> -- A handle to the mutex being released, or 'given'. This is the handle returned by xSemaphoreCreateMutex();</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the semaphore was given.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreGiveFromISR">
<span class="target" id="semphr_8h_1a68aa43df8b2a0dbe17d05fad74670ef0"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreGiveFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGiveFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Macro</em> to release a semaphore. The semaphore must have previously been created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().</p>
<p>Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.</p>
<p>This macro can be used from an ISR.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define LONG_TIME 0xffff</span>
<span class="cp">#define TICKS_TO_WAIT 10</span>
<span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="c1">// Repetitive task.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// We want this task to run every 10 ticks of a timer.  The semaphore</span>
<span class="w">     </span><span class="c1">// was created before this task was started.</span>

<span class="w">     </span><span class="c1">// Block waiting for the semaphore to become available.</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphoreTake</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">,</span><span class="w"> </span><span class="n">LONG_TIME</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// It is time to execute.</span>

<span class="w">         </span><span class="c1">// ...</span>

<span class="w">         </span><span class="c1">// We have finished our task.  Return to the top of the loop where</span>
<span class="w">         </span><span class="c1">// we will block on the semaphore until it is time to execute</span>
<span class="w">         </span><span class="c1">// again.  Note when using the semaphore for synchronisation with an</span>
<span class="w">         </span><span class="c1">// ISR in this manner there is no need to &#39;give&#39; the semaphore back.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Timer ISR</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vTimerISR</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucLocalTickCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// A timer tick has occurred.</span>

<span class="w"> </span><span class="c1">// ... Do other time functions.</span>

<span class="w"> </span><span class="c1">// Is it time for vATask () to run?</span>
<span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>
<span class="w"> </span><span class="n">ucLocalTickCount</span><span class="o">++</span><span class="p">;</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ucLocalTickCount</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">TICKS_TO_WAIT</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Unblock the task by releasing the semaphore.</span>
<span class="w">     </span><span class="n">xSemaphoreGiveFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="c1">// Reset the count so we release the semaphore again in 10 ticks time.</span>
<span class="w">     </span><span class="n">ucLocalTickCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// We can force a context switch here.  Context switching from an</span>
<span class="w">     </span><span class="c1">// ISR uses port specific syntax.  Check the demo task for your port</span>
<span class="w">     </span><span class="c1">// to find the syntax required.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xSemaphore</strong> -- A handle to the semaphore being released. This is the handle returned when the semaphore was created.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- xSemaphoreGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreTakeFromISR">
<span class="target" id="semphr_8h_1a076419b58e072655686939016e7ca3c5"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreTakeFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreTakeFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Macro</em> to take a semaphore from an ISR. The semaphore must have previously been created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().</p>
<p>Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.</p>
<p>This macro can be used from an ISR, however taking a semaphore from an ISR is not a common operation. It is likely to only be useful when taking a counting semaphore when an interrupt is obtaining an object from a resource pool (when the semaphore count indicates the number of resources available).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xSemaphore</strong> -- A handle to the semaphore being taken. This is the handle returned when the semaphore was created.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- xSemaphoreTakeFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreTakeFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the semaphore was successfully taken, otherwise pdFALSE </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreCreateMutex">
<span class="target" id="semphr_8h_1aa6a00aa9b91a9e5b3ebe4ae1c3f115c6"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateMutex</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateMutex" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new mutex type semaphore instance, and returns a handle by which the new mutex can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, mutex semaphores use a block of memory, in which the mutex structure is stored. If a mutex is created using xSemaphoreCreateMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateMutex() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a mutex is created using xSemaphoreCreateMutexStatic() then the application writer must provided the memory. xSemaphoreCreateMutexStatic() therefore allows a mutex to be created without using any dynamic memory allocation.</p>
<p>Mutexes created using this function can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros must not be used.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Semaphore cannot be used before a call to xSemaphoreCreateMutex().</span>
<span class="w"> </span><span class="c1">// This is a macro so pass the variable in directly.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateMutex</span><span class="p">();</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The semaphore was created successfully.</span>
<span class="w">     </span><span class="c1">// The semaphore can now be used.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If the mutex was successfully created then a handle to the created semaphore is returned. If there was not enough heap to allocate the mutex data structures then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreCreateMutexStatic">
<span class="target" id="semphr_8h_1a2f6fea163b7069a27a4a3fd8adfbfadd"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateMutexStatic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pxMutexBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateMutexStatic" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new mutex type semaphore instance, and returns a handle by which the new mutex can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, mutex semaphores use a block of memory, in which the mutex structure is stored. If a mutex is created using xSemaphoreCreateMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateMutex() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a mutex is created using xSemaphoreCreateMutexStatic() then the application writer must provided the memory. xSemaphoreCreateMutexStatic() therefore allows a mutex to be created without using any dynamic memory allocation.</p>
<p>Mutexes created using this function can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros must not be used.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span><span class="w"> </span><span class="n">xMutexBuffer</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// A mutex cannot be used before it has been created.  xMutexBuffer is</span>
<span class="w"> </span><span class="c1">// into xSemaphoreCreateMutexStatic() so no dynamic memory allocation is</span>
<span class="w"> </span><span class="c1">// attempted.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateMutexStatic</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xMutexBuffer</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// As no dynamic memory allocation was performed, xSemaphore cannot be NULL,</span>
<span class="w"> </span><span class="c1">// so there is no need to check it.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxMutexBuffer</strong> -- Must point to a variable of type StaticSemaphore_t, which will be used to hold the mutex's data structure, removing the need for the memory to be allocated dynamically.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the mutex was successfully created then a handle to the created mutex is returned. If pxMutexBuffer was NULL then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreCreateRecursiveMutex">
<span class="target" id="semphr_8h_1a1bbc843be5a41ea83d2693b2189fc0f8"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateRecursiveMutex</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateRecursiveMutex" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new recursive mutex type semaphore instance, and returns a handle by which the new recursive mutex can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, recursive mutexes use a block of memory, in which the mutex structure is stored. If a recursive mutex is created using xSemaphoreCreateRecursiveMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateRecursiveMutex() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic() then the application writer must provide the memory that will get used by the mutex. xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to be created without using any dynamic memory allocation.</p>
<p>Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros. The xSemaphoreTake() and xSemaphoreGive() macros must not be used.</p>
<p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// Semaphore cannot be used before a call to xSemaphoreCreateMutex().</span>
<span class="w"> </span><span class="c1">// This is a macro so pass the variable in directly.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateRecursiveMutex</span><span class="p">();</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The semaphore was created successfully.</span>
<span class="w">     </span><span class="c1">// The semaphore can now be used.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>xSemaphore Handle to the created mutex semaphore. Should be of type SemaphoreHandle_t.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreCreateRecursiveMutexStatic">
<span class="target" id="semphr_8h_1a6fda8db26863762a083770f060d1285b"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateRecursiveMutexStatic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pxStaticSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateRecursiveMutexStatic" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new recursive mutex type semaphore instance, and returns a handle by which the new recursive mutex can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, recursive mutexes use a block of memory, in which the mutex structure is stored. If a recursive mutex is created using xSemaphoreCreateRecursiveMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateRecursiveMutex() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic() then the application writer must provide the memory that will get used by the mutex. xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to be created without using any dynamic memory allocation.</p>
<p>Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros. The xSemaphoreTake() and xSemaphoreGive() macros must not be used.</p>
<p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span><span class="w"> </span><span class="n">xMutexBuffer</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="c1">// A recursive semaphore cannot be used before it is created.  Here a</span>
<span class="w"> </span><span class="c1">// recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic().</span>
<span class="w"> </span><span class="c1">// The address of xMutexBuffer is passed into the function, and will hold</span>
<span class="w"> </span><span class="c1">// the mutexes data structures - so no dynamic memory allocation will be</span>
<span class="w"> </span><span class="c1">// attempted.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateRecursiveMutexStatic</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xMutexBuffer</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// As no dynamic memory allocation was performed, xSemaphore cannot be NULL,</span>
<span class="w"> </span><span class="c1">// so there is no need to check it.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxStaticSemaphore</strong> -- Must point to a variable of type StaticSemaphore_t, which will then be used to hold the recursive mutex's data structure, removing the need for the memory to be allocated dynamically.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the recursive mutex was successfully created then a handle to the created recursive mutex is returned. If pxStaticSemaphore was NULL then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreCreateCounting">
<span class="target" id="semphr_8h_1a7764616a918a46115403569a88148ad4"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateCounting</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uxMaxCount</span></span>, <span class="n"><span class="pre">uxInitialCount</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateCounting" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new counting semaphore instance, and returns a handle by which the new counting semaphore can be referenced.</p>
<p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a counting semaphore! <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a></p>
<p>Internally, within the FreeRTOS implementation, counting semaphores use a block of memory, in which the counting semaphore structure is stored. If a counting semaphore is created using xSemaphoreCreateCounting() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateCounting() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a counting semaphore is created using xSemaphoreCreateCountingStatic() then the application writer can instead optionally provide the memory that will get used by the counting semaphore. xSemaphoreCreateCountingStatic() therefore allows a counting semaphore to be created without using any dynamic memory allocation.</p>
<p>Counting semaphores are typically used for two things:</p>
<p>1) Counting events.</p>
<p>In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.</p>
<p>2) Resource management.</p>
<p>In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Semaphore cannot be used before a call to xSemaphoreCreateCounting().</span>
<span class="w"> </span><span class="c1">// The max value to which the semaphore can count should be 10, and the</span>
<span class="w"> </span><span class="c1">// initial value assigned to the count should be 0.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateCounting</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The semaphore was created successfully.</span>
<span class="w">     </span><span class="c1">// The semaphore can now be used.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uxMaxCount</strong> -- The maximum count value that can be reached. When the semaphore reaches this value it can no longer be 'given'.</p></li>
<li><p><strong>uxInitialCount</strong> -- The count value assigned to the semaphore when it is created.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created semaphore. Null if the semaphore could not be created.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreCreateCountingStatic">
<span class="target" id="semphr_8h_1a955bf5b3c1e256c5ce42c73d577c8438"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateCountingStatic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uxMaxCount</span></span>, <span class="n"><span class="pre">uxInitialCount</span></span>, <span class="n"><span class="pre">pxSemaphoreBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateCountingStatic" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new counting semaphore instance, and returns a handle by which the new counting semaphore can be referenced.</p>
<p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a counting semaphore! <a class="reference external" href="https://www.FreeRTOS.org/RTOS-task-notifications.html">https://www.FreeRTOS.org/RTOS-task-notifications.html</a></p>
<p>Internally, within the FreeRTOS implementation, counting semaphores use a block of memory, in which the counting semaphore structure is stored. If a counting semaphore is created using xSemaphoreCreateCounting() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateCounting() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a counting semaphore is created using xSemaphoreCreateCountingStatic() then the application writer must provide the memory. xSemaphoreCreateCountingStatic() therefore allows a counting semaphore to be created without using any dynamic memory allocation.</p>
<p>Counting semaphores are typically used for two things:</p>
<p>1) Counting events.</p>
<p>In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.</p>
<p>2) Resource management.</p>
<p>In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span><span class="w"> </span><span class="n">xSemaphoreBuffer</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vATask</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Counting semaphore cannot be used before they have been created.  Create</span>
<span class="w"> </span><span class="c1">// a counting semaphore using xSemaphoreCreateCountingStatic().  The max</span>
<span class="w"> </span><span class="c1">// value to which the semaphore can count is 10, and the initial value</span>
<span class="w"> </span><span class="c1">// assigned to the count will be 0.  The address of xSemaphoreBuffer is</span>
<span class="w"> </span><span class="c1">// passed in and will be used to hold the semaphore structure, so no dynamic</span>
<span class="w"> </span><span class="c1">// memory allocation will be used.</span>
<span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xSemaphoreCreateCounting</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xSemaphoreBuffer</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// No memory allocation was attempted so xSemaphore cannot be NULL, so there</span>
<span class="w"> </span><span class="c1">// is no need to check its value.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uxMaxCount</strong> -- The maximum count value that can be reached. When the semaphore reaches this value it can no longer be 'given'.</p></li>
<li><p><strong>uxInitialCount</strong> -- The count value assigned to the semaphore when it is created.</p></li>
<li><p><strong>pxSemaphoreBuffer</strong> -- Must point to a variable of type StaticSemaphore_t, which will then be used to hold the semaphore's data structure, removing the need for the memory to be allocated dynamically.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the counting semaphore was successfully created then a handle to the created counting semaphore is returned. If pxSemaphoreBuffer was NULL then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.vSemaphoreDelete">
<span class="target" id="semphr_8h_1acd7d0eda0923d7caeeaaee9202c43eab"></span><span class="sig-name descname"><span class="n"><span class="pre">vSemaphoreDelete</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vSemaphoreDelete" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delete a semaphore. This function must be used with care. For example, do not delete a mutex type semaphore if the mutex is held by a task.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xSemaphore</strong> -- A handle to the semaphore to be deleted. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreGetMutexHolder">
<span class="target" id="semphr_8h_1a7403bfbc06fb8449b2334f55d939a4c4"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreGetMutexHolder</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGetMutexHolder" title="Permalink to this definition"></a><br /></dt>
<dd><p>If xMutex is indeed a mutex type semaphore, return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held by a task), return NULL.</p>
<p>Note: This is a good way of determining if the calling task is the mutex holder, but not a good way of determining the identity of the mutex holder as the holder may change between the function exiting and the returned value being tested. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreGetMutexHolderFromISR">
<span class="target" id="semphr_8h_1ac3db48a47d2030b535651f306b44191b"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreGetMutexHolderFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGetMutexHolderFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>If xMutex is indeed a mutex type semaphore, return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held by a task), return NULL. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.uxSemaphoreGetCount">
<span class="target" id="semphr_8h_1aa26a3d7cf9b5595a652daeb7f81229f3"></span><span class="sig-name descname"><span class="n"><span class="pre">uxSemaphoreGetCount</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uxSemaphoreGetCount" title="Permalink to this definition"></a><br /></dt>
<dd><p>If the semaphore is a counting semaphore then uxSemaphoreGetCount() returns its current count value. If the semaphore is a binary semaphore then uxSemaphoreGetCount() returns 1 if the semaphore is available, and 0 if the semaphore is not available. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.uxSemaphoreGetCountFromISR">
<span class="target" id="semphr_8h_1a03b7cb6ac11b161ce9e11f18a111d24c"></span><span class="sig-name descname"><span class="n"><span class="pre">uxSemaphoreGetCountFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uxSemaphoreGetCountFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>semphr.h <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">UBaseType_t</span><span class="w"> </span><span class="nf">uxSemaphoreGetCountFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">SemaphoreHandle_t</span><span class="w"> </span><span class="n">xSemaphore</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
</p>
<p>If the semaphore is a counting semaphore then uxSemaphoreGetCountFromISR() returns its current count value. If the semaphore is a binary semaphore then uxSemaphoreGetCountFromISR() returns 1 if the semaphore is available, and 0 if the semaphore is not available. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xSemaphoreGetStaticBuffer">
<span class="target" id="semphr_8h_1a0c92cc56512a2cd1f3b599eed88e3b4a"></span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreGetStaticBuffer</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xSemaphore</span></span>, <span class="n"><span class="pre">ppxSemaphoreBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGetStaticBuffer" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve pointer to a statically created binary semaphore, counting semaphore, or mutex semaphore's data structure buffer. This is the same buffer that is supplied at the time of creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xSemaphore</strong> -- The semaphore for which to retrieve the buffer.</p></li>
<li><p><strong>ppxSemaphoreBuffer</strong> -- Used to return a pointer to the semaphore's data structure buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if buffer was retrieved, pdFALSE otherwise. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id7">
<h3>Type Definitions<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv417SemaphoreHandle_t">
<span id="_CPPv317SemaphoreHandle_t"></span><span id="_CPPv217SemaphoreHandle_t"></span><span id="SemaphoreHandle_t"></span><span class="target" id="semphr_8h_1ad88c6df4a04beedeac782918c8a332f5"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SemaphoreHandle_t</span></span></span><a class="headerlink" href="#_CPPv417SemaphoreHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
<section id="timer-api">
<h3>Timer API<a class="headerlink" href="#timer-api" title="Permalink to this heading"></a></h3>
</section>
<section id="id8">
<h3>Header File<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/freertos/FreeRTOS-Kernel/include/freertos/timers.h">components/freertos/FreeRTOS-Kernel/include/freertos/timers.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/timers.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id9">
<h3>Functions<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412xTimerCreatePCKcK10TickType_tK10BaseType_tPCv23TimerCallbackFunction_t">
<span id="_CPPv312xTimerCreatePCKcK10TickType_tK10BaseType_tPCv23TimerCallbackFunction_t"></span><span id="_CPPv212xTimerCreatePCKcK10TickType_tK10BaseType_tPCv23TimerCallbackFunction_t"></span><span id="xTimerCreate__cCPC.TickType_tC.BaseType_tC.voidPC.TimerCallbackFunction_t"></span><span class="target" id="timers_8h_1a60a98dc69e8f80f36bfe95e0f8329f93"></span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerCreate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pcTimerName</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTimerPeriodInTicks</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xAutoReload</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvTimerID</span></span>, <a class="reference internal" href="#_CPPv423TimerCallbackFunction_t" title="TimerCallbackFunction_t"><span class="n"><span class="pre">TimerCallbackFunction_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pxCallbackFunction</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412xTimerCreatePCKcK10TickType_tK10BaseType_tPCv23TimerCallbackFunction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new software timer instance, and returns a handle by which the created software timer can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, software timers use a block of memory, in which the timer data structure is stored. If a software timer is created using xTimerCreate() then the required memory is automatically dynamically allocated inside the xTimerCreate() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a software timer is created using xTimerCreateStatic() then the application writer must provide the memory that will get used by the software timer. xTimerCreateStatic() therefore allows a software timer to be created without using any dynamic memory allocation.</p>
<p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* #define NUM_TIMERS 5
*
* // An array to hold handles to the created timers.
* TimerHandle_t xTimers[ NUM_TIMERS ];
*
* // An array to hold a count of the number of times each timer expires.
* int32_t lExpireCounters[ NUM_TIMERS ] = { 0 };
*
* // Define a callback function that will be used by multiple timer instances.
* // The callback function does nothing but count the number of times the
* // associated timer expires, and stop the timer once the timer has expired
* // 10 times.
* void vTimerCallback( TimerHandle_t pxTimer )
* {
* int32_t lArrayIndex;
* const int32_t xMaxExpiryCountBeforeStopping = 10;
*
*     // Optionally do something if the pxTimer parameter is NULL.
*     configASSERT( pxTimer );
*
*     // Which timer expired?
*     lArrayIndex = ( int32_t ) pvTimerGetTimerID( pxTimer );
*
*     // Increment the number of times that pxTimer has expired.
*     lExpireCounters[ lArrayIndex ] += 1;
*
*     // If the timer has expired 10 times then stop it from running.
*     if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
*     {
*         // Do not use a block time if calling a timer API function from a
*         // timer callback function, as doing so could cause a deadlock!
*         xTimerStop( pxTimer, 0 );
*     }
* }
*
* void main( void )
* {
* int32_t x;
*
*     // Create then start some timers.  Starting the timers before the scheduler
*     // has been started means the timers will start running immediately that
*     // the scheduler starts.
*     for( x = 0; x &lt; NUM_TIMERS; x++ )
*     {
*         xTimers[ x ] = xTimerCreate(    &quot;Timer&quot;,             // Just a text name, not used by the kernel.
*                                         ( 100 * ( x + 1 ) ), // The timer period in ticks.
*                                         pdTRUE,              // The timers will auto-reload themselves when they expire.
*                                         ( void * ) x,        // Assign each timer a unique id equal to its array index.
*                                         vTimerCallback       // Each timer calls the same callback when it expires.
*                                     );
*
*         if( xTimers[ x ] == NULL )
*         {
*             // The timer was not created.
*         }
*         else
*         {
*             // Start the timer.  No block time is specified, and even if one was
*             // it would be ignored because the scheduler has not yet been
*             // started.
*             if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
*             {
*                 // The timer could not be set into the Active state.
*             }
*         }
*     }
*
*     // ...
*     // Create tasks here.
*     // ...
*
*     // Starting the scheduler will start the timers running as they have already
*     // been set into the active state.
*     vTaskStartScheduler();
*
*     // Should not reach here.
*     for( ;; );
* }
*
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pcTimerName</strong> -- A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.</p></li>
<li><p><strong>xTimerPeriodInTicks</strong> -- The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. Time timer period must be greater than 0.</p></li>
<li><p><strong>xAutoReload</strong> -- If xAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If xAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</p></li>
<li><p><strong>pvTimerID</strong> -- An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</p></li>
<li><p><strong>pxCallbackFunction</strong> -- The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is &quot;void vCallbackFunction( TimerHandle_t xTimer );&quot;.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the timer is successfully created then a handle to the newly created timer is returned. If the timer cannot be created because there is insufficient FreeRTOS heap remaining to allocate the timer structures then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418xTimerCreateStaticPCKcK10TickType_tK10BaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t">
<span id="_CPPv318xTimerCreateStaticPCKcK10TickType_tK10BaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t"></span><span id="_CPPv218xTimerCreateStaticPCKcK10TickType_tK10BaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t"></span><span id="xTimerCreateStatic__cCPC.TickType_tC.BaseType_tC.voidPC.TimerCallbackFunction_t.StaticTimer_tP"></span><span class="target" id="timers_8h_1aab5899c56f3c6a755a0989e8d08f84ad"></span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerCreateStatic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pcTimerName</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTimerPeriodInTicks</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xAutoReload</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvTimerID</span></span>, <a class="reference internal" href="#_CPPv423TimerCallbackFunction_t" title="TimerCallbackFunction_t"><span class="n"><span class="pre">TimerCallbackFunction_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pxCallbackFunction</span></span>, <span class="n"><span class="pre">StaticTimer_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxTimerBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xTimerCreateStaticPCKcK10TickType_tK10BaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new software timer instance, and returns a handle by which the created software timer can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, software timers use a block of memory, in which the timer data structure is stored. If a software timer is created using xTimerCreate() then the required memory is automatically dynamically allocated inside the xTimerCreate() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If a software timer is created using xTimerCreateStatic() then the application writer must provide the memory that will get used by the software timer. xTimerCreateStatic() therefore allows a software timer to be created without using any dynamic memory allocation.</p>
<p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">used</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="s1">&#39;s data structure.</span>
<span class="o">*</span> <span class="n">static</span> <span class="n">StaticTimer_t</span> <span class="n">xTimerBuffer</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">A</span> <span class="n">variable</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incremented</span> <span class="n">by</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="s1">&#39;s callback</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">function</span><span class="o">.</span>
<span class="o">*</span> <span class="n">UBaseType_t</span> <span class="n">uxVariableToIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">A</span> <span class="n">software</span> <span class="n">timer</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">that</span> <span class="n">increments</span> <span class="n">a</span> <span class="n">variable</span> <span class="n">passed</span> <span class="n">to</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">it</span> <span class="n">when</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span> <span class="n">was</span> <span class="n">created</span><span class="o">.</span>  <span class="n">After</span> <span class="n">the</span> <span class="mi">5</span><span class="n">th</span> <span class="n">increment</span> <span class="n">the</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">stops</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="o">.</span>
<span class="o">*</span> <span class="n">static</span> <span class="n">void</span> <span class="n">prvTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">xExpiredTimer</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span> <span class="n">UBaseType_t</span> <span class="o">*</span><span class="n">puxVariableToIncrement</span><span class="p">;</span>
<span class="o">*</span> <span class="n">BaseType_t</span> <span class="n">xReturned</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Obtain</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">to</span> <span class="n">increment</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">timer</span> <span class="n">ID</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">puxVariableToIncrement</span> <span class="o">=</span> <span class="p">(</span> <span class="n">UBaseType_t</span> <span class="o">*</span> <span class="p">)</span> <span class="n">pvTimerGetTimerID</span><span class="p">(</span> <span class="n">xExpiredTimer</span> <span class="p">);</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Increment</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">to</span> <span class="n">show</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">callback</span> <span class="n">has</span> <span class="n">executed</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">(</span> <span class="o">*</span><span class="n">puxVariableToIncrement</span> <span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">If</span> <span class="n">this</span> <span class="n">callback</span> <span class="n">has</span> <span class="n">executed</span> <span class="n">the</span> <span class="n">required</span> <span class="n">number</span> <span class="n">of</span> <span class="n">times</span><span class="p">,</span> <span class="n">stop</span> <span class="n">the</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">timer</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">puxVariableToIncrement</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">called</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">timer</span> <span class="n">callback</span> <span class="n">so</span> <span class="n">must</span> <span class="ow">not</span> <span class="n">block</span><span class="o">.</span>
<span class="o">*</span>         <span class="n">xTimerStop</span><span class="p">(</span> <span class="n">xExpiredTimer</span><span class="p">,</span> <span class="n">staticDONT_BLOCK</span> <span class="p">);</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">software</span> <span class="n">time</span><span class="o">.</span>  <span class="n">xTimerCreateStatic</span><span class="p">()</span> <span class="n">has</span> <span class="n">an</span> <span class="n">extra</span> <span class="n">parameter</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">than</span> <span class="n">the</span> <span class="n">normal</span> <span class="n">xTimerCreate</span><span class="p">()</span> <span class="n">API</span> <span class="n">function</span><span class="o">.</span>  <span class="n">The</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">pointer</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">to</span> <span class="n">the</span> <span class="n">StaticTimer_t</span> <span class="n">structure</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">structure</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="n">passed</span> <span class="k">as</span> <span class="n">NULL</span> <span class="n">then</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">will</span> <span class="n">be</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">allocated</span> <span class="n">dynamically</span><span class="p">,</span> <span class="n">just</span> <span class="k">as</span> <span class="k">if</span> <span class="n">xTimerCreate</span><span class="p">()</span> <span class="n">had</span> <span class="n">been</span> <span class="n">called</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">xTimer</span> <span class="o">=</span> <span class="n">xTimerCreateStatic</span><span class="p">(</span> <span class="s2">&quot;T1&quot;</span><span class="p">,</span>             <span class="o">//</span> <span class="n">Text</span> <span class="n">name</span> <span class="k">for</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>  <span class="n">Helps</span> <span class="n">debugging</span> <span class="n">only</span><span class="o">.</span>  <span class="n">Not</span> <span class="n">used</span> <span class="n">by</span> <span class="n">FreeRTOS</span><span class="o">.</span>
<span class="o">*</span>                                  <span class="n">xTimerPeriod</span><span class="p">,</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">period</span> <span class="n">of</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">in</span> <span class="n">ticks</span><span class="o">.</span>
<span class="o">*</span>                                  <span class="n">pdTRUE</span><span class="p">,</span>           <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">auto</span><span class="o">-</span><span class="n">reload</span> <span class="n">timer</span><span class="o">.</span>
<span class="o">*</span>                                  <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">uxVariableToIncrement</span><span class="p">,</span>    <span class="o">//</span> <span class="n">A</span> <span class="n">variable</span> <span class="n">incremented</span> <span class="n">by</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="s1">&#39;s callback function</span>
<span class="o">*</span>                                  <span class="n">prvTimerCallback</span><span class="p">,</span> <span class="o">//</span> <span class="n">The</span> <span class="n">function</span> <span class="n">to</span> <span class="n">execute</span> <span class="n">when</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">expires</span><span class="o">.</span>
<span class="o">*</span>                                  <span class="o">&amp;</span><span class="n">xTimerBuffer</span> <span class="p">);</span>  <span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span> <span class="n">structure</span><span class="o">.</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">scheduler</span> <span class="n">has</span> <span class="ow">not</span> <span class="n">started</span> <span class="n">yet</span> <span class="n">so</span> <span class="n">a</span> <span class="n">block</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">xReturned</span> <span class="o">=</span> <span class="n">xTimerStart</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="o">...</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Create</span> <span class="n">tasks</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>     <span class="o">//</span> <span class="o">...</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Starting</span> <span class="n">the</span> <span class="n">scheduler</span> <span class="n">will</span> <span class="n">start</span> <span class="n">the</span> <span class="n">timers</span> <span class="n">running</span> <span class="k">as</span> <span class="n">they</span> <span class="n">have</span> <span class="n">already</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">into</span> <span class="n">the</span> <span class="n">active</span> <span class="n">state</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">vTaskStartScheduler</span><span class="p">();</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Should</span> <span class="ow">not</span> <span class="n">reach</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">);</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pcTimerName</strong> -- A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.</p></li>
<li><p><strong>xTimerPeriodInTicks</strong> -- The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. The timer period must be greater than 0.</p></li>
<li><p><strong>xAutoReload</strong> -- If xAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If xAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</p></li>
<li><p><strong>pvTimerID</strong> -- An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</p></li>
<li><p><strong>pxCallbackFunction</strong> -- The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is &quot;void vCallbackFunction( TimerHandle_t xTimer );&quot;.</p></li>
<li><p><strong>pxTimerBuffer</strong> -- Must point to a variable of type StaticTimer_t, which will be then be used to hold the software timer's data structures, removing the need for the memory to be allocated dynamically.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the timer is created then a handle to the created timer is returned. If pxTimerBuffer was NULL then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417pvTimerGetTimerIDK13TimerHandle_t">
<span id="_CPPv317pvTimerGetTimerIDK13TimerHandle_t"></span><span id="_CPPv217pvTimerGetTimerIDK13TimerHandle_t"></span><span id="pvTimerGetTimerID__TimerHandle_tC"></span><span class="target" id="timers_8h_1ac2747e22330633fe57f9473f2516e3d5"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pvTimerGetTimerID</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417pvTimerGetTimerIDK13TimerHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the ID assigned to the timer.</p>
<p>IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer, and by calling the vTimerSetTimerID() API function.</p>
<p>If the same callback function is assigned to multiple timers then the timer ID can be used as time specific (timer local) storage.</p>
<p>
Example usage:</p>
<p>See the xTimerCreate() API function example usage scenario. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTimer</strong> -- The timer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The ID assigned to the timer being queried.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416vTimerSetTimerID13TimerHandle_tPv">
<span id="_CPPv316vTimerSetTimerID13TimerHandle_tPv"></span><span id="_CPPv216vTimerSetTimerID13TimerHandle_tPv"></span><span id="vTimerSetTimerID__TimerHandle_t.voidP"></span><span class="target" id="timers_8h_1a2192cd01f3ec23d9b22f736ac6431a19"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTimerSetTimerID</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvNewID</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416vTimerSetTimerID13TimerHandle_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sets the ID assigned to the timer.</p>
<p>IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer.</p>
<p>If the same callback function is assigned to multiple timers then the timer ID can be used as time specific (timer local) storage.</p>
<p>
Example usage:</p>
<p>See the xTimerCreate() API function example usage scenario. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The timer being updated.</p></li>
<li><p><strong>pvNewID</strong> -- The ID to assign to the timer.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419xTimerIsTimerActive13TimerHandle_t">
<span id="_CPPv319xTimerIsTimerActive13TimerHandle_t"></span><span id="_CPPv219xTimerIsTimerActive13TimerHandle_t"></span><span id="xTimerIsTimerActive__TimerHandle_t"></span><span class="target" id="timers_8h_1ac4a95ad98c314e2d023ff72c4ea1100e"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerIsTimerActive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xTimerIsTimerActive13TimerHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queries a timer to see if it is active or dormant.</p>
<p>A timer will be dormant if: 1) It has been created but not started, or 2) It is an expired one-shot timer that has not been restarted.</p>
<p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">//</span> <span class="n">This</span> <span class="n">function</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">xTimer</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xTimerIsTimerActive</span><span class="p">(</span> <span class="n">xTimer</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span> <span class="o">//</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">simply</span> <span class="ow">and</span> <span class="n">equivalently</span> <span class="s2">&quot;if( xTimerIsTimerActive( xTimer ) )&quot;</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="n">active</span><span class="p">,</span> <span class="n">do</span> <span class="n">something</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span>     <span class="k">else</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">active</span><span class="p">,</span> <span class="n">do</span> <span class="n">something</span> <span class="k">else</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTimer</strong> -- The timer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFALSE will be returned if the timer is dormant. A value other than pdFALSE will be returned if the timer is active.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430xTimerGetTimerDaemonTaskHandlev">
<span id="_CPPv330xTimerGetTimerDaemonTaskHandlev"></span><span id="_CPPv230xTimerGetTimerDaemonTaskHandlev"></span><span id="xTimerGetTimerDaemonTaskHandle__void"></span><span class="target" id="timers_8h_1a1fe9e235a8c27986902b71ebda7385d8"></span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerGetTimerDaemonTaskHandle</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430xTimerGetTimerDaemonTaskHandlev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Simply returns the handle of the timer service/daemon task. It it not valid to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t">
<span id="_CPPv329xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t"></span><span id="_CPPv229xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t"></span><span id="xTimerPendFunctionCallFromISR__PendedFunction_t.voidP.uint32_t.BaseType_tP"></span><span class="target" id="timers_8h_1af4444b6b1a4e8d7db156e6aaccdf66fa"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerPendFunctionCallFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416PendedFunction_t" title="PendedFunction_t"><span class="n"><span class="pre">PendedFunction_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xFunctionToPend</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvParameter1</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ulParameter2</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with 'Timer').</p>
<p>Ideally an interrupt service routine (ISR) is kept as short as possible, but sometimes an ISR either has a lot of processing to do, or needs to perform processing that is not deterministic. In these cases xTimerPendFunctionCallFromISR() can be used to defer processing of a function to the RTOS daemon task.</p>
<p>A mechanism is provided that allows the interrupt to return directly to the task that will subsequently execute the pended callback function. This allows the callback function to execute contiguously in time with the interrupt - just as if the callback had executed in the interrupt itself.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span>
<span class="o">*</span>  <span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">that</span> <span class="n">will</span> <span class="n">execute</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">context</span> <span class="n">of</span> <span class="n">the</span> <span class="n">daemon</span> <span class="n">task</span><span class="o">.</span>
<span class="o">*</span>  <span class="o">//</span> <span class="n">Note</span> <span class="n">callback</span> <span class="n">functions</span> <span class="n">must</span> <span class="nb">all</span> <span class="n">use</span> <span class="n">this</span> <span class="n">same</span> <span class="n">prototype</span><span class="o">.</span>
<span class="o">*</span>  <span class="n">void</span> <span class="n">vProcessInterface</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameter1</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">ulParameter2</span> <span class="p">)</span>
<span class="o">*</span>  <span class="p">{</span>
<span class="o">*</span>      <span class="n">BaseType_t</span> <span class="n">xInterfaceToService</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">The</span> <span class="n">interface</span> <span class="n">that</span> <span class="n">requires</span> <span class="n">servicing</span> <span class="ow">is</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">second</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">parameter</span><span class="o">.</span>  <span class="n">The</span> <span class="n">first</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span><span class="o">.</span>
<span class="o">*</span>      <span class="n">xInterfaceToService</span> <span class="o">=</span> <span class="p">(</span> <span class="n">BaseType_t</span> <span class="p">)</span> <span class="n">ulParameter2</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="o">//</span> <span class="o">...</span><span class="n">Perform</span> <span class="n">the</span> <span class="n">processing</span> <span class="n">here</span><span class="o">...</span>
<span class="o">*</span>  <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span>  <span class="o">//</span> <span class="n">An</span> <span class="n">ISR</span> <span class="n">that</span> <span class="n">receives</span> <span class="n">data</span> <span class="n">packets</span> <span class="kn">from</span> <span class="nn">multiple</span> <span class="n">interfaces</span>
<span class="o">*</span>  <span class="n">void</span> <span class="n">vAnISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="o">*</span>  <span class="p">{</span>
<span class="o">*</span>      <span class="n">BaseType_t</span> <span class="n">xInterfaceToService</span><span class="p">,</span> <span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">Query</span> <span class="n">the</span> <span class="n">hardware</span> <span class="n">to</span> <span class="n">determine</span> <span class="n">which</span> <span class="n">interface</span> <span class="n">needs</span> <span class="n">processing</span><span class="o">.</span>
<span class="o">*</span>      <span class="n">xInterfaceToService</span> <span class="o">=</span> <span class="n">prvCheckInterfaces</span><span class="p">();</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">The</span> <span class="n">actual</span> <span class="n">processing</span> <span class="ow">is</span> <span class="n">to</span> <span class="n">be</span> <span class="n">deferred</span> <span class="n">to</span> <span class="n">a</span> <span class="n">task</span><span class="o">.</span>  <span class="n">Request</span> <span class="n">the</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">vProcessInterface</span><span class="p">()</span> <span class="n">callback</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">executed</span><span class="p">,</span> <span class="n">passing</span> <span class="ow">in</span> <span class="n">the</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">that</span> <span class="n">needs</span> <span class="n">processing</span><span class="o">.</span>  <span class="n">The</span> <span class="n">interface</span> <span class="n">to</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">service</span> <span class="ow">is</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">second</span> <span class="n">parameter</span><span class="o">.</span>  <span class="n">The</span> <span class="n">first</span> <span class="n">parameter</span> <span class="ow">is</span>
<span class="o">*</span>      <span class="o">//</span> <span class="ow">not</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span><span class="o">.</span>
<span class="o">*</span>      <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
<span class="o">*</span>      <span class="n">xTimerPendFunctionCallFromISR</span><span class="p">(</span> <span class="n">vProcessInterface</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="n">xInterfaceToService</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="ow">is</span> <span class="n">now</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdTRUE</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">switch</span> <span class="n">should</span> <span class="n">be</span> <span class="n">requested</span><span class="o">.</span>  <span class="n">The</span> <span class="n">macro</span> <span class="n">used</span> <span class="ow">is</span> <span class="n">port</span> <span class="n">specific</span> <span class="ow">and</span> <span class="n">will</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">be</span> <span class="n">either</span> <span class="n">portYIELD_FROM_ISR</span><span class="p">()</span> <span class="ow">or</span> <span class="n">portEND_SWITCHING_ISR</span><span class="p">()</span> <span class="o">-</span> <span class="n">refer</span> <span class="n">to</span>
<span class="o">*</span>      <span class="o">//</span> <span class="n">the</span> <span class="n">documentation</span> <span class="n">page</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="o">.</span>
<span class="o">*</span>      <span class="n">portYIELD_FROM_ISR</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>
<span class="o">*</span>
<span class="o">*</span>  <span class="p">}</span>
<span class="o">*</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xFunctionToPend</strong> -- The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype.</p></li>
<li><p><strong>pvParameter1</strong> -- The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, unsigned longs can be cast to a void *, or the void * can be used to point to a structure.</p></li>
<li><p><strong>ulParameter2</strong> -- The value of the callback function's second parameter.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- As mentioned above, calling this function will result in a message being sent to the timer daemon task. If the priority of the timer daemon task (which is set using configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE within xTimerPendFunctionCallFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t">
<span id="_CPPv322xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t"></span><span id="_CPPv222xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t"></span><span id="xTimerPendFunctionCall__PendedFunction_t.voidP.uint32_t.TickType_t"></span><span class="target" id="timers_8h_1a5df6d08740c1184489440072246a02f2"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerPendFunctionCall</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416PendedFunction_t" title="PendedFunction_t"><span class="n"><span class="pre">PendedFunction_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xFunctionToPend</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvParameter1</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ulParameter2</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Used to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with 'Timer').</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xFunctionToPend</strong> -- The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype.</p></li>
<li><p><strong>pvParameter1</strong> -- The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, unsigned longs can be cast to a void *, or the void * can be used to point to a structure.</p></li>
<li><p><strong>ulParameter2</strong> -- The value of the callback function's second parameter.</p></li>
<li><p><strong>xTicksToWait</strong> -- Calling this function will result in a message being sent to the timer daemon task on a queue. xTicksToWait is the amount of time the calling task should remain in the Blocked state (so not using any processing time) for space to become available on the timer queue if the queue is found to be full.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414pcTimerGetName13TimerHandle_t">
<span id="_CPPv314pcTimerGetName13TimerHandle_t"></span><span id="_CPPv214pcTimerGetName13TimerHandle_t"></span><span id="pcTimerGetName__TimerHandle_t"></span><span class="target" id="timers_8h_1a6967093b6b936d267d5d332490f61f67"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcTimerGetName</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414pcTimerGetName13TimerHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the name that was assigned to a timer when the timer was created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTimer</strong> -- The handle of the timer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The name assigned to the timer specified by the xTimer parameter. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419vTimerSetReloadMode13TimerHandle_tK10BaseType_t">
<span id="_CPPv319vTimerSetReloadMode13TimerHandle_tK10BaseType_t"></span><span id="_CPPv219vTimerSetReloadMode13TimerHandle_tK10BaseType_t"></span><span id="vTimerSetReloadMode__TimerHandle_t.BaseType_tC"></span><span class="target" id="timers_8h_1a7640ba25a6dcd983ba1977546bcc4890"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTimerSetReloadMode</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xAutoReload</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419vTimerSetReloadMode13TimerHandle_tK10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Updates a timer to be either an auto-reload timer, in which case the timer automatically resets itself each time it expires, or a one-shot timer, in which case the timer will only expire once unless it is manually restarted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer being updated.</p></li>
<li><p><strong>xAutoReload</strong> -- If xAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the timer's period (see the xTimerPeriodInTicks parameter of the xTimerCreate() API function). If xAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419xTimerGetReloadMode13TimerHandle_t">
<span id="_CPPv319xTimerGetReloadMode13TimerHandle_t"></span><span id="_CPPv219xTimerGetReloadMode13TimerHandle_t"></span><span id="xTimerGetReloadMode__TimerHandle_t"></span><span class="target" id="timers_8h_1ae27812a9a18910b6ba5bf4b8b5fd9e13"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerGetReloadMode</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xTimerGetReloadMode13TimerHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queries a timer to determine if it is an auto-reload timer, in which case the timer automatically resets itself each time it expires, or a one-shot timer, in which case the timer will only expire once unless it is manually restarted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTimer</strong> -- The handle of the timer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the timer is an auto-reload timer then pdTRUE is returned, otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420uxTimerGetReloadMode13TimerHandle_t">
<span id="_CPPv320uxTimerGetReloadMode13TimerHandle_t"></span><span id="_CPPv220uxTimerGetReloadMode13TimerHandle_t"></span><span id="uxTimerGetReloadMode__TimerHandle_t"></span><span class="target" id="timers_8h_1ae281f6088f74deabbad629db94bc7a0e"></span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uxTimerGetReloadMode</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420uxTimerGetReloadMode13TimerHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queries a timer to determine if it is an auto-reload timer, in which case the timer automatically resets itself each time it expires, or a one-shot timer, in which case the timer will only expire once unless it is manually restarted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTimer</strong> -- The handle of the timer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the timer is an auto-reload timer then pdTRUE is returned, otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415xTimerGetPeriod13TimerHandle_t">
<span id="_CPPv315xTimerGetPeriod13TimerHandle_t"></span><span id="_CPPv215xTimerGetPeriod13TimerHandle_t"></span><span id="xTimerGetPeriod__TimerHandle_t"></span><span class="target" id="timers_8h_1aaf2738cf9e595b223683962afa9efb49"></span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerGetPeriod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xTimerGetPeriod13TimerHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the period of a timer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTimer</strong> -- The handle of the timer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The period of the timer in ticks. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419xTimerGetExpiryTime13TimerHandle_t">
<span id="_CPPv319xTimerGetExpiryTime13TimerHandle_t"></span><span id="_CPPv219xTimerGetExpiryTime13TimerHandle_t"></span><span id="xTimerGetExpiryTime__TimerHandle_t"></span><span class="target" id="timers_8h_1ab1fb26f1672c65763cccc8c2cf276d07"></span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerGetExpiryTime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xTimerGetExpiryTime13TimerHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the time in ticks at which the timer will expire. If this is less than the current tick count then the expiry time has overflowed from the current time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTimer</strong> -- The handle of the timer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the timer is running then the time in ticks at which the timer will next expire is returned. If the timer is not running then the return value is undefined. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421xTimerGetStaticBuffer13TimerHandle_tPP13StaticTimer_t">
<span id="_CPPv321xTimerGetStaticBuffer13TimerHandle_tPP13StaticTimer_t"></span><span id="_CPPv221xTimerGetStaticBuffer13TimerHandle_tPP13StaticTimer_t"></span><span id="xTimerGetStaticBuffer__TimerHandle_t.StaticTimer_tPP"></span><span class="target" id="timers_8h_1a32923f505dd2166bfc8b0caea9159159"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTimerGetStaticBuffer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">StaticTimer_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppxTimerBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421xTimerGetStaticBuffer13TimerHandle_tPP13StaticTimer_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve pointer to a statically created timer's data structure buffer. This is the same buffer that is supplied at the time of creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The timer for which to retrieve the buffer.</p></li>
<li><p><strong>ppxTimerBuffer</strong> -- Used to return a pointer to the timers's data structure buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the buffer was retrieved, pdFALSE otherwise. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430vApplicationGetTimerTaskMemoryPP12StaticTask_tPP11StackType_tP8uint32_t">
<span id="_CPPv330vApplicationGetTimerTaskMemoryPP12StaticTask_tPP11StackType_tP8uint32_t"></span><span id="_CPPv230vApplicationGetTimerTaskMemoryPP12StaticTask_tPP11StackType_tP8uint32_t"></span><span id="vApplicationGetTimerTaskMemory__StaticTask_tPP.StackType_tPP.uint32_tP"></span><span class="target" id="timers_8h_1a1e80ecbd3fc2d04f18d6409ffa893a86"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vApplicationGetTimerTaskMemory</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">StaticTask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppxTimerTaskTCBBuffer</span></span>, <span class="n"><span class="pre">StackType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppxTimerTaskStackBuffer</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulTimerTaskStackSize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430vApplicationGetTimerTaskMemoryPP12StaticTask_tPP11StackType_tP8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Timer Task TCB. This function is required when configSUPPORT_STATIC_ALLOCATION is set. For more information see this URI: <a class="reference external" href="https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION">https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ppxTimerTaskTCBBuffer</strong> -- A handle to a statically allocated TCB buffer </p></li>
<li><p><strong>ppxTimerTaskStackBuffer</strong> -- A handle to a statically allocated Stack buffer for the idle task </p></li>
<li><p><strong>pulTimerTaskStackSize</strong> -- A pointer to the number of elements that will fit in the allocated stack buffer </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="id10">
<h3>Macros<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTimerStart">
<span class="target" id="timers_8h_1a3a9b838f48991e852ce05c986b0eeb8c"></span><span class="sig-name descname"><span class="n"><span class="pre">xTimerStart</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerStart" title="Permalink to this definition"></a><br /></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerStart() starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerStart() has equivalent functionality to the xTimerReset() API function.</p>
<p>Starting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after xTimerStart() was called, where 'n' is the timers defined period.</p>
<p>It is valid to call xTimerStart() before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when xTimerStart() was called.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart() to be available.</p>
<p>
Example usage:</p>
<p>See the xTimerCreate() API function example usage scenario. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer being started/restarted.</p></li>
<li><p><strong>xTicksToWait</strong> -- Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the start command to be successfully sent to the timer command queue, should the queue already be full when xTimerStart() was called. xTicksToWait is ignored if xTimerStart() is called before the scheduler is started.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFAIL will be returned if the start command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTimerStop">
<span class="target" id="timers_8h_1a8327c7fc10aee414cb163b445c5269a4"></span><span class="sig-name descname"><span class="n"><span class="pre">xTimerStop</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerStop" title="Permalink to this definition"></a><br /></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerStop() stops a timer that was previously started using either of the The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() or xTimerChangePeriodFromISR() API functions.</p>
<p>Stopping a timer ensures the timer is not in the active state.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop() to be available.</p>
<p>
Example usage:</p>
<p>See the xTimerCreate() API function example usage scenario. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer being stopped.</p></li>
<li><p><strong>xTicksToWait</strong> -- Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the stop command to be successfully sent to the timer command queue, should the queue already be full when xTimerStop() was called. xTicksToWait is ignored if xTimerStop() is called before the scheduler is started.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFAIL will be returned if the stop command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTimerChangePeriod">
<span class="target" id="timers_8h_1ab12eac1c69a3437b8161ce81ff34b2f4"></span><span class="sig-name descname"><span class="n"><span class="pre">xTimerChangePeriod</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">xNewPeriod</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerChangePeriod" title="Permalink to this definition"></a><br /></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerChangePeriod() changes the period of a timer that was previously created using the xTimerCreate() API function.</p>
<p>xTimerChangePeriod() can be called to change the period of an active or dormant state timer.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerChangePeriod() to be available.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">//</span> <span class="n">This</span> <span class="n">function</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">timer</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">referenced</span> <span class="n">by</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">active</span> <span class="n">when</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">called</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">timer</span>
<span class="o">*</span> <span class="o">//</span> <span class="ow">is</span> <span class="n">deleted</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">referenced</span> <span class="n">by</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">active</span> <span class="n">when</span> <span class="n">it</span> <span class="ow">is</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">called</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="nb">set</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">started</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">xTimer</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xTimerIsTimerActive</span><span class="p">(</span> <span class="n">xTimer</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span> <span class="o">//</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">simply</span> <span class="ow">and</span> <span class="n">equivalently</span> <span class="s2">&quot;if( xTimerIsTimerActive( xTimer ) )&quot;</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">active</span> <span class="o">-</span> <span class="n">delete</span> <span class="n">it</span><span class="o">.</span>
<span class="o">*</span>         <span class="n">xTimerDelete</span><span class="p">(</span> <span class="n">xTimer</span> <span class="p">);</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span>     <span class="k">else</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">active</span><span class="p">,</span> <span class="n">change</span> <span class="n">its</span> <span class="n">period</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>  <span class="n">This</span> <span class="n">will</span> <span class="n">also</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">to</span> <span class="n">start</span><span class="o">.</span>  <span class="n">Block</span> <span class="k">for</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">of</span> <span class="mi">100</span> <span class="n">ticks</span> <span class="k">if</span> <span class="n">the</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">change</span> <span class="n">period</span> <span class="n">command</span> <span class="n">cannot</span> <span class="n">immediately</span> <span class="n">be</span> <span class="n">sent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">timer</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">command</span> <span class="n">queue</span><span class="o">.</span>
<span class="o">*</span>         <span class="k">if</span><span class="p">(</span> <span class="n">xTimerChangePeriod</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="mi">500</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span> <span class="o">==</span> <span class="n">pdPASS</span> <span class="p">)</span>
<span class="o">*</span>         <span class="p">{</span>
<span class="o">*</span>             <span class="o">//</span> <span class="n">The</span> <span class="n">command</span> <span class="n">was</span> <span class="n">successfully</span> <span class="n">sent</span><span class="o">.</span>
<span class="o">*</span>         <span class="p">}</span>
<span class="o">*</span>         <span class="k">else</span>
<span class="o">*</span>         <span class="p">{</span>
<span class="o">*</span>             <span class="o">//</span> <span class="n">The</span> <span class="n">command</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">sent</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="n">waiting</span> <span class="k">for</span> <span class="mi">100</span> <span class="n">ticks</span>
<span class="o">*</span>             <span class="o">//</span> <span class="n">to</span> <span class="k">pass</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>         <span class="p">}</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer that is having its period changed.</p></li>
<li><p><strong>xNewPeriod</strong> -- The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</p></li>
<li><p><strong>xTicksToWait</strong> -- Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the change period command to be successfully sent to the timer command queue, should the queue already be full when xTimerChangePeriod() was called. xTicksToWait is ignored if xTimerChangePeriod() is called before the scheduler is started.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFAIL will be returned if the change period command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTimerDelete">
<span class="target" id="timers_8h_1a8c8e21f05ebe92e15449addc5d269d10"></span><span class="sig-name descname"><span class="n"><span class="pre">xTimerDelete</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerDelete" title="Permalink to this definition"></a><br /></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerDelete() deletes a timer that was previously created using the xTimerCreate() API function.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerDelete() to be available.</p>
<p>
Example usage:</p>
<p>See the xTimerChangePeriod() API function example usage scenario. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer being deleted.</p></li>
<li><p><strong>xTicksToWait</strong> -- Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the delete command to be successfully sent to the timer command queue, should the queue already be full when xTimerDelete() was called. xTicksToWait is ignored if xTimerDelete() is called before the scheduler is started.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFAIL will be returned if the delete command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTimerReset">
<span class="target" id="timers_8h_1a8081b4541b752908dc55df2693e53287"></span><span class="sig-name descname"><span class="n"><span class="pre">xTimerReset</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerReset" title="Permalink to this definition"></a><br /></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerReset() re-starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerReset() will cause the timer to re-evaluate its expiry time so that it is relative to when xTimerReset() was called. If the timer was in the dormant state then xTimerReset() has equivalent functionality to the xTimerStart() API function.</p>
<p>Resetting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after xTimerReset() was called, where 'n' is the timers defined period.</p>
<p>It is valid to call xTimerReset() before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when xTimerReset() was called.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset() to be available.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">//</span> <span class="n">When</span> <span class="n">a</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">an</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">on</span><span class="o">.</span>  <span class="n">If</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">pass</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">without</span> <span class="n">a</span> <span class="n">key</span> <span class="n">being</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">off</span><span class="o">.</span>  <span class="n">In</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">this</span> <span class="n">case</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>
<span class="o">*</span>
<span class="o">*</span> <span class="n">TimerHandle_t</span> <span class="n">xBacklightTimer</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">the</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vBacklightTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">pxTimer</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">expired</span><span class="p">,</span> <span class="n">therefore</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">must</span> <span class="n">have</span> <span class="n">passed</span> <span class="n">since</span> <span class="n">a</span> <span class="n">key</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">was</span> <span class="n">pressed</span><span class="o">.</span>  <span class="n">Switch</span> <span class="n">off</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_OFF</span> <span class="p">);</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">The</span> <span class="n">key</span> <span class="n">press</span> <span class="n">event</span> <span class="n">handler</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vKeyPressEventHandler</span><span class="p">(</span> <span class="n">char</span> <span class="n">cKey</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Ensure</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">on</span><span class="p">,</span> <span class="n">then</span> <span class="n">reset</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">of</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">key</span> <span class="n">inactivity</span><span class="o">.</span>  <span class="n">Wait</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">the</span> <span class="n">command</span> <span class="n">to</span> <span class="n">be</span> <span class="n">successfully</span> <span class="n">sent</span>
<span class="o">*</span>     <span class="o">//</span> <span class="k">if</span> <span class="n">it</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">sent</span> <span class="n">immediately</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_ON</span> <span class="p">);</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xTimerReset</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">The</span> <span class="n">reset</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">key</span> <span class="n">processing</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span> <span class="n">int32_t</span> <span class="n">x</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Create</span> <span class="n">then</span> <span class="n">start</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="k">if</span> <span class="n">no</span> <span class="n">keys</span> <span class="n">are</span> <span class="n">pressed</span> <span class="n">within</span> <span class="n">a</span> <span class="mi">5</span> <span class="n">second</span> <span class="n">period</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">xBacklightTimer</span> <span class="o">=</span> <span class="n">xTimerCreate</span><span class="p">(</span> <span class="s2">&quot;BacklightTimer&quot;</span><span class="p">,</span>           <span class="o">//</span> <span class="n">Just</span> <span class="n">a</span> <span class="n">text</span> <span class="n">name</span><span class="p">,</span> <span class="ow">not</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">kernel</span><span class="o">.</span>
<span class="o">*</span>                                     <span class="p">(</span> <span class="mi">5000</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">),</span> <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">period</span> <span class="ow">in</span> <span class="n">ticks</span><span class="o">.</span>
<span class="o">*</span>                                     <span class="n">pdFALSE</span><span class="p">,</span>                    <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>
<span class="o">*</span>                                     <span class="mi">0</span><span class="p">,</span>                          <span class="o">//</span> <span class="n">The</span> <span class="nb">id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">callback</span> <span class="n">so</span> <span class="n">can</span> <span class="n">take</span> <span class="nb">any</span> <span class="n">value</span><span class="o">.</span>
<span class="o">*</span>                                     <span class="n">vBacklightTimerCallback</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">that</span> <span class="n">switches</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span><span class="o">.</span>
<span class="o">*</span>                                   <span class="p">);</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xBacklightTimer</span> <span class="o">==</span> <span class="n">NULL</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">created</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span>     <span class="k">else</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">Start</span> <span class="n">the</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">No</span> <span class="n">block</span> <span class="n">time</span> <span class="ow">is</span> <span class="n">specified</span><span class="p">,</span> <span class="ow">and</span> <span class="n">even</span> <span class="k">if</span> <span class="n">one</span> <span class="n">was</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">it</span> <span class="n">would</span> <span class="n">be</span> <span class="n">ignored</span> <span class="n">because</span> <span class="n">the</span> <span class="n">scheduler</span> <span class="n">has</span> <span class="ow">not</span> <span class="n">yet</span> <span class="n">been</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">started</span><span class="o">.</span>
<span class="o">*</span>         <span class="k">if</span><span class="p">(</span> <span class="n">xTimerStart</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
<span class="o">*</span>         <span class="p">{</span>
<span class="o">*</span>             <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">into</span> <span class="n">the</span> <span class="n">Active</span> <span class="n">state</span><span class="o">.</span>
<span class="o">*</span>         <span class="p">}</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="o">...</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Create</span> <span class="n">tasks</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>     <span class="o">//</span> <span class="o">...</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Starting</span> <span class="n">the</span> <span class="n">scheduler</span> <span class="n">will</span> <span class="n">start</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">running</span> <span class="k">as</span> <span class="n">it</span> <span class="n">has</span> <span class="n">already</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">into</span> <span class="n">the</span> <span class="n">active</span> <span class="n">state</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">vTaskStartScheduler</span><span class="p">();</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Should</span> <span class="ow">not</span> <span class="n">reach</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">);</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer being reset/started/restarted.</p></li>
<li><p><strong>xTicksToWait</strong> -- Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the reset command to be successfully sent to the timer command queue, should the queue already be full when xTimerReset() was called. xTicksToWait is ignored if xTimerReset() is called before the scheduler is started.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFAIL will be returned if the reset command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTimerStartFromISR">
<span class="target" id="timers_8h_1adab5809f9679e44a343b8dbb8fb7c67f"></span><span class="sig-name descname"><span class="n"><span class="pre">xTimerStartFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerStartFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xTimerStart() that can be called from an interrupt service routine.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xBacklightTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">When</span> <span class="n">a</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">an</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">on</span><span class="o">.</span>  <span class="n">If</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">pass</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">without</span> <span class="n">a</span> <span class="n">key</span> <span class="n">being</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">off</span><span class="o">.</span>  <span class="n">In</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">this</span> <span class="n">case</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="p">,</span> <span class="ow">and</span> <span class="n">unlike</span> <span class="n">the</span> <span class="n">example</span> <span class="n">given</span> <span class="k">for</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">the</span> <span class="n">xTimerReset</span><span class="p">()</span> <span class="n">function</span><span class="p">,</span> <span class="n">the</span> <span class="n">key</span> <span class="n">press</span> <span class="n">event</span> <span class="n">handler</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">the</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vBacklightTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">pxTimer</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">expired</span><span class="p">,</span> <span class="n">therefore</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">must</span> <span class="n">have</span> <span class="n">passed</span> <span class="n">since</span> <span class="n">a</span> <span class="n">key</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">was</span> <span class="n">pressed</span><span class="o">.</span>  <span class="n">Switch</span> <span class="n">off</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_OFF</span> <span class="p">);</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">The</span> <span class="n">key</span> <span class="n">press</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vKeyPressEventInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span> <span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Ensure</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">on</span><span class="p">,</span> <span class="n">then</span> <span class="n">restart</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">of</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">key</span> <span class="n">inactivity</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">so</span> <span class="n">can</span> <span class="n">only</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">call</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">&quot;FromISR&quot;</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_ON</span> <span class="p">);</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">xTimerStartFromISR</span><span class="p">()</span> <span class="ow">or</span> <span class="n">xTimerResetFromISR</span><span class="p">()</span> <span class="n">could</span> <span class="n">be</span> <span class="n">called</span> <span class="n">here</span>
<span class="o">*</span>     <span class="o">//</span> <span class="k">as</span> <span class="n">both</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">to</span> <span class="n">re</span><span class="o">-</span><span class="n">calculate</span> <span class="n">its</span> <span class="n">expiry</span> <span class="n">time</span><span class="o">.</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="n">initialised</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">when</span> <span class="n">it</span> <span class="n">was</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">declared</span> <span class="p">(</span><span class="ow">in</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xTimerStartFromISR</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">The</span> <span class="n">start</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">key</span> <span class="n">processing</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
<span class="o">*</span>     <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer being started/restarted.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStartFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStartFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStartFromISR() function. If xTimerStartFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFAIL will be returned if the start command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStartFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTimerStopFromISR">
<span class="target" id="timers_8h_1aef0f53e7ecfaa881621da83d61072db7"></span><span class="sig-name descname"><span class="n"><span class="pre">xTimerStopFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerStopFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xTimerStop() that can be called from an interrupt service routine.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">started</span><span class="o">.</span>  <span class="n">When</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">occurs</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">should</span> <span class="n">be</span> <span class="n">simply</span> <span class="n">stopped</span><span class="o">.</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">that</span> <span class="n">stops</span> <span class="n">the</span> <span class="n">timer</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vAnExampleInterruptServiceRoutine</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span> <span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">has</span> <span class="n">occurred</span> <span class="o">-</span> <span class="n">simply</span> <span class="n">stop</span> <span class="n">the</span> <span class="n">timer</span><span class="o">.</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">where</span> <span class="n">it</span> <span class="n">was</span> <span class="n">defined</span>
<span class="o">*</span>     <span class="o">//</span> <span class="p">(</span><span class="n">within</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>  <span class="n">As</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="p">,</span> <span class="n">only</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">&quot;FromISR&quot;</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xTimerStopFromISR</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">The</span> <span class="n">stop</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
<span class="o">*</span>     <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer being stopped.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStopFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStopFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStopFromISR() function. If xTimerStopFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFAIL will be returned if the stop command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTimerChangePeriodFromISR">
<span class="target" id="timers_8h_1a6d89ca6afb6e692e98932b5038c9e14a"></span><span class="sig-name descname"><span class="n"><span class="pre">xTimerChangePeriodFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">xNewPeriod</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerChangePeriodFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xTimerChangePeriod() that can be called from an interrupt service routine.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">started</span><span class="o">.</span>  <span class="n">When</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">occurs</span><span class="p">,</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">xTimer</span> <span class="n">should</span> <span class="n">be</span> <span class="n">changed</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">that</span> <span class="n">changes</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">xTimer</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vAnExampleInterruptServiceRoutine</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span> <span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">has</span> <span class="n">occurred</span> <span class="o">-</span> <span class="n">change</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">xTimer</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">where</span> <span class="n">it</span> <span class="n">was</span> <span class="n">defined</span>
<span class="o">*</span>     <span class="o">//</span> <span class="p">(</span><span class="n">within</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>  <span class="n">As</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="p">,</span> <span class="n">only</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">&quot;FromISR&quot;</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xTimerChangePeriodFromISR</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">The</span> <span class="n">command</span> <span class="n">to</span> <span class="n">change</span> <span class="n">the</span> <span class="n">timers</span> <span class="n">period</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
<span class="o">*</span>     <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer that is having its period changed.</p></li>
<li><p><strong>xNewPeriod</strong> -- The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerChangePeriodFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/ daemon task out of the Blocked state. If calling xTimerChangePeriodFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerChangePeriodFromISR() function. If xTimerChangePeriodFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFAIL will be returned if the command to change the timers period could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xTimerResetFromISR">
<span class="target" id="timers_8h_1a448138d0cebf76044f107ca56c842230"></span><span class="sig-name descname"><span class="n"><span class="pre">xTimerResetFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xTimer</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerResetFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xTimerReset() that can be called from an interrupt service routine.</p>
<p>
Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xBacklightTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">When</span> <span class="n">a</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">an</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">on</span><span class="o">.</span>  <span class="n">If</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">pass</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">without</span> <span class="n">a</span> <span class="n">key</span> <span class="n">being</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">off</span><span class="o">.</span>  <span class="n">In</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">this</span> <span class="n">case</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="p">,</span> <span class="ow">and</span> <span class="n">unlike</span> <span class="n">the</span> <span class="n">example</span> <span class="n">given</span> <span class="k">for</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">the</span> <span class="n">xTimerReset</span><span class="p">()</span> <span class="n">function</span><span class="p">,</span> <span class="n">the</span> <span class="n">key</span> <span class="n">press</span> <span class="n">event</span> <span class="n">handler</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">the</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vBacklightTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">pxTimer</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">expired</span><span class="p">,</span> <span class="n">therefore</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">must</span> <span class="n">have</span> <span class="n">passed</span> <span class="n">since</span> <span class="n">a</span> <span class="n">key</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">was</span> <span class="n">pressed</span><span class="o">.</span>  <span class="n">Switch</span> <span class="n">off</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_OFF</span> <span class="p">);</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span> <span class="o">//</span> <span class="n">The</span> <span class="n">key</span> <span class="n">press</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>
<span class="o">*</span> <span class="n">void</span> <span class="n">vKeyPressEventInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="o">*</span> <span class="p">{</span>
<span class="o">*</span> <span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Ensure</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">on</span><span class="p">,</span> <span class="n">then</span> <span class="n">reset</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">of</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">key</span> <span class="n">inactivity</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">so</span> <span class="n">can</span> <span class="n">only</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">call</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">&quot;FromISR&quot;</span><span class="o">.</span>
<span class="o">*</span>     <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_ON</span> <span class="p">);</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">xTimerStartFromISR</span><span class="p">()</span> <span class="ow">or</span> <span class="n">xTimerResetFromISR</span><span class="p">()</span> <span class="n">could</span> <span class="n">be</span> <span class="n">called</span> <span class="n">here</span>
<span class="o">*</span>     <span class="o">//</span> <span class="k">as</span> <span class="n">both</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">to</span> <span class="n">re</span><span class="o">-</span><span class="n">calculate</span> <span class="n">its</span> <span class="n">expiry</span> <span class="n">time</span><span class="o">.</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="n">initialised</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">when</span> <span class="n">it</span> <span class="n">was</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">declared</span> <span class="p">(</span><span class="ow">in</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xTimerResetFromISR</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">The</span> <span class="n">reset</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">key</span> <span class="n">processing</span> <span class="n">here</span><span class="o">.</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
<span class="o">*</span>     <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
<span class="o">*</span>     <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
<span class="o">*</span>     <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
<span class="o">*</span>     <span class="p">{</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
<span class="o">*</span>         <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
<span class="o">*</span>     <span class="p">}</span>
<span class="o">*</span> <span class="p">}</span>
<span class="o">*</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTimer</strong> -- The handle of the timer that is to be started, reset, or restarted.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerResetFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerResetFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerResetFromISR() function. If xTimerResetFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdFAIL will be returned if the reset command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerResetFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id11">
<h3>Type Definitions<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv413TimerHandle_t">
<span id="_CPPv313TimerHandle_t"></span><span id="_CPPv213TimerHandle_t"></span><span id="TimerHandle_t"></span><span class="target" id="timers_8h_1ae2aa96927b4806e5dcfd264ba7bc8bf6"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">tmrTimerControl</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">TimerHandle_t</span></span></span><a class="headerlink" href="#_CPPv413TimerHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv423TimerCallbackFunction_t">
<span id="_CPPv323TimerCallbackFunction_t"></span><span id="_CPPv223TimerCallbackFunction_t"></span><span id="TimerCallbackFunction_t"></span><span class="target" id="timers_8h_1a5cf6d1f61ccd4871022ed8ad454c6027"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">TimerCallbackFunction_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t"><span class="n"><span class="pre">TimerHandle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">xTimer</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv423TimerCallbackFunction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Defines the prototype to which timer callback functions must conform. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv416PendedFunction_t">
<span id="_CPPv316PendedFunction_t"></span><span id="_CPPv216PendedFunction_t"></span><span id="PendedFunction_t"></span><span class="target" id="timers_8h_1af6e8e2be58df2be9f9bb808fcdc51622"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PendedFunction_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv416PendedFunction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Defines the prototype to which functions used with the xTimerPendFunctionCallFromISR() function must conform. </p>
</dd></dl>

</section>
<section id="event-group-api">
<h3>Event Group API<a class="headerlink" href="#event-group-api" title="Permalink to this heading"></a></h3>
</section>
<section id="id12">
<h3>Header File<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/freertos/FreeRTOS-Kernel/include/freertos/event_groups.h">components/freertos/FreeRTOS-Kernel/include/freertos/event_groups.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/event_groups.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id13">
<h3>Functions<a class="headerlink" href="#id13" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417xEventGroupCreatev">
<span id="_CPPv317xEventGroupCreatev"></span><span id="_CPPv217xEventGroupCreatev"></span><span id="xEventGroupCreate__void"></span><span class="target" id="event__groups_8h_1a2e8622ce280fff2f60ad867dff0a4519"></span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupCreate</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xEventGroupCreatev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a new event group.</p>
<p>Internally, within the FreeRTOS implementation, event groups use a [small] block of memory, in which the event group's structure is stored. If an event groups is created using xEventGroupCreate() then the required memory is automatically dynamically allocated inside the xEventGroupCreate() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If an event group is created using xEventGroupCreateStatic() then the application writer must instead provide the memory that will get used by the event group. xEventGroupCreateStatic() therefore allows an event group to be created without using any dynamic memory allocation.</p>
<p>Although event groups are not related to ticks, for internal implementation reasons the number of bits available for use in an event group is dependent on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h. If configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit 0 to bit 7). If configUSE_16_BIT_TICKS is set to 0 then each event group has 24 usable bits (bit 0 to bit 23). The EventBits_t type is used to store event bits within an event group.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declare a variable to hold the created event group.</span>
<span class="n">EventGroupHandle_t</span><span class="w"> </span><span class="n">xCreatedEventGroup</span><span class="p">;</span>

<span class="c1">// Attempt to create the event group.</span>
<span class="n">xCreatedEventGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xEventGroupCreate</span><span class="p">();</span>

<span class="c1">// Was the event group created successfully?</span>
<span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xCreatedEventGroup</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// The event group was not created because there was insufficient</span>
<span class="w">    </span><span class="c1">// FreeRTOS heap available.</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// The event group was created.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If the event group was created then a handle to the event group is returned. If there was insufficient FreeRTOS heap available to create the event group then NULL is returned. See <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423xEventGroupCreateStaticP18StaticEventGroup_t">
<span id="_CPPv323xEventGroupCreateStaticP18StaticEventGroup_t"></span><span id="_CPPv223xEventGroupCreateStaticP18StaticEventGroup_t"></span><span id="xEventGroupCreateStatic__StaticEventGroup_tP"></span><span class="target" id="event__groups_8h_1a9d922720db6c6824907263c274fe52c0"></span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupCreateStatic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">StaticEventGroup_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxEventGroupBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423xEventGroupCreateStaticP18StaticEventGroup_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a new event group.</p>
<p>Internally, within the FreeRTOS implementation, event groups use a [small] block of memory, in which the event group's structure is stored. If an event groups is created using xEventGroupCreate() then the required memory is automatically dynamically allocated inside the xEventGroupCreate() function. (see <a class="reference external" href="https://www.FreeRTOS.org/a00111.html">https://www.FreeRTOS.org/a00111.html</a>). If an event group is created using xEventGroupCreateStatic() then the application writer must instead provide the memory that will get used by the event group. xEventGroupCreateStatic() therefore allows an event group to be created without using any dynamic memory allocation.</p>
<p>Although event groups are not related to ticks, for internal implementation reasons the number of bits available for use in an event group is dependent on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h. If configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit 0 to bit 7). If configUSE_16_BIT_TICKS is set to 0 then each event group has 24 usable bits (bit 0 to bit 23). The EventBits_t type is used to store event bits within an event group.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// StaticEventGroup_t is a publicly accessible structure that has the same</span>
<span class="c1">// size and alignment requirements as the real event group structure.  It is</span>
<span class="c1">// provided as a mechanism for applications to know the size of the event</span>
<span class="c1">// group (which is dependent on the architecture and configuration file</span>
<span class="c1">// settings) without breaking the strict data hiding policy by exposing the</span>
<span class="c1">// real event group internals.  This StaticEventGroup_t variable is passed</span>
<span class="c1">// into the xSemaphoreCreateEventGroupStatic() function and is used to store</span>
<span class="c1">// the event group&#39;s data structures</span>
<span class="n">StaticEventGroup_t</span><span class="w"> </span><span class="n">xEventGroupBuffer</span><span class="p">;</span>

<span class="c1">// Create the event group without dynamically allocating any memory.</span>
<span class="n">xEventGroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xEventGroupCreateStatic</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xEventGroupBuffer</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pxEventGroupBuffer</strong> -- pxEventGroupBuffer must point to a variable of type StaticEventGroup_t, which will be then be used to hold the event group's data structures, removing the need for the memory to be allocated dynamically.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the event group was created then a handle to the event group is returned. If pxEventGroupBuffer was NULL then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t">
<span id="_CPPv319xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t"></span><span id="_CPPv219xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t"></span><span id="xEventGroupWaitBits__EventGroupHandle_t.EventBits_tC.BaseType_tC.BaseType_tC.TickType_t"></span><span class="target" id="event__groups_8h_1a379c5cca4552d3d8acd4c51e8220a6c3"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupWaitBits</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xEventGroup</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">uxBitsToWaitFor</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xClearOnExit</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xWaitForAllBits</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>[Potentially] block to wait for one or more bits to be set within a previously created event group.</p>
<p>This function cannot be called from an interrupt.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BIT_0 ( 1 &lt;&lt; 0 )</span>
<span class="cp">#define BIT_4 ( 1 &lt;&lt; 4 )</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">aFunction</span><span class="p">(</span><span class="w"> </span><span class="n">EventGroupHandle_t</span><span class="w"> </span><span class="n">xEventGroup</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span><span class="w"> </span><span class="n">uxBits</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">portTICK_PERIOD_MS</span><span class="p">;</span>

<span class="w">     </span><span class="c1">// Wait a maximum of 100ms for either bit 0 or bit 4 to be set within</span>
<span class="w">     </span><span class="c1">// the event group.  Clear the bits before exiting.</span>
<span class="w">     </span><span class="n">uxBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xEventGroupWaitBits</span><span class="p">(</span>
<span class="w">                 </span><span class="n">xEventGroup</span><span class="p">,</span><span class="w">    </span><span class="c1">// The event group being tested.</span>
<span class="w">                 </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="p">,</span><span class="w">  </span><span class="c1">// The bits within the event group to wait for.</span>
<span class="w">                 </span><span class="n">pdTRUE</span><span class="p">,</span><span class="w">         </span><span class="c1">// BIT_0 and BIT_4 should be cleared before returning.</span>
<span class="w">                 </span><span class="n">pdFALSE</span><span class="p">,</span><span class="w">        </span><span class="c1">// Don&#39;t wait for both bits, either bit will do.</span>
<span class="w">                 </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// Wait a maximum of 100ms for either bit to be set.</span>

<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// xEventGroupWaitBits() returned because both bits were set.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BIT_0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// xEventGroupWaitBits() returned because just BIT_0 was set.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// xEventGroupWaitBits() returned because just BIT_4 was set.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// xEventGroupWaitBits() returned because xTicksToWait ticks passed</span>
<span class="w">         </span><span class="c1">// without either BIT_0 or BIT_4 becoming set.</span>
<span class="w">     </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xEventGroup</strong> -- The event group in which the bits are being tested. The event group must have previously been created using a call to xEventGroupCreate().</p></li>
<li><p><strong>uxBitsToWaitFor</strong> -- A bitwise value that indicates the bit or bits to test inside the event group. For example, to wait for bit 0 and/or bit 2 set uxBitsToWaitFor to 0x05. To wait for bits 0 and/or bit 1 and/or bit 2 set uxBitsToWaitFor to 0x07. Etc.</p></li>
<li><p><strong>xClearOnExit</strong> -- If xClearOnExit is set to pdTRUE then any bits within uxBitsToWaitFor that are set within the event group will be cleared before xEventGroupWaitBits() returns if the wait condition was met (if the function returns for a reason other than a timeout). If xClearOnExit is set to pdFALSE then the bits set in the event group are not altered when the call to xEventGroupWaitBits() returns.</p></li>
<li><p><strong>xWaitForAllBits</strong> -- If xWaitForAllBits is set to pdTRUE then xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor are set or the specified block time expires. If xWaitForAllBits is set to pdFALSE then xEventGroupWaitBits() will return when any one of the bits set in uxBitsToWaitFor is set or the specified block time expires. The block time is specified by the xTicksToWait parameter.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time (specified in 'ticks') to wait for one/all (depending on the xWaitForAllBits value) of the bits specified by uxBitsToWaitFor to become set. A value of portMAX_DELAY can be used to block indefinitely (provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the event group at the time either the bits being waited for became set, or the block time expired. Test the return value to know which bits were set. If xEventGroupWaitBits() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupWaitBits() returned because the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared in the case that xClearOnExit parameter was set to pdTRUE.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420xEventGroupClearBits18EventGroupHandle_tK11EventBits_t">
<span id="_CPPv320xEventGroupClearBits18EventGroupHandle_tK11EventBits_t"></span><span id="_CPPv220xEventGroupClearBits18EventGroupHandle_tK11EventBits_t"></span><span id="xEventGroupClearBits__EventGroupHandle_t.EventBits_tC"></span><span class="target" id="event__groups_8h_1a71dd2680fdfbdde7d6b10db203e266ba"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupClearBits</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xEventGroup</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">uxBitsToClear</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xEventGroupClearBits18EventGroupHandle_tK11EventBits_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Clear bits within an event group. This function cannot be called from an interrupt.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BIT_0 ( 1 &lt;&lt; 0 )</span>
<span class="cp">#define BIT_4 ( 1 &lt;&lt; 4 )</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">aFunction</span><span class="p">(</span><span class="w"> </span><span class="n">EventGroupHandle_t</span><span class="w"> </span><span class="n">xEventGroup</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span><span class="w"> </span><span class="n">uxBits</span><span class="p">;</span>

<span class="w">     </span><span class="c1">// Clear bit 0 and bit 4 in xEventGroup.</span>
<span class="w">     </span><span class="n">uxBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xEventGroupClearBits</span><span class="p">(</span>
<span class="w">                             </span><span class="n">xEventGroup</span><span class="p">,</span><span class="w">    </span><span class="c1">// The event group being updated.</span>
<span class="w">                             </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">);</span><span class="c1">// The bits being cleared.</span>

<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Both bit 0 and bit 4 were set before xEventGroupClearBits() was</span>
<span class="w">         </span><span class="c1">// called.  Both will now be clear (not set).</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BIT_0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Bit 0 was set before xEventGroupClearBits() was called.  It will</span>
<span class="w">         </span><span class="c1">// now be clear.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Bit 4 was set before xEventGroupClearBits() was called.  It will</span>
<span class="w">         </span><span class="c1">// now be clear.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Neither bit 0 nor bit 4 were set in the first place.</span>
<span class="w">     </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xEventGroup</strong> -- The event group in which the bits are to be cleared.</p></li>
<li><p><strong>uxBitsToClear</strong> -- A bitwise value that indicates the bit or bits to clear in the event group. For example, to clear bit 3 only, set uxBitsToClear to 0x08. To clear bit 3 and bit 0 set uxBitsToClear to 0x09.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the event group before the specified bits were cleared.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418xEventGroupSetBits18EventGroupHandle_tK11EventBits_t">
<span id="_CPPv318xEventGroupSetBits18EventGroupHandle_tK11EventBits_t"></span><span id="_CPPv218xEventGroupSetBits18EventGroupHandle_tK11EventBits_t"></span><span id="xEventGroupSetBits__EventGroupHandle_t.EventBits_tC"></span><span class="target" id="event__groups_8h_1a9ac7cd970f50e2e50a494b656e0eb239"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupSetBits</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xEventGroup</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">uxBitsToSet</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xEventGroupSetBits18EventGroupHandle_tK11EventBits_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set bits within an event group. This function cannot be called from an interrupt. xEventGroupSetBitsFromISR() is a version that can be called from an interrupt.</p>
<p>Setting bits in an event group will automatically unblock tasks that are blocked waiting for the bits.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BIT_0 ( 1 &lt;&lt; 0 )</span>
<span class="cp">#define BIT_4 ( 1 &lt;&lt; 4 )</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">aFunction</span><span class="p">(</span><span class="w"> </span><span class="n">EventGroupHandle_t</span><span class="w"> </span><span class="n">xEventGroup</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span><span class="w"> </span><span class="n">uxBits</span><span class="p">;</span>

<span class="w">     </span><span class="c1">// Set bit 0 and bit 4 in xEventGroup.</span>
<span class="w">     </span><span class="n">uxBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xEventGroupSetBits</span><span class="p">(</span>
<span class="w">                         </span><span class="n">xEventGroup</span><span class="p">,</span><span class="w">    </span><span class="c1">// The event group being updated.</span>
<span class="w">                         </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">);</span><span class="c1">// The bits being set.</span>

<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Both bit 0 and bit 4 remained set when the function returned.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BIT_0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Bit 0 remained set when the function returned, but bit 4 was</span>
<span class="w">         </span><span class="c1">// cleared.  It might be that bit 4 was cleared automatically as a</span>
<span class="w">         </span><span class="c1">// task that was waiting for bit 4 was removed from the Blocked</span>
<span class="w">         </span><span class="c1">// state.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Bit 4 remained set when the function returned, but bit 0 was</span>
<span class="w">         </span><span class="c1">// cleared.  It might be that bit 0 was cleared automatically as a</span>
<span class="w">         </span><span class="c1">// task that was waiting for bit 0 was removed from the Blocked</span>
<span class="w">         </span><span class="c1">// state.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">else</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// Neither bit 0 nor bit 4 remained set.  It might be that a task</span>
<span class="w">         </span><span class="c1">// was waiting for both of the bits to be set, and the bits were</span>
<span class="w">         </span><span class="c1">// cleared as the task left the Blocked state.</span>
<span class="w">     </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xEventGroup</strong> -- The event group in which the bits are to be set.</p></li>
<li><p><strong>uxBitsToSet</strong> -- A bitwise value that indicates the bit or bits to set. For example, to set bit 3 only, set uxBitsToSet to 0x08. To set bit 3 and bit 0 set uxBitsToSet to 0x09.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the event group at the time the call to xEventGroupSetBits() returns. There are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared. First, if setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will be cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()). Second, any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t">
<span id="_CPPv315xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t"></span><span id="_CPPv215xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t"></span><span id="xEventGroupSync__EventGroupHandle_t.EventBits_tC.EventBits_tC.TickType_t"></span><span class="target" id="event__groups_8h_1ac38db316f0928c7ddaacb677a75dbc03"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupSync</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xEventGroup</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">uxBitsToSet</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">uxBitsToWaitFor</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Atomically set bits within an event group, then wait for a combination of bits to be set within the same event group. This functionality is typically used to synchronise multiple tasks, where each task has to wait for the other tasks to reach a synchronisation point before proceeding.</p>
<p>This function cannot be used from an interrupt.</p>
<p>The function will return before its block time expires if the bits specified by the uxBitsToWait parameter are set, or become set within that time. In this case all the bits specified by uxBitsToWait will be automatically cleared before the function returns.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Bits used by the three tasks.</span>
<span class="cp">#define TASK_0_BIT     ( 1 &lt;&lt; 0 )</span>
<span class="cp">#define TASK_1_BIT     ( 1 &lt;&lt; 1 )</span>
<span class="cp">#define TASK_2_BIT     ( 1 &lt;&lt; 2 )</span>

<span class="cp">#define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )</span>

<span class="c1">// Use an event group to synchronise three tasks.  It is assumed this event</span>
<span class="c1">// group has already been created elsewhere.</span>
<span class="n">EventGroupHandle_t</span><span class="w"> </span><span class="n">xEventBits</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTask0</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span><span class="w"> </span><span class="n">uxReturn</span><span class="p">;</span>
<span class="n">TickType_t</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">portTICK_PERIOD_MS</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Perform task functionality here.</span>

<span class="w">     </span><span class="c1">// Set bit 0 in the event flag to note this task has reached the</span>
<span class="w">     </span><span class="c1">// sync point.  The other two tasks will set the other two bits defined</span>
<span class="w">     </span><span class="c1">// by ALL_SYNC_BITS.  All three tasks have reached the synchronisation</span>
<span class="w">     </span><span class="c1">// point when all the ALL_SYNC_BITS are set.  Wait a maximum of 100ms</span>
<span class="w">     </span><span class="c1">// for this to happen.</span>
<span class="w">     </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xEventGroupSync</span><span class="p">(</span><span class="w"> </span><span class="n">xEventBits</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_0_BIT</span><span class="p">,</span><span class="w"> </span><span class="n">ALL_SYNC_BITS</span><span class="p">,</span><span class="w"> </span><span class="n">xTicksToWait</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">uxReturn</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ALL_SYNC_BITS</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ALL_SYNC_BITS</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// All three tasks reached the synchronisation point before the call</span>
<span class="w">         </span><span class="c1">// to xEventGroupSync() timed out.</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTask1</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Perform task functionality here.</span>

<span class="w">     </span><span class="c1">// Set bit 1 in the event flag to note this task has reached the</span>
<span class="w">     </span><span class="c1">// synchronisation point.  The other two tasks will set the other two</span>
<span class="w">     </span><span class="c1">// bits defined by ALL_SYNC_BITS.  All three tasks have reached the</span>
<span class="w">     </span><span class="c1">// synchronisation point when all the ALL_SYNC_BITS are set.  Wait</span>
<span class="w">     </span><span class="c1">// indefinitely for this to happen.</span>
<span class="w">     </span><span class="n">xEventGroupSync</span><span class="p">(</span><span class="w"> </span><span class="n">xEventBits</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_1_BIT</span><span class="p">,</span><span class="w"> </span><span class="n">ALL_SYNC_BITS</span><span class="p">,</span><span class="w"> </span><span class="n">portMAX_DELAY</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="c1">// xEventGroupSync() was called with an indefinite block time, so</span>
<span class="w">     </span><span class="c1">// this task will only reach here if the synchronisation was made by all</span>
<span class="w">     </span><span class="c1">// three tasks, so there is no need to test the return value.</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vTask2</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pvParameters</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Perform task functionality here.</span>

<span class="w">     </span><span class="c1">// Set bit 2 in the event flag to note this task has reached the</span>
<span class="w">     </span><span class="c1">// synchronisation point.  The other two tasks will set the other two</span>
<span class="w">     </span><span class="c1">// bits defined by ALL_SYNC_BITS.  All three tasks have reached the</span>
<span class="w">     </span><span class="c1">// synchronisation point when all the ALL_SYNC_BITS are set.  Wait</span>
<span class="w">     </span><span class="c1">// indefinitely for this to happen.</span>
<span class="w">     </span><span class="n">xEventGroupSync</span><span class="p">(</span><span class="w"> </span><span class="n">xEventBits</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_2_BIT</span><span class="p">,</span><span class="w"> </span><span class="n">ALL_SYNC_BITS</span><span class="p">,</span><span class="w"> </span><span class="n">portMAX_DELAY</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="c1">// xEventGroupSync() was called with an indefinite block time, so</span>
<span class="w">     </span><span class="c1">// this task will only reach here if the synchronisation was made by all</span>
<span class="w">     </span><span class="c1">// three tasks, so there is no need to test the return value.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xEventGroup</strong> -- The event group in which the bits are being tested. The event group must have previously been created using a call to xEventGroupCreate().</p></li>
<li><p><strong>uxBitsToSet</strong> -- The bits to set in the event group before determining if, and possibly waiting for, all the bits specified by the uxBitsToWait parameter are set.</p></li>
<li><p><strong>uxBitsToWaitFor</strong> -- A bitwise value that indicates the bit or bits to test inside the event group. For example, to wait for bit 0 and bit 2 set uxBitsToWaitFor to 0x05. To wait for bits 0 and bit 1 and bit 2 set uxBitsToWaitFor to 0x07. Etc.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time (specified in 'ticks') to wait for all of the bits specified by uxBitsToWaitFor to become set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the event group at the time either the bits being waited for became set, or the block time expired. Test the return value to know which bits were set. If xEventGroupSync() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupSync() returned because all the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425xEventGroupGetBitsFromISR18EventGroupHandle_t">
<span id="_CPPv325xEventGroupGetBitsFromISR18EventGroupHandle_t"></span><span id="_CPPv225xEventGroupGetBitsFromISR18EventGroupHandle_t"></span><span id="xEventGroupGetBitsFromISR__EventGroupHandle_t"></span><span class="target" id="event__groups_8h_1adcb3d3f7dded9fa372bb1ee405c36b8d"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t"><span class="n"><span class="pre">EventBits_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupGetBitsFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xEventGroup</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xEventGroupGetBitsFromISR18EventGroupHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xEventGroupGetBits() that can be called from an ISR.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xEventGroup</strong> -- The event group being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event group bits at the time xEventGroupGetBitsFromISR() was called. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417vEventGroupDelete18EventGroupHandle_t">
<span id="_CPPv317vEventGroupDelete18EventGroupHandle_t"></span><span id="_CPPv217vEventGroupDelete18EventGroupHandle_t"></span><span id="vEventGroupDelete__EventGroupHandle_t"></span><span class="target" id="event__groups_8h_1a6939faca89fc4ba52fa8288527042464"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vEventGroupDelete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xEventGroup</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417vEventGroupDelete18EventGroupHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delete an event group that was previously created by a call to xEventGroupCreate(). Tasks that are blocked on the event group will be unblocked and obtain 0 as the event group's value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xEventGroup</strong> -- The event group being deleted. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426xEventGroupGetStaticBuffer18EventGroupHandle_tPP18StaticEventGroup_t">
<span id="_CPPv326xEventGroupGetStaticBuffer18EventGroupHandle_tPP18StaticEventGroup_t"></span><span id="_CPPv226xEventGroupGetStaticBuffer18EventGroupHandle_tPP18StaticEventGroup_t"></span><span id="xEventGroupGetStaticBuffer__EventGroupHandle_t.StaticEventGroup_tPP"></span><span class="target" id="event__groups_8h_1a9ec382b4c4959e71740245519e21f6ae"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupGetStaticBuffer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xEventGroup</span></span>, <span class="n"><span class="pre">StaticEventGroup_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppxEventGroupBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426xEventGroupGetStaticBuffer18EventGroupHandle_tPP18StaticEventGroup_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve a pointer to a statically created event groups's data structure buffer. It is the same buffer that is supplied at the time of creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xEventGroup</strong> -- The event group for which to retrieve the buffer.</p></li>
<li><p><strong>ppxEventGroupBuffer</strong> -- Used to return a pointer to the event groups's data structure buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if the buffer was retrieved, pdFALSE otherwise. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id14">
<h3>Macros<a class="headerlink" href="#id14" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xEventGroupClearBitsFromISR">
<span class="target" id="event__groups_8h_1a3d7de214a697f33fe7b914e26a93f33a"></span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupClearBitsFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xEventGroup</span></span>, <span class="n"><span class="pre">uxBitsToClear</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xEventGroupClearBitsFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xEventGroupClearBits() that can be called from an interrupt.</p>
<p>Setting bits in an event group is not a deterministic operation because there are an unknown number of tasks that may be waiting for the bit or bits being set. FreeRTOS does not allow nondeterministic operations to be performed while interrupts are disabled, so protects event groups that are accessed from tasks by suspending the scheduler rather than disabling interrupts. As a result event groups cannot be accessed directly from an interrupt service routine. Therefore xEventGroupClearBitsFromISR() sends a message to the timer task to have the clear operation performed in the context of the timer task.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BIT_0 ( 1 &lt;&lt; 0 )</span>
<span class="cp">#define BIT_4 ( 1 &lt;&lt; 4 )</span>

<span class="c1">// An event group which it is assumed has already been created by a call to</span>
<span class="c1">// xEventGroupCreate().</span>
<span class="n">EventGroupHandle_t</span><span class="w"> </span><span class="n">xEventGroup</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">anInterruptHandler</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">     </span><span class="c1">// Clear bit 0 and bit 4 in xEventGroup.</span>
<span class="w">     </span><span class="n">xResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xEventGroupClearBitsFromISR</span><span class="p">(</span>
<span class="w">                         </span><span class="n">xEventGroup</span><span class="p">,</span><span class="w">     </span><span class="c1">// The event group being updated.</span>
<span class="w">                         </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// The bits being set.</span>

<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xResult</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdPASS</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// The message was posted successfully.</span>
<span class="w">         </span><span class="n">portYIELD_FROM_ISR</span><span class="p">(</span><span class="n">pdTRUE</span><span class="p">);</span>
<span class="w">     </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this function returns pdPASS then the timer task is ready to run and a portYIELD_FROM_ISR(pdTRUE) should be executed to perform the needed clear on the event group. This behavior is different from xEventGroupSetBitsFromISR because the parameter xHigherPriorityTaskWoken is not present.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xEventGroup</strong> -- The event group in which the bits are to be cleared.</p></li>
<li><p><strong>uxBitsToClear</strong> -- A bitwise value that indicates the bit or bits to clear. For example, to clear bit 3 only, set uxBitsToClear to 0x08. To clear bit 3 and bit 0 set uxBitsToClear to 0x09.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the request to execute the function was posted successfully then pdPASS is returned, otherwise pdFALSE is returned. pdFALSE will be returned if the timer service queue was full.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xEventGroupSetBitsFromISR">
<span class="target" id="event__groups_8h_1a62b68278abac6358369ae8e390988a02"></span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupSetBitsFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xEventGroup</span></span>, <span class="n"><span class="pre">uxBitsToSet</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xEventGroupSetBitsFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>A version of xEventGroupSetBits() that can be called from an interrupt.</p>
<p>Setting bits in an event group is not a deterministic operation because there are an unknown number of tasks that may be waiting for the bit or bits being set. FreeRTOS does not allow nondeterministic operations to be performed in interrupts or from critical sections. Therefore xEventGroupSetBitsFromISR() sends a message to the timer task to have the set operation performed in the context of the timer task - where a scheduler lock is used in place of a critical section.</p>
<p>
Example usage: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BIT_0 ( 1 &lt;&lt; 0 )</span>
<span class="cp">#define BIT_4 ( 1 &lt;&lt; 4 )</span>

<span class="c1">// An event group which it is assumed has already been created by a call to</span>
<span class="c1">// xEventGroupCreate().</span>
<span class="n">EventGroupHandle_t</span><span class="w"> </span><span class="n">xEventGroup</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">anInterruptHandler</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="p">,</span><span class="w"> </span><span class="n">xResult</span><span class="p">;</span>

<span class="w">     </span><span class="c1">// xHigherPriorityTaskWoken must be initialised to pdFALSE.</span>
<span class="w">     </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span>

<span class="w">     </span><span class="c1">// Set bit 0 and bit 4 in xEventGroup.</span>
<span class="w">     </span><span class="n">xResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xEventGroupSetBitsFromISR</span><span class="p">(</span>
<span class="w">                         </span><span class="n">xEventGroup</span><span class="p">,</span><span class="w">    </span><span class="c1">// The event group being updated.</span>
<span class="w">                         </span><span class="n">BIT_0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">BIT_4</span><span class="w">   </span><span class="c1">// The bits being set.</span>
<span class="w">                         </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w">     </span><span class="c1">// Was the message posted successfully?</span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xResult</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdPASS</span><span class="w"> </span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="c1">// If xHigherPriorityTaskWoken is now set to pdTRUE then a context</span>
<span class="w">         </span><span class="c1">// switch should be requested.  The macro used is port specific and</span>
<span class="w">         </span><span class="c1">// will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -</span>
<span class="w">         </span><span class="c1">// refer to the documentation page for the port being used.</span>
<span class="w">         </span><span class="n">portYIELD_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>
<span class="w">     </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xEventGroup</strong> -- The event group in which the bits are to be set.</p></li>
<li><p><strong>uxBitsToSet</strong> -- A bitwise value that indicates the bit or bits to set. For example, to set bit 3 only, set uxBitsToSet to 0x08. To set bit 3 and bit 0 set uxBitsToSet to 0x09.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- As mentioned above, calling this function will result in a message being sent to the timer daemon task. If the priority of the timer daemon task is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE by xEventGroupSetBitsFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the request to execute the function was posted successfully then pdPASS is returned, otherwise pdFALSE is returned. pdFALSE will be returned if the timer service queue was full.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xEventGroupGetBits">
<span class="target" id="event__groups_8h_1a0ae86f092fb07ccb475ae938f9a12584"></span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupGetBits</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xEventGroup</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xEventGroupGetBits" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the current value of the bits in an event group. This function cannot be used from an interrupt.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xEventGroup</strong> -- The event group being queried.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event group bits at the time xEventGroupGetBits() was called. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id15">
<h3>Type Definitions<a class="headerlink" href="#id15" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv418EventGroupHandle_t">
<span id="_CPPv318EventGroupHandle_t"></span><span id="_CPPv218EventGroupHandle_t"></span><span id="EventGroupHandle_t"></span><span class="target" id="event__groups_8h_1acab96e0b6a5cab7f7b29822b79cc78ed"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">EventGroupDef_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">EventGroupHandle_t</span></span></span><a class="headerlink" href="#_CPPv418EventGroupHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv411EventBits_t">
<span id="_CPPv311EventBits_t"></span><span id="_CPPv211EventBits_t"></span><span id="EventBits_t"></span><span class="target" id="event__groups_8h_1ab2f21b93db0b2a0ab64d7a81ff32ac2e"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EventBits_t</span></span></span><a class="headerlink" href="#_CPPv411EventBits_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
<section id="stream-buffer-api">
<h3>Stream Buffer API<a class="headerlink" href="#stream-buffer-api" title="Permalink to this heading"></a></h3>
</section>
<section id="id16">
<h3>Header File<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/freertos/FreeRTOS-Kernel/include/freertos/stream_buffer.h">components/freertos/FreeRTOS-Kernel/include/freertos/stream_buffer.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/stream_buffer.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id17">
<h3>Functions<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429xStreamBufferGetStaticBuffers20StreamBufferHandle_tPP7uint8_tPP20StaticStreamBuffer_t">
<span id="_CPPv329xStreamBufferGetStaticBuffers20StreamBufferHandle_tPP7uint8_tPP20StaticStreamBuffer_t"></span><span id="_CPPv229xStreamBufferGetStaticBuffers20StreamBufferHandle_tPP7uint8_tPP20StaticStreamBuffer_t"></span><span id="xStreamBufferGetStaticBuffers__StreamBufferHandle_t.uint8_tPP.StaticStreamBuffer_tPP"></span><span class="target" id="stream__buffer_8h_1a011aeeeb8f927a735cdf1e33d3759ca3"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferGetStaticBuffers</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppucStreamBufferStorageArea</span></span>, <span class="n"><span class="pre">StaticStreamBuffer_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppxStaticStreamBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429xStreamBufferGetStaticBuffers20StreamBufferHandle_tPP7uint8_tPP20StaticStreamBuffer_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve pointers to a statically created stream buffer's data structure buffer and storage area buffer. These are the same buffers that are supplied at the time of creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xStreamBuffer</strong> -- The stream buffer for which to retrieve the buffers.</p></li>
<li><p><strong>ppucStreamBufferStorageArea</strong> -- Used to return a pointer to the stream buffer's storage area buffer.</p></li>
<li><p><strong>ppxStaticStreamBuffer</strong> -- Used to return a pointer to the stream buffer's data structure buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if buffers were retrieved, pdFALSE otherwise. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417xStreamBufferSend20StreamBufferHandle_tPKv6size_t10TickType_t">
<span id="_CPPv317xStreamBufferSend20StreamBufferHandle_tPKv6size_t10TickType_t"></span><span id="_CPPv217xStreamBufferSend20StreamBufferHandle_tPKv6size_t10TickType_t"></span><span id="xStreamBufferSend__StreamBufferHandle_t.voidCP.s.TickType_t"></span><span class="target" id="stream__buffer_8h_1adf807ecf262fcd5df2584d5d3e6ed6c5"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferSend</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvTxData</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xDataLengthBytes</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xStreamBufferSend20StreamBufferHandle_tPKv6size_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sends bytes to a stream buffer. The bytes are copied into the stream buffer.</p>
<p><em><strong>NOTE</strong></em>: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xStreamBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xStreamBufferReceive()) inside a critical section and set the receive block time to 0.</p>
<p>Use xStreamBufferSend() to write to a stream buffer from a task. Use xStreamBufferSendFromISR() to write to a stream buffer from an interrupt service routine (ISR).</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="n">StreamBufferHandle_t</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">xBytesSent</span><span class="p">;</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucArrayToSend</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcStringToSend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;String to send&quot;</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">x100ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Send an array to the stream buffer, blocking for a maximum of 100ms to</span>
<span class="w"> </span><span class="c1">// wait for enough space to be available in the stream buffer.</span>
<span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xStreamBufferSend</span><span class="p">(</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ucArrayToSend</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucArrayToSend</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">x100ms</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucArrayToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The call to xStreamBufferSend() times out before there was enough</span>
<span class="w">     </span><span class="c1">// space in the buffer for the data to be written, but it did</span>
<span class="w">     </span><span class="c1">// successfully write xBytesSent bytes.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// Send the string to the stream buffer.  Return immediately if there is not</span>
<span class="w"> </span><span class="c1">// enough space in the buffer.</span>
<span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xStreamBufferSend</span><span class="p">(</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The entire string could not be added to the stream buffer because</span>
<span class="w">     </span><span class="c1">// there was not enough free space in the buffer, but xBytesSent bytes</span>
<span class="w">     </span><span class="c1">// were sent.  Could try again to send the remaining bytes.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer to which a stream is being sent.</p></li>
<li><p><strong>pvTxData</strong> -- A pointer to the buffer that holds the bytes to be copied into the stream buffer.</p></li>
<li><p><strong>xDataLengthBytes</strong> -- The maximum number of bytes to copy from pvTxData into the stream buffer.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the task should remain in the Blocked state to wait for enough space to become available in the stream buffer, should the stream buffer contain too little space to hold the another xDataLengthBytes bytes. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting xTicksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. If a task times out before it can write all xDataLengthBytes into the buffer it will still write as many bytes as possible. A task does not use any CPU time when it is in the blocked state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bytes written to the stream buffer. If a task times out before it can write all xDataLengthBytes into the buffer it will still write as many bytes as possible.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424xStreamBufferSendFromISR20StreamBufferHandle_tPKv6size_tPC10BaseType_t">
<span id="_CPPv324xStreamBufferSendFromISR20StreamBufferHandle_tPKv6size_tPC10BaseType_t"></span><span id="_CPPv224xStreamBufferSendFromISR20StreamBufferHandle_tPKv6size_tPC10BaseType_t"></span><span id="xStreamBufferSendFromISR__StreamBufferHandle_t.voidCP.s.BaseType_tPC"></span><span class="target" id="stream__buffer_8h_1a3072d8c5cedf79a72550da051a0866b4"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferSendFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvTxData</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xDataLengthBytes</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424xStreamBufferSendFromISR20StreamBufferHandle_tPKv6size_tPC10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Interrupt safe version of the API function that sends a stream of bytes to the stream buffer.</p>
<p><em><strong>NOTE</strong></em>: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xStreamBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xStreamBufferReceive()) inside a critical section and set the receive block time to 0.</p>
<p>Use xStreamBufferSend() to write to a stream buffer from a task. Use xStreamBufferSendFromISR() to write to a stream buffer from an interrupt service routine (ISR).</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// A stream buffer that has already been created.</span>
<span class="n">StreamBufferHandle_t</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vAnInterruptServiceRoutine</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">xBytesSent</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcStringToSend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;String to send&quot;</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initialised to pdFALSE.</span>

<span class="w"> </span><span class="c1">// Attempt to send the string to the stream buffer.</span>
<span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xStreamBufferSendFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="p">,</span>
<span class="w">                                        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="w"> </span><span class="p">),</span>
<span class="w">                                        </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// There was not enough free space in the stream buffer for the entire</span>
<span class="w">     </span><span class="c1">// string to be written, ut xBytesSent bytes were written.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// If xHigherPriorityTaskWoken was set to pdTRUE inside</span>
<span class="w"> </span><span class="c1">// xStreamBufferSendFromISR() then a task that has a priority above the</span>
<span class="w"> </span><span class="c1">// priority of the currently executing task was unblocked and a context</span>
<span class="w"> </span><span class="c1">// switch should be performed to ensure the ISR returns to the unblocked</span>
<span class="w"> </span><span class="c1">// task.  In most FreeRTOS ports this is done by simply passing</span>
<span class="w"> </span><span class="c1">// xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the</span>
<span class="w"> </span><span class="c1">// variables value, and perform the context switch if necessary.  Check the</span>
<span class="w"> </span><span class="c1">// documentation for the port in use for port specific instructions.</span>
<span class="w"> </span><span class="n">portYIELD_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer to which a stream is being sent.</p></li>
<li><p><strong>pvTxData</strong> -- A pointer to the data that is to be copied into the stream buffer.</p></li>
<li><p><strong>xDataLengthBytes</strong> -- The maximum number of bytes to copy from pvTxData into the stream buffer.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- It is possible that a stream buffer will have a task blocked on it waiting for data. Calling xStreamBufferSendFromISR() can make data available, and so cause a task that was waiting for data to leave the Blocked state. If calling xStreamBufferSendFromISR() causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, xStreamBufferSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE. If xStreamBufferSendFromISR() sets this value to pdTRUE, then normally a context switch should be performed before the interrupt is exited. This will ensure that the interrupt returns directly to the highest priority Ready state task. *pxHigherPriorityTaskWoken should be set to pdFALSE before it is passed into the function. See the example code below for an example.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bytes actually written to the stream buffer, which will be less than xDataLengthBytes if the stream buffer didn't have enough free space for all the bytes to be written.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420xStreamBufferReceive20StreamBufferHandle_tPv6size_t10TickType_t">
<span id="_CPPv320xStreamBufferReceive20StreamBufferHandle_tPv6size_t10TickType_t"></span><span id="_CPPv220xStreamBufferReceive20StreamBufferHandle_tPv6size_t10TickType_t"></span><span id="xStreamBufferReceive__StreamBufferHandle_t.voidP.s.TickType_t"></span><span class="target" id="stream__buffer_8h_1afcfcf6f4bc80ec5e31e5e1f8093cacac"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferReceive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvRxData</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferLengthBytes</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xStreamBufferReceive20StreamBufferHandle_tPv6size_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Receives bytes from a stream buffer.</p>
<p><em><strong>NOTE</strong></em>: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xStreamBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xStreamBufferReceive()) inside a critical section and set the receive block time to 0.</p>
<p>Use xStreamBufferReceive() to read from a stream buffer from a task. Use xStreamBufferReceiveFromISR() to read from a stream buffer from an interrupt service routine (ISR).</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="n">StreamBuffer_t</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucRxData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">xReceivedBytes</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xBlockTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Receive up to another sizeof( ucRxData ) bytes from the stream buffer.</span>
<span class="w"> </span><span class="c1">// Wait in the Blocked state (so not using any CPU processing time) for a</span>
<span class="w"> </span><span class="c1">// maximum of 100ms for the full sizeof( ucRxData ) number of bytes to be</span>
<span class="w"> </span><span class="c1">// available.</span>
<span class="w"> </span><span class="n">xReceivedBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xStreamBufferReceive</span><span class="p">(</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="p">,</span>
<span class="w">                                        </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ucRxData</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucRxData</span><span class="w"> </span><span class="p">),</span>
<span class="w">                                        </span><span class="n">xBlockTime</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xReceivedBytes</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// A ucRxData contains another xReceivedBytes bytes of data, which can</span>
<span class="w">     </span><span class="c1">// be processed here....</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer from which bytes are to be received.</p></li>
<li><p><strong>pvRxData</strong> -- A pointer to the buffer into which the received bytes will be copied.</p></li>
<li><p><strong>xBufferLengthBytes</strong> -- The length of the buffer pointed to by the pvRxData parameter. This sets the maximum number of bytes to receive in one call. xStreamBufferReceive will return as many bytes as possible up to a maximum set by xBufferLengthBytes.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the task should remain in the Blocked state to wait for data to become available if the stream buffer is empty. xStreamBufferReceive() will return immediately if xTicksToWait is zero. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting xTicksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. A task does not use any CPU time when it is in the Blocked state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bytes actually read from the stream buffer, which will be less than xBufferLengthBytes if the call to xStreamBufferReceive() timed out before xBufferLengthBytes were available.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427xStreamBufferReceiveFromISR20StreamBufferHandle_tPv6size_tPC10BaseType_t">
<span id="_CPPv327xStreamBufferReceiveFromISR20StreamBufferHandle_tPv6size_tPC10BaseType_t"></span><span id="_CPPv227xStreamBufferReceiveFromISR20StreamBufferHandle_tPv6size_tPC10BaseType_t"></span><span id="xStreamBufferReceiveFromISR__StreamBufferHandle_t.voidP.s.BaseType_tPC"></span><span class="target" id="stream__buffer_8h_1a06c67a59495190f8359322184fe0462b"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferReceiveFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvRxData</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferLengthBytes</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427xStreamBufferReceiveFromISR20StreamBufferHandle_tPv6size_tPC10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>An interrupt safe version of the API function that receives bytes from a stream buffer.</p>
<p>Use xStreamBufferReceive() to read bytes from a stream buffer from a task. Use xStreamBufferReceiveFromISR() to read bytes from a stream buffer from an interrupt service routine (ISR).</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// A stream buffer that has already been created.</span>
<span class="n">StreamBuffer_t</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vAnInterruptServiceRoutine</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucRxData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">xReceivedBytes</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span><span class="w">  </span><span class="c1">// Initialised to pdFALSE.</span>

<span class="w"> </span><span class="c1">// Receive the next stream from the stream buffer.</span>
<span class="w"> </span><span class="n">xReceivedBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xStreamBufferReceiveFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="p">,</span>
<span class="w">                                               </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ucRxData</span><span class="p">,</span>
<span class="w">                                               </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucRxData</span><span class="w"> </span><span class="p">),</span>
<span class="w">                                               </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xReceivedBytes</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// ucRxData contains xReceivedBytes read from the stream buffer.</span>
<span class="w">     </span><span class="c1">// Process the stream here....</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// If xHigherPriorityTaskWoken was set to pdTRUE inside</span>
<span class="w"> </span><span class="c1">// xStreamBufferReceiveFromISR() then a task that has a priority above the</span>
<span class="w"> </span><span class="c1">// priority of the currently executing task was unblocked and a context</span>
<span class="w"> </span><span class="c1">// switch should be performed to ensure the ISR returns to the unblocked</span>
<span class="w"> </span><span class="c1">// task.  In most FreeRTOS ports this is done by simply passing</span>
<span class="w"> </span><span class="c1">// xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the</span>
<span class="w"> </span><span class="c1">// variables value, and perform the context switch if necessary.  Check the</span>
<span class="w"> </span><span class="c1">// documentation for the port in use for port specific instructions.</span>
<span class="w"> </span><span class="n">portYIELD_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer from which a stream is being received.</p></li>
<li><p><strong>pvRxData</strong> -- A pointer to the buffer into which the received bytes are copied.</p></li>
<li><p><strong>xBufferLengthBytes</strong> -- The length of the buffer pointed to by the pvRxData parameter. This sets the maximum number of bytes to receive in one call. xStreamBufferReceive will return as many bytes as possible up to a maximum set by xBufferLengthBytes.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- It is possible that a stream buffer will have a task blocked on it waiting for space to become available. Calling xStreamBufferReceiveFromISR() can make space available, and so cause a task that is waiting for space to leave the Blocked state. If calling xStreamBufferReceiveFromISR() causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, xStreamBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE. If xStreamBufferReceiveFromISR() sets this value to pdTRUE, then normally a context switch should be performed before the interrupt is exited. That will ensure the interrupt returns directly to the highest priority Ready state task. *pxHigherPriorityTaskWoken should be set to pdFALSE before it is passed into the function. See the code example below for an example.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bytes read from the stream buffer, if any.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419vStreamBufferDelete20StreamBufferHandle_t">
<span id="_CPPv319vStreamBufferDelete20StreamBufferHandle_t"></span><span id="_CPPv219vStreamBufferDelete20StreamBufferHandle_t"></span><span id="vStreamBufferDelete__StreamBufferHandle_t"></span><span class="target" id="stream__buffer_8h_1a7e66db41c3fd13acf3b9f814d650f77d"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vStreamBufferDelete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419vStreamBufferDelete20StreamBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deletes a stream buffer that was previously created using a call to xStreamBufferCreate() or xStreamBufferCreateStatic(). If the stream buffer was created using dynamic memory (that is, by xStreamBufferCreate()), then the allocated memory is freed.</p>
<p>A stream buffer handle must not be used after the stream buffer has been deleted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer to be deleted. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419xStreamBufferIsFull20StreamBufferHandle_t">
<span id="_CPPv319xStreamBufferIsFull20StreamBufferHandle_t"></span><span id="_CPPv219xStreamBufferIsFull20StreamBufferHandle_t"></span><span id="xStreamBufferIsFull__StreamBufferHandle_t"></span><span class="target" id="stream__buffer_8h_1a77c2ae33c45c948e7af4d61fdd6cf1f1"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferIsFull</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xStreamBufferIsFull20StreamBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queries a stream buffer to see if it is full. A stream buffer is full if it does not have any free space, and therefore cannot accept any more data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the stream buffer is full then pdTRUE is returned. Otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420xStreamBufferIsEmpty20StreamBufferHandle_t">
<span id="_CPPv320xStreamBufferIsEmpty20StreamBufferHandle_t"></span><span id="_CPPv220xStreamBufferIsEmpty20StreamBufferHandle_t"></span><span id="xStreamBufferIsEmpty__StreamBufferHandle_t"></span><span class="target" id="stream__buffer_8h_1a95465cd3702e3eae08afb8e69e1c6525"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferIsEmpty</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xStreamBufferIsEmpty20StreamBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queries a stream buffer to see if it is empty. A stream buffer is empty if it does not contain any data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the stream buffer is empty then pdTRUE is returned. Otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418xStreamBufferReset20StreamBufferHandle_t">
<span id="_CPPv318xStreamBufferReset20StreamBufferHandle_t"></span><span id="_CPPv218xStreamBufferReset20StreamBufferHandle_t"></span><span id="xStreamBufferReset__StreamBufferHandle_t"></span><span class="target" id="stream__buffer_8h_1a05ed4d42963aa4aaf50e49700d44659c"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferReset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xStreamBufferReset20StreamBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Resets a stream buffer to its initial, empty, state. Any data that was in the stream buffer is discarded. A stream buffer can only be reset if there are no tasks blocked waiting to either send to or receive from the stream buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer being reset.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the stream buffer is reset then pdPASS is returned. If there was a task blocked waiting to send to or read from the stream buffer then the stream buffer is not reset and pdFAIL is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428xStreamBufferSpacesAvailable20StreamBufferHandle_t">
<span id="_CPPv328xStreamBufferSpacesAvailable20StreamBufferHandle_t"></span><span id="_CPPv228xStreamBufferSpacesAvailable20StreamBufferHandle_t"></span><span id="xStreamBufferSpacesAvailable__StreamBufferHandle_t"></span><span class="target" id="stream__buffer_8h_1a8fb90892c74eb94fb063b2a018a10509"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferSpacesAvailable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428xStreamBufferSpacesAvailable20StreamBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queries a stream buffer to see how much free space it contains, which is equal to the amount of data that can be sent to the stream buffer before it is full.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bytes that can be written to the stream buffer before the stream buffer would be full. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427xStreamBufferBytesAvailable20StreamBufferHandle_t">
<span id="_CPPv327xStreamBufferBytesAvailable20StreamBufferHandle_t"></span><span id="_CPPv227xStreamBufferBytesAvailable20StreamBufferHandle_t"></span><span id="xStreamBufferBytesAvailable__StreamBufferHandle_t"></span><span class="target" id="stream__buffer_8h_1a5c473cb971d8a20b0528a1abc890833c"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferBytesAvailable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427xStreamBufferBytesAvailable20StreamBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Queries a stream buffer to see how much data it contains, which is equal to the number of bytes that can be read from the stream buffer before the stream buffer would be empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer being queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bytes that can be read from the stream buffer before the stream buffer would be empty. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428xStreamBufferSetTriggerLevel20StreamBufferHandle_t6size_t">
<span id="_CPPv328xStreamBufferSetTriggerLevel20StreamBufferHandle_t6size_t"></span><span id="_CPPv228xStreamBufferSetTriggerLevel20StreamBufferHandle_t6size_t"></span><span id="xStreamBufferSetTriggerLevel__StreamBufferHandle_t.s"></span><span class="target" id="stream__buffer_8h_1a375b92e87b73351a6a30c8a2ba7d2ce0"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferSetTriggerLevel</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTriggerLevel</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428xStreamBufferSetTriggerLevel20StreamBufferHandle_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>A stream buffer's trigger level is the number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state. For example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 1 then the task will be unblocked when a single byte is written to the buffer or the task's block time expires. As another example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 10 then the task will not be unblocked until the stream buffer contains at least 10 bytes or the task's block time expires. If a reading task's block time expires before the trigger level is reached then the task will still receive however many bytes are actually available. Setting a trigger level of 0 will result in a trigger level of 1 being used. It is not valid to specify a trigger level that is greater than the buffer size.</p>
<p>A trigger level is set when the stream buffer is created, and can be modified using xStreamBufferSetTriggerLevel().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer being updated.</p></li>
<li><p><strong>xTriggerLevel</strong> -- The new trigger level for the stream buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If xTriggerLevel was less than or equal to the stream buffer's length then the trigger level will be updated and pdTRUE is returned. Otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv433xStreamBufferSendCompletedFromISR20StreamBufferHandle_tP10BaseType_t">
<span id="_CPPv333xStreamBufferSendCompletedFromISR20StreamBufferHandle_tP10BaseType_t"></span><span id="_CPPv233xStreamBufferSendCompletedFromISR20StreamBufferHandle_tP10BaseType_t"></span><span id="xStreamBufferSendCompletedFromISR__StreamBufferHandle_t.BaseType_tP"></span><span class="target" id="stream__buffer_8h_1a734bf1bcef16810abb6d53781b8f1f07"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferSendCompletedFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433xStreamBufferSendCompletedFromISR20StreamBufferHandle_tP10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>For advanced users only.</p>
<p>The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when data is sent to a message buffer or stream buffer. If there was a task that was blocked on the message or stream buffer waiting for data to arrive then the sbSEND_COMPLETED() macro sends a notification to the task to remove it from the Blocked state. xStreamBufferSendCompletedFromISR() does the same thing. It is provided to enable application writers to implement their own version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.</p>
<p>See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for additional information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer to which data was written.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- *pxHigherPriorityTaskWoken should be initialised to pdFALSE before it is passed into xStreamBufferSendCompletedFromISR(). If calling xStreamBufferSendCompletedFromISR() removes a task from the Blocked state, and the task has a priority above the priority of the currently running task, then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a context switch should be performed before exiting the ISR.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If a task was removed from the Blocked state then pdTRUE is returned. Otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv436xStreamBufferReceiveCompletedFromISR20StreamBufferHandle_tP10BaseType_t">
<span id="_CPPv336xStreamBufferReceiveCompletedFromISR20StreamBufferHandle_tP10BaseType_t"></span><span id="_CPPv236xStreamBufferReceiveCompletedFromISR20StreamBufferHandle_tP10BaseType_t"></span><span id="xStreamBufferReceiveCompletedFromISR__StreamBufferHandle_t.BaseType_tP"></span><span class="target" id="stream__buffer_8h_1adbcf08da91cb0b9c179d012e0c99237d"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferReceiveCompletedFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv436xStreamBufferReceiveCompletedFromISR20StreamBufferHandle_tP10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>For advanced users only.</p>
<p>The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when data is read out of a message buffer or stream buffer. If there was a task that was blocked on the message or stream buffer waiting for data to arrive then the sbRECEIVE_COMPLETED() macro sends a notification to the task to remove it from the Blocked state. xStreamBufferReceiveCompletedFromISR() does the same thing. It is provided to enable application writers to implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.</p>
<p>See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for additional information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xStreamBuffer</strong> -- The handle of the stream buffer from which data was read.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- *pxHigherPriorityTaskWoken should be initialised to pdFALSE before it is passed into xStreamBufferReceiveCompletedFromISR(). If calling xStreamBufferReceiveCompletedFromISR() removes a task from the Blocked state, and the task has a priority above the priority of the currently running task, then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a context switch should be performed before exiting the ISR.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If a task was removed from the Blocked state then pdTRUE is returned. Otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id18">
<h3>Macros<a class="headerlink" href="#id18" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xStreamBufferCreateWithCallback">
<span class="target" id="stream__buffer_8h_1a1737ec8145762cf3e1f1b7c227e1b1f3"></span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferCreateWithCallback</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xBufferSizeBytes</span></span>, <span class="n"><span class="pre">xTriggerLevelBytes</span></span>, <span class="n"><span class="pre">pxSendCompletedCallback</span></span>, <span class="n"><span class="pre">pxReceiveCompletedCallback</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xStreamBufferCreateWithCallback" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new stream buffer using dynamically allocated memory. See xStreamBufferCreateStatic() for a version that uses statically allocated memory (memory that is allocated at compile time).</p>
<p>configSUPPORT_DYNAMIC_ALLOCATION must be set to 1 or left undefined in FreeRTOSConfig.h for xStreamBufferCreate() to be available.</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">StreamBufferHandle_t</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">xStreamBufferSizeBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="n">xTriggerLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a stream buffer that can hold 100 bytes.  The memory used to hold</span>
<span class="w"> </span><span class="c1">// both the stream buffer structure and the data in the stream buffer is</span>
<span class="w"> </span><span class="c1">// allocated dynamically.</span>
<span class="w"> </span><span class="n">xStreamBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xStreamBufferCreate</span><span class="p">(</span><span class="w"> </span><span class="n">xStreamBufferSizeBytes</span><span class="p">,</span><span class="w"> </span><span class="n">xTriggerLevel</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// There was not enough heap memory space available to create the</span>
<span class="w">     </span><span class="c1">// stream buffer.</span>
<span class="w"> </span><span class="p">}</span>
<span class="w"> </span><span class="k">else</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The stream buffer was created successfully and can now be used.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xBufferSizeBytes</strong> -- The total number of bytes the stream buffer will be able to hold at any one time.</p></li>
<li><p><strong>xTriggerLevelBytes</strong> -- The number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state. For example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 1 then the task will be unblocked when a single byte is written to the buffer or the task's block time expires. As another example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 10 then the task will not be unblocked until the stream buffer contains at least 10 bytes or the task's block time expires. If a reading task's block time expires before the trigger level is reached then the task will still receive however many bytes are actually available. Setting a trigger level of 0 will result in a trigger level of 1 being used. It is not valid to specify a trigger level that is greater than the buffer size.</p></li>
<li><p><strong>pxSendCompletedCallback</strong> -- Callback invoked when number of bytes at least equal to trigger level is sent to the stream buffer. If the parameter is NULL, it will use the default implementation provided by sbSEND_COMPLETED macro. To enable the callback, configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.</p></li>
<li><p><strong>pxReceiveCompletedCallback</strong> -- Callback invoked when more than zero bytes are read from a stream buffer. If the parameter is NULL, it will use the default implementation provided by sbRECEIVE_COMPLETED macro. To enable the callback, configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If NULL is returned, then the stream buffer cannot be created because there is insufficient heap memory available for FreeRTOS to allocate the stream buffer data structures and storage area. A non-NULL value being returned indicates that the stream buffer has been created successfully - the returned value should be stored as the handle to the created stream buffer.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xStreamBufferCreateStaticWithCallback">
<span class="target" id="stream__buffer_8h_1af10db11ba361f32fe0c2a66523e0dbb3"></span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferCreateStaticWithCallback</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xBufferSizeBytes</span></span>, <span class="n"><span class="pre">xTriggerLevelBytes</span></span>, <span class="n"><span class="pre">pucStreamBufferStorageArea</span></span>, <span class="n"><span class="pre">pxStaticStreamBuffer</span></span>, <span class="n"><span class="pre">pxSendCompletedCallback</span></span>, <span class="n"><span class="pre">pxReceiveCompletedCallback</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xStreamBufferCreateStaticWithCallback" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new stream buffer using statically allocated memory. See xStreamBufferCreate() for a version that uses dynamically allocated memory.</p>
<p>configSUPPORT_STATIC_ALLOCATION must be set to 1 in FreeRTOSConfig.h for xStreamBufferCreateStatic() to be available.</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Used to dimension the array used to hold the streams.  The available space</span>
<span class="w">  </span><span class="c1">// will actually be one less than this, so 999.</span>
<span class="cp">#define STORAGE_SIZE_BYTES 1000</span>
<span class="w"> </span>
<span class="w">  </span><span class="c1">// Defines the memory that will actually hold the streams within the stream</span>
<span class="w">  </span><span class="c1">// buffer.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucStorageBuffer</span><span class="p">[</span><span class="w"> </span><span class="n">STORAGE_SIZE_BYTES</span><span class="w"> </span><span class="p">];</span>
<span class="w"> </span>
<span class="w">  </span><span class="c1">// The variable used to hold the stream buffer structure.</span>
<span class="w">  </span><span class="n">StaticStreamBuffer_t</span><span class="w"> </span><span class="n">xStreamBufferStruct</span><span class="p">;</span>
<span class="w"> </span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">MyFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">  </span><span class="n">StreamBufferHandle_t</span><span class="w"> </span><span class="n">xStreamBuffer</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">xTriggerLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w"> </span>
<span class="w">   </span><span class="n">xStreamBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xStreamBufferCreateStatic</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucStorageBuffer</span><span class="w"> </span><span class="p">),</span>
<span class="w">                                              </span><span class="n">xTriggerLevel</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">ucStorageBuffer</span><span class="p">,</span>
<span class="w">                                              </span><span class="o">&amp;</span><span class="n">xStreamBufferStruct</span><span class="w"> </span><span class="p">);</span>
<span class="w"> </span>
<span class="w">   </span><span class="c1">// As neither the pucStreamBufferStorageArea or pxStaticStreamBuffer</span>
<span class="w">   </span><span class="c1">// parameters were NULL, xStreamBuffer will not be NULL, and can be used to</span>
<span class="w">   </span><span class="c1">// reference the created stream buffer in other stream buffer API calls.</span>
<span class="w"> </span>
<span class="w">   </span><span class="c1">// Other code that uses the stream buffer can go here.</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xBufferSizeBytes</strong> -- The size, in bytes, of the buffer pointed to by the pucStreamBufferStorageArea parameter.</p></li>
<li><p><strong>xTriggerLevelBytes</strong> -- The number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state. For example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 1 then the task will be unblocked when a single byte is written to the buffer or the task's block time expires. As another example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 10 then the task will not be unblocked until the stream buffer contains at least 10 bytes or the task's block time expires. If a reading task's block time expires before the trigger level is reached then the task will still receive however many bytes are actually available. Setting a trigger level of 0 will result in a trigger level of 1 being used. It is not valid to specify a trigger level that is greater than the buffer size.</p></li>
<li><p><strong>pucStreamBufferStorageArea</strong> -- Must point to a uint8_t array that is at least xBufferSizeBytes big. This is the array to which streams are copied when they are written to the stream buffer.</p></li>
<li><p><strong>pxStaticStreamBuffer</strong> -- Must point to a variable of type StaticStreamBuffer_t, which will be used to hold the stream buffer's data structure.</p></li>
<li><p><strong>pxSendCompletedCallback</strong> -- Callback invoked when number of bytes at least equal to trigger level is sent to the stream buffer. If the parameter is NULL, it will use the default implementation provided by sbSEND_COMPLETED macro. To enable the callback, configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.</p></li>
<li><p><strong>pxReceiveCompletedCallback</strong> -- Callback invoked when more than zero bytes are read from a stream buffer. If the parameter is NULL, it will use the default implementation provided by sbRECEIVE_COMPLETED macro. To enable the callback, configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the stream buffer is created successfully then a handle to the created stream buffer is returned. If either pucStreamBufferStorageArea or pxStaticstreamBuffer are NULL then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id19">
<h3>Type Definitions<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv420StreamBufferHandle_t">
<span id="_CPPv320StreamBufferHandle_t"></span><span id="_CPPv220StreamBufferHandle_t"></span><span id="StreamBufferHandle_t"></span><span class="target" id="stream__buffer_8h_1a8b80974e2278f073412293e6580ce56f"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">StreamBufferDef_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></span><a class="headerlink" href="#_CPPv420StreamBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv430StreamBufferCallbackFunction_t">
<span id="_CPPv330StreamBufferCallbackFunction_t"></span><span id="_CPPv230StreamBufferCallbackFunction_t"></span><span id="StreamBufferCallbackFunction_t"></span><span class="target" id="stream__buffer_8h_1a3fa0171a4f35fbb965cb152b91a97fc5"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">StreamBufferCallbackFunction_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">xStreamBuffer</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n"><span class="pre">xIsInsideISR</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv430StreamBufferCallbackFunction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type used as a stream buffer's optional callback. </p>
</dd></dl>

</section>
<section id="message-buffer-api">
<h3>Message Buffer API<a class="headerlink" href="#message-buffer-api" title="Permalink to this heading"></a></h3>
</section>
<section id="id20">
<h3>Header File<a class="headerlink" href="#id20" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/freertos/FreeRTOS-Kernel/include/freertos/message_buffer.h">components/freertos/FreeRTOS-Kernel/include/freertos/message_buffer.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/message_buffer.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id21">
<h3>Macros<a class="headerlink" href="#id21" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferCreateWithCallback">
<span class="target" id="message__buffer_8h_1a238005c8952f1de4979dd1d6ed5ad1ca"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferCreateWithCallback</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xBufferSizeBytes</span></span>, <span class="n"><span class="pre">pxSendCompletedCallback</span></span>, <span class="n"><span class="pre">pxReceiveCompletedCallback</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferCreateWithCallback" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new message buffer using dynamically allocated memory. See xMessageBufferCreateStatic() for a version that uses statically allocated memory (memory that is allocated at compile time).</p>
<p>configSUPPORT_DYNAMIC_ALLOCATION must be set to 1 or left undefined in FreeRTOSConfig.h for xMessageBufferCreate() to be available.</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">MessageBufferHandle_t</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">xMessageBufferSizeBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// Create a message buffer that can hold 100 bytes.  The memory used to hold</span>
<span class="w"> </span><span class="c1">// both the message buffer structure and the messages themselves is allocated</span>
<span class="w"> </span><span class="c1">// dynamically.  Each message added to the buffer consumes an additional 4</span>
<span class="w"> </span><span class="c1">// bytes which are used to hold the length of the message.</span>
<span class="w"> </span><span class="n">xMessageBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xMessageBufferCreate</span><span class="p">(</span><span class="w"> </span><span class="n">xMessageBufferSizeBytes</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// There was not enough heap memory space available to create the</span>
<span class="w">     </span><span class="c1">// message buffer.</span>
<span class="w"> </span><span class="p">}</span>
<span class="w"> </span><span class="k">else</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The message buffer was created successfully and can now be used.</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xBufferSizeBytes</strong> -- The total number of bytes (not messages) the message buffer will be able to hold at any one time. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so on most 32-bit architectures a 10 byte message will take up 14 bytes of message buffer space.</p></li>
<li><p><strong>pxSendCompletedCallback</strong> -- Callback invoked when a send operation to the message buffer is complete. If the parameter is NULL or xMessageBufferCreate() is called without the parameter, then it will use the default implementation provided by sbSEND_COMPLETED macro. To enable the callback, configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.</p></li>
<li><p><strong>pxReceiveCompletedCallback</strong> -- Callback invoked when a receive operation from the message buffer is complete. If the parameter is NULL or xMessageBufferCreate() is called without the parameter, it will use the default implementation provided by sbRECEIVE_COMPLETED macro. To enable the callback, configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If NULL is returned, then the message buffer cannot be created because there is insufficient heap memory available for FreeRTOS to allocate the message buffer data structures and storage area. A non-NULL value being returned indicates that the message buffer has been created successfully - the returned value should be stored as the handle to the created message buffer.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferCreateStaticWithCallback">
<span class="target" id="message__buffer_8h_1a22945c32c5c1e2f986fe7b2d57fa3a14"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferCreateStaticWithCallback</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xBufferSizeBytes</span></span>, <span class="n"><span class="pre">pucMessageBufferStorageArea</span></span>, <span class="n"><span class="pre">pxStaticMessageBuffer</span></span>, <span class="n"><span class="pre">pxSendCompletedCallback</span></span>, <span class="n"><span class="pre">pxReceiveCompletedCallback</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferCreateStaticWithCallback" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a new message buffer using statically allocated memory. See xMessageBufferCreate() for a version that uses dynamically allocated memory.</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Used to dimension the array used to hold the messages.  The available space</span>
<span class="c1">// will actually be one less than this, so 999.</span>
<span class="cp">#define STORAGE_SIZE_BYTES 1000</span>

<span class="c1">// Defines the memory that will actually hold the messages within the message</span>
<span class="c1">// buffer.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucStorageBuffer</span><span class="p">[</span><span class="w"> </span><span class="n">STORAGE_SIZE_BYTES</span><span class="w"> </span><span class="p">];</span>

<span class="c1">// The variable used to hold the message buffer structure.</span>
<span class="n">StaticMessageBuffer_t</span><span class="w"> </span><span class="n">xMessageBufferStruct</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">MyFunction</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="n">MessageBufferHandle_t</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="p">;</span>

<span class="w"> </span><span class="n">xMessageBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xMessageBufferCreateStatic</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucStorageBuffer</span><span class="w"> </span><span class="p">),</span>
<span class="w">                                              </span><span class="n">ucStorageBuffer</span><span class="p">,</span>
<span class="w">                                              </span><span class="o">&amp;</span><span class="n">xMessageBufferStruct</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// As neither the pucMessageBufferStorageArea or pxStaticMessageBuffer</span>
<span class="w"> </span><span class="c1">// parameters were NULL, xMessageBuffer will not be NULL, and can be used to</span>
<span class="w"> </span><span class="c1">// reference the created message buffer in other message buffer API calls.</span>

<span class="w"> </span><span class="c1">// Other code that uses the message buffer can go here.</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xBufferSizeBytes</strong> -- The size, in bytes, of the buffer pointed to by the pucMessageBufferStorageArea parameter. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so on most 32-bit architecture a 10 byte message will take up 14 bytes of message buffer space. The maximum number of bytes that can be stored in the message buffer is actually (xBufferSizeBytes - 1).</p></li>
<li><p><strong>pucMessageBufferStorageArea</strong> -- Must point to a uint8_t array that is at least xBufferSizeBytes big. This is the array to which messages are copied when they are written to the message buffer.</p></li>
<li><p><strong>pxStaticMessageBuffer</strong> -- Must point to a variable of type StaticMessageBuffer_t, which will be used to hold the message buffer's data structure.</p></li>
<li><p><strong>pxSendCompletedCallback</strong> -- Callback invoked when a new message is sent to the message buffer. If the parameter is NULL or xMessageBufferCreate() is called without the parameter, then it will use the default implementation provided by sbSEND_COMPLETED macro. To enable the callback, configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.</p></li>
<li><p><strong>pxReceiveCompletedCallback</strong> -- Callback invoked when a message is read from a message buffer. If the parameter is NULL or xMessageBufferCreate() is called without the parameter, it will use the default implementation provided by sbRECEIVE_COMPLETED macro. To enable the callback, configUSE_SB_COMPLETED_CALLBACK must be set to 1 in FreeRTOSConfig.h.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the message buffer is created successfully then a handle to the created message buffer is returned. If either pucMessageBufferStorageArea or pxStaticmessageBuffer are NULL then NULL is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferGetStaticBuffers">
<span class="target" id="message__buffer_8h_1ac439b58bb4e7fc4c98664a7eeecd8719"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferGetStaticBuffers</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span>, <span class="n"><span class="pre">ppucMessageBufferStorageArea</span></span>, <span class="n"><span class="pre">ppxStaticMessageBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferGetStaticBuffers" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve pointers to a statically created message buffer's data structure buffer and storage area buffer. These are the same buffers that are supplied at the time of creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The message buffer for which to retrieve the buffers.</p></li>
<li><p><strong>ppucMessageBufferStorageArea</strong> -- Used to return a pointer to the message buffer's storage area buffer.</p></li>
<li><p><strong>ppxStaticMessageBuffer</strong> -- Used to return a pointer to the message buffer's data structure buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if buffers were retrieved, pdFALSE otherwise. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferSend">
<span class="target" id="message__buffer_8h_1a858f6da6fe24a226c45caf1634ea1605"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferSend</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span>, <span class="n"><span class="pre">pvTxData</span></span>, <span class="n"><span class="pre">xDataLengthBytes</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferSend" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sends a discrete message to the message buffer. The message can be any length that fits within the buffer's free space, and is copied into the buffer.</p>
<p><em><strong>NOTE</strong></em>: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xMessageBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xMessageBufferRead()) inside a critical section and set the receive block time to 0.</p>
<p>Use xMessageBufferSend() to write to a message buffer from a task. Use xMessageBufferSendFromISR() to write to a message buffer from an interrupt service routine (ISR).</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="n">MessageBufferHandle_t</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">xBytesSent</span><span class="p">;</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucArrayToSend</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcStringToSend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;String to send&quot;</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">x100ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Send an array to the message buffer, blocking for a maximum of 100ms to</span>
<span class="w"> </span><span class="c1">// wait for enough space to be available in the message buffer.</span>
<span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xMessageBufferSend</span><span class="p">(</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ucArrayToSend</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucArrayToSend</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">x100ms</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucArrayToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The call to xMessageBufferSend() times out before there was enough</span>
<span class="w">     </span><span class="c1">// space in the buffer for the data to be written.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// Send the string to the message buffer.  Return immediately if there is</span>
<span class="w"> </span><span class="c1">// not enough space in the buffer.</span>
<span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xMessageBufferSend</span><span class="p">(</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The string could not be added to the message buffer because there was</span>
<span class="w">     </span><span class="c1">// not enough free space in the buffer.</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer to which a message is being sent.</p></li>
<li><p><strong>pvTxData</strong> -- A pointer to the message that is to be copied into the message buffer.</p></li>
<li><p><strong>xDataLengthBytes</strong> -- The length of the message. That is, the number of bytes to copy from pvTxData into the message buffer. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so on most 32-bit architecture setting xDataLengthBytes to 20 will reduce the free space in the message buffer by 24 bytes (20 bytes of message data and 4 bytes to hold the message length).</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the calling task should remain in the Blocked state to wait for enough space to become available in the message buffer, should the message buffer have insufficient space when xMessageBufferSend() is called. The calling task will never block if xTicksToWait is zero. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting xTicksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. Tasks do not use any CPU time when they are in the Blocked state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bytes written to the message buffer. If the call to xMessageBufferSend() times out before there was enough space to write the message into the message buffer then zero is returned. If the call did not time out then xDataLengthBytes is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferSendFromISR">
<span class="target" id="message__buffer_8h_1aeef5b0c4f8c2db6ca2230a8874813e79"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferSendFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span>, <span class="n"><span class="pre">pvTxData</span></span>, <span class="n"><span class="pre">xDataLengthBytes</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferSendFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>Interrupt safe version of the API function that sends a discrete message to the message buffer. The message can be any length that fits within the buffer's free space, and is copied into the buffer.</p>
<p><em><strong>NOTE</strong></em>: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xMessageBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xMessageBufferRead()) inside a critical section and set the receive block time to 0.</p>
<p>Use xMessageBufferSend() to write to a message buffer from a task. Use xMessageBufferSendFromISR() to write to a message buffer from an interrupt service routine (ISR).</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// A message buffer that has already been created.</span>
<span class="n">MessageBufferHandle_t</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vAnInterruptServiceRoutine</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">xBytesSent</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pcStringToSend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;String to send&quot;</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initialised to pdFALSE.</span>

<span class="w"> </span><span class="c1">// Attempt to send the string to the message buffer.</span>
<span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xMessageBufferSendFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="p">,</span>
<span class="w">                                         </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="w"> </span><span class="p">),</span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xBytesSent</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="w"> </span><span class="n">pcStringToSend</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// The string could not be added to the message buffer because there was</span>
<span class="w">     </span><span class="c1">// not enough free space in the buffer.</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// If xHigherPriorityTaskWoken was set to pdTRUE inside</span>
<span class="w"> </span><span class="c1">// xMessageBufferSendFromISR() then a task that has a priority above the</span>
<span class="w"> </span><span class="c1">// priority of the currently executing task was unblocked and a context</span>
<span class="w"> </span><span class="c1">// switch should be performed to ensure the ISR returns to the unblocked</span>
<span class="w"> </span><span class="c1">// task.  In most FreeRTOS ports this is done by simply passing</span>
<span class="w"> </span><span class="c1">// xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the</span>
<span class="w"> </span><span class="c1">// variables value, and perform the context switch if necessary.  Check the</span>
<span class="w"> </span><span class="c1">// documentation for the port in use for port specific instructions.</span>
<span class="w"> </span><span class="n">portYIELD_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer to which a message is being sent.</p></li>
<li><p><strong>pvTxData</strong> -- A pointer to the message that is to be copied into the message buffer.</p></li>
<li><p><strong>xDataLengthBytes</strong> -- The length of the message. That is, the number of bytes to copy from pvTxData into the message buffer. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so on most 32-bit architecture setting xDataLengthBytes to 20 will reduce the free space in the message buffer by 24 bytes (20 bytes of message data and 4 bytes to hold the message length).</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- It is possible that a message buffer will have a task blocked on it waiting for data. Calling xMessageBufferSendFromISR() can make data available, and so cause a task that was waiting for data to leave the Blocked state. If calling xMessageBufferSendFromISR() causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, xMessageBufferSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE. If xMessageBufferSendFromISR() sets this value to pdTRUE, then normally a context switch should be performed before the interrupt is exited. This will ensure that the interrupt returns directly to the highest priority Ready state task. *pxHigherPriorityTaskWoken should be set to pdFALSE before it is passed into the function. See the code example below for an example.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bytes actually written to the message buffer. If the message buffer didn't have enough free space for the message to be stored then 0 is returned, otherwise xDataLengthBytes is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferReceive">
<span class="target" id="message__buffer_8h_1af12a227ba511a95cbea5aa81c7f3ba12"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferReceive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span>, <span class="n"><span class="pre">pvRxData</span></span>, <span class="n"><span class="pre">xBufferLengthBytes</span></span>, <span class="n"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferReceive" title="Permalink to this definition"></a><br /></dt>
<dd><p>Receives a discrete message from a message buffer. Messages can be of variable length and are copied out of the buffer.</p>
<p><em><strong>NOTE</strong></em>: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xMessageBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xMessageBufferRead()) inside a critical section and set the receive block time to 0.</p>
<p>Use xMessageBufferReceive() to read from a message buffer from a task. Use xMessageBufferReceiveFromISR() to read from a message buffer from an interrupt service routine (ISR).</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vAFunction</span><span class="p">(</span><span class="w"> </span><span class="n">MessageBuffer_t</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucRxData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">xReceivedBytes</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">TickType_t</span><span class="w"> </span><span class="n">xBlockTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="c1">// Receive the next message from the message buffer.  Wait in the Blocked</span>
<span class="w"> </span><span class="c1">// state (so not using any CPU processing time) for a maximum of 100ms for</span>
<span class="w"> </span><span class="c1">// a message to become available.</span>
<span class="w"> </span><span class="n">xReceivedBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xMessageBufferReceive</span><span class="p">(</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="p">,</span>
<span class="w">                                         </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ucRxData</span><span class="p">,</span>
<span class="w">                                         </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucRxData</span><span class="w"> </span><span class="p">),</span>
<span class="w">                                         </span><span class="n">xBlockTime</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xReceivedBytes</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// A ucRxData contains a message that is xReceivedBytes long.  Process</span>
<span class="w">     </span><span class="c1">// the message here....</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer from which a message is being received.</p></li>
<li><p><strong>pvRxData</strong> -- A pointer to the buffer into which the received message is to be copied.</p></li>
<li><p><strong>xBufferLengthBytes</strong> -- The length of the buffer pointed to by the pvRxData parameter. This sets the maximum length of the message that can be received. If xBufferLengthBytes is too small to hold the next message then the message will be left in the message buffer and 0 will be returned.</p></li>
<li><p><strong>xTicksToWait</strong> -- The maximum amount of time the task should remain in the Blocked state to wait for a message, should the message buffer be empty. xMessageBufferReceive() will return immediately if xTicksToWait is zero and the message buffer is empty. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting xTicksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. Tasks do not use any CPU time when they are in the Blocked state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The length, in bytes, of the message read from the message buffer, if any. If xMessageBufferReceive() times out before a message became available then zero is returned. If the length of the message is greater than xBufferLengthBytes then the message will be left in the message buffer and zero is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferReceiveFromISR">
<span class="target" id="message__buffer_8h_1adf596c00c44752a3c8c542cc6b5df234"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferReceiveFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span>, <span class="n"><span class="pre">pvRxData</span></span>, <span class="n"><span class="pre">xBufferLengthBytes</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferReceiveFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>An interrupt safe version of the API function that receives a discrete message from a message buffer. Messages can be of variable length and are copied out of the buffer.</p>
<p><em><strong>NOTE</strong></em>: Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as xMessageBufferSend()) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as xMessageBufferRead()) inside a critical section and set the receive block time to 0.</p>
<p>Use xMessageBufferReceive() to read from a message buffer from a task. Use xMessageBufferReceiveFromISR() to read from a message buffer from an interrupt service routine (ISR).</p>
<p>
Example use: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// A message buffer that has already been created.</span>
<span class="n">MessageBuffer_t</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vAnInterruptServiceRoutine</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ucRxData</span><span class="p">[</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">xReceivedBytes</span><span class="p">;</span>
<span class="n">BaseType_t</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdFALSE</span><span class="p">;</span><span class="w">  </span><span class="c1">// Initialised to pdFALSE.</span>

<span class="w"> </span><span class="c1">// Receive the next message from the message buffer.</span>
<span class="w"> </span><span class="n">xReceivedBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xMessageBufferReceiveFromISR</span><span class="p">(</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="p">,</span>
<span class="w">                                               </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">ucRxData</span><span class="p">,</span>
<span class="w">                                               </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">ucRxData</span><span class="w"> </span><span class="p">),</span>
<span class="w">                                               </span><span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>

<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">xReceivedBytes</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// A ucRxData contains a message that is xReceivedBytes long.  Process</span>
<span class="w">     </span><span class="c1">// the message here....</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">// If xHigherPriorityTaskWoken was set to pdTRUE inside</span>
<span class="w"> </span><span class="c1">// xMessageBufferReceiveFromISR() then a task that has a priority above the</span>
<span class="w"> </span><span class="c1">// priority of the currently executing task was unblocked and a context</span>
<span class="w"> </span><span class="c1">// switch should be performed to ensure the ISR returns to the unblocked</span>
<span class="w"> </span><span class="c1">// task.  In most FreeRTOS ports this is done by simply passing</span>
<span class="w"> </span><span class="c1">// xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the</span>
<span class="w"> </span><span class="c1">// variables value, and perform the context switch if necessary.  Check the</span>
<span class="w"> </span><span class="c1">// documentation for the port in use for port specific instructions.</span>
<span class="w"> </span><span class="n">portYIELD_FROM_ISR</span><span class="p">(</span><span class="w"> </span><span class="n">xHigherPriorityTaskWoken</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer from which a message is being received.</p></li>
<li><p><strong>pvRxData</strong> -- A pointer to the buffer into which the received message is to be copied.</p></li>
<li><p><strong>xBufferLengthBytes</strong> -- The length of the buffer pointed to by the pvRxData parameter. This sets the maximum length of the message that can be received. If xBufferLengthBytes is too small to hold the next message then the message will be left in the message buffer and 0 will be returned.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- It is possible that a message buffer will have a task blocked on it waiting for space to become available. Calling xMessageBufferReceiveFromISR() can make space available, and so cause a task that is waiting for space to leave the Blocked state. If calling xMessageBufferReceiveFromISR() causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, xMessageBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE. If xMessageBufferReceiveFromISR() sets this value to pdTRUE, then normally a context switch should be performed before the interrupt is exited. That will ensure the interrupt returns directly to the highest priority Ready state task. *pxHigherPriorityTaskWoken should be set to pdFALSE before it is passed into the function. See the code example below for an example.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The length, in bytes, of the message read from the message buffer, if any.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.vMessageBufferDelete">
<span class="target" id="message__buffer_8h_1aa29d6c50600a7b0154e4a47e7c981d1a"></span><span class="sig-name descname"><span class="n"><span class="pre">vMessageBufferDelete</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vMessageBufferDelete" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deletes a message buffer that was previously created using a call to xMessageBufferCreate() or xMessageBufferCreateStatic(). If the message buffer was created using dynamic memory (that is, by xMessageBufferCreate()), then the allocated memory is freed.</p>
<p>A message buffer handle must not be used after the message buffer has been deleted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer to be deleted. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferIsFull">
<span class="target" id="message__buffer_8h_1a60a7e136b74c2a8ce703a99ef636f179"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferIsFull</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferIsFull" title="Permalink to this definition"></a><br /></dt>
<dd><p>Tests to see if a message buffer is full. A message buffer is full if it cannot accept any more messages, of any size, until space is made available by a message being removed from the message buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer being queried.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the message buffer referenced by xMessageBuffer is full then pdTRUE is returned. Otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferIsEmpty">
<span class="target" id="message__buffer_8h_1a7bc30ef43be4bd228d80de1da88c71d8"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferIsEmpty</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferIsEmpty" title="Permalink to this definition"></a><br /></dt>
<dd><p>Tests to see if a message buffer is empty (does not contain any messages).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer being queried.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the message buffer referenced by xMessageBuffer is empty then pdTRUE is returned. Otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferReset">
<span class="target" id="message__buffer_8h_1a6d22ac0fd0463b202f2e22674380a41c"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferReset</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferReset" title="Permalink to this definition"></a><br /></dt>
<dd><p>Resets a message buffer to its initial empty state, discarding any message it contained.</p>
<p>A message buffer can only be reset if there are no tasks blocked on it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer being reset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the message buffer was reset then pdPASS is returned. If the message buffer could not be reset because either there was a task blocked on the message queue to wait for space to become available, or to wait for a a message to be available, then pdFAIL is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferSpaceAvailable">
<span class="target" id="message__buffer_8h_1a9f1e75a283ef603e914e10ae354e5ab8"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferSpaceAvailable</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferSpaceAvailable" title="Permalink to this definition"></a><br /></dt>
<dd><p>message_buffer.h <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="nf">xMessageBufferSpaceAvailable</span><span class="p">(</span><span class="w"> </span><span class="n">MessageBufferHandle_t</span><span class="w"> </span><span class="n">xMessageBuffer</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
 Returns the number of bytes of free space in the message buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer being queried.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of bytes that can be written to the message buffer before the message buffer would be full. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so if xMessageBufferSpacesAvailable() returns 10, then the size of the largest message that can be written to the message buffer is 6 bytes. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferSpacesAvailable">
<span class="target" id="message__buffer_8h_1a572622608a32242b1d7a922b71f96658"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferSpacesAvailable</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferSpacesAvailable" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferNextLengthBytes">
<span class="target" id="message__buffer_8h_1ae2b56b6564cf2476891394231a31ecad"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferNextLengthBytes</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferNextLengthBytes" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the length (in bytes) of the next message in a message buffer. Useful if xMessageBufferReceive() returned 0 because the size of the buffer passed into xMessageBufferReceive() was too small to hold the next message.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the message buffer being queried.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The length (in bytes) of the next message in the message buffer, or 0 if the message buffer is empty. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferSendCompletedFromISR">
<span class="target" id="message__buffer_8h_1a45918d12bf530cb2b4bf21c0936460a9"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferSendCompletedFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferSendCompletedFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>For advanced users only.</p>
<p>The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when data is sent to a message buffer or stream buffer. If there was a task that was blocked on the message or stream buffer waiting for data to arrive then the sbSEND_COMPLETED() macro sends a notification to the task to remove it from the Blocked state. xMessageBufferSendCompletedFromISR() does the same thing. It is provided to enable application writers to implement their own version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.</p>
<p>See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for additional information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the stream buffer to which data was written.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- *pxHigherPriorityTaskWoken should be initialised to pdFALSE before it is passed into xMessageBufferSendCompletedFromISR(). If calling xMessageBufferSendCompletedFromISR() removes a task from the Blocked state, and the task has a priority above the priority of the currently running task, then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a context switch should be performed before exiting the ISR.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If a task was removed from the Blocked state then pdTRUE is returned. Otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.xMessageBufferReceiveCompletedFromISR">
<span class="target" id="message__buffer_8h_1a22b1a37d0d4f39acd87250f73d9aab0c"></span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferReceiveCompletedFromISR</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">xMessageBuffer</span></span>, <span class="n"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xMessageBufferReceiveCompletedFromISR" title="Permalink to this definition"></a><br /></dt>
<dd><p>For advanced users only.</p>
<p>The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when data is read out of a message buffer or stream buffer. If there was a task that was blocked on the message or stream buffer waiting for data to arrive then the sbRECEIVE_COMPLETED() macro sends a notification to the task to remove it from the Blocked state. xMessageBufferReceiveCompletedFromISR() does the same thing. It is provided to enable application writers to implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.</p>
<p>See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for additional information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xMessageBuffer</strong> -- The handle of the stream buffer from which data was read.</p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- *pxHigherPriorityTaskWoken should be initialised to pdFALSE before it is passed into xMessageBufferReceiveCompletedFromISR(). If calling xMessageBufferReceiveCompletedFromISR() removes a task from the Blocked state, and the task has a priority above the priority of the currently running task, then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a context switch should be performed before exiting the ISR.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If a task was removed from the Blocked state then pdTRUE is returned. Otherwise pdFALSE is returned. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id22">
<h3>Type Definitions<a class="headerlink" href="#id22" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv421MessageBufferHandle_t">
<span id="_CPPv321MessageBufferHandle_t"></span><span id="_CPPv221MessageBufferHandle_t"></span><span id="MessageBufferHandle_t"></span><span class="target" id="message__buffer_8h_1a6c510e0a4aeb3a08df4af49c1d651057"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">MessageBufferHandle_t</span></span></span><a class="headerlink" href="#_CPPv421MessageBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type by which message buffers are referenced. For example, a call to xMessageBufferCreate() returns an MessageBufferHandle_t variable that can then be used as a parameter to xMessageBufferSend(), xMessageBufferReceive(), etc. Message buffer is essentially built as a stream buffer hence its handle is also set to same type as a stream buffer handle. </p>
</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=FreeRTOS (IDF) (api-reference/system/freertos_idf)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=FreeRTOS (IDF) (api-reference/system/freertos_idf)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="freertos.html" class="btn btn-neutral float-left" title="FreeRTOS Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="freertos_additions.html" class="btn btn-neutral float-right" title="FreeRTOS (Supplemental Features)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>