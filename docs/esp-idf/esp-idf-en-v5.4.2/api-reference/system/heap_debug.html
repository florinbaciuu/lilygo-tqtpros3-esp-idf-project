<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Heap Memory Debugging - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/heap_debug.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/system/heap_debug';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="ESP Timer (High Resolution Timer)" href="esp_timer.html" />
    <link rel="prev" title="Memory Management for MMU Supported Memory" href="mm.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth® API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Project Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">System API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">App Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="bootloader_image_format.html">Bootloader Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">Application Level Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_function_with_shared_stack.html">Call Function with External Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="chip_revision.html">Chip Revision</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console</a></li>
<li class="toctree-l3"><a class="reference internal" href="efuse.html">eFuse Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">Error Code and Helper Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">Event Loop Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos.html">FreeRTOS Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_idf.html">FreeRTOS (IDF)</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_additions.html">FreeRTOS (Supplemental Features)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mem_alloc.html">Heap Memory Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm.html">Memory Management for MMU Supported Memory</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Heap Memory Debugging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-information">Heap Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-allocation-and-free-function-hooks">Heap Allocation and Free Function Hooks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-corruption-detection">Heap Corruption Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-task-tracking">Heap Task Tracking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-tracing">Heap Tracing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-examples">Application Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference-heap-tracing">API Reference - Heap Tracing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">ESP Timer (High Resolution Timer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="internal-unstable.html">Internal and Unstable APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">Inter-Processor Call (IPC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">Interrupt Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">Logging library</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_system_api.html">Miscellaneous System APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">Over The Air Updates (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">Performance Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="pthread.html">POSIX Support (Including POSIX Threads Support)</a></li>
<li class="toctree-l3"><a class="reference internal" href="random.html">Random Number Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">Sleep Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="soc_caps.html">SoC Capabilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">System Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ulp.html">ULP Coprocessor Programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">Watchdogs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">System API</a></li>
      <li class="breadcrumb-item active">Heap Memory Debugging</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-reference/system/heap_debug.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="heap-memory-debugging">
<h1>Heap Memory Debugging<a class="headerlink" href="#heap-memory-debugging" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/v5.4.2/esp32/api-reference/system/heap_debug.html">[中文]</a></p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>ESP-IDF integrates tools for requesting <a class="reference internal" href="#heap-information"><span class="std std-ref">heap information</span></a>, <a class="reference internal" href="#heap-corruption"><span class="std std-ref">heap corruption detection</span></a>, and <a class="reference internal" href="#heap-tracing"><span class="std std-ref">heap tracing</span></a>. These can help track down memory-related bugs.</p>
<p>For general information about the heap memory allocator, see <a class="reference internal" href="mem_alloc.html"><span class="doc">Heap Memory Allocation</span></a>.</p>
</section>
<section id="heap-information">
<span id="id1"></span><h2>Heap Information<a class="headerlink" href="#heap-information" title="Permalink to this heading"></a></h2>
<p>To obtain information about the state of the heap, call the following functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv423heap_caps_get_free_size8uint32_t" title="heap_caps_get_free_size"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_free_size()</span></code></a> can be used to return the current free memory for different memory capabilities.</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv432heap_caps_get_largest_free_block8uint32_t" title="heap_caps_get_largest_free_block"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_largest_free_block()</span></code></a> can be used to return the largest free block in the heap, which is also the largest single allocation currently possible. Tracking this value and comparing it to the total free heap allows you to detect heap fragmentation.</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv431heap_caps_get_minimum_free_size8uint32_t" title="heap_caps_get_minimum_free_size"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_minimum_free_size()</span></code></a> can be used to track the heap &quot;low watermark&quot; since boot.</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv418heap_caps_get_infoP17multi_heap_info_t8uint32_t" title="heap_caps_get_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_info()</span></code></a> returns a <a class="reference internal" href="mem_alloc.html#_CPPv417multi_heap_info_t" title="multi_heap_info_t"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">multi_heap_info_t</span></code></a> structure, which contains the information from the above functions, plus some additional heap-specific data (number of allocations, etc.).</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv425heap_caps_print_heap_info8uint32_t" title="heap_caps_print_heap_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_heap_info()</span></code></a> prints a summary of the information returned by <a class="reference internal" href="mem_alloc.html#_CPPv418heap_caps_get_infoP17multi_heap_info_t8uint32_t" title="heap_caps_get_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_info()</span></code></a> to stdout.</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_dump8uint32_t" title="heap_caps_dump"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_dump()</span></code></a> and <a class="reference internal" href="mem_alloc.html#_CPPv418heap_caps_dump_allv" title="heap_caps_dump_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_dump_all()</span></code></a> output detailed information about the structure of each block in the heap. Note that this can be a large amount of output.</p></li>
</ul>
</section>
<section id="heap-allocation-and-free-function-hooks">
<span id="heap-allocation-free"></span><h2>Heap Allocation and Free Function Hooks<a class="headerlink" href="#heap-allocation-and-free-function-hooks" title="Permalink to this heading"></a></h2>
<p>Heap allocation and free detection hooks allow you to be notified of every successful allocation and free operation:</p>
<ul class="simple">
<li><p>Providing a definition of <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_alloc_hook()</span></code> allows you to be notified of every successful memory allocation operation</p></li>
<li><p>Providing a definition of <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_free_hook()</span></code> allows you to be notified of every successful memory-free operations</p></li>
</ul>
<p>This feature can be enabled by setting the <a class="reference internal" href="../kconfig.html#config-heap-use-hooks"><span class="std std-ref">CONFIG_HEAP_USE_HOOKS</span></a> option. <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_alloc_hook()</span></code> and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_free_hook()</span></code> have weak declarations (e.g., <code class="docutils literal notranslate"><span class="pre">__attribute__((weak))</span></code>), thus it is not necessary to provide declarations for both hooks. Given that it is technically possible to allocate and free memory from an ISR (<strong>though strongly discouraged from doing so</strong>), the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_alloc_hook()</span></code> and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_free_hook()</span></code> can potentially be called from an ISR.</p>
<p>It is not recommended to perform (or call API functions to perform) blocking operations or memory allocation/free operations in the hook functions. In general, the best practice is to keep the implementation concise and leave the heavy computation outside of the hook functions.</p>
<p>The example below shows how to define the allocation and free function hooks:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_caps.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">esp_heap_trace_alloc_hook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">caps</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">esp_heap_trace_free_hook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">app_main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="heap-corruption-detection">
<span id="heap-corruption"></span><h2>Heap Corruption Detection<a class="headerlink" href="#heap-corruption-detection" title="Permalink to this heading"></a></h2>
<p>Heap corruption detection allows you to detect various types of heap memory errors:</p>
<ul class="simple">
<li><p>Out-of-bound writes &amp; buffer overflows</p></li>
<li><p>Writes to freed memory</p></li>
<li><p>Reads from freed or uninitialized memory</p></li>
</ul>
<section id="assertions">
<h3>Assertions<a class="headerlink" href="#assertions" title="Permalink to this heading"></a></h3>
<p>The heap implementation (<a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/heap/multi_heap.c">heap/multi_heap.c</a>, etc.) includes numerous assertions that will fail if the heap memory is corrupted. To detect heap corruption most effectively, ensure that assertions are enabled in the project configuration via the <a class="reference internal" href="../kconfig.html#config-compiler-optimization-assertion-level"><span class="std std-ref">CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL</span></a> option.</p>
<p>If a heap integrity assertion fails, a line will be printed like <code class="docutils literal notranslate"><span class="pre">CORRUPT</span> <span class="pre">HEAP:</span> <span class="pre">multi_heap.c:225</span> <span class="pre">detected</span> <span class="pre">at</span> <span class="pre">0x3ffbb71c</span></code>. The memory address printed is the address of the heap structure that has corrupt content.</p>
<p>It is also possible to manually check heap integrity by calling <a class="reference internal" href="mem_alloc.html#_CPPv429heap_caps_check_integrity_allb" title="heap_caps_check_integrity_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity_all()</span></code></a> or related functions. This function checks all of the requested heap memory for integrity and can be used even if assertions are disabled. If the integrity checks detects an error, it will print the error along with the address(es) of corrupt heap structures.</p>
</section>
<section id="memory-allocation-failed-hook">
<h3>Memory Allocation Failed Hook<a class="headerlink" href="#memory-allocation-failed-hook" title="Permalink to this heading"></a></h3>
<p>Users can use <a class="reference internal" href="mem_alloc.html#_CPPv440heap_caps_register_failed_alloc_callback23esp_alloc_failed_hook_t" title="heap_caps_register_failed_alloc_callback"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_register_failed_alloc_callback()</span></code></a> to register a callback that is invoked every time an allocation operation fails.</p>
<p>Additionally, users can enable the <a class="reference internal" href="../kconfig.html#config-heap-abort-when-allocation-fails"><span class="std std-ref">CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS</span></a>, which will automatically trigger a system abort if any allocation operation fails.</p>
<p>The example below shows how to register an allocation failure callback:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_caps.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">heap_caps_alloc_failed_hook</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">requested_size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">caps</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">function_name</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s was called but failed to allocate %d bytes with 0x%X capabilities. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">function_name</span><span class="p">,</span><span class="w"> </span><span class="n">requested_size</span><span class="p">,</span><span class="w"> </span><span class="n">caps</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">app_main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">esp_err_t</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap_caps_register_failed_alloc_callback</span><span class="p">(</span><span class="n">heap_caps_alloc_failed_hook</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap_caps_malloc</span><span class="p">(</span><span class="n">allocation_size</span><span class="p">,</span><span class="w"> </span><span class="n">MALLOC_CAP_DEFAULT</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="finding-heap-corruption">
<h3>Finding Heap Corruption<a class="headerlink" href="#finding-heap-corruption" title="Permalink to this heading"></a></h3>
<p>Memory corruption can be one of the hardest classes of bugs to find and fix, as the source of the corruption could be completely unrelated to the symptoms of the corruption. Here are some tips:</p>
<ul class="simple">
<li><p>A crash with a <code class="docutils literal notranslate"><span class="pre">CORRUPT</span> <span class="pre">HEAP:</span></code> message usually includes a stack trace, but this stack trace is rarely useful. The crash is the symptom of memory corruption when the system realizes the heap is corrupt. But usually, the corruption happens elsewhere and earlier in time.</p></li>
<li><p>Increasing the heap memory debugging <a class="reference internal" href="#configuration">Configuration</a> level to &quot;Light impact&quot; or &quot;Comprehensive&quot; gives you a more accurate message with the first corrupt memory address.</p></li>
<li><p>Adding regular calls to <a class="reference internal" href="mem_alloc.html#_CPPv429heap_caps_check_integrity_allb" title="heap_caps_check_integrity_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity_all()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv430heap_caps_check_integrity_addr8intptr_tb" title="heap_caps_check_integrity_addr"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity_addr()</span></code></a> in your code helps you pin down the exact time that the corruption happened. You can move these checks around to &quot;close in on&quot; the section of code that corrupted the heap.</p></li>
<li><p>Based on the memory address that has been corrupted, you can use <a class="reference internal" href="../../api-guides/jtag-debugging/index.html#jtag-debugging-introduction"><span class="std std-ref">JTAG debugging</span></a> to set a watchpoint on this address and have the CPU halt when it is written to.</p></li>
<li><p>If you do not have JTAG, but you do know roughly when the corruption happens, set a watchpoint in software just beforehand via <a class="reference internal" href="misc_system_api.html#_CPPv422esp_cpu_set_watchpointiPKv6size_t28esp_cpu_watchpoint_trigger_t" title="esp_cpu_set_watchpoint"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_cpu_set_watchpoint()</span></code></a>. A fatal exception will occur when the watchpoint triggers. The following is an example of how to use the function - <code class="docutils literal notranslate"><span class="pre">esp_cpu_set_watchpoint(0,</span> <span class="pre">(void</span> <span class="pre">*)addr,</span> <span class="pre">4,</span> <span class="pre">ESP_WATCHPOINT_STORE)</span></code>. Note that watchpoints are per-CPU and are set on the current running CPU only. So if you do not know which CPU is corrupting memory, call this function on both CPUs.</p></li>
<li><p>For buffer overflows, <a class="reference internal" href="#id3">heap tracing</a> in <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_ALL</span></code> mode tells which callers are allocating which addresses from the heap. See <a class="reference internal" href="#heap-tracing-to-find-heap-corruption">Heap Tracing To Find Heap Corruption</a> for more details. You can try to find the function that allocates memory with an address immediately before the corrupted address, since it is probably the function that overflows the buffer.</p></li>
<li><p>Calling <a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_dump8uint32_t" title="heap_caps_dump"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_dump()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv418heap_caps_dump_allv" title="heap_caps_dump_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_dump_all()</span></code></a> can give an indication of what heap blocks are surrounding the corrupted region and may have overflowed or underflowed, etc.</p></li>
</ul>
</section>
<section id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this heading"></a></h3>
<p>Temporarily increasing the heap corruption detection level can give more detailed information about heap corruption errors.</p>
<p>In the project configuration menu, under <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code>, there is a menu <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">memory</span> <span class="pre">debugging</span></code>. The option <a class="reference internal" href="../kconfig.html#config-heap-corruption-detection"><span class="std std-ref">CONFIG_HEAP_CORRUPTION_DETECTION</span></a> can be set to one of the following three levels:</p>
<section id="basic-no-poisoning">
<h4>Basic (No Poisoning)<a class="headerlink" href="#basic-no-poisoning" title="Permalink to this heading"></a></h4>
<p>This is the default level. By default, no special heap corruption features are enabled, but the provided assertions are enabled. A heap corruption error will be printed if any of the heap's internal data structures appear overwritten or corrupted. This usually indicates a buffer overrun or out-of-bounds write.</p>
<p>If assertions are enabled, an assertion will also trigger if a double-free occurs (the same memory is freed twice).</p>
<p>Calling <a class="reference internal" href="mem_alloc.html#_CPPv425heap_caps_check_integrity8uint32_tb" title="heap_caps_check_integrity"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity()</span></code></a> in Basic mode checks the integrity of all heap structures, and print errors if any appear to be corrupted.</p>
</section>
<section id="light-impact">
<h4>Light Impact<a class="headerlink" href="#light-impact" title="Permalink to this heading"></a></h4>
<p>At this level, heap memory is additionally &quot;poisoned&quot; with head and tail &quot;canary bytes&quot; before and after each block that is allocated. If an application writes outside the bounds of allocated buffers, the canary bytes will be corrupted, and the integrity check will fail.</p>
<p>The head canary word is <code class="docutils literal notranslate"><span class="pre">0xABBA1234</span></code> (<code class="docutils literal notranslate"><span class="pre">3412BAAB</span></code> in byte order), and the tail canary word is <code class="docutils literal notranslate"><span class="pre">0xBAAD5678</span></code> (<code class="docutils literal notranslate"><span class="pre">7856ADBA</span></code> in byte order).</p>
<p>With basic heap corruption checks, most out-of-bound writes can be detected and the number of overrun bytes before a failure is detected depends on the properties of the heap. However, the Light Impact mode is more precise as even a single-byte overrun can be detected.</p>
<p>Enabling light-impact checking increases the memory usage. Each individual allocation uses 9 to 12 additional bytes of memory depending on alignment.</p>
<p>Each time <a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_freePv" title="heap_caps_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_free()</span></code></a> is called in Light Impact mode, the head and tail canary bytes of the buffer being freed are checked against the expected values.</p>
<p>When <a class="reference internal" href="mem_alloc.html#_CPPv425heap_caps_check_integrity8uint32_tb" title="heap_caps_check_integrity"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity()</span></code></a> is called, all allocated blocks of heap memory have their canary bytes checked against the expected values.</p>
<p>In both cases, the functions involve checking that the first 4 bytes of an allocated block (before the buffer is returned to the user) should be the word <code class="docutils literal notranslate"><span class="pre">0xABBA1234</span></code>, and the last 4 bytes of the allocated block (after the buffer is returned to the user) should be the word <code class="docutils literal notranslate"><span class="pre">0xBAAD5678</span></code>.</p>
<p>Different values usually indicate buffer underrun or overrun. Overrun indicates that when writing to memory, the data written exceeds the size of the allocated memory, resulting in writing to an unallocated memory area; underrun indicates that when reading memory, the data read exceeds the allocated memory and reads data from an unallocated memory area.</p>
</section>
<section id="comprehensive">
<h4>Comprehensive<a class="headerlink" href="#comprehensive" title="Permalink to this heading"></a></h4>
<p>This level incorporates the &quot;light impact&quot; detection features plus additional checks for uninitialized-access and use-after-free bugs. In this mode, all freshly allocated memory is filled with the pattern <code class="docutils literal notranslate"><span class="pre">0xCE</span></code>, and all freed memory is filled with the pattern <code class="docutils literal notranslate"><span class="pre">0xFE</span></code>.</p>
<p>Enabling Comprehensive mode has a substantial impact on runtime performance, as all memory needs to be set to the allocation patterns each time a <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_freePv" title="heap_caps_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_free()</span></code></a> completes, and the memory also needs to be checked each time. However, this mode allows easier detection of memory corruption bugs which are much more subtle to find otherwise. It is recommended to only enable this mode when debugging, not in production.</p>
<section id="crashes-in-comprehensive-mode">
<h5>Crashes in Comprehensive Mode<a class="headerlink" href="#crashes-in-comprehensive-mode" title="Permalink to this heading"></a></h5>
<p>If an application crashes when reading or writing an address related to <code class="docutils literal notranslate"><span class="pre">0xCECECECE</span></code> in Comprehensive mode, it indicates that it has read uninitialized memory. The application should be changed to either use <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_calloc6size_t6size_t8uint32_t" title="heap_caps_calloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_calloc()</span></code></a> (which zeroes memory), or initialize the memory before using it. The value <code class="docutils literal notranslate"><span class="pre">0xCECECECE</span></code> may also be seen in stack-allocated automatic variables, because, in ESP-IDF, most task stacks are originally allocated from the heap, and in C, stack memory is uninitialized by default.</p>
<p>If an application crashes, and the exception register dump indicates that some addresses or values were <code class="docutils literal notranslate"><span class="pre">0xFEFEFEFE</span></code>, this indicates that it is reading heap memory after it has been freed, i.e., a &quot;use-after-free bug&quot;. The application should be changed to not access heap memory after it has been freed.</p>
<p>If a call to <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv417heap_caps_reallocPv6size_t8uint32_t" title="heap_caps_realloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_realloc()</span></code></a> causes a crash because it was expected to find the pattern <code class="docutils literal notranslate"><span class="pre">0xFEFEFEFE</span></code> in free memory and a different pattern was found, it indicates that the app has a use-after-free bug where it is writing to memory that has already been freed.</p>
</section>
<section id="manual-heap-checks-in-comprehensive-mode">
<h5>Manual Heap Checks in Comprehensive Mode<a class="headerlink" href="#manual-heap-checks-in-comprehensive-mode" title="Permalink to this heading"></a></h5>
<p>Calls to <a class="reference internal" href="mem_alloc.html#_CPPv425heap_caps_check_integrity8uint32_tb" title="heap_caps_check_integrity"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity()</span></code></a> may print errors relating to <code class="docutils literal notranslate"><span class="pre">0xFEFEFEFE</span></code>, <code class="docutils literal notranslate"><span class="pre">0xABBA1234</span></code>, or <code class="docutils literal notranslate"><span class="pre">0xBAAD5678</span></code>. In each case the checker is expected to find a given pattern, and will error out if not found:</p>
<ul class="simple">
<li><p>For free heap blocks, the checker expects to find all bytes set to <code class="docutils literal notranslate"><span class="pre">0xFE</span></code>. Any other values indicate a use-after-free bug where free memory has been incorrectly overwritten.</p></li>
<li><p>For allocated heap blocks, the behavior is the same as for the Light Impact mode. The canary bytes <code class="docutils literal notranslate"><span class="pre">0xABBA1234</span></code> and <code class="docutils literal notranslate"><span class="pre">0xBAAD5678</span></code> are checked at the head and tail of each allocated buffer, and any variation indicates a buffer overrun or underrun.</p></li>
</ul>
</section>
</section>
</section>
</section>
<section id="heap-task-tracking">
<span id="id2"></span><h2>Heap Task Tracking<a class="headerlink" href="#heap-task-tracking" title="Permalink to this heading"></a></h2>
<p>Heap Task Tracking can be used to get per-task info for heap memory allocation. The application has to specify the heap capabilities for which the heap allocation is to be tracked.</p>
<p>Example code is provided in <a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/system/heap_task_tracking">system/heap_task_tracking</a>.</p>
</section>
<section id="heap-tracing">
<span id="id3"></span><h2>Heap Tracing<a class="headerlink" href="#heap-tracing" title="Permalink to this heading"></a></h2>
<p>Heap Tracing allows the tracing of code which allocates or frees memory. Two tracing modes are supported:</p>
<ul class="simple">
<li><p>Standalone. In this mode, traced data are kept on-board, so the size of the gathered information is limited by the buffer assigned for that purpose, and the analysis is done by the on-board code. There are a couple of APIs available for accessing and dumping collected info.</p></li>
<li><p>Host-based. This mode does not have the limitation of the standalone mode, because traced data are sent to the host over JTAG connection using app_trace library. Later on, they can be analyzed using special tools.</p></li>
</ul>
<p>Heap tracing can perform two functions:</p>
<ul class="simple">
<li><p>Leak checking: find memory that is allocated and never freed.</p></li>
<li><p>Heap use analysis: show all functions that are allocating or freeing memory while the trace is running.</p></li>
</ul>
<section id="how-to-diagnose-memory-leaks">
<h3>How to Diagnose Memory Leaks<a class="headerlink" href="#how-to-diagnose-memory-leaks" title="Permalink to this heading"></a></h3>
<p>If you suspect a memory leak, the first step is to figure out which part of the program is leaking memory. Use the <a class="reference internal" href="mem_alloc.html#_CPPv423heap_caps_get_free_size8uint32_t" title="heap_caps_get_free_size"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_free_size()</span></code></a> or related functions in <a class="reference internal" href="#heap-information"><span class="std std-ref">heap information</span></a> to track memory use over the life of the application. Try to narrow the leak down to a single function or sequence of functions where free memory always decreases and never recovers.</p>
<section id="standalone-mode">
<h4>Standalone Mode<a class="headerlink" href="#standalone-mode" title="Permalink to this heading"></a></h4>
<p>Once you have identified the code which you think is leaking:</p>
<ul class="simple">
<li><p>Enable the <a class="reference internal" href="../kconfig.html#config-heap-tracing-dest"><span class="std std-ref">CONFIG_HEAP_TRACING_DEST</span></a> option.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv426heap_trace_init_standaloneP19heap_trace_record_t6size_t" title="heap_trace_init_standalone"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_init_standalone()</span></code></a> early in the program, to register a buffer that can be used to record the memory trace.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="heap_trace_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_start()</span></code></a> to begin recording all mallocs or frees in the system. Call this immediately before the piece of code which you suspect is leaking memory.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a> to stop the trace once the suspect piece of code has finished executing. This state will stop the tracing of both allocations and frees.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv422heap_trace_alloc_pausev" title="heap_trace_alloc_pause"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_alloc_pause()</span></code></a> to pause the tracing of new allocations while continuing to trace the frees. Call this immediately after the piece of code which you suspect is leaking memory to prevent any new allocations to be recorded.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv415heap_trace_dumpv" title="heap_trace_dump"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_dump()</span></code></a> to dump the results of the heap trace.</p></li>
</ul>
<p>The following code snippet demonstrates how application code would typically initialize, start, and stop heap tracing:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_trace.h&quot;</span>

<span class="cp">#define NUM_RECORDS 100</span>
<span class="k">static</span><span class="w"> </span><span class="n">heap_trace_record_t</span><span class="w"> </span><span class="n">trace_record</span><span class="p">[</span><span class="n">NUM_RECORDS</span><span class="p">];</span><span class="w"> </span><span class="c1">// This buffer must be in internal RAM</span>

<span class="p">...</span>

<span class="kt">void</span><span class="w"> </span><span class="n">app_main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_init_standalone</span><span class="p">(</span><span class="n">trace_record</span><span class="p">,</span><span class="w"> </span><span class="n">NUM_RECORDS</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_start</span><span class="p">(</span><span class="n">HEAP_TRACE_LEAKS</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">do_something_you_suspect_is_leaking</span><span class="p">();</span>

<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_stop</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">heap_trace_dump</span><span class="p">();</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The output from the heap trace has a similar format to the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2 allocations trace (100 entry buffer)
32 bytes (@ 0x3ffaf214) allocated CPU 0 ccount 0x2e9b7384 caller 0x400d276d:0x400d27c1
0x400d276d: leak_some_memory at /path/to/idf/examples/get-started/blink/main/./blink.c:27

0x400d27c1: blink_task at /path/to/idf/examples/get-started/blink/main/./blink.c:52

8 bytes (@ 0x3ffaf804) allocated CPU 0 ccount 0x2e9b79c0 caller 0x400d2776:0x400d27c1
0x400d2776: leak_some_memory at /path/to/idf/examples/get-started/blink/main/./blink.c:29

0x400d27c1: blink_task at /path/to/idf/examples/get-started/blink/main/./blink.c:52

40 bytes &#39;leaked&#39; in trace (2 allocations)
total allocations 2 total frees 0
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above example output uses <a class="reference internal" href="../../api-guides/tools/idf-monitor.html"><span class="doc">IDF Monitor</span></a> to automatically decode PC addresses to their source files and line numbers.</p>
</div>
<p>The first line indicates how many allocation entries are in the buffer, compared to its total size.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_LEAKS</span></code> mode, for each traced memory allocation that has not already been freed, a line is printed with:</p>
<p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">XX</span> <span class="pre">bytes</span></code> is the number of bytes allocated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;</span> <span class="pre">0x...</span></code> is the heap address returned from <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_calloc6size_t6size_t8uint32_t" title="heap_caps_calloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_calloc()</span></code></a> .</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Internal</span></code> or <code class="docutils literal notranslate"><span class="pre">PSRAM</span></code> is the general location of the allocated memory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CPU</span> <span class="pre">x</span></code> is the CPU (0 or 1) running when the allocation was made.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ccount</span> <span class="pre">0x...</span></code> is the CCOUNT (CPU cycle count) register value the allocation was made. The value is different for CPU 0 vs CPU 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">caller</span> <span class="pre">0x...</span></code> gives the call stack of the call to <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_freePv" title="heap_caps_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_free()</span></code></a> , as a list of PC addresses. These can be decoded to source files and line numbers, as shown above.</p></li>
</ul>
</p>
<p>The depth of the call stack recorded for each trace entry can be configured in the project configuration menu, under <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">Memory</span> <span class="pre">Debugging</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Enable</span> <span class="pre">heap</span> <span class="pre">tracing</span></code> &gt; <a class="reference internal" href="../kconfig.html#config-heap-tracing-stack-depth"><span class="std std-ref">CONFIG_HEAP_TRACING_STACK_DEPTH</span></a>. Up to 32 stack frames can be recorded for each allocation (the default is 2). Each additional stack frame increases the memory usage of each <code class="docutils literal notranslate"><span class="pre">heap_trace_record_t</span></code> record by eight bytes.</p>
<p>Finally, the total number of the 'leaked' bytes (bytes allocated but not freed while the trace is running) is printed together with the total number of allocations it represents.</p>
<p>A warning will be printed if the trace buffer was not large enough to hold all the allocations happened. If you see this warning, consider either shortening the tracing period or increasing the number of records in the trace buffer.</p>
</section>
<section id="host-based-mode">
<h4>Host-Based Mode<a class="headerlink" href="#host-based-mode" title="Permalink to this heading"></a></h4>
<p>Once you have identified the code which you think is leaking:</p>
<ul>
<li><p>In the project configuration menu, navigate to <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">settings</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">Memory</span> <span class="pre">Debugging</span></code> &gt; <a class="reference internal" href="../kconfig.html#config-heap-tracing-dest"><span class="std std-ref">CONFIG_HEAP_TRACING_DEST</span></a> and select <code class="docutils literal notranslate"><span class="pre">Host-Based</span></code>.</p></li>
<li><p>In the project configuration menu, navigate to <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">settings</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Application</span> <span class="pre">Level</span> <span class="pre">Tracing</span></code> &gt; <a class="reference internal" href="../kconfig.html#config-apptrace-destination1"><span class="std std-ref">CONFIG_APPTRACE_DESTINATION1</span></a> and select <code class="docutils literal notranslate"><span class="pre">Trace</span> <span class="pre">memory</span></code>.</p></li>
<li><p>In the project configuration menu, navigate to <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">settings</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Application</span> <span class="pre">Level</span> <span class="pre">Tracing</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">FreeRTOS</span> <span class="pre">SystemView</span> <span class="pre">Tracing</span></code> and enable <a class="reference internal" href="../kconfig.html#config-apptrace-sv-enable"><span class="std std-ref">CONFIG_APPTRACE_SV_ENABLE</span></a>.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv422heap_trace_init_tohostv" title="heap_trace_init_tohost"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_init_tohost()</span></code></a> early in the program, to initialize the JTAG heap tracing module.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="heap_trace_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_start()</span></code></a> to begin recording all memory allocation and free calls in the system. Call this immediately before the piece of code which you suspect is leaking memory.</p>
<p>In host-based mode, the argument to this function is ignored, and the heap tracing module behaves like <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_ALL</span></code> is passed, i.e., all allocations and deallocations are sent to the host.</p>
</li>
<li><p>Call the function <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a> to stop the trace once the suspect piece of code has finished executing.</p></li>
</ul>
<p>The following code snippet demonstrates how application code would typically initialize, start, and stop host-based mode heap tracing:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_trace.h&quot;</span>

<span class="p">...</span>

<span class="kt">void</span><span class="w"> </span><span class="n">app_main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_init_tohost</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_start</span><span class="p">(</span><span class="n">HEAP_TRACE_LEAKS</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">do_something_you_suspect_is_leaking</span><span class="p">();</span>

<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_stop</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To gather and analyze heap trace, do the following on the host:</p>
<ol class="arabic simple">
<li><p>Build the program and download it to the target as described in <a class="reference internal" href="../../get-started/linux-macos-setup.html#get-started-build"><span class="std std-ref">Step 5. First Steps on ESP-IDF</span></a>.</p></li>
<li><p>Run OpenOCD (see <a class="reference internal" href="../../api-guides/jtag-debugging/index.html"><span class="doc">JTAG Debugging</span></a>).</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order to use this feature, you need OpenOCD version <code class="docutils literal notranslate"><span class="pre">v0.10.0-esp32-20181105</span></code> or later.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>You can use GDB to start and/or stop tracing automatically. To do this you need to prepare a special <code class="docutils literal notranslate"><span class="pre">gdbinit</span></code> file:</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">target</span><span class="w"> </span><span class="n">remote</span><span class="w"> </span><span class="o">:</span><span class="mi">3333</span>

<span class="n">mon</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="n">halt</span>
<span class="n">maintenance</span><span class="w"> </span><span class="n">flush</span><span class="w"> </span><span class="k">register</span><span class="o">-</span><span class="n">cache</span>

<span class="n">tb</span><span class="w"> </span><span class="n">heap_trace_start</span>
<span class="n">commands</span>
<span class="n">mon</span><span class="w"> </span><span class="n">esp</span><span class="w"> </span><span class="n">sysview</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="n">file</span><span class="o">:</span><span class="c1">///tmp/heap.svdat</span>
<span class="n">c</span>
<span class="n">end</span>

<span class="n">tb</span><span class="w"> </span><span class="n">heap_trace_stop</span>
<span class="n">commands</span>
<span class="n">mon</span><span class="w"> </span><span class="n">esp</span><span class="w"> </span><span class="n">sysview</span><span class="w"> </span><span class="n">stop</span>
<span class="n">end</span>

<span class="n">c</span>
</pre></div>
</div>
<p>Using this file GDB can connect to the target, reset it, and start tracing when the program hits breakpoint at <a class="reference internal" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="heap_trace_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_start()</span></code></a>. Tracing will be stopped when the program hits breakpoint at <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a>. Traced data will be saved to <code class="docutils literal notranslate"><span class="pre">/tmp/heap_log.svdat</span></code>.</p>
<ol class="arabic simple" start="4">
<li><p>Run GDB using <code class="docutils literal notranslate"><span class="pre">xtensa-esp32-elf-gdb</span> <span class="pre">-x</span> <span class="pre">gdbinit</span> <span class="pre">&lt;/path/to/program/elf&gt;</span></code>.</p></li>
<li><p>Quit GDB when the program stops at <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a>. Traced data are saved in <code class="docutils literal notranslate"><span class="pre">/tmp/heap.svdat</span></code>.</p></li>
<li><p>Run processing script <code class="docutils literal notranslate"><span class="pre">$IDF_PATH/tools/esp_app_trace/sysviewtrace_proc.py</span> <span class="pre">-p</span> <span class="pre">-b</span> <span class="pre">&lt;/path/to/program/elf&gt;</span> <span class="pre">/tmp/heap_log.svdat</span></code>.</p></li>
</ol>
<p>The output from the heap trace has a similar format to the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Parse trace from &#39;/tmp/heap.svdat&#39;...
Stop parsing trace. (Timeout 0.000000 sec while reading 1 bytes!)
Process events from &#39;[&#39;/tmp/heap.svdat&#39;]&#39;...
[0.002244575] HEAP: Allocated 1 bytes @ 0x3ffaffd8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.002258425] HEAP: Allocated 2 bytes @ 0x3ffaffe0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.002563725] HEAP: Freed bytes @ 0x3ffaffe0 from task &quot;free&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.002782950] HEAP: Freed bytes @ 0x3ffb40b8 from task &quot;main&quot; on core 0 by:
/home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590
/home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590

[0.002798700] HEAP: Freed bytes @ 0x3ffb50bc from task &quot;main&quot; on core 0 by:
/home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590
/home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590

[0.102436025] HEAP: Allocated 2 bytes @ 0x3ffaffe0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.102449800] HEAP: Allocated 4 bytes @ 0x3ffaffe8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.102666150] HEAP: Freed bytes @ 0x3ffaffe8 from task &quot;free&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.202436200] HEAP: Allocated 3 bytes @ 0x3ffaffe8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.202451725] HEAP: Allocated 6 bytes @ 0x3ffafff0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.202667075] HEAP: Freed bytes @ 0x3ffafff0 from task &quot;free&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.302436000] HEAP: Allocated 4 bytes @ 0x3ffafff0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.302451475] HEAP: Allocated 8 bytes @ 0x3ffb40b8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.302667500] HEAP: Freed bytes @ 0x3ffb40b8 from task &quot;free&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

Processing completed.

Processed 1019 events

=============== HEAP TRACE REPORT ===============

Processed 14 heap events.

[0.002244575] HEAP: Allocated 1 bytes @ 0x3ffaffd8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.102436025] HEAP: Allocated 2 bytes @ 0x3ffaffe0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.202436200] HEAP: Allocated 3 bytes @ 0x3ffaffe8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.302436000] HEAP: Allocated 4 bytes @ 0x3ffafff0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

Found 10 leaked bytes in 4 blocks.
</pre></div>
</div>
</section>
</section>
<section id="heap-tracing-to-find-heap-corruption">
<h3>Heap Tracing To Find Heap Corruption<a class="headerlink" href="#heap-tracing-to-find-heap-corruption" title="Permalink to this heading"></a></h3>
<p>Heap tracing can also be used to help track down heap corruption. When a region in the heap is corrupted, it may be from some other part of the program that allocated memory at a nearby address.</p>
<p>If you have an approximate idea of when the corruption occurred, enabling heap tracing in <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_ALL</span></code> mode allows you to record all the memory allocation functions used and the corresponding allocation addresses.</p>
<p>Using heap tracing in this way is very similar to memory leak detection as described above. For memories that are allocated and not freed, the output is the same. However, records will also be shown for memory that has been freed.</p>
</section>
<section id="performance-impact">
<h3>Performance Impact<a class="headerlink" href="#performance-impact" title="Permalink to this heading"></a></h3>
<p>Enabling heap tracing in menuconfig increases the code size of your program, and has a very small negative impact on the performance of heap allocation or free operations even when heap tracing is not running.</p>
<p>When heap tracing is running, heap allocation or free operations are substantially slower than when heap tracing is stopped. Increasing the depth of stack frames recorded for each allocation (see above) also increases this performance impact.</p>
<p>To mitigate the performance loss when the heap tracing is enabled and active, enable <a class="reference internal" href="../kconfig.html#config-heap-trace-hash-map"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP</span></a>. With this configuration enabled, a hash map mechanism will be used to handle the heap trace records, thus considerably decreasing the heap allocation or free execution time. The size of the hash map can be modified by setting the value of <a class="reference internal" href="../kconfig.html#config-heap-trace-hash-map-size"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP_SIZE</span></a>.</p>
<p>By default, the hash map is placed into internal RAM. It can also be placed into external RAM if <a class="reference internal" href="../kconfig.html#config-heap-trace-hash-map-in-ext-ram"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP_IN_EXT_RAM</span></a> is enabled. In order to enable this configuration, make sure to enable <a class="reference internal" href="../kconfig.html#config-spiram"><span class="std std-ref">CONFIG_SPIRAM</span></a> and <a class="reference internal" href="../kconfig.html#config-spiram-allow-bss-seg-external-memory"><span class="std std-ref">CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY</span></a>.</p>
</section>
<section id="false-positive-memory-leaks">
<h3>False-Positive Memory Leaks<a class="headerlink" href="#false-positive-memory-leaks" title="Permalink to this heading"></a></h3>
<p>Not everything printed by <a class="reference internal" href="#_CPPv415heap_trace_dumpv" title="heap_trace_dump"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_dump()</span></code></a> is necessarily a memory leak. The following cases may also be printed:</p>
<ul class="simple">
<li><p>Any memory that is allocated after <a class="reference internal" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="heap_trace_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_start()</span></code></a> but freed after <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a> appears in the leaked dump.</p></li>
<li><p>Allocations may be made by other tasks in the system. Depending on the timing of these tasks, it is quite possible that this memory is freed after <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a> is called.</p></li>
<li><p>The first time a task uses stdio - e.g., when it calls <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_printf()</span></code> - a lock, i.e., RTOS mutex semaphore, is allocated by the libc. This allocation lasts until the task is deleted.</p></li>
<li><p>Certain uses of <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_printf()</span></code>, such as printing floating point numbers and allocating some memory from the heap on demand. These allocations last until the task is deleted.</p></li>
<li><p>The Bluetooth, Wi-Fi, and TCP/IP libraries allocate heap memory buffers to handle incoming or outgoing data. These memory buffers are usually short-lived, but some may be shown in the heap leak trace if the data has been received or transmitted by the lower levels of the network during the heap tracing.</p></li>
<li><p>TCP connections retain some memory even after they are closed due to the <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> state. Once the <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> period is completed, this memory will be freed.</p></li>
</ul>
<p>One way to differentiate between &quot;real&quot; and &quot;false positive&quot; memory leaks is to call the suspect code multiple times while tracing is running, and look for patterns (multiple matching allocations) in the heap trace output.</p>
</section>
</section>
<section id="application-examples">
<h2>Application Examples<a class="headerlink" href="#application-examples" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/system/heap_task_tracking">system/heap_task_tracking</a> demonstrates the use of the heap task tracking feature to track heap memory allocated on a per-task basis.</p></li>
</ul>
</section>
<section id="api-reference-heap-tracing">
<h2>API Reference - Heap Tracing<a class="headerlink" href="#api-reference-heap-tracing" title="Permalink to this heading"></a></h2>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/heap/include/esp_heap_trace.h">components/heap/include/esp_heap_trace.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_trace.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426heap_trace_init_standaloneP19heap_trace_record_t6size_t">
<span id="_CPPv326heap_trace_init_standaloneP19heap_trace_record_t6size_t"></span><span id="_CPPv226heap_trace_init_standaloneP19heap_trace_record_t6size_t"></span><span id="heap_trace_init_standalone__heap_trace_record_tP.s"></span><span class="target" id="esp__heap__trace_8h_1a8884934797d03cc7114b64f1849420e2"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_init_standalone</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419heap_trace_record_t" title="heap_trace_record_t"><span class="n"><span class="pre">heap_trace_record_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record_buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_records</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426heap_trace_init_standaloneP19heap_trace_record_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialise heap tracing in standalone mode. </p>
<p>This function must be called before any other heap tracing functions.</p>
<p>To disable heap tracing and allow the buffer to be freed, stop tracing and then call heap_trace_init_standalone(NULL, 0);</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>record_buffer</strong> -- Provide a buffer to use for heap trace data. Note: External RAM is allowed, but it prevents recording allocations made from ISR's. </p></li>
<li><p><strong>num_records</strong> -- Size of the heap trace buffer, as number of record structures. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing is currently in progress.</p></li>
<li><p>ESP_OK Heap tracing initialised successfully. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422heap_trace_init_tohostv">
<span id="_CPPv322heap_trace_init_tohostv"></span><span id="_CPPv222heap_trace_init_tohostv"></span><span id="heap_trace_init_tohost__void"></span><span class="target" id="esp__heap__trace_8h_1a01c97e0002efcd2a3402a412640b02fd"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_init_tohost</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422heap_trace_init_tohostv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialise heap tracing in host-based mode. </p>
<p>This function must be called before any other heap tracing functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_STATE Heap tracing is currently in progress.</p></li>
<li><p>ESP_OK Heap tracing initialised successfully. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416heap_trace_start17heap_trace_mode_t">
<span id="_CPPv316heap_trace_start17heap_trace_mode_t"></span><span id="_CPPv216heap_trace_start17heap_trace_mode_t"></span><span id="heap_trace_start__heap_trace_mode_t"></span><span class="target" id="esp__heap__trace_8h_1ac324e6c910f4a2a71e0e364130c069b6"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_start</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417heap_trace_mode_t" title="heap_trace_mode_t"><span class="n"><span class="pre">heap_trace_mode_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Start heap tracing. All heap allocations &amp; frees will be traced, until heap_trace_stop() is called. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>heap_trace_init_standalone() must be called to provide a valid buffer, before this function is called.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this function while heap tracing is running will reset the heap trace state and continue tracing.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mode</strong> -- Mode for tracing.<ul class="simple">
<li><p>HEAP_TRACE_ALL means all heap allocations and frees are traced.</p></li>
<li><p>HEAP_TRACE_LEAKS means only suspected memory leaks are traced. (When memory is freed, the record is removed from the trace buffer.) </p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE A non-zero-length buffer has not been set via heap_trace_init_standalone().</p></li>
<li><p>ESP_OK Tracing is started. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415heap_trace_stopv">
<span id="_CPPv315heap_trace_stopv"></span><span id="_CPPv215heap_trace_stopv"></span><span id="heap_trace_stop__void"></span><span class="target" id="esp__heap__trace_8h_1aa2a9740da05f6833efbc39c0520681de"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_stop</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415heap_trace_stopv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stop heap tracing. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing was not in progress.</p></li>
<li><p>ESP_OK Heap tracing stopped. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422heap_trace_alloc_pausev">
<span id="_CPPv322heap_trace_alloc_pausev"></span><span id="_CPPv222heap_trace_alloc_pausev"></span><span id="heap_trace_alloc_pause__void"></span><span class="target" id="esp__heap__trace_8h_1acb0dff8e79267ab04a8d5350c36c01be"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_alloc_pause</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422heap_trace_alloc_pausev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pause heap tracing of allocations. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function puts the heap tracing in the state where the new allocations will no longer be traced but the free will still be. This can be used to e.g., strategically monitor a set of allocations to make sure each of them will get freed without polluting the list of records with unwanted allocations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing was not in progress.</p></li>
<li><p>ESP_OK Heap tracing paused. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417heap_trace_resumev">
<span id="_CPPv317heap_trace_resumev"></span><span id="_CPPv217heap_trace_resumev"></span><span id="heap_trace_resume__void"></span><span class="target" id="esp__heap__trace_8h_1a62cef359ef92ecb1b0760b3e1e5e1203"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_resume</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417heap_trace_resumev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Resume heap tracing which was previously stopped. </p>
<p>Unlike heap_trace_start(), this function does not clear the buffer of any pre-existing trace records.</p>
<p>The heap trace mode is the same as when heap_trace_start() was last called (or HEAP_TRACE_ALL if heap_trace_start() was never called).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing was already started.</p></li>
<li><p>ESP_OK Heap tracing resumed. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420heap_trace_get_countv">
<span id="_CPPv320heap_trace_get_countv"></span><span id="_CPPv220heap_trace_get_countv"></span><span id="heap_trace_get_count__void"></span><span class="target" id="esp__heap__trace_8h_1a9ac798a6e570fd665d6e5c715c1a3d1b"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_get_count</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420heap_trace_get_countv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return number of records in the heap trace buffer. </p>
<p>It is safe to call this function while heap tracing is running. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414heap_trace_get6size_tP19heap_trace_record_t">
<span id="_CPPv314heap_trace_get6size_tP19heap_trace_record_t"></span><span id="_CPPv214heap_trace_get6size_tP19heap_trace_record_t"></span><span id="heap_trace_get__s.heap_trace_record_tP"></span><span class="target" id="esp__heap__trace_8h_1a007b0b85daa123d2a7a7d74e6383f42c"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_get</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">index</span></span>, <a class="reference internal" href="#_CPPv419heap_trace_record_t" title="heap_trace_record_t"><span class="n"><span class="pre">heap_trace_record_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414heap_trace_get6size_tP19heap_trace_record_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return a raw record from the heap trace buffer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is safe to call this function while heap tracing is running, however in HEAP_TRACE_LEAK mode record indexing may skip entries unless heap tracing is stopped first.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> -- Index (zero-based) of the record to return. </p></li>
<li><p><strong>record</strong> -- <strong>[out]</strong> Record where the heap trace record will be copied. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing was not initialised.</p></li>
<li><p>ESP_ERR_INVALID_ARG Index is out of bounds for current heap trace record count.</p></li>
<li><p>ESP_OK Record returned successfully. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415heap_trace_dumpv">
<span id="_CPPv315heap_trace_dumpv"></span><span id="_CPPv215heap_trace_dumpv"></span><span id="heap_trace_dump__void"></span><span class="target" id="esp__heap__trace_8h_1a9e80331ce5188a84bb60fdf0bd1ab828"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_dump</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415heap_trace_dumpv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Dump heap trace record data to stdout. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is safe to call this function while heap tracing is running, however in HEAP_TRACE_LEAK mode the dump may skip entries unless heap tracing is stopped first. </p>
</div>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420heap_trace_dump_capsK8uint32_t">
<span id="_CPPv320heap_trace_dump_capsK8uint32_t"></span><span id="_CPPv220heap_trace_dump_capsK8uint32_t"></span><span id="heap_trace_dump_caps__uint32_tC"></span><span class="target" id="esp__heap__trace_8h_1a34ce005489fd109724235c2a56b6ba6e"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_dump_caps</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">caps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420heap_trace_dump_capsK8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Dump heap trace from the memory of the capabilities passed as parameter. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>caps</strong> -- Capability(ies) of the memory from which to dump the trace. Set MALLOC_CAP_INTERNAL to dump heap trace data from internal memory. Set MALLOC_CAP_SPIRAM to dump heap trace data from PSRAM. Set both to dump both heap trace data. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418heap_trace_summaryP20heap_trace_summary_t">
<span id="_CPPv318heap_trace_summaryP20heap_trace_summary_t"></span><span id="_CPPv218heap_trace_summaryP20heap_trace_summary_t"></span><span id="heap_trace_summary__heap_trace_summary_tP"></span><span class="target" id="esp__heap__trace_8h_1a53cd82e24a7196120841e2742e4e8203"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_summary</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420heap_trace_summary_t" title="heap_trace_summary_t"><span class="n"><span class="pre">heap_trace_summary_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">summary</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418heap_trace_summaryP20heap_trace_summary_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get summary information about the result of a heap trace. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is safe to call this function while heap tracing is running. </p>
</div>
</dd></dl>

</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv419heap_trace_record_t">
<span id="_CPPv319heap_trace_record_t"></span><span id="_CPPv219heap_trace_record_t"></span><span id="heap_trace_record_t"></span><span class="target" id="structheap__trace__record__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_record_t</span></span></span><a class="headerlink" href="#_CPPv419heap_trace_record_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Trace record data type. Stores information about an allocated region of memory. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t6ccountE">
<span id="_CPPv3N19heap_trace_record_t6ccountE"></span><span id="_CPPv2N19heap_trace_record_t6ccountE"></span><span id="heap_trace_record_t::ccount__uint32_t"></span><span class="target" id="structheap__trace__record__t_1a3a5a11507218cbab8b0f1ec08f8f5c40"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ccount</span></span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t6ccountE" title="Permalink to this definition"></a><br /></dt>
<dd><p>CCOUNT of the CPU when the allocation was made. LSB (bit value 1) is the CPU number (0 or 1). </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t7addressE">
<span id="_CPPv3N19heap_trace_record_t7addressE"></span><span id="_CPPv2N19heap_trace_record_t7addressE"></span><span id="heap_trace_record_t::address__voidP"></span><span class="target" id="structheap__trace__record__t_1a948933cb24b2aa572f45b806e82ae818"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">address</span></span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t7addressE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Address which was allocated. If NULL, then this record is empty. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t4sizeE">
<span id="_CPPv3N19heap_trace_record_t4sizeE"></span><span id="_CPPv2N19heap_trace_record_t4sizeE"></span><span id="heap_trace_record_t::size__s"></span><span class="target" id="structheap__trace__record__t_1a1a13eb467724bf28ccacb694627b6f3d"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t4sizeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size of the allocation. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t10alloced_byE">
<span id="_CPPv3N19heap_trace_record_t10alloced_byE"></span><span id="_CPPv2N19heap_trace_record_t10alloced_byE"></span><span id="heap_trace_record_t::alloced_by__voidPA"></span><span class="target" id="structheap__trace__record__t_1aa3ed0367bc373515a3d4961a7269fdf2"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloced_by</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">CONFIG_HEAP_TRACING_STACK_DEPTH</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t10alloced_byE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Call stack of the caller which allocated the memory. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t8freed_byE">
<span id="_CPPv3N19heap_trace_record_t8freed_byE"></span><span id="_CPPv2N19heap_trace_record_t8freed_byE"></span><span id="heap_trace_record_t::freed_by__voidPA"></span><span class="target" id="structheap__trace__record__t_1a3ad6d8c9eb49b5285a508e1ec230cea1"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">freed_by</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">CONFIG_HEAP_TRACING_STACK_DEPTH</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t8freed_byE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Call stack of the caller which freed the memory (all zero if not freed.) </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv420heap_trace_summary_t">
<span id="_CPPv320heap_trace_summary_t"></span><span id="_CPPv220heap_trace_summary_t"></span><span id="heap_trace_summary_t"></span><span class="target" id="structheap__trace__summary__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_summary_t</span></span></span><a class="headerlink" href="#_CPPv420heap_trace_summary_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stores information about the result of a heap trace. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t4modeE">
<span id="_CPPv3N20heap_trace_summary_t4modeE"></span><span id="_CPPv2N20heap_trace_summary_t4modeE"></span><span id="heap_trace_summary_t::mode__heap_trace_mode_t"></span><span class="target" id="structheap__trace__summary__t_1a4bb33a9b038d1591038dc4be323ab92c"></span><a class="reference internal" href="#_CPPv417heap_trace_mode_t" title="heap_trace_mode_t"><span class="n"><span class="pre">heap_trace_mode_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mode</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t4modeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The heap trace mode we just completed / are running. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t17total_allocationsE">
<span id="_CPPv3N20heap_trace_summary_t17total_allocationsE"></span><span id="_CPPv2N20heap_trace_summary_t17total_allocationsE"></span><span id="heap_trace_summary_t::total_allocations__s"></span><span class="target" id="structheap__trace__summary__t_1ad3f449a7671d6d546b813341c7ef2f44"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">total_allocations</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t17total_allocationsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The total number of allocations made during tracing. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t11total_freesE">
<span id="_CPPv3N20heap_trace_summary_t11total_freesE"></span><span id="_CPPv2N20heap_trace_summary_t11total_freesE"></span><span id="heap_trace_summary_t::total_frees__s"></span><span class="target" id="structheap__trace__summary__t_1a2d4ba79c244082c41632b2f9299f46be"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">total_frees</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t11total_freesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The total number of frees made during tracing. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t5countE">
<span id="_CPPv3N20heap_trace_summary_t5countE"></span><span id="_CPPv2N20heap_trace_summary_t5countE"></span><span id="heap_trace_summary_t::count__s"></span><span class="target" id="structheap__trace__summary__t_1ad280196846066da6de8c0fcec658674e"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">count</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t5countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The number of records in the internal buffer. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t8capacityE">
<span id="_CPPv3N20heap_trace_summary_t8capacityE"></span><span id="_CPPv2N20heap_trace_summary_t8capacityE"></span><span id="heap_trace_summary_t::capacity__s"></span><span class="target" id="structheap__trace__summary__t_1ab602abb4192fa346bce29aa9dea0a7b0"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">capacity</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t8capacityE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The capacity of the internal buffer. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t15high_water_markE">
<span id="_CPPv3N20heap_trace_summary_t15high_water_markE"></span><span id="_CPPv2N20heap_trace_summary_t15high_water_markE"></span><span id="heap_trace_summary_t::high_water_mark__s"></span><span class="target" id="structheap__trace__summary__t_1a2e33ef2478a3037b018e22ccdb221f26"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">high_water_mark</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t15high_water_markE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The maximum value that 'count' got to. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t14has_overflowedE">
<span id="_CPPv3N20heap_trace_summary_t14has_overflowedE"></span><span id="_CPPv2N20heap_trace_summary_t14has_overflowedE"></span><span id="heap_trace_summary_t::has_overflowed__s"></span><span class="target" id="structheap__trace__summary__t_1aaf53462beab90b12820d405d27bfd805"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">has_overflowed</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t14has_overflowedE" title="Permalink to this definition"></a><br /></dt>
<dd><p>True if the internal buffer overflowed at some point. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.CONFIG_HEAP_TRACING_STACK_DEPTH">
<span class="target" id="esp__heap__trace_8h_1a962faaf6cd044ada51170a779dd716ff"></span><span class="sig-name descname"><span class="n"><span class="pre">CONFIG_HEAP_TRACING_STACK_DEPTH</span></span></span><a class="headerlink" href="#c.CONFIG_HEAP_TRACING_STACK_DEPTH" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
<section id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp">
<span class="target" id="esp__heap__trace_8h_1a8d683ac07b6bebc8120f6a2c42f1f3ee"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv419heap_trace_record_t" title="heap_trace_record_t"><span class="n"><span class="pre">heap_trace_record_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_record_t</span></span></span><br /></dt>
<dd><p>Trace record data type. Stores information about an allocated region of memory. </p>
</dd></dl>

</section>
<section id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv417heap_trace_mode_t">
<span id="_CPPv317heap_trace_mode_t"></span><span id="_CPPv217heap_trace_mode_t"></span><span class="target" id="esp__heap__trace_8h_1a405bc5c6c3a6e07f82086254c944563d"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_mode_t</span></span></span><a class="headerlink" href="#_CPPv417heap_trace_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17heap_trace_mode_t14HEAP_TRACE_ALLE">
<span id="_CPPv3N17heap_trace_mode_t14HEAP_TRACE_ALLE"></span><span id="_CPPv2N17heap_trace_mode_t14HEAP_TRACE_ALLE"></span><span class="target" id="esp__heap__trace_8h_1a405bc5c6c3a6e07f82086254c944563da852d11079e290f8415591926a5465d0e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HEAP_TRACE_ALL</span></span></span><a class="headerlink" href="#_CPPv4N17heap_trace_mode_t14HEAP_TRACE_ALLE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17heap_trace_mode_t16HEAP_TRACE_LEAKSE">
<span id="_CPPv3N17heap_trace_mode_t16HEAP_TRACE_LEAKSE"></span><span id="_CPPv2N17heap_trace_mode_t16HEAP_TRACE_LEAKSE"></span><span class="target" id="esp__heap__trace_8h_1a405bc5c6c3a6e07f82086254c944563da8b871cc1175288956caf38a820f56930"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HEAP_TRACE_LEAKS</span></span></span><a class="headerlink" href="#_CPPv4N17heap_trace_mode_t16HEAP_TRACE_LEAKSE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Heap Memory Debugging (api-reference/system/heap_debug)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Heap Memory Debugging (api-reference/system/heap_debug)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mm.html" class="btn btn-neutral float-left" title="Memory Management for MMU Supported Memory" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="esp_timer.html" class="btn btn-neutral float-right" title="ESP Timer (High Resolution Timer)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>