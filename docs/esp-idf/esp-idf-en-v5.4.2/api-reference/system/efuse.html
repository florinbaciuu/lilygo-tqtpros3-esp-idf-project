<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>eFuse Manager - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/efuse.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/system/efuse';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Error Code and Helper Functions" href="esp_err.html" />
    <link rel="prev" title="Console" href="console.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth® API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Project Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">System API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">App Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="bootloader_image_format.html">Bootloader Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">Application Level Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_function_with_shared_stack.html">Call Function with External Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="chip_revision.html">Chip Revision</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">eFuse Manager</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#efuse-manager-vs-idf-py">eFuse Manager vs <code class="docutils literal notranslate"><span class="pre">idf.py</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-description">Hardware Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-efuse-fields">Defining eFuse Fields</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structured-efuse-fields">Structured eFuse Fields</a></li>
<li class="toctree-l4"><a class="reference internal" href="#efuse-table-gen-py-tool"><code class="docutils literal notranslate"><span class="pre">efuse_table_gen.py</span></code> Tool</a></li>
<li class="toctree-l4"><a class="reference internal" href="#supported-coding-schemes">Supported Coding Schemes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#efuse-api">eFuse API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-to-add-a-new-field">How to Add a New Field</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bit-order">Bit Order</a></li>
<li class="toctree-l4"><a class="reference internal" href="#get-efuses-during-build">Get eFuses During Build</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debug-efuse-unit-tests">Debug eFuse &amp; Unit Tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-examples">Application Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">Error Code and Helper Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">Event Loop Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos.html">FreeRTOS Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_idf.html">FreeRTOS (IDF)</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_additions.html">FreeRTOS (Supplemental Features)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mem_alloc.html">Heap Memory Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm.html">Memory Management for MMU Supported Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="heap_debug.html">Heap Memory Debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">ESP Timer (High Resolution Timer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="internal-unstable.html">Internal and Unstable APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">Inter-Processor Call (IPC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">Interrupt Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">Logging library</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_system_api.html">Miscellaneous System APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">Over The Air Updates (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">Performance Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="pthread.html">POSIX Support (Including POSIX Threads Support)</a></li>
<li class="toctree-l3"><a class="reference internal" href="random.html">Random Number Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">Sleep Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="soc_caps.html">SoC Capabilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">System Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ulp.html">ULP Coprocessor Programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">Watchdogs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">System API</a></li>
      <li class="breadcrumb-item active">eFuse Manager</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-reference/system/efuse.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="efuse-manager">
<h1>eFuse Manager<a class="headerlink" href="#efuse-manager" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/v5.4.2/esp32/api-reference/system/efuse.html">[中文]</a></p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>eFuse (Electronic Fuses) are microscopic one-time programmable fuses that can be &quot;burned&quot; (i.e., programmed) to store data into the ESP32. eFuse bits are organized into different data fields, and these data fields could be used for system parameters (i.e., data parameters used by ESP-IDF of ESP32) or user defined parameters.</p>
<p>The eFuse Manager component is a collection of tools and APIs that assist with defining, burning, accessing eFuses parameters. The notable tools and APIs include:</p>
<ul class="simple">
<li><p>A table format used to define eFuse data fields in CSV file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">efuse_table_gen.py</span></code> tool to generate C structure representation of eFuse data fields specified by the CSV file.</p></li>
<li><p>Collection of C API to read/write eFuse data fields.</p></li>
</ul>
</section>
<section id="efuse-manager-vs-idf-py">
<h2>eFuse Manager vs <code class="docutils literal notranslate"><span class="pre">idf.py</span></code><a class="headerlink" href="#efuse-manager-vs-idf-py" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">idf.py</span></code> provides a subset of the functionality of the eFuse Manager via the <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">efuse-&lt;subcommand&gt;</span></code> commands. In this documentation, mostly <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> based commands will be used, although you can still see some <code class="docutils literal notranslate"><span class="pre">espefuse.py</span></code> based commands for advanced or rare cases. To see all available commands, run <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">--help</span></code> and search for those prefixed with <code class="docutils literal notranslate"><span class="pre">efuse-</span></code>.</p>
</section>
<section id="hardware-description">
<h2>Hardware Description<a class="headerlink" href="#hardware-description" title="Permalink to this heading"></a></h2>
<p>The ESP32 has a number of eFuses which can store system and user parameters. Each eFuse is a one-bit field which can be programmed to 1 after which it cannot be reverted back to 0. The eFuse bits are grouped into blocks of 256 bits, where each block is further divided into 8 32-bit registers. Some blocks are reserved for system parameters while the remaining blocks can be used for user parameters.</p>
<p>For more details, see <em>ESP32 Technical Reference Manual</em> &gt; <em>eFuse Controller (eFuse)</em> [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#efuse">PDF</a>].</p>
<p>ESP32 has 4 eFuse blocks each containing 256 bits (not all bits can be used for user parameters):</p>
<ul class="simple">
<li><p>EFUSE_BLK0 is used entirely for system purposes</p></li>
<li><p>EFUSE_BLK1 is used for Flash Encryption keys. If the Flash Encryption feature is not used, this block can be used for user parameters.</p></li>
<li><p>EFUSE_BLK2 is used for the Secure Boot key. If the Secure Boot feature is not used, this block can be used for user parameters.</p></li>
<li><p>EFUSE_BLK3 can be partially reserved to store a custom MAC address, or can be used entirely for user parameters. Note that some bits are already used in ESP-IDF.</p></li>
</ul>
</section>
<section id="defining-efuse-fields">
<h2>Defining eFuse Fields<a class="headerlink" href="#defining-efuse-fields" title="Permalink to this heading"></a></h2>
<p>eFuse fields are defined as a table of records in a CSV file according to a specific format. This record format provides the ability to form eFuse fields of any length and from any number of individual bits.</p>
<p>Moreover, the record format allows structured definition of eFuse fields consisting of sub-fields, meaning that a parent eFuse field may consist of multiple child eFuse fields occupying the same eFuse bits.</p>
<section id="record-format">
<h3>Record Format<a class="headerlink" href="#record-format" title="Permalink to this heading"></a></h3>
<p>In simple cases, each record occupies a single row in the table. Each record contains the following values (i.e., columns):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># field_name, efuse_block(EFUSE_BLK0..EFUSE_BLK3), bit_start(0..255), bit_count(1..256), comment
</pre></div>
</div>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">field_name</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>Name of the eFuse field.</p></li>
<li><p>The prefix <code class="docutils literal notranslate"><span class="pre">ESP_EFUSE_</span></code> is automatically added to the name, and this name will be used when referring to the field in C code.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">field_name</span></code> unique across all eFuse fields.</p></li>
<li><p>If this value is left empty, then this record is combined with the previous record. This allows you define an eFuse field with arbitrary bit ordering (see <code class="docutils literal notranslate"><span class="pre">MAC_FACTORY</span></code> field in the common table).</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">.</span></code> will define a child eFuse field. See <a class="reference internal" href="#structured-efuse-fields"><span class="std std-ref">Structured eFuse Fields</span></a> for more details.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">efuse_block</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The eFuse field's block number. E.g., EFUSE_BLK0 to EFUSE_BLK3.</p></li>
<li><p>This determines which block the eFuse field is placed.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bit_start</span></code></p>
<blockquote>
<div><ul>
<li><p>Bit offset (0 to 255) of the eFuse within the block.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bit_start</span></code> is optional and can be omitted.</p>
<blockquote>
<div><ul class="simple">
<li><p>In this case, it is set to <code class="docutils literal notranslate"><span class="pre">bit_start</span> <span class="pre">+</span> <span class="pre">bit_count</span></code> from the previous record, given that the previous record is in the same eFuse block.</p></li>
<li><p>If the previous record is in a different eFuse block, an error will be generated.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bit_count</span></code></p>
<blockquote>
<div><ul>
<li><p>The size of the eFuse field in bits (1 to N).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bit_count</span></code> cannot be omitted.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">MAX_BLK_LEN</span></code> the eFuse field's size will be the maximum allowable eFuse field size in the block.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MAX_BLK_LEN</span></code> takes into account the coding scheme of eFuse.</p></li>
<li><p>Depending on the coding scheme selected via <a class="reference internal" href="../kconfig.html#config-efuse-code-scheme-selector"><span class="std std-ref">CONFIG_EFUSE_CODE_SCHEME_SELECTOR</span></a>, <code class="docutils literal notranslate"><span class="pre">MAX_BLK_LEN</span></code> could be 256 (&quot;None&quot;), 192 (&quot;3/4&quot;), or 128 (&quot;REPEAT&quot;).</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">comment</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>Comment describing the eFuse field.</p></li>
<li><p>The comment is copied verbatim into the C header file.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>If an eFuse field requires non-sequential bit ordering, then the eFuse field will span multiple records (i.e., multiple rows). The first record's <code class="docutils literal notranslate"><span class="pre">field_name</span></code> should specify the eFuse field's name, and the following records should leave <code class="docutils literal notranslate"><span class="pre">field_name</span></code> blank to indicate that they belong to the same eFuse field.</p>
<p>The following example demonstrates the records to specify the non-sequential eFuse field <code class="docutils literal notranslate"><span class="pre">MAC_FACTORY</span></code> followed by a regular eFuse field <code class="docutils literal notranslate"><span class="pre">MAC_FACTORY_CRC</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Factory MAC address #
#######################
MAC_FACTORY,            EFUSE_BLK0,    72,    8,    Factory MAC addr [0]
,                       EFUSE_BLK0,    64,    8,    Factory MAC addr [1]
,                       EFUSE_BLK0,    56,    8,    Factory MAC addr [2]
,                       EFUSE_BLK0,    48,    8,    Factory MAC addr [3]
,                       EFUSE_BLK0,    40,    8,    Factory MAC addr [4]
,                       EFUSE_BLK0,    32,    8,    Factory MAC addr [5]
MAC_FACTORY_CRC,        EFUSE_BLK0,    80,    8,    CRC8 for factory MAC address
</pre></div>
</div>
<p>This eFuse fields will be made available in C code as <code class="docutils literal notranslate"><span class="pre">ESP_EFUSE_MAC_FACTORY</span></code> and <code class="docutils literal notranslate"><span class="pre">ESP_EFUSE_MAC_FACTORY_CRC</span></code>.</p>
</section>
</section>
<section id="structured-efuse-fields">
<span id="id1"></span><h2>Structured eFuse Fields<a class="headerlink" href="#structured-efuse-fields" title="Permalink to this heading"></a></h2>
<p>Typically, an eFuse field represents a particular parameter. However, in some cases where an eFuse field consists of multiple sub-fields, it may be useful to have isolated access to those sub-fields. For example, if an eFuse field contained a floating point parameter, it may be useful to be access the sign, exponent, and mantissa fields of the floating as separate eFuse fields.</p>
<p>Therefore, it is possible for records to define eFuse fields in a structured manner using the <code class="docutils literal notranslate"><span class="pre">.</span></code> operator in <code class="docutils literal notranslate"><span class="pre">field_name</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">XX.YY.ZZ</span></code> defines a eFuse field <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> that is a child of eFuse field <code class="docutils literal notranslate"><span class="pre">YY</span></code> which in turn is a child field of eFuse field <code class="docutils literal notranslate"><span class="pre">XX</span></code>.</p>
<p>The following records demonstrate the definition of eFuse fields in a structured manner:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>WR_DIS,                           EFUSE_BLK0,   0,    32,     Write protection
WR_DIS.RD_DIS,                    EFUSE_BLK0,   0,    1,      Write protection for RD_DIS
WR_DIS.FIELD_1,                   EFUSE_BLK0,   1,    1,      Write protection for FIELD_1
WR_DIS.FIELD_2,                   EFUSE_BLK0,   2,    4,      Write protection for FIELD_2 (includes B1 and B2)
WR_DIS.FIELD_2.B1,                EFUSE_BLK0,   2,    2,      Write protection for FIELD_2.B1
WR_DIS.FIELD_2.B2,                EFUSE_BLK0,   4,    2,      Write protection for FIELD_2.B2
WR_DIS.FIELD_3,                   EFUSE_BLK0,   5,    1,      Write protection for FIELD_3
WR_DIS.FIELD_3.ALIAS,             EFUSE_BLK0,   5,    1,      Write protection for FIELD_3 (just a alias for WR_DIS.FIELD_3)
WR_DIS.FIELD_4,                   EFUSE_BLK0,   7,    1,      Write protection for FIELD_4
</pre></div>
</div>
<p>Some things to note regarding the example above:</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">WR_DIS</span></code> record defines the parent eFuse field. All the other records are child fields of <code class="docutils literal notranslate"><span class="pre">WR_DIS</span></code> due to their <code class="docutils literal notranslate"><span class="pre">WR_DIS.</span></code> prefix.</p></li>
<li><p>The child fields must utilize the same bits as their parent field. Take note of <code class="docutils literal notranslate"><span class="pre">bit_start</span></code> and <code class="docutils literal notranslate"><span class="pre">bit_count</span></code> of the child and parent fields:</p>
<blockquote>
<div><ul class="simple">
<li><p>The bits of the child fields are always in the range of their parent field. For example, <code class="docutils literal notranslate"><span class="pre">WR_DIS.RD_DIS</span></code> and <code class="docutils literal notranslate"><span class="pre">WR_DIS.RD_DIS</span></code> occupy the first and second bit of <code class="docutils literal notranslate"><span class="pre">WR_DIS</span></code>.</p></li>
<li><p>Child fields cannot use overlapping bits (except for when aliasing).</p></li>
</ul>
</div></blockquote>
</li>
<li><p>It is possible to create aliases as a child field. For example, <code class="docutils literal notranslate"><span class="pre">WR_DIS.FIELD_3.ALIAS</span></code> is a child field and alias of <code class="docutils literal notranslate"><span class="pre">WR_DIS.FIELD_3</span></code> as they both occupy the same bits.</p></li>
</ul>
<p>All eFuse Fields are eventually converted to C structures via the <code class="docutils literal notranslate"><span class="pre">efuse_table_gen.py</span></code> tool. The C structure for each eFuse field will derive their identifier from the <code class="docutils literal notranslate"><span class="pre">field_name</span></code> of the eFuse field's record, where all <code class="docutils literal notranslate"><span class="pre">.</span></code> are replaced with <code class="docutils literal notranslate"><span class="pre">_</span></code>. For example, the C symbols for <code class="docutils literal notranslate"><span class="pre">WR_DIS.RD_DIS</span></code> and <code class="docutils literal notranslate"><span class="pre">WR_DIS.FIELD_2.B1</span></code> will be <code class="docutils literal notranslate"><span class="pre">ESP_EFUSE_WR_DIS_RD_DIS</span></code> and <code class="docutils literal notranslate"><span class="pre">ESP_EFUSE_WR_DIS_FIELD_2_B1</span></code> respectively.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">efuse_table_gen.py</span></code> tool also checks that the fields do not overlap each other and must be within the range of a field. If there is a violation, then the following error is generated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Field at USER_DATA, EFUSE_BLK3, 0, 256 intersected with SERIAL_NUMBER, EFUSE_BLK3, 0, 32
</pre></div>
</div>
<p>In this case, the error can be resolved by making <code class="docutils literal notranslate"><span class="pre">SERIAL_NUMBER</span></code> a child field of <code class="docutils literal notranslate"><span class="pre">USER_DATA</span></code> via <code class="docutils literal notranslate"><span class="pre">USER_DATA.SERIAL_NUMBER</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Field at FIELD, EFUSE_BLK3, 0, 50 out of range FIELD.MAJOR_NUMBER, EFUSE_BLK3, 60, 32
</pre></div>
</div>
<p>In this case, the error can be resolved by changing <code class="docutils literal notranslate"><span class="pre">bit_start</span></code> for <code class="docutils literal notranslate"><span class="pre">FIELD.MAJOR_NUMBER</span></code> from <code class="docutils literal notranslate"><span class="pre">60</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code> so that <code class="docutils literal notranslate"><span class="pre">MAJOR_NUMBER</span></code> overlaps with <code class="docutils literal notranslate"><span class="pre">FIELD</span></code>.</p>
</section>
<section id="efuse-table-gen-py-tool">
<h2><code class="docutils literal notranslate"><span class="pre">efuse_table_gen.py</span></code> Tool<a class="headerlink" href="#efuse-table-gen-py-tool" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">efuse_table_gen.py</span></code> tool is designed to generate C source files containing C structures (of type <a class="reference internal" href="#_CPPv416esp_efuse_desc_t" title="esp_efuse_desc_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">esp_efuse_desc_t</span></code></a>) representing the eFuse fields defined in CSV files. Moreover, the tool also runs some checks on the provided CSV files before generation to ensure that:</p>
<ul class="simple">
<li><p>the names of the eFuse fields are unique</p></li>
<li><p>the eFuse fields do not use overlapping bits</p></li>
</ul>
<p>As mentioned previously, eFuse fields can be used to hold either system parameters or user parameters. Given that system parameter eFuse fields are inherently required by ESP-IDF and ESP32, those eFuse fields are defined in a <strong>common</strong> CSV file (<code class="docutils literal notranslate"><span class="pre">esp_efuse_table.csv</span></code>) and distributed as part of ESP-IDF. For user parameter eFuse fields, users should define those fields in a <strong>custom</strong> CSV file (e.g., <code class="docutils literal notranslate"><span class="pre">esp_efuse_custom_table.csv</span></code>).</p>
<p>To generate C source files using the <strong>common</strong> CSV file, use the <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">efuse-common-table</span></code> or the following:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span><span class="nv">$IDF_PATH</span>/components/efuse/
./efuse_table_gen.py<span class="w"> </span>--idf_target<span class="w"> </span>esp32<span class="w"> </span>esp32/esp_efuse_table.csv
</pre></div>
</div>
<p>The following C source/header files will be generated by the tool in <code class="docutils literal notranslate"><span class="pre">$IDF_PATH/components/efuse/esp32</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">esp_efuse_table.c</span></code> file containing the C structures of the system parameter eFuse fields</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_efuse_table.h</span></code> file in the <code class="docutils literal notranslate"><span class="pre">include</span></code> folder. This header can be included by the application to use those C structures.</p></li>
</ul>
<p>To generate C source files using a <strong>custom</strong> CSV file, use the command <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">efuse-custom-table</span></code> or the following:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span><span class="nv">$IDF_PATH</span>/components/efuse/
./efuse_table_gen.py<span class="w"> </span>--idf_target<span class="w"> </span>esp32<span class="w"> </span>esp32/esp_efuse_table.csv<span class="w"> </span>PROJECT_PATH/main/esp_efuse_custom_table.csv
</pre></div>
</div>
<p>The following C source/header files will be generated by the tool in <code class="docutils literal notranslate"><span class="pre">PROJECT_PATH/main</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">esp_efuse_custom_table.c</span></code> file containing the C structures of the user parameter eFuse fields</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_efuse_custom_table.h</span></code> file in the <code class="docutils literal notranslate"><span class="pre">include</span></code> folder. This header can be included by the application to use those C structures.</p></li>
</ul>
<p>To use the generated fields, you need to include two files:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_efuse.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_efuse_table.h&quot;</span><span class="c1"> // or &quot;esp_efuse_custom_table.h&quot;</span>
</pre></div>
</div>
</section>
<section id="supported-coding-schemes">
<h2>Supported Coding Schemes<a class="headerlink" href="#supported-coding-schemes" title="Permalink to this heading"></a></h2>
<p>Various coding schemes are supported by eFuses which can protect eFuses against data corruption by detecting and/or correcting for errors.</p>
<p>ESP32 supports the following eFuse coding schemes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (value 0), meaning no coding scheme is applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3/4</span></code> (value 1).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Repeat</span></code> (value 2). It is not entirely supported by IDF, not recommended for use.</p></li>
</ul>
<p>The coding schemes will encode each eFuse block individually. Furthermore, only EFUSE_BLK1, EFUSE_BLK2 and EFUSE_BLK3 will be encoded, meaning EUSE_BLK0 always uses the <code class="docutils literal notranslate"><span class="pre">None</span></code> coding scheme.</p>
<p>Coding schemes require some bits within an eFuse block to be used as overhead. Thus, by applying a coding scheme, only a subset of the 256 bits within an eFuse block will be usable as eFuse fields.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: 256 usable bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3/4</span></code>: 192 usable bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Repeat</span></code>: 128 usable bits</p></li>
</ul>
<p>When using a coding scheme, the length of the payload that can be written is limited. For more details, Please Refer to <em>ESP32 Technical Reference Manual</em> &gt; <em>Chapter 20 eFuse Controller</em> [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#efuse">PDF</a>] &gt; <em>Section 20.3.1.3 System Parameter coding_scheme</em>.</p>
<p>You can find out the coding scheme of your chip:</p>
<ul class="simple">
<li><p>run the <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">efuse-summary</span></code> command.</p></li>
<li><p>from <code class="docutils literal notranslate"><span class="pre">esptool</span></code> utility logs (during flashing).</p></li>
<li><p>calling the function <a class="reference internal" href="#_CPPv427esp_efuse_get_coding_scheme17esp_efuse_block_t" title="esp_efuse_get_coding_scheme"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_get_coding_scheme()</span></code></a> in the application for the EFUSE_BLK3 block.</p></li>
</ul>
<p>The eFuse fields specified in the CSV files must always comply with the eFuse coding scheme used by the chip. The <a class="reference internal" href="../kconfig.html#config-efuse-code-scheme-selector"><span class="std std-ref">CONFIG_EFUSE_CODE_SCHEME_SELECTOR</span></a> option selects which coding scheme is used by the CSV files. When generating source files, if the records in the CSV files do not adhere to the coding scheme, an error message will be displayed. In that case, you must adjust the <code class="docutils literal notranslate"><span class="pre">bit_start</span></code> and <code class="docutils literal notranslate"><span class="pre">bit_count</span></code> of the records to comply with the limitations of the selected coding scheme.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>After changing the coding scheme, run <code class="docutils literal notranslate"><span class="pre">efuse_common_table</span></code> and <code class="docutils literal notranslate"><span class="pre">efuse_custom_table</span></code> commands to check the tables of the new coding scheme.</p>
</div>
<p>If your program was compiled with <code class="docutils literal notranslate"><span class="pre">None</span></code> encoding but <code class="docutils literal notranslate"><span class="pre">3/4</span></code> is used by the chip, then the <code class="docutils literal notranslate"><span class="pre">ESP_ERR_CODING</span></code> error may occur when calling the eFuse API (The field is outside the block boundaries). If the field matches the new block boundaries, then the API will work without errors.</p>
<section id="none-coding-scheme">
<h3><code class="docutils literal notranslate"><span class="pre">None</span></code> Coding Scheme<a class="headerlink" href="#none-coding-scheme" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">None</span></code> coding scheme indicates that no coding scheme is applied, thus all 256 bits of each eFuse block are usable. However, there will be no protection against the corruption of eFuse bits.</p>
</section>
<section id="coding-scheme">
<h3><code class="docutils literal notranslate"><span class="pre">3/4</span></code> Coding Scheme<a class="headerlink" href="#coding-scheme" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">3/4</span></code> coding scheme imposes restrictions on writing bits belonging to one coding unit. The whole block with a length of 256 bits is divided into 4 coding units. In each coding unit there are 6 bytes of useful data and 2 service bytes. These 2 service bytes contain the checksum of the previous 6 data bytes.</p>
<p>Due to the calculation of the checksum for each coding unit, the writing process must be divided into the coding units. As such, the normal method (used by the <code class="docutils literal notranslate"><span class="pre">None</span></code> coding scheme) of burning eFuse bits separately over multiple write operations will no longer work. The data for the eFuse fields of a particular coding unit and the unit's associated checksum must be burned in one go. This is known as Batch Writing Mode.</p>
<p>As a result of Batch Writing Mode, a particular coding unit can only be written once (i.e., repeated writing to the same coding unit is prohibited). Thus, any coding unit that is written at run time can only contain one eFuse field. However, if the eFuse fields of a coding unit was specified in advance (via CSV records) or written to via <a class="reference internal" href="#_CPPv421esp_efuse_write_block17esp_efuse_block_tPKv6size_t6size_t" title="esp_efuse_write_block"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_write_block()</span></code></a>, then a coding unit can still contain multiple eFuse fields.</p>
</section>
<section id="repeat-coding-scheme">
<h3><code class="docutils literal notranslate"><span class="pre">Repeat</span></code> Coding Scheme<a class="headerlink" href="#repeat-coding-scheme" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Repeat</span></code> coding scheme simply repeats each eFuse bit, thus does not impose the same Batch Writing Mode restrictions as the <code class="docutils literal notranslate"><span class="pre">3/4</span></code> coding scheme. However, this comes at the cost of a larger overhead, leaving only 128 usable bits per eFuse block.</p>
</section>
<section id="batch-writing-mode">
<h3>Batch Writing Mode<a class="headerlink" href="#batch-writing-mode" title="Permalink to this heading"></a></h3>
<p>When writing to eFuse fields at run time, it may be necessary to use the Batch Writing Mode depending on the coding scheme used for eFuse block. Batch writing mode can be used as follows:</p>
<ol class="arabic simple">
<li><p>Enable batch writing mode by calling <a class="reference internal" href="#_CPPv427esp_efuse_batch_write_beginv" title="esp_efuse_batch_write_begin"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_batch_write_begin()</span></code></a></p></li>
<li><p>Write to the eFuse fields as usual using various <code class="docutils literal notranslate"><span class="pre">esp_efuse_write_...</span></code> functions.</p></li>
<li><p>Once all writes are complete, call <a class="reference internal" href="#_CPPv428esp_efuse_batch_write_commitv" title="esp_efuse_batch_write_commit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_batch_write_commit()</span></code></a> which burns prepared data to the eFuse blocks.</p></li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If there is already pre-written data in the eFuse block using the <code class="docutils literal notranslate"><span class="pre">3/4</span> <span class="pre">or</span> <span class="pre">Repeat</span></code> encoding scheme, then it is not possible to write anything extra (even if the required bits are empty) without breaking the previous data's checksums/check-symbols.</p>
<p>The checksums/check-symbols will be overwritten with new checksums/check-symbols and be completely destroyed (however, the payload eFuses are not damaged).</p>
<p>If you happen to find pre-written data in CUSTOM_MAC, SPI_PAD_CONFIG_HD, SPI_PAD_CONFIG_CS, etc., please contact Espressif to obtain the required pre-burnt eFuses.</p>
<p>FOR TESTING ONLY (NOT RECOMMENDED): You can ignore or suppress errors that violate encoding scheme data in order to burn the necessary bits in the eFuse block.</p>
</div>
</section>
</section>
<section id="efuse-api">
<span id="id2"></span><h2>eFuse API<a class="headerlink" href="#efuse-api" title="Permalink to this heading"></a></h2>
<p>Access to the fields is via a pointer to the description structure. API functions have some basic operation:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv425esp_efuse_read_field_blobA_PK16esp_efuse_desc_tPv6size_t" title="esp_efuse_read_field_blob"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_read_field_blob()</span></code></a> - returns an array of read eFuse bits.</p></li>
<li><p><a class="reference internal" href="#_CPPv424esp_efuse_read_field_cntA_PK16esp_efuse_desc_tP6size_t" title="esp_efuse_read_field_cnt"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_read_field_cnt()</span></code></a> - returns the number of bits programmed as &quot;1&quot;.</p></li>
<li><p><a class="reference internal" href="#_CPPv426esp_efuse_write_field_blobA_PK16esp_efuse_desc_tPKv6size_t" title="esp_efuse_write_field_blob"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_write_field_blob()</span></code></a> - writes an array.</p></li>
<li><p><a class="reference internal" href="#_CPPv425esp_efuse_write_field_cntA_PK16esp_efuse_desc_t6size_t" title="esp_efuse_write_field_cnt"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_write_field_cnt()</span></code></a> - writes a required count of bits as &quot;1&quot;.</p></li>
<li><p><a class="reference internal" href="#_CPPv424esp_efuse_get_field_sizeA_PK16esp_efuse_desc_t" title="esp_efuse_get_field_size"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_get_field_size()</span></code></a> - returns the number of bits by the field name.</p></li>
<li><p><a class="reference internal" href="#_CPPv418esp_efuse_read_reg17esp_efuse_block_tj" title="esp_efuse_read_reg"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_read_reg()</span></code></a> - returns value of eFuse register.</p></li>
<li><p><a class="reference internal" href="#_CPPv419esp_efuse_write_reg17esp_efuse_block_tj8uint32_t" title="esp_efuse_write_reg"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_write_reg()</span></code></a> - writes value to eFuse register.</p></li>
<li><p><a class="reference internal" href="#_CPPv427esp_efuse_get_coding_scheme17esp_efuse_block_t" title="esp_efuse_get_coding_scheme"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_get_coding_scheme()</span></code></a> - returns eFuse coding scheme for blocks.</p></li>
<li><p><a class="reference internal" href="#_CPPv420esp_efuse_read_block17esp_efuse_block_tPv6size_t6size_t" title="esp_efuse_read_block"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_read_block()</span></code></a> - reads a key from an eFuse block starting at the offset with required size.</p></li>
<li><p><a class="reference internal" href="#_CPPv421esp_efuse_write_block17esp_efuse_block_tPKv6size_t6size_t" title="esp_efuse_write_block"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_write_block()</span></code></a> - writes a key to an eFuse block starting at the offset with required size.</p></li>
<li><p><a class="reference internal" href="#_CPPv427esp_efuse_batch_write_beginv" title="esp_efuse_batch_write_begin"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_batch_write_begin()</span></code></a> - set the batch mode of writing fields.</p></li>
<li><p><a class="reference internal" href="#_CPPv428esp_efuse_batch_write_commitv" title="esp_efuse_batch_write_commit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_batch_write_commit()</span></code></a> - writes all prepared data for batch writing mode and reset the batch writing mode.</p></li>
<li><p><a class="reference internal" href="#_CPPv428esp_efuse_batch_write_cancelv" title="esp_efuse_batch_write_cancel"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_batch_write_cancel()</span></code></a> - reset the batch writing mode and prepared data.</p></li>
<li><p><a class="reference internal" href="#_CPPv426esp_efuse_get_key_dis_read17esp_efuse_block_t" title="esp_efuse_get_key_dis_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_get_key_dis_read()</span></code></a> - Returns a read protection for the key block.</p></li>
<li><p><a class="reference internal" href="#_CPPv426esp_efuse_set_key_dis_read17esp_efuse_block_t" title="esp_efuse_set_key_dis_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_set_key_dis_read()</span></code></a> - Sets a read protection for the key block.</p></li>
<li><p><a class="reference internal" href="#_CPPv427esp_efuse_get_key_dis_write17esp_efuse_block_t" title="esp_efuse_get_key_dis_write"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_get_key_dis_write()</span></code></a> - Returns a write protection for the key block.</p></li>
<li><p><a class="reference internal" href="#_CPPv427esp_efuse_set_key_dis_write17esp_efuse_block_t" title="esp_efuse_set_key_dis_write"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_set_key_dis_write()</span></code></a> - Sets a write protection for the key block.</p></li>
<li><p><a class="reference internal" href="#_CPPv425esp_efuse_get_key_purpose17esp_efuse_block_t" title="esp_efuse_get_key_purpose"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_get_key_purpose()</span></code></a> - Returns the current purpose set for an eFuse key block.</p></li>
<li><p><a class="reference internal" href="#_CPPv419esp_efuse_write_key17esp_efuse_block_t19esp_efuse_purpose_tPKv6size_t" title="esp_efuse_write_key"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_write_key()</span></code></a> - Programs a block of key data to an eFuse block.</p></li>
<li><p><a class="reference internal" href="#_CPPv420esp_efuse_write_keysA_K19esp_efuse_purpose_tA_AL32E_7uint8_tj" title="esp_efuse_write_keys"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_write_keys()</span></code></a> - Programs keys to unused eFuse blocks.</p></li>
<li><p><a class="reference internal" href="#_CPPv422esp_efuse_find_purpose19esp_efuse_purpose_tP17esp_efuse_block_t" title="esp_efuse_find_purpose"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_find_purpose()</span></code></a> - Finds a key block with the particular purpose set.</p></li>
<li><p><a class="reference internal" href="#_CPPv434esp_efuse_get_keypurpose_dis_write17esp_efuse_block_t" title="esp_efuse_get_keypurpose_dis_write"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_get_keypurpose_dis_write()</span></code></a> - Returns a write protection of the key purpose field for an eFuse key block (for esp32 always true).</p></li>
<li><p><a class="reference internal" href="#_CPPv426esp_efuse_key_block_unused17esp_efuse_block_t" title="esp_efuse_key_block_unused"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_key_block_unused()</span></code></a> - Returns true if the key block is unused, false otherwise.</p></li>
<li><p><a class="reference internal" href="#_CPPv423esp_efuse_destroy_block17esp_efuse_block_t" title="esp_efuse_destroy_block"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_destroy_block()</span></code></a> - Destroys the data in this eFuse block. There are two things to do: (1) if write protection is not set, then the remaining unset bits are burned, (2) set read protection for this block if it is not locked.</p></li>
</ul>
<p>For frequently used fields, special functions are made, like this <a class="reference internal" href="#_CPPv421esp_efuse_get_pkg_verv" title="esp_efuse_get_pkg_ver"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_efuse_get_pkg_ver()</span></code></a>.</p>
</section>
<section id="how-to-add-a-new-field">
<h2>How to Add a New Field<a class="headerlink" href="#how-to-add-a-new-field" title="Permalink to this heading"></a></h2>
<ol class="arabic simple">
<li><p>Find free bits for field. Refer to the <code class="docutils literal notranslate"><span class="pre">esp_efuse_table.csv</span></code> file, running <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">show-efuse-table</span></code>, or running the following command:</p></li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./efuse_table_gen.py esp32/esp_efuse_table.csv --info

Parsing efuse CSV input file $IDF_PATH/components/efuse/esp32/esp_efuse_table.csv ...
Verifying efuse table...
Max number of bits in BLK 192
Sorted efuse table:
#       field_name                      efuse_block     bit_start       bit_count
1       WR_DIS                          EFUSE_BLK0         0               16
2       WR_DIS.RD_DIS                   EFUSE_BLK0         0               1
3       WR_DIS.WR_DIS                   EFUSE_BLK0         1               1
4       WR_DIS.FLASH_CRYPT_CNT          EFUSE_BLK0         2               1
5       WR_DIS.UART_DOWNLOAD_DIS        EFUSE_BLK0         2               1
6       WR_DIS.MAC                      EFUSE_BLK0         3               1
7       WR_DIS.MAC_CRC                  EFUSE_BLK0         3               1
8       WR_DIS.DISABLE_APP_CPU          EFUSE_BLK0         3               1
9       WR_DIS.DISABLE_BT               EFUSE_BLK0         3               1
10      WR_DIS.DIS_CACHE                EFUSE_BLK0         3               1
11      WR_DIS.VOL_LEVEL_HP_INV         EFUSE_BLK0         3               1
12      WR_DIS.CLK8M_FREQ               EFUSE_BLK0         4               1
13      WR_DIS.ADC_VREF                 EFUSE_BLK0         4               1
14      WR_DIS.XPD_SDIO_REG             EFUSE_BLK0         5               1
15      WR_DIS.XPD_SDIO_TIEH            EFUSE_BLK0         5               1
16      WR_DIS.XPD_SDIO_FORCE           EFUSE_BLK0         5               1
17      WR_DIS.SPI_PAD_CONFIG_CLK       EFUSE_BLK0         6               1
18      WR_DIS.SPI_PAD_CONFIG_Q         EFUSE_BLK0         6               1
19      WR_DIS.SPI_PAD_CONFIG_D         EFUSE_BLK0         6               1
20      WR_DIS.SPI_PAD_CONFIG_CS0       EFUSE_BLK0         6               1
21      WR_DIS.BLOCK1                   EFUSE_BLK0         7               1
22      WR_DIS.BLOCK2                   EFUSE_BLK0         8               1
23      WR_DIS.BLOCK3                   EFUSE_BLK0         9               1
24      WR_DIS.CUSTOM_MAC_CRC           EFUSE_BLK0         9               1
25      WR_DIS.CUSTOM_MAC               EFUSE_BLK0         9               1
26      WR_DIS.ADC1_TP_LOW              EFUSE_BLK0         9               1
27      WR_DIS.ADC1_TP_HIGH             EFUSE_BLK0         9               1
28      WR_DIS.ADC2_TP_LOW              EFUSE_BLK0         9               1
29      WR_DIS.ADC2_TP_HIGH             EFUSE_BLK0         9               1
30      WR_DIS.SECURE_VERSION           EFUSE_BLK0         9               1
31      WR_DIS.MAC_VERSION              EFUSE_BLK0         9               1
32      WR_DIS.BLK3_PART_RESERVE        EFUSE_BLK0         10              1
33      WR_DIS.FLASH_CRYPT_CONFIG       EFUSE_BLK0         10              1
34      WR_DIS.CODING_SCHEME            EFUSE_BLK0         10              1
35      WR_DIS.KEY_STATUS               EFUSE_BLK0         10              1
36      WR_DIS.ABS_DONE_0               EFUSE_BLK0         12              1
37      WR_DIS.ABS_DONE_1               EFUSE_BLK0         13              1
38      WR_DIS.JTAG_DISABLE             EFUSE_BLK0         14              1
39      WR_DIS.CONSOLE_DEBUG_DISABLE    EFUSE_BLK0         15              1
40      WR_DIS.DISABLE_DL_ENCRYPT       EFUSE_BLK0         15              1
41      WR_DIS.DISABLE_DL_DECRYPT       EFUSE_BLK0         15              1
42      WR_DIS.DISABLE_DL_CACHE         EFUSE_BLK0         15              1
43      RD_DIS                          EFUSE_BLK0         16              4
44      RD_DIS.BLOCK1                   EFUSE_BLK0         16              1
45      RD_DIS.BLOCK2                   EFUSE_BLK0         17              1
46      RD_DIS.BLOCK3                   EFUSE_BLK0         18              1
47      RD_DIS.CUSTOM_MAC_CRC           EFUSE_BLK0         18              1
48      RD_DIS.CUSTOM_MAC               EFUSE_BLK0         18              1
49      RD_DIS.ADC1_TP_LOW              EFUSE_BLK0         18              1
50      RD_DIS.ADC1_TP_HIGH             EFUSE_BLK0         18              1
51      RD_DIS.ADC2_TP_LOW              EFUSE_BLK0         18              1
52      RD_DIS.ADC2_TP_HIGH             EFUSE_BLK0         18              1
53      RD_DIS.SECURE_VERSION           EFUSE_BLK0         18              1
54      RD_DIS.MAC_VERSION              EFUSE_BLK0         18              1
55      RD_DIS.BLK3_PART_RESERVE        EFUSE_BLK0         19              1
56      RD_DIS.FLASH_CRYPT_CONFIG       EFUSE_BLK0         19              1
57      RD_DIS.CODING_SCHEME            EFUSE_BLK0         19              1
58      RD_DIS.KEY_STATUS               EFUSE_BLK0         19              1
59      FLASH_CRYPT_CNT                 EFUSE_BLK0         20              7
60      UART_DOWNLOAD_DIS               EFUSE_BLK0         27              1
61      MAC                             EFUSE_BLK0         32              8
62      MAC                             EFUSE_BLK0         40              8
63      MAC                             EFUSE_BLK0         48              8
64      MAC                             EFUSE_BLK0         56              8
65      MAC                             EFUSE_BLK0         64              8
66      MAC                             EFUSE_BLK0         72              8
67      MAC_CRC                         EFUSE_BLK0         80              8
68      DISABLE_APP_CPU                 EFUSE_BLK0         96              1
69      DISABLE_BT                      EFUSE_BLK0         97              1
70      CHIP_PACKAGE_4BIT               EFUSE_BLK0         98              1
71      DIS_CACHE                       EFUSE_BLK0         99              1
72      SPI_PAD_CONFIG_HD               EFUSE_BLK0        100              5
73      CHIP_PACKAGE                    EFUSE_BLK0        105              3
74      CHIP_CPU_FREQ_LOW               EFUSE_BLK0        108              1
75      CHIP_CPU_FREQ_RATED             EFUSE_BLK0        109              1
76      BLK3_PART_RESERVE               EFUSE_BLK0        110              1
77      CHIP_VER_REV1                   EFUSE_BLK0        111              1
78      CLK8M_FREQ                      EFUSE_BLK0        128              8
79      ADC_VREF                        EFUSE_BLK0        136              5
80      XPD_SDIO_REG                    EFUSE_BLK0        142              1
81      XPD_SDIO_TIEH                   EFUSE_BLK0        143              1
82      XPD_SDIO_FORCE                  EFUSE_BLK0        144              1
83      SPI_PAD_CONFIG_CLK              EFUSE_BLK0        160              5
84      SPI_PAD_CONFIG_Q                EFUSE_BLK0        165              5
85      SPI_PAD_CONFIG_D                EFUSE_BLK0        170              5
86      SPI_PAD_CONFIG_CS0              EFUSE_BLK0        175              5
87      CHIP_VER_REV2                   EFUSE_BLK0        180              1
88      VOL_LEVEL_HP_INV                EFUSE_BLK0        182              2
89      WAFER_VERSION_MINOR             EFUSE_BLK0        184              2
90      FLASH_CRYPT_CONFIG              EFUSE_BLK0        188              4
91      CODING_SCHEME                   EFUSE_BLK0        192              2
92      CONSOLE_DEBUG_DISABLE           EFUSE_BLK0        194              1
93      DISABLE_SDIO_HOST               EFUSE_BLK0        195              1
94      ABS_DONE_0                      EFUSE_BLK0        196              1
95      ABS_DONE_1                      EFUSE_BLK0        197              1
96      JTAG_DISABLE                    EFUSE_BLK0        198              1
97      DISABLE_DL_ENCRYPT              EFUSE_BLK0        199              1
98      DISABLE_DL_DECRYPT              EFUSE_BLK0        200              1
99      DISABLE_DL_CACHE                EFUSE_BLK0        201              1
100     KEY_STATUS                      EFUSE_BLK0        202              1
101     BLOCK1                          EFUSE_BLK1         0              192
102     BLOCK2                          EFUSE_BLK2         0              192
103     CUSTOM_MAC_CRC                  EFUSE_BLK3         0               8
104     MAC_CUSTOM                      EFUSE_BLK3         8               48
105     ADC1_TP_LOW                     EFUSE_BLK3         96              7
106     ADC1_TP_HIGH                    EFUSE_BLK3        103              9
107     ADC2_TP_LOW                     EFUSE_BLK3        112              7
108     ADC2_TP_HIGH                    EFUSE_BLK3        119              9
109     SECURE_VERSION                  EFUSE_BLK3        128              32
110     MAC_VERSION                     EFUSE_BLK3        184              8

Used bits in efuse table:
EFUSE_BLK0
[0 15] [0 2] [2 3] ... [19 19] [19 27] [32 87] [96 111] [128 140] [142 144] [160 180] [182 185] [188 202]
EFUSE_BLK1
[0 191]
EFUSE_BLK2
[0 191]
EFUSE_BLK3
[0 55] [96 159] [184 191]
Note: Not printed ranges are free for using. (bits in EFUSE_BLK0 are reserved for Espressif)
</pre></div>
</div>
<p>The number of bits not included in square brackets are free (some bits are reserved by Espressif). All fields are checked for overlapping bits.</p>
<p>To add child fields to an existing field, <a class="reference internal" href="#structured-efuse-fields"><span class="std std-ref">Structured eFuse Fields</span></a> can be used. The following example demonstrates adding of the the fields <code class="docutils literal notranslate"><span class="pre">SERIAL_NUMBER</span></code>, <code class="docutils literal notranslate"><span class="pre">MODEL_NUMBER</span></code> and <code class="docutils literal notranslate"><span class="pre">HARDWARE_REV</span></code> to an existing <code class="docutils literal notranslate"><span class="pre">USER_DATA</span></code> field by using the <code class="docutils literal notranslate"><span class="pre">.</span></code> operator:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>USER_DATA.SERIAL_NUMBER,                  EFUSE_BLK3,    0,  32,
USER_DATA.MODEL_NUMBER,                   EFUSE_BLK3,    32, 10,
USER_DATA.HARDWARE_REV,                   EFUSE_BLK3,    42, 10,
</pre></div>
</div>
<p>In general, to add new eFuse Fields:</p>
<ol class="arabic simple">
<li><p>Add a record for each eFuse field in CSV file.</p></li>
<li><p>Run the <code class="docutils literal notranslate"><span class="pre">show_efuse_table</span></code> command to check eFuse table.</p></li>
<li><p>To generate source files run the <code class="docutils literal notranslate"><span class="pre">efuse_common_table</span></code> or <code class="docutils literal notranslate"><span class="pre">efuse_custom_table</span></code> commands.</p></li>
</ol>
<p>You may get errors such as <code class="docutils literal notranslate"><span class="pre">intersects</span> <span class="pre">with</span></code> or <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">of</span> <span class="pre">range</span></code>. Please see how to solve them in the <a class="reference internal" href="#structured-efuse-fields"><span class="std std-ref">Structured eFuse Fields</span></a> article.</p>
</section>
<section id="bit-order">
<h2>Bit Order<a class="headerlink" href="#bit-order" title="Permalink to this heading"></a></h2>
<p>The eFuses bit order is little endian (see the example below), meaning that eFuse bits are read and written from LSB to MSB:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ idf.py efuse-dump

USER_DATA      (BLOCK3          ) [3 ] read_regs: 03020100 07060504 0B0A0908 0F0E0D0C 13121111 17161514 1B1A1918 1F1E1D1C
BLOCK4         (BLOCK4          ) [4 ] read_regs: 03020100 07060504 0B0A0908 0F0E0D0C 13121111 17161514 1B1A1918 1F1E1D1C

where is the register representation:

EFUSE_RD_USR_DATA0_REG = 0x03020100
EFUSE_RD_USR_DATA1_REG = 0x07060504
EFUSE_RD_USR_DATA2_REG = 0x0B0A0908
EFUSE_RD_USR_DATA3_REG = 0x0F0E0D0C
EFUSE_RD_USR_DATA4_REG = 0x13121111
EFUSE_RD_USR_DATA5_REG = 0x17161514
EFUSE_RD_USR_DATA6_REG = 0x1B1A1918
EFUSE_RD_USR_DATA7_REG = 0x1F1E1D1C

where is the byte representation:

byte[0] = 0x00, byte[1] = 0x01, ... byte[3] = 0x03, byte[4] = 0x04, ..., byte[31] = 0x1F
</pre></div>
</div>
<p>For example, CSV file describes the <code class="docutils literal notranslate"><span class="pre">USER_DATA</span></code> field, which occupies all 256 bits (a whole block).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>USER_DATA,          EFUSE_BLK3,    0,  256,     User data
USER_DATA.FIELD1,   EFUSE_BLK3,    16,  16,     Field1

ID,                 EFUSE_BLK4,    8,  3,      ID bit[0..2]
,                   EFUSE_BLK4,    16, 2,      ID bit[3..4]
,                   EFUSE_BLK4,    32, 3,      ID bit[5..7]
</pre></div>
</div>
<p>Thus, reading the eFuse <code class="docutils literal notranslate"><span class="pre">USER_DATA</span></code> block written as above gives the following results:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="n">esp_efuse_read_field_blob</span><span class="p">(</span><span class="n">ESP_EFUSE_USER_DATA</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="c1">// buf[0] = 0x00, buf[1] = 0x01, ... buf[31] = 0x1F</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">field1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">field1_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ESP_EFUSE_USER_DATA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bit_count</span><span class="p">;</span><span class="w"> </span><span class="c1">// can be used for this case because it only consists of one entry</span>
<span class="n">esp_efuse_read_field_blob</span><span class="p">(</span><span class="n">ESP_EFUSE_USER_DATA</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">field1</span><span class="p">,</span><span class="w"> </span><span class="n">field1_size</span><span class="p">);</span>
<span class="c1">// field1 = 0x0302</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">field1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">esp_efuse_read_field_blob</span><span class="p">(</span><span class="n">ESP_EFUSE_USER_DATA</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">field1_1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// reads only first 2 bits</span>
<span class="c1">// field1 = 0x0002</span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">id_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">esp_efuse_get_field_size</span><span class="p">(</span><span class="n">ESP_EFUSE_ID</span><span class="p">);</span><span class="w"> </span><span class="c1">// returns 6</span>
<span class="c1">// size_t id_size = ESP_EFUSE_USER_DATA[0]-&gt;bit_count; // cannot be used because it consists of 3 entries. It returns 3 not 6</span>
<span class="n">esp_efuse_read_field_blob</span><span class="p">(</span><span class="n">ESP_EFUSE_ID</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">id_size</span><span class="p">);</span>
<span class="c1">// id = 0x91</span>
<span class="c1">// b&#39;100 10  001</span>
<span class="c1">//   [3] [2] [3]</span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="n">id_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">esp_efuse_read_field_blob</span><span class="p">(</span><span class="n">ESP_EFUSE_ID</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">id_1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="c1">// id = 0x01</span>
<span class="c1">// b&#39;001</span>
</pre></div>
</div>
</section>
<section id="get-efuses-during-build">
<h2>Get eFuses During Build<a class="headerlink" href="#get-efuses-during-build" title="Permalink to this heading"></a></h2>
<p>There is a way to get the state of eFuses at the build stage of the project. There are two CMake functions for this:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">espefuse_get_json_summary()</span></code> - It calls the <code class="docutils literal notranslate"><span class="pre">espefuse.py</span> <span class="pre">summary</span> <span class="pre">--format</span> <span class="pre">json</span></code> command and returns a JSON string (it is not stored in a file).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">espefuse_get_efuse()</span></code> - It finds a given eFuse name in the JSON string and returns its property.</p></li>
</ul>
<p>The JSON string has the following properties:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;MAC&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;bit_len&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">48</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;block&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;category&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;identity&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;description&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Factory MAC Address&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;efuse_type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;bytes:6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;MAC&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;pos&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;readable&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;94:b9:7e:5a:6e:58 (CRC 0xe2 OK)&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;word&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;writeable&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These functions can be used from a top-level project <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> (<a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/examples/system/efuse/CMakeLists.txt">system/efuse/CMakeLists.txt</a>):</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># ...</span>
<span class="nb">project</span><span class="p">(</span><span class="s">hello_world</span><span class="p">)</span>

<span class="nb">espefuse_get_json_summary</span><span class="p">(</span><span class="s">efuse_json</span><span class="p">)</span>
<span class="nb">espefuse_get_efuse</span><span class="p">(</span><span class="s">ret_data</span><span class="w"> </span><span class="o">${</span><span class="nv">efuse_json</span><span class="o">}</span><span class="w"> </span><span class="s2">&quot;MAC&quot;</span><span class="w"> </span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
<span class="nb">message</span><span class="p">(</span><span class="s2">&quot;MAC:&quot;</span><span class="w"> </span><span class="o">${</span><span class="nv">ret_data</span><span class="o">}</span><span class="p">)</span>
</pre></div>
</div>
<p>The format of the <code class="docutils literal notranslate"><span class="pre">value</span></code> property is the same as shown in <code class="docutils literal notranslate"><span class="pre">espefuse.py</span> <span class="pre">summary</span></code> or <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">efuse-summary</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MAC:94:b9:7e:5a:6e:58 (CRC 0xe2 OK)
</pre></div>
</div>
<p>There is an example test <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/examples/system/efuse/CMakeLists.txt">system/efuse/CMakeLists.txt</a> which adds a custom target <code class="docutils literal notranslate"><span class="pre">efuse-filter</span></code>. This allows you to run the <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">efuse-filter</span></code> command to read the required eFuses (specified in the <code class="docutils literal notranslate"><span class="pre">efuse_names</span></code> list) at any time, not just during the project build.</p>
</section>
<section id="debug-efuse-unit-tests">
<h2>Debug eFuse &amp; Unit Tests<a class="headerlink" href="#debug-efuse-unit-tests" title="Permalink to this heading"></a></h2>
<section id="virtual-efuses">
<span id="id3"></span><h3>Virtual eFuses<a class="headerlink" href="#virtual-efuses" title="Permalink to this heading"></a></h3>
<p>The Kconfig option <a class="reference internal" href="../kconfig.html#config-efuse-virtual"><span class="std std-ref">CONFIG_EFUSE_VIRTUAL</span></a> virtualizes eFuse values inside the eFuse Manager, so writes are emulated and no eFuse values are permanently changed. This can be useful for debugging and unit testing.</p>
<p>During startup, the eFuses are copied to RAM. All eFuse operations (read and write) are performed with RAM instead of the real eFuse registers.</p>
<p>In addition to the <a class="reference internal" href="../kconfig.html#config-efuse-virtual"><span class="std std-ref">CONFIG_EFUSE_VIRTUAL</span></a> option, there is the <a class="reference internal" href="../kconfig.html#config-efuse-virtual-keep-in-flash"><span class="std std-ref">CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH</span></a> option that adds a feature to keep eFuses in flash memory. To use this mode, the partition_table should have include an <code class="docutils literal notranslate"><span class="pre">efuse</span></code> partition in <code class="docutils literal notranslate"><span class="pre">partition.csv</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>efuse_em, data, efuse,   ,   0x2000,
</pre></div>
</div>
<p>During startup, the eFuses are copied from flash, or in case where flash is empty, copied from real eFuse to RAM and then write flash. This option allows keeping eFuses after reboots, making it possible to test Secure Boot and Flash Encryption features.</p>
<section id="flash-encryption-testing">
<h4>Flash Encryption Testing<a class="headerlink" href="#flash-encryption-testing" title="Permalink to this heading"></a></h4>
<p>Flash encryption is a hardware feature that requires the physical burning of eFuses <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CNT</span></code>. If flash encryption is not actually enabled, then enabling the <a class="reference internal" href="../kconfig.html#config-efuse-virtual-keep-in-flash"><span class="std std-ref">CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH</span></a> option just provides testing possibilities and does not encrypt anything in the flash, even though the logs indicates that encryption happens.</p>
<p>The <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">bootloader_flash_write()</span></code> is adapted for this purpose. But if flash encryption is already enabled on the chip when the application is run, or if the bootloader is created with the <a class="reference internal" href="../kconfig.html#config-efuse-virtual-keep-in-flash"><span class="std std-ref">CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH</span></a> option, then the flash encryption/decryption operations will work properly. This means that data are encrypted as it is written into an encrypted flash partition and decrypted when they are read from an encrypted partition.</p>
</section>
</section>
<section id="espefuse-py">
<h3><code class="docutils literal notranslate"><span class="pre">espefuse.py</span></code><a class="headerlink" href="#espefuse-py" title="Permalink to this heading"></a></h3>
<p>esptool includes a useful tool for reading/writing ESP32 eFuse bits - <a class="reference external" href="https://docs.espressif.com/projects/esptool/en/latest/esp32/espefuse/index.html">espefuse.py</a>.</p>
<p>Part of the functionality of this tool is also provided directly by <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> commands. For example, the <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">efuse-summary</span></code> command is equivalent to <code class="docutils literal notranslate"><span class="pre">espefuse.py</span> <span class="pre">summary</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf.py efuse-summary

Executing action: efuse-summary
(...)

EFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)
----------------------------------------------------------------------------------------
Calibration fuses:
ADC_VREF (BLOCK0)                                  True ADC reference voltage                         = 1121 R/W (0b00011)

Config fuses:
WR_DIS (BLOCK0)                                    Efuse write disable mask                           = 0 R/W (0x0000)
RD_DIS (BLOCK0)                                    Disable reading from BlOCK1-3                      = 0 R/W (0x0)
DISABLE_APP_CPU (BLOCK0)                           Disables APP CPU                                   = False R/W (0b0)
DISABLE_BT (BLOCK0)                                Disables Bluetooth                                 = False R/W (0b0)
DIS_CACHE (BLOCK0)                                 Disables cache                                     = False R/W (0b0)
CHIP_CPU_FREQ_LOW (BLOCK0)                         If set alongside EFUSE_RD_CHIP_CPU_FREQ_RATED; the = False R/W (0b0)
                                                    ESP32&#39;s max CPU frequency is rated for 160MHz. 24
                                                   0MHz otherwise
CHIP_CPU_FREQ_RATED (BLOCK0)                       If set; the ESP32&#39;s maximum CPU frequency has been = True R/W (0b1)
                                                    rated
BLK3_PART_RESERVE (BLOCK0)                         BLOCK3 partially served for ADC calibration data   = False R/W (0b0)
CLK8M_FREQ (BLOCK0)                                8MHz clock freq override                           = 51 R/W (0x33)
VOL_LEVEL_HP_INV (BLOCK0)                          This field stores the voltage level for CPU to run = 0 R/W (0b00)
                                                    at 240 MHz; or for flash/PSRAM to run at 80 MHz.0
                                                   x0: level 7; 0x1: level 6; 0x2: level 5; 0x3:i
                                                   level 4. (RO)
CODING_SCHEME (BLOCK0)                             Efuse variable block length scheme
   = NONE (BLK1-3 len=256 bits) R/W (0b00)
CONSOLE_DEBUG_DISABLE (BLOCK0)                     Disable ROM BASIC interpreter fallback             = True R/W (0b1)
DISABLE_SDIO_HOST (BLOCK0)                                                                            = False R/W (0b0)
DISABLE_DL_CACHE (BLOCK0)                          Disable flash cache in UART bootloader             = False R/W (0b0)

Flash fuses:
FLASH_CRYPT_CNT (BLOCK0)                           Flash encryption is enabled if this field has an o = 0 R/W (0b0000000)
                                                   dd number of bits set
FLASH_CRYPT_CONFIG (BLOCK0)                        Flash encryption config (key tweak bits)           = 0 R/W (0x0)

Identity fuses:
CHIP_PACKAGE_4BIT (BLOCK0)                         Chip package identifier #4bit                      = False R/W (0b0)
CHIP_PACKAGE (BLOCK0)                              Chip package identifier                            = 1 R/W (0b001)
CHIP_VER_REV1 (BLOCK0)                             bit is set to 1 for rev1 silicon                   = True R/W (0b1)
CHIP_VER_REV2 (BLOCK0)                                                                                = True R/W (0b1)
WAFER_VERSION_MINOR (BLOCK0)                                                                          = 0 R/W (0b00)
WAFER_VERSION_MAJOR (BLOCK0)                       calc WAFER VERSION MAJOR from CHIP_VER_REV1 and CH = 3 R/W (0b011)
                                                   IP_VER_REV2 and apb_ctl_date (read only)
PKG_VERSION (BLOCK0)                               calc Chip package = CHIP_PACKAGE_4BIT &lt;&lt; 3 + CHIP_ = 1 R/W (0x1)
                                                   PACKAGE (read only)

Jtag fuses:
JTAG_DISABLE (BLOCK0)                              Disable JTAG                                       = False R/W (0b0)

Mac fuses:
MAC (BLOCK0)                                       MAC address
   = 94:b9:7e:5a:6e:58 (CRC 0xe2 OK) R/W
MAC_CRC (BLOCK0)                                   CRC8 for MAC address                               = 226 R/W (0xe2)
MAC_VERSION (BLOCK3)                               Version of the MAC field                           = 0 R/W (0x00)

Security fuses:
UART_DOWNLOAD_DIS (BLOCK0)                         Disable UART download mode. Valid for ESP32 V3 and = False R/W (0b0)
                                                    newer; only
ABS_DONE_0 (BLOCK0)                                Secure boot V1 is enabled for bootloader image     = False R/W (0b0)
ABS_DONE_1 (BLOCK0)                                Secure boot V2 is enabled for bootloader image     = False R/W (0b0)
DISABLE_DL_ENCRYPT (BLOCK0)                        Disable flash encryption in UART bootloader        = False R/W (0b0)
DISABLE_DL_DECRYPT (BLOCK0)                        Disable flash decryption in UART bootloader        = False R/W (0b0)
KEY_STATUS (BLOCK0)                                Usage of efuse block 3 (reserved)                  = False R/W (0b0)
SECURE_VERSION (BLOCK3)                            Secure version for anti-rollback                   = 0 R/W (0x00000000)
BLOCK1 (BLOCK1)                                    Flash encryption key
   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
BLOCK2 (BLOCK2)                                    Security boot key
   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W
BLOCK3 (BLOCK3)                                    Variable Block 3
   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W

Spi Pad fuses:
SPI_PAD_CONFIG_HD (BLOCK0)                         read for SPI_pad_config_hd                         = 0 R/W (0b00000)
SPI_PAD_CONFIG_CLK (BLOCK0)                        Override SD_CLK pad (GPIO6/SPICLK)                 = 0 R/W (0b00000)
SPI_PAD_CONFIG_Q (BLOCK0)                          Override SD_DATA_0 pad (GPIO7/SPIQ)                = 0 R/W (0b00000)
SPI_PAD_CONFIG_D (BLOCK0)                          Override SD_DATA_1 pad (GPIO8/SPID)                = 0 R/W (0b00000)
SPI_PAD_CONFIG_CS0 (BLOCK0)                        Override SD_CMD pad (GPIO11/SPICS0)                = 0 R/W (0b00000)

Vdd fuses:
XPD_SDIO_REG (BLOCK0)                              read for XPD_SDIO_REG                              = False R/W (0b0)
XPD_SDIO_TIEH (BLOCK0)                             If XPD_SDIO_FORCE &amp; XPD_SDIO_REG                   = 1.8V R/W (0b0)
XPD_SDIO_FORCE (BLOCK0)                            Ignore MTDI pin (GPIO12) for VDD_SDIO on reset     = False R/W (0b0)

Flash voltage (VDD_SDIO) determined by GPIO12 on reset (High for 1.8V, Low/NC for 3.3V)
</pre></div>
</div>
<p>To get a dump for all eFuse registers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf.py efuse-dump

Executing action: efuse-dump
Running espefuse.py in directory &lt;project-directory&gt;
Executing &quot;espefuse.py dump --chip esp32&quot;...
espefuse.py v4.6-dev
Connecting....
BLOCK0          (                ) [0 ] read_regs: 00000000 7e5a6e58 00e294b9 0000a200 00000333 00100000 00000004
BLOCK1          (flash_encryption) [1 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
BLOCK2          (secure_boot_v1 s) [2 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
BLOCK3          (                ) [3 ] read_regs: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

EFUSE_REG_DEC_STATUS        0x00000000

=== Run &quot;dump&quot; command ===
</pre></div>
</div>
</section>
</section>
<section id="application-examples">
<h2>Application Examples<a class="headerlink" href="#application-examples" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/system/efuse">system/efuse</a> demonstrates how to use the eFuse API on ESP32, showing read and write operations with fields from the common and custom eFuse tables, and explaining the use of virtual eFuses for debugging purposes.</p></li>
</ul>
</section>
<section id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h2>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/efuse/esp32/include/esp_efuse_chip.h">components/efuse/esp32/include/esp_efuse_chip.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_efuse_chip.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">efuse</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">efuse</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES efuse
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES efuse
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv417esp_efuse_block_t">
<span id="_CPPv317esp_efuse_block_t"></span><span id="_CPPv217esp_efuse_block_t"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_block_t</span></span></span><a class="headerlink" href="#_CPPv417esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of eFuse blocks for ESP32. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t10EFUSE_BLK0E">
<span id="_CPPv3N17esp_efuse_block_t10EFUSE_BLK0E"></span><span id="_CPPv2N17esp_efuse_block_t10EFUSE_BLK0E"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044aa8a1fee4a7a33266b6596e0c07919f8c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK0</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t10EFUSE_BLK0E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of eFuse block. Reserved. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t10EFUSE_BLK1E">
<span id="_CPPv3N17esp_efuse_block_t10EFUSE_BLK1E"></span><span id="_CPPv2N17esp_efuse_block_t10EFUSE_BLK1E"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044a7992a87ca878ddec905c49119a58fdfa"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK1</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t10EFUSE_BLK1E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of eFuse block. Used for Flash Encryption. If not using that Flash Encryption feature, they can be used for another purpose. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t14EFUSE_BLK_KEY0E">
<span id="_CPPv3N17esp_efuse_block_t14EFUSE_BLK_KEY0E"></span><span id="_CPPv2N17esp_efuse_block_t14EFUSE_BLK_KEY0E"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044a38ff97eefb8794ef3878536b236cebe6"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK_KEY0</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t14EFUSE_BLK_KEY0E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of eFuse block. Used for Flash Encryption. If not using that Flash Encryption feature, they can be used for another purpose. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t23EFUSE_BLK_ENCRYPT_FLASHE">
<span id="_CPPv3N17esp_efuse_block_t23EFUSE_BLK_ENCRYPT_FLASHE"></span><span id="_CPPv2N17esp_efuse_block_t23EFUSE_BLK_ENCRYPT_FLASHE"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044afa890495250a0c4c53b4bb79fe952eac"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK_ENCRYPT_FLASH</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t23EFUSE_BLK_ENCRYPT_FLASHE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of eFuse block. Used for Flash Encryption. If not using that Flash Encryption feature, they can be used for another purpose. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t10EFUSE_BLK2E">
<span id="_CPPv3N17esp_efuse_block_t10EFUSE_BLK2E"></span><span id="_CPPv2N17esp_efuse_block_t10EFUSE_BLK2E"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044a94e685744c446eb0431ebf8a668163fb"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK2</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t10EFUSE_BLK2E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of eFuse block. Used for Secure Boot. If not using that Secure Boot feature, they can be used for another purpose. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t14EFUSE_BLK_KEY1E">
<span id="_CPPv3N17esp_efuse_block_t14EFUSE_BLK_KEY1E"></span><span id="_CPPv2N17esp_efuse_block_t14EFUSE_BLK_KEY1E"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044ac1829c81ec31ce62f10d092223cf50a5"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK_KEY1</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t14EFUSE_BLK_KEY1E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of eFuse block. Used for Secure Boot. If not using that Secure Boot feature, they can be used for another purpose. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t21EFUSE_BLK_SECURE_BOOTE">
<span id="_CPPv3N17esp_efuse_block_t21EFUSE_BLK_SECURE_BOOTE"></span><span id="_CPPv2N17esp_efuse_block_t21EFUSE_BLK_SECURE_BOOTE"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044a162b8219357b88fc70be74ae5e83e2da"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK_SECURE_BOOT</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t21EFUSE_BLK_SECURE_BOOTE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of eFuse block. Used for Secure Boot. If not using that Secure Boot feature, they can be used for another purpose. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t10EFUSE_BLK3E">
<span id="_CPPv3N17esp_efuse_block_t10EFUSE_BLK3E"></span><span id="_CPPv2N17esp_efuse_block_t10EFUSE_BLK3E"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044ac7dd2228b97b62904749bd376d654e0a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK3</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t10EFUSE_BLK3E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of eFuse block. Uses for the purpose of the user. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t14EFUSE_BLK_KEY2E">
<span id="_CPPv3N17esp_efuse_block_t14EFUSE_BLK_KEY2E"></span><span id="_CPPv2N17esp_efuse_block_t14EFUSE_BLK_KEY2E"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044aa6aadf0b7678ef95ed2e39ddd3bcc6c8"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK_KEY2</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t14EFUSE_BLK_KEY2E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of eFuse block. Uses for the purpose of the user. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t17EFUSE_BLK_KEY_MAXE">
<span id="_CPPv3N17esp_efuse_block_t17EFUSE_BLK_KEY_MAXE"></span><span id="_CPPv2N17esp_efuse_block_t17EFUSE_BLK_KEY_MAXE"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044a4816102363f861e0968e1fbeab5d7d7c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK_KEY_MAX</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t17EFUSE_BLK_KEY_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17esp_efuse_block_t13EFUSE_BLK_MAXE">
<span id="_CPPv3N17esp_efuse_block_t13EFUSE_BLK_MAXE"></span><span id="_CPPv2N17esp_efuse_block_t13EFUSE_BLK_MAXE"></span><span class="target" id="esp__efuse__chip_8h_1af826e730fb92c4e1983aa2c8c97cd044a478dd5220b2b8644ba4959d9ce8fc267"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_BLK_MAX</span></span></span><a class="headerlink" href="#_CPPv4N17esp_efuse_block_t13EFUSE_BLK_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv425esp_efuse_coding_scheme_t">
<span id="_CPPv325esp_efuse_coding_scheme_t"></span><span id="_CPPv225esp_efuse_coding_scheme_t"></span><span class="target" id="esp__efuse__chip_8h_1a81136a9c93affb0bb96c2b9a5d3f1215"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_coding_scheme_t</span></span></span><a class="headerlink" href="#_CPPv425esp_efuse_coding_scheme_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of coding scheme. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N25esp_efuse_coding_scheme_t24EFUSE_CODING_SCHEME_NONEE">
<span id="_CPPv3N25esp_efuse_coding_scheme_t24EFUSE_CODING_SCHEME_NONEE"></span><span id="_CPPv2N25esp_efuse_coding_scheme_t24EFUSE_CODING_SCHEME_NONEE"></span><span class="target" id="esp__efuse__chip_8h_1a81136a9c93affb0bb96c2b9a5d3f1215a719483da2d8d64d21c972922fab92eca"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_CODING_SCHEME_NONE</span></span></span><a class="headerlink" href="#_CPPv4N25esp_efuse_coding_scheme_t24EFUSE_CODING_SCHEME_NONEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>None </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N25esp_efuse_coding_scheme_t23EFUSE_CODING_SCHEME_3_4E">
<span id="_CPPv3N25esp_efuse_coding_scheme_t23EFUSE_CODING_SCHEME_3_4E"></span><span id="_CPPv2N25esp_efuse_coding_scheme_t23EFUSE_CODING_SCHEME_3_4E"></span><span class="target" id="esp__efuse__chip_8h_1a81136a9c93affb0bb96c2b9a5d3f1215a67565b62a290739b284e6b24cdd625d4"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_CODING_SCHEME_3_4</span></span></span><a class="headerlink" href="#_CPPv4N25esp_efuse_coding_scheme_t23EFUSE_CODING_SCHEME_3_4E" title="Permalink to this definition"></a><br /></dt>
<dd><p>3/4 coding </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N25esp_efuse_coding_scheme_t26EFUSE_CODING_SCHEME_REPEATE">
<span id="_CPPv3N25esp_efuse_coding_scheme_t26EFUSE_CODING_SCHEME_REPEATE"></span><span id="_CPPv2N25esp_efuse_coding_scheme_t26EFUSE_CODING_SCHEME_REPEATE"></span><span class="target" id="esp__efuse__chip_8h_1a81136a9c93affb0bb96c2b9a5d3f1215a04f947abdbeeaa84858c9252f650ecbc"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">EFUSE_CODING_SCHEME_REPEAT</span></span></span><a class="headerlink" href="#_CPPv4N25esp_efuse_coding_scheme_t26EFUSE_CODING_SCHEME_REPEATE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Repeat coding </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv419esp_efuse_purpose_t">
<span id="_CPPv319esp_efuse_purpose_t"></span><span id="_CPPv219esp_efuse_purpose_t"></span><span class="target" id="esp__efuse__chip_8h_1a2d3c747be6a4c94e6093a74b6cb38b2b"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_purpose_t</span></span></span><a class="headerlink" href="#_CPPv419esp_efuse_purpose_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of key purpose (virtual because ESP32 has only fixed purposes for blocks) </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19esp_efuse_purpose_t26ESP_EFUSE_KEY_PURPOSE_USERE">
<span id="_CPPv3N19esp_efuse_purpose_t26ESP_EFUSE_KEY_PURPOSE_USERE"></span><span id="_CPPv2N19esp_efuse_purpose_t26ESP_EFUSE_KEY_PURPOSE_USERE"></span><span class="target" id="esp__efuse__chip_8h_1a2d3c747be6a4c94e6093a74b6cb38b2ba522864ebb1be10cbe07fcdb8d82b2cef"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ESP_EFUSE_KEY_PURPOSE_USER</span></span></span><a class="headerlink" href="#_CPPv4N19esp_efuse_purpose_t26ESP_EFUSE_KEY_PURPOSE_USERE" title="Permalink to this definition"></a><br /></dt>
<dd><p>BLOCK3 </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19esp_efuse_purpose_t28ESP_EFUSE_KEY_PURPOSE_SYSTEME">
<span id="_CPPv3N19esp_efuse_purpose_t28ESP_EFUSE_KEY_PURPOSE_SYSTEME"></span><span id="_CPPv2N19esp_efuse_purpose_t28ESP_EFUSE_KEY_PURPOSE_SYSTEME"></span><span class="target" id="esp__efuse__chip_8h_1a2d3c747be6a4c94e6093a74b6cb38b2ba90a171128849d954a329feb445812c76"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ESP_EFUSE_KEY_PURPOSE_SYSTEM</span></span></span><a class="headerlink" href="#_CPPv4N19esp_efuse_purpose_t28ESP_EFUSE_KEY_PURPOSE_SYSTEME" title="Permalink to this definition"></a><br /></dt>
<dd><p>BLOCK0 </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19esp_efuse_purpose_t38ESP_EFUSE_KEY_PURPOSE_FLASH_ENCRYPTIONE">
<span id="_CPPv3N19esp_efuse_purpose_t38ESP_EFUSE_KEY_PURPOSE_FLASH_ENCRYPTIONE"></span><span id="_CPPv2N19esp_efuse_purpose_t38ESP_EFUSE_KEY_PURPOSE_FLASH_ENCRYPTIONE"></span><span class="target" id="esp__efuse__chip_8h_1a2d3c747be6a4c94e6093a74b6cb38b2bae7efda747a2fa19812afb1d73877763b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ESP_EFUSE_KEY_PURPOSE_FLASH_ENCRYPTION</span></span></span><a class="headerlink" href="#_CPPv4N19esp_efuse_purpose_t38ESP_EFUSE_KEY_PURPOSE_FLASH_ENCRYPTIONE" title="Permalink to this definition"></a><br /></dt>
<dd><p>BLOCK1 </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19esp_efuse_purpose_t36ESP_EFUSE_KEY_PURPOSE_SECURE_BOOT_V2E">
<span id="_CPPv3N19esp_efuse_purpose_t36ESP_EFUSE_KEY_PURPOSE_SECURE_BOOT_V2E"></span><span id="_CPPv2N19esp_efuse_purpose_t36ESP_EFUSE_KEY_PURPOSE_SECURE_BOOT_V2E"></span><span class="target" id="esp__efuse__chip_8h_1a2d3c747be6a4c94e6093a74b6cb38b2ba5d0c6e733841994cf9f782387ebda17e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ESP_EFUSE_KEY_PURPOSE_SECURE_BOOT_V2</span></span></span><a class="headerlink" href="#_CPPv4N19esp_efuse_purpose_t36ESP_EFUSE_KEY_PURPOSE_SECURE_BOOT_V2E" title="Permalink to this definition"></a><br /></dt>
<dd><p>BLOCK2 </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N19esp_efuse_purpose_t25ESP_EFUSE_KEY_PURPOSE_MAXE">
<span id="_CPPv3N19esp_efuse_purpose_t25ESP_EFUSE_KEY_PURPOSE_MAXE"></span><span id="_CPPv2N19esp_efuse_purpose_t25ESP_EFUSE_KEY_PURPOSE_MAXE"></span><span class="target" id="esp__efuse__chip_8h_1a2d3c747be6a4c94e6093a74b6cb38b2ba961f867ef0805fa91d0bab79bf191c42"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ESP_EFUSE_KEY_PURPOSE_MAX</span></span></span><a class="headerlink" href="#_CPPv4N19esp_efuse_purpose_t25ESP_EFUSE_KEY_PURPOSE_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd><p>MAX PURPOSE </p>
</dd></dl>

</dd></dl>

</section>
<section id="id5">
<h3>Header File<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/efuse/include/esp_efuse.h">components/efuse/include/esp_efuse.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_efuse.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">efuse</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">efuse</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES efuse
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES efuse
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425esp_efuse_read_field_blobA_PK16esp_efuse_desc_tPv6size_t">
<span id="_CPPv325esp_efuse_read_field_blobA_PK16esp_efuse_desc_tPv6size_t"></span><span id="_CPPv225esp_efuse_read_field_blobA_PK16esp_efuse_desc_tPv6size_t"></span><span id="esp_efuse_read_field_blob__esp_efuse_desc_tCPA.voidP.s"></span><span class="target" id="esp__efuse_8h_1ab35f098da6963a917045c0db4d018bdb"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_read_field_blob</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416esp_efuse_desc_t" title="esp_efuse_desc_t"><span class="n"><span class="pre">esp_efuse_desc_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">field</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dst</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dst_size_bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425esp_efuse_read_field_blobA_PK16esp_efuse_desc_tPv6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reads bits from EFUSE field and writes it into an array. </p>
<p>The number of read bits will be limited to the minimum value from the description of the bits in &quot;field&quot; structure or &quot;dst_size_bits&quot; required size. Use &quot;esp_efuse_get_field_size()&quot; function to determine the length of the field.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please note that reading in the batch mode does not show uncommitted changes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> -- <strong>[in]</strong> A pointer to the structure describing the fields of efuse. </p></li>
<li><p><strong>dst</strong> -- <strong>[out]</strong> A pointer to array that will contain the result of reading. </p></li>
<li><p><strong>dst_size_bits</strong> -- <strong>[in]</strong> The number of bits required to read. If the requested number of bits is greater than the field, the number will be limited to the field size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424esp_efuse_read_field_bitA_PK16esp_efuse_desc_t">
<span id="_CPPv324esp_efuse_read_field_bitA_PK16esp_efuse_desc_t"></span><span id="_CPPv224esp_efuse_read_field_bitA_PK16esp_efuse_desc_t"></span><span id="esp_efuse_read_field_bit__esp_efuse_desc_tCPA"></span><span class="target" id="esp__efuse_8h_1a3c2d609036cbe621b30bd425f48f30a5"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_read_field_bit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416esp_efuse_desc_t" title="esp_efuse_desc_t"><span class="n"><span class="pre">esp_efuse_desc_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">field</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424esp_efuse_read_field_bitA_PK16esp_efuse_desc_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Read a single bit eFuse field as a boolean value. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value must exist and must be a single bit wide. If there is any possibility of an error in the provided arguments, call esp_efuse_read_field_blob() and check the returned value instead.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If assertions are enabled and the parameter is invalid, execution will abort </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please note that reading in the batch mode does not show uncommitted changes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>field</strong> -- <strong>[in]</strong> A pointer to the structure describing the fields of efuse. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>true: The field parameter is valid and the bit is set.</p></li>
<li><p>false: The bit is not set, or the parameter is invalid and assertions are disabled. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424esp_efuse_read_field_cntA_PK16esp_efuse_desc_tP6size_t">
<span id="_CPPv324esp_efuse_read_field_cntA_PK16esp_efuse_desc_tP6size_t"></span><span id="_CPPv224esp_efuse_read_field_cntA_PK16esp_efuse_desc_tP6size_t"></span><span id="esp_efuse_read_field_cnt__esp_efuse_desc_tCPA.sP"></span><span class="target" id="esp__efuse_8h_1a65647081fd89b3e1c10cf1aaea3cc192"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_read_field_cnt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416esp_efuse_desc_t" title="esp_efuse_desc_t"><span class="n"><span class="pre">esp_efuse_desc_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">field</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_cnt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424esp_efuse_read_field_cntA_PK16esp_efuse_desc_tP6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reads bits from EFUSE field and returns number of bits programmed as &quot;1&quot;. </p>
<p>If the bits are set not sequentially, they will still be counted. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please note that reading in the batch mode does not show uncommitted changes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> -- <strong>[in]</strong> A pointer to the structure describing the fields of efuse. </p></li>
<li><p><strong>out_cnt</strong> -- <strong>[out]</strong> A pointer that will contain the number of programmed as &quot;1&quot; bits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426esp_efuse_write_field_blobA_PK16esp_efuse_desc_tPKv6size_t">
<span id="_CPPv326esp_efuse_write_field_blobA_PK16esp_efuse_desc_tPKv6size_t"></span><span id="_CPPv226esp_efuse_write_field_blobA_PK16esp_efuse_desc_tPKv6size_t"></span><span id="esp_efuse_write_field_blob__esp_efuse_desc_tCPA.voidCP.s"></span><span class="target" id="esp__efuse_8h_1a8a068ddea9cbd74986a27e9cf44097ff"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_write_field_blob</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416esp_efuse_desc_t" title="esp_efuse_desc_t"><span class="n"><span class="pre">esp_efuse_desc_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">field</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">src_size_bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426esp_efuse_write_field_blobA_PK16esp_efuse_desc_tPKv6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Writes array to EFUSE field. </p>
<p>The number of write bits will be limited to the minimum value from the description of the bits in &quot;field&quot; structure or &quot;src_size_bits&quot; required size. Use &quot;esp_efuse_get_field_size()&quot; function to determine the length of the field. After the function is completed, the writing registers are cleared. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> -- <strong>[in]</strong> A pointer to the structure describing the fields of efuse. </p></li>
<li><p><strong>src</strong> -- <strong>[in]</strong> A pointer to array that contains the data for writing. </p></li>
<li><p><strong>src_size_bits</strong> -- <strong>[in]</strong> The number of bits required to write.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.</p></li>
<li><p>ESP_ERR_CODING: Error range of data does not match the coding scheme. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425esp_efuse_write_field_cntA_PK16esp_efuse_desc_t6size_t">
<span id="_CPPv325esp_efuse_write_field_cntA_PK16esp_efuse_desc_t6size_t"></span><span id="_CPPv225esp_efuse_write_field_cntA_PK16esp_efuse_desc_t6size_t"></span><span id="esp_efuse_write_field_cnt__esp_efuse_desc_tCPA.s"></span><span class="target" id="esp__efuse_8h_1a8faaf20c7a791b90e106e632179c1294"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_write_field_cnt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416esp_efuse_desc_t" title="esp_efuse_desc_t"><span class="n"><span class="pre">esp_efuse_desc_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">field</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">cnt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425esp_efuse_write_field_cntA_PK16esp_efuse_desc_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Writes a required count of bits as &quot;1&quot; to EFUSE field. </p>
<p>If there are no free bits in the field to set the required number of bits to &quot;1&quot;, ESP_ERR_EFUSE_CNT_IS_FULL error is returned, the field will not be partially recorded. After the function is completed, the writing registers are cleared. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> -- <strong>[in]</strong> A pointer to the structure describing the fields of efuse. </p></li>
<li><p><strong>cnt</strong> -- <strong>[in]</strong> Required number of programmed as &quot;1&quot; bits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_EFUSE_CNT_IS_FULL: Not all requested cnt bits is set. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425esp_efuse_write_field_bitA_PK16esp_efuse_desc_t">
<span id="_CPPv325esp_efuse_write_field_bitA_PK16esp_efuse_desc_t"></span><span id="_CPPv225esp_efuse_write_field_bitA_PK16esp_efuse_desc_t"></span><span id="esp_efuse_write_field_bit__esp_efuse_desc_tCPA"></span><span class="target" id="esp__efuse_8h_1a6c415e6424e45e58ee93fba228301b88"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_write_field_bit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416esp_efuse_desc_t" title="esp_efuse_desc_t"><span class="n"><span class="pre">esp_efuse_desc_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">field</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425esp_efuse_write_field_bitA_PK16esp_efuse_desc_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Write a single bit eFuse field to 1. </p>
<p>For use with eFuse fields that are a single bit. This function will write the bit to value 1 if it is not already set, or does nothing if the bit is already set.</p>
<p>This is equivalent to calling esp_efuse_write_field_cnt() with the cnt parameter equal to 1, except that it will return ESP_OK if the field is already set to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>field</strong> -- <strong>[in]</strong> Pointer to the structure describing the efuse field.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed, or the bit was already set to value 1.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arugments, including if the efuse field is not 1 bit wide. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427esp_efuse_set_write_protect17esp_efuse_block_t">
<span id="_CPPv327esp_efuse_set_write_protect17esp_efuse_block_t"></span><span id="_CPPv227esp_efuse_set_write_protect17esp_efuse_block_t"></span><span id="esp_efuse_set_write_protect__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1a7b12ebd1b6ae334e22538e6878182058"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_set_write_protect</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">blk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427esp_efuse_set_write_protect17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sets a write protection for the whole block. </p>
<p>After that, it is impossible to write to this block. The write protection does not apply to block 0. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>blk</strong> -- <strong>[in]</strong> Block number of eFuse. (EFUSE_BLK1, EFUSE_BLK2 and EFUSE_BLK3)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_EFUSE_CNT_IS_FULL: Not all requested cnt bits is set.</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED: The block does not support this command. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426esp_efuse_set_read_protect17esp_efuse_block_t">
<span id="_CPPv326esp_efuse_set_read_protect17esp_efuse_block_t"></span><span id="_CPPv226esp_efuse_set_read_protect17esp_efuse_block_t"></span><span id="esp_efuse_set_read_protect__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1acc58dbcb97926797a2b9c5bf148fe193"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_set_read_protect</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">blk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426esp_efuse_set_read_protect17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sets a read protection for the whole block. </p>
<p>After that, it is impossible to read from this block. The read protection does not apply to block 0. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>blk</strong> -- <strong>[in]</strong> Block number of eFuse. (EFUSE_BLK1, EFUSE_BLK2 and EFUSE_BLK3)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_EFUSE_CNT_IS_FULL: Not all requested cnt bits is set.</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED: The block does not support this command. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424esp_efuse_get_field_sizeA_PK16esp_efuse_desc_t">
<span id="_CPPv324esp_efuse_get_field_sizeA_PK16esp_efuse_desc_t"></span><span id="_CPPv224esp_efuse_get_field_sizeA_PK16esp_efuse_desc_t"></span><span id="esp_efuse_get_field_size__esp_efuse_desc_tCPA"></span><span class="target" id="esp__efuse_8h_1a8f4c68b8300425e1eca3bc1f622411e5"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_get_field_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416esp_efuse_desc_t" title="esp_efuse_desc_t"><span class="n"><span class="pre">esp_efuse_desc_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">field</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424esp_efuse_get_field_sizeA_PK16esp_efuse_desc_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the number of bits used by field. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>field</strong> -- <strong>[in]</strong> A pointer to the structure describing the fields of efuse.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns the number of bits used by field. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418esp_efuse_read_reg17esp_efuse_block_tj">
<span id="_CPPv318esp_efuse_read_reg17esp_efuse_block_tj"></span><span id="_CPPv218esp_efuse_read_reg17esp_efuse_block_tj"></span><span id="esp_efuse_read_reg__esp_efuse_block_t.unsigned-i"></span><span class="target" id="esp__efuse_8h_1a2b6771b7fc03db678a6a0cd46dd978e7"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_read_reg</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">blk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_reg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418esp_efuse_read_reg17esp_efuse_block_tj" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns value of efuse register. </p>
<p>This is a thread-safe implementation. Example: EFUSE_BLK2_RDATA3_REG where (blk=2, num_reg=3) </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please note that reading in the batch mode does not show uncommitted changes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>blk</strong> -- <strong>[in]</strong> Block number of eFuse. </p></li>
<li><p><strong>num_reg</strong> -- <strong>[in]</strong> The register number in the block.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Value of register </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419esp_efuse_write_reg17esp_efuse_block_tj8uint32_t">
<span id="_CPPv319esp_efuse_write_reg17esp_efuse_block_tj8uint32_t"></span><span id="_CPPv219esp_efuse_write_reg17esp_efuse_block_tj8uint32_t"></span><span id="esp_efuse_write_reg__esp_efuse_block_t.unsigned-i.uint32_t"></span><span class="target" id="esp__efuse_8h_1a7d7248578c5f9178306f8e064aebac68"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_write_reg</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">blk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_reg</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">val</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419esp_efuse_write_reg17esp_efuse_block_tj8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Write value to efuse register. </p>
<p>Apply a coding scheme if necessary. This is a thread-safe implementation. Example: EFUSE_BLK3_WDATA0_REG where (blk=3, num_reg=0) </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>blk</strong> -- <strong>[in]</strong> Block number of eFuse. </p></li>
<li><p><strong>num_reg</strong> -- <strong>[in]</strong> The register number in the block. </p></li>
<li><p><strong>val</strong> -- <strong>[in]</strong> Value to write.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed.</p></li>
<li><p>ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427esp_efuse_get_coding_scheme17esp_efuse_block_t">
<span id="_CPPv327esp_efuse_get_coding_scheme17esp_efuse_block_t"></span><span id="_CPPv227esp_efuse_get_coding_scheme17esp_efuse_block_t"></span><span id="esp_efuse_get_coding_scheme__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1a880f60da0aef1b711f3908f67ae47f48"></span><a class="reference internal" href="#_CPPv425esp_efuse_coding_scheme_t" title="esp_efuse_coding_scheme_t"><span class="n"><span class="pre">esp_efuse_coding_scheme_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_get_coding_scheme</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">blk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427esp_efuse_get_coding_scheme17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return efuse coding scheme for blocks. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The coding scheme is applicable only to 1, 2 and 3 blocks. For 0 block, the coding scheme is always <code class="docutils literal notranslate"><span class="pre">NONE</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>blk</strong> -- <strong>[in]</strong> Block number of eFuse. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Return efuse coding scheme for blocks </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420esp_efuse_read_block17esp_efuse_block_tPv6size_t6size_t">
<span id="_CPPv320esp_efuse_read_block17esp_efuse_block_tPv6size_t6size_t"></span><span id="_CPPv220esp_efuse_read_block17esp_efuse_block_tPv6size_t6size_t"></span><span id="esp_efuse_read_block__esp_efuse_block_t.voidP.s.s"></span><span class="target" id="esp__efuse_8h_1ac003d476b16051af8f9b181fef4533e1"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_read_block</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">blk</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dst_key</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">offset_in_bits</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">size_bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420esp_efuse_read_block17esp_efuse_block_tPv6size_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Read key to efuse block starting at the offset and the required size. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please note that reading in the batch mode does not show uncommitted changes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>blk</strong> -- <strong>[in]</strong> Block number of eFuse. </p></li>
<li><p><strong>dst_key</strong> -- <strong>[in]</strong> A pointer to array that will contain the result of reading. </p></li>
<li><p><strong>offset_in_bits</strong> -- <strong>[in]</strong> Start bit in block. </p></li>
<li><p><strong>size_bits</strong> -- <strong>[in]</strong> The number of bits required to read.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_CODING: Error range of data does not match the coding scheme. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421esp_efuse_write_block17esp_efuse_block_tPKv6size_t6size_t">
<span id="_CPPv321esp_efuse_write_block17esp_efuse_block_tPKv6size_t6size_t"></span><span id="_CPPv221esp_efuse_write_block17esp_efuse_block_tPKv6size_t6size_t"></span><span id="esp_efuse_write_block__esp_efuse_block_t.voidCP.s.s"></span><span class="target" id="esp__efuse_8h_1afe7789e02aab4db9b5f7132ac093aea5"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_write_block</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">blk</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">src_key</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">offset_in_bits</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">size_bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421esp_efuse_write_block17esp_efuse_block_tPKv6size_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Write key to efuse block starting at the offset and the required size. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>blk</strong> -- <strong>[in]</strong> Block number of eFuse. </p></li>
<li><p><strong>src_key</strong> -- <strong>[in]</strong> A pointer to array that contains the key for writing. </p></li>
<li><p><strong>offset_in_bits</strong> -- <strong>[in]</strong> Start bit in block. </p></li>
<li><p><strong>size_bits</strong> -- <strong>[in]</strong> The number of bits required to write.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: The operation was successfully completed.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_CODING: Error range of data does not match the coding scheme.</p></li>
<li><p>ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421esp_efuse_get_pkg_verv">
<span id="_CPPv321esp_efuse_get_pkg_verv"></span><span id="_CPPv221esp_efuse_get_pkg_verv"></span><span id="esp_efuse_get_pkg_ver__void"></span><span class="target" id="esp__efuse_8h_1afa52f4f1e15eac6c3d0f109505d97a77"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_get_pkg_ver</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421esp_efuse_get_pkg_verv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns chip package from efuse. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>chip package </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415esp_efuse_resetv">
<span id="_CPPv315esp_efuse_resetv"></span><span id="_CPPv215esp_efuse_resetv"></span><span id="esp_efuse_reset__void"></span><span class="target" id="esp__efuse_8h_1ae255a8b5da57ffa295f27460a95050f1"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_reset</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415esp_efuse_resetv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reset efuse write registers. </p>
<p>Efuse write registers are written to zero, to negate any changes that have been staged here.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is not threadsafe, if calling code updates efuse values from multiple tasks then this is caller's responsibility to serialise. </p>
</div>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv435esp_efuse_disable_basic_rom_consolev">
<span id="_CPPv335esp_efuse_disable_basic_rom_consolev"></span><span id="_CPPv235esp_efuse_disable_basic_rom_consolev"></span><span id="esp_efuse_disable_basic_rom_console__void"></span><span class="target" id="esp__efuse_8h_1a2f9ad85c162139719fdd789f261eb12d"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_disable_basic_rom_console</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435esp_efuse_disable_basic_rom_consolev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Disable BASIC ROM Console via efuse. </p>
<p>By default, if booting from flash fails the ESP32 will boot a BASIC console in ROM.</p>
<p>Call this function (from bootloader or app) to permanently disable the console on this chip. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv435esp_efuse_disable_rom_download_modev">
<span id="_CPPv335esp_efuse_disable_rom_download_modev"></span><span id="_CPPv235esp_efuse_disable_rom_download_modev"></span><span id="esp_efuse_disable_rom_download_mode__void"></span><span class="target" id="esp__efuse_8h_1a1bf7f9fe8a381a73dc34e7fa0bc29e1c"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_disable_rom_download_mode</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435esp_efuse_disable_rom_download_modev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Disable ROM Download Mode via eFuse. </p>
<p>Permanently disables the ROM Download Mode feature. Once disabled, if the SoC is booted with strapping pins set for ROM Download Mode then an error is printed instead.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not all SoCs support this option. An error will be returned if called on an ESP32 with a silicon revision lower than 3, as these revisions do not support this option.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If ROM Download Mode is already disabled, this function does nothing and returns success.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_OK If the eFuse was successfully burned, or had already been burned.</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED (ESP32 only) This SoC is not capable of disabling UART download mode</p></li>
<li><p>ESP_ERR_INVALID_STATE (ESP32 only) This eFuse is write protected and cannot be written </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428esp_efuse_set_rom_log_scheme26esp_efuse_rom_log_scheme_t">
<span id="_CPPv328esp_efuse_set_rom_log_scheme26esp_efuse_rom_log_scheme_t"></span><span id="_CPPv228esp_efuse_set_rom_log_scheme26esp_efuse_rom_log_scheme_t"></span><span id="esp_efuse_set_rom_log_scheme__esp_efuse_rom_log_scheme_t"></span><span class="target" id="esp__efuse_8h_1a4e04d974196ee66bc5a3322961a3e7f2"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_set_rom_log_scheme</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv426esp_efuse_rom_log_scheme_t" title="esp_efuse_rom_log_scheme_t"><span class="n"><span class="pre">esp_efuse_rom_log_scheme_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">log_scheme</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428esp_efuse_set_rom_log_scheme26esp_efuse_rom_log_scheme_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set boot ROM log scheme via eFuse. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By default, the boot ROM will always print to console. This API can be called to set the log scheme only once per chip, once the value is changed from the default it can't be changed again.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>log_scheme</strong> -- Supported ROM log scheme </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK If the eFuse was successfully burned, or had already been burned.</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED (ESP32 only) This SoC is not capable of setting ROM log scheme</p></li>
<li><p>ESP_ERR_INVALID_STATE This eFuse is write protected or has been burned already </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429esp_efuse_read_secure_versionv">
<span id="_CPPv329esp_efuse_read_secure_versionv"></span><span id="_CPPv229esp_efuse_read_secure_versionv"></span><span id="esp_efuse_read_secure_version__void"></span><span class="target" id="esp__efuse_8h_1a31852749e81ef58b42cafa977fa6fb2f"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_read_secure_version</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429esp_efuse_read_secure_versionv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return secure_version from efuse field. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Secure version from efuse field </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430esp_efuse_check_secure_version8uint32_t">
<span id="_CPPv330esp_efuse_check_secure_version8uint32_t"></span><span id="_CPPv230esp_efuse_check_secure_version8uint32_t"></span><span id="esp_efuse_check_secure_version__uint32_t"></span><span class="target" id="esp__efuse_8h_1aca752c5d18d7bf69a0181169d4994643"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_check_secure_version</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">secure_version</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430esp_efuse_check_secure_version8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check secure_version from app and secure_version and from efuse field. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>secure_version</strong> -- Secure version from app. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>True: If version of app is equal or more then secure_version from efuse. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431esp_efuse_update_secure_version8uint32_t">
<span id="_CPPv331esp_efuse_update_secure_version8uint32_t"></span><span id="_CPPv231esp_efuse_update_secure_version8uint32_t"></span><span id="esp_efuse_update_secure_version__uint32_t"></span><span class="target" id="esp__efuse_8h_1a3b29f67252c3e50978f77a5a8201976c"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_update_secure_version</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">secure_version</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431esp_efuse_update_secure_version8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Write efuse field by secure_version value. </p>
<p>Update the secure_version value is available if the coding scheme is None. Note: Do not use this function in your applications. This function is called as part of the other API.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>secure_version</strong> -- <strong>[in]</strong> Secure version from app. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Successful.</p></li>
<li><p>ESP_FAIL: secure version of app cannot be set to efuse field.</p></li>
<li><p>ESP_ERR_NOT_SUPPORTED: Anti rollback is not supported with the 3/4 and Repeat coding scheme. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427esp_efuse_batch_write_beginv">
<span id="_CPPv327esp_efuse_batch_write_beginv"></span><span id="_CPPv227esp_efuse_batch_write_beginv"></span><span id="esp_efuse_batch_write_begin__void"></span><span class="target" id="esp__efuse_8h_1aa89ab9ca7102181a603729bdc3c624c4"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_batch_write_begin</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427esp_efuse_batch_write_beginv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set the batch mode of writing fields. </p>
<p>This mode allows you to write the fields in the batch mode when need to burn several efuses at one time. To enable batch mode call begin() then perform as usually the necessary operations read and write and at the end call commit() to actually burn all written efuses. The batch mode can be used nested. The commit will be done by the last commit() function. The number of begin() functions should be equal to the number of commit() functions.</p>
<p>
Note: If batch mode is enabled by the first task, at this time the second task cannot write/read efuses. The second task will wait for the first task to complete the batch operation.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of using the batch writing mode.</span>

<span class="c1">// set the batch writing mode</span>
<span class="n">esp_efuse_batch_write_begin</span><span class="p">();</span>

<span class="c1">// use any writing functions as usual</span>
<span class="n">esp_efuse_write_field_blob</span><span class="p">(</span><span class="n">ESP_EFUSE_</span><span class="p">...);</span>
<span class="n">esp_efuse_write_field_cnt</span><span class="p">(</span><span class="n">ESP_EFUSE_</span><span class="p">...);</span>
<span class="n">esp_efuse_set_write_protect</span><span class="p">(</span><span class="n">EFUSE_BLKx</span><span class="p">);</span>
<span class="n">esp_efuse_write_reg</span><span class="p">(</span><span class="n">EFUSE_BLKx</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="n">esp_efuse_write_block</span><span class="p">(</span><span class="n">EFUSE_BLKx</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="n">esp_efuse_write</span><span class="p">(</span><span class="n">ESP_EFUSE_1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">  </span><span class="c1">// ESP_EFUSE_1 == 1, here we write a new value = 3. The changes will be burn by the commit() function.</span>
<span class="n">esp_efuse_read_</span><span class="p">...(</span><span class="n">ESP_EFUSE_1</span><span class="p">);</span><span class="w">  </span><span class="c1">// this function returns ESP_EFUSE_1 == 1 because uncommitted changes are not readable, it will be available only after commit.</span>
<span class="p">...</span>

<span class="c1">// esp_efuse_batch_write APIs can be called recursively.</span>
<span class="n">esp_efuse_batch_write_begin</span><span class="p">();</span>
<span class="n">esp_efuse_set_write_protect</span><span class="p">(</span><span class="n">EFUSE_BLKx</span><span class="p">);</span>
<span class="n">esp_efuse_batch_write_commit</span><span class="p">();</span><span class="w"> </span><span class="c1">// the burn will be skipped here, it will be done in the last commit().</span>

<span class="p">...</span>

<span class="c1">// Write all of these fields to the efuse registers</span>
<span class="n">esp_efuse_batch_write_commit</span><span class="p">();</span>
<span class="n">esp_efuse_read_</span><span class="p">...(</span><span class="n">ESP_EFUSE_1</span><span class="p">);</span><span class="w">  </span><span class="c1">// this function returns ESP_EFUSE_1 == 3.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please note that reading in the batch mode does not show uncommitted changes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_OK: Successful. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428esp_efuse_batch_write_cancelv">
<span id="_CPPv328esp_efuse_batch_write_cancelv"></span><span id="_CPPv228esp_efuse_batch_write_cancelv"></span><span id="esp_efuse_batch_write_cancel__void"></span><span class="target" id="esp__efuse_8h_1accf5d790230366e1b0245b665d2dff00"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_batch_write_cancel</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428esp_efuse_batch_write_cancelv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reset the batch mode of writing fields. </p>
<p>It will reset the batch writing mode and any written changes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_OK: Successful.</p></li>
<li><p>ESP_ERR_INVALID_STATE: Tha batch mode was not set. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428esp_efuse_batch_write_commitv">
<span id="_CPPv328esp_efuse_batch_write_commitv"></span><span id="_CPPv228esp_efuse_batch_write_commitv"></span><span id="esp_efuse_batch_write_commit__void"></span><span class="target" id="esp__efuse_8h_1a663d6623253d8b03976967372311303d"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_batch_write_commit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428esp_efuse_batch_write_commitv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Writes all prepared data for the batch mode. </p>
<p>Must be called to ensure changes are written to the efuse registers. After this the batch writing mode will be reset.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_OK: Successful.</p></li>
<li><p>ESP_ERR_INVALID_STATE: The deferred writing mode was not set. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424esp_efuse_block_is_empty17esp_efuse_block_t">
<span id="_CPPv324esp_efuse_block_is_empty17esp_efuse_block_t"></span><span id="_CPPv224esp_efuse_block_is_empty17esp_efuse_block_t"></span><span id="esp_efuse_block_is_empty__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1a61a200cda2cd04911b8b23fbea0212b6"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_block_is_empty</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424esp_efuse_block_is_empty17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Checks that the given block is empty. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>True: The block is empty.</p></li>
<li><p>False: The block is not empty or was an error. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426esp_efuse_get_key_dis_read17esp_efuse_block_t">
<span id="_CPPv326esp_efuse_get_key_dis_read17esp_efuse_block_t"></span><span id="_CPPv226esp_efuse_get_key_dis_read17esp_efuse_block_t"></span><span id="esp_efuse_get_key_dis_read__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1ae5ca913f6f89bf1068be939f6bd785e4"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_get_key_dis_read</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426esp_efuse_get_key_dis_read17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns a read protection for the key block. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>block</strong> -- <strong>[in]</strong> A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True: The key block is read protected False: The key block is readable. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426esp_efuse_set_key_dis_read17esp_efuse_block_t">
<span id="_CPPv326esp_efuse_set_key_dis_read17esp_efuse_block_t"></span><span id="_CPPv226esp_efuse_set_key_dis_read17esp_efuse_block_t"></span><span id="esp_efuse_set_key_dis_read__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1a59c3f08a9affbc8bb3c319db81338011"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_set_key_dis_read</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426esp_efuse_set_key_dis_read17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sets a read protection for the key block. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>block</strong> -- <strong>[in]</strong> A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Successful.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.</p></li>
<li><p>ESP_ERR_CODING: Error range of data does not match the coding scheme. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427esp_efuse_get_key_dis_write17esp_efuse_block_t">
<span id="_CPPv327esp_efuse_get_key_dis_write17esp_efuse_block_t"></span><span id="_CPPv227esp_efuse_get_key_dis_write17esp_efuse_block_t"></span><span id="esp_efuse_get_key_dis_write__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1a4ba26c34c363bdb8ec8bdd0509bae993"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_get_key_dis_write</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427esp_efuse_get_key_dis_write17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns a write protection for the key block. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>block</strong> -- <strong>[in]</strong> A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True: The key block is write protected False: The key block is writeable. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427esp_efuse_set_key_dis_write17esp_efuse_block_t">
<span id="_CPPv327esp_efuse_set_key_dis_write17esp_efuse_block_t"></span><span id="_CPPv227esp_efuse_set_key_dis_write17esp_efuse_block_t"></span><span id="esp_efuse_set_key_dis_write__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1a6e5dbe3f4197b431184000496fdeaf9a"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_set_key_dis_write</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427esp_efuse_set_key_dis_write17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sets a write protection for the key block. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>block</strong> -- <strong>[in]</strong> A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Successful.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.</p></li>
<li><p>ESP_ERR_CODING: Error range of data does not match the coding scheme. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426esp_efuse_key_block_unused17esp_efuse_block_t">
<span id="_CPPv326esp_efuse_key_block_unused17esp_efuse_block_t"></span><span id="_CPPv226esp_efuse_key_block_unused17esp_efuse_block_t"></span><span id="esp_efuse_key_block_unused__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1a91ba8feb415b034e74e200c4308dbbc9"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_key_block_unused</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426esp_efuse_key_block_unused17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns true if the key block is unused, false otherwise. </p>
<p>An unused key block is all zero content, not read or write protected, and has purpose 0 (ESP_EFUSE_KEY_PURPOSE_USER)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>block</strong> -- key block to check.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>True if key block is unused,</p></li>
<li><p>False if key block is used or the specified block index is not a key block. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422esp_efuse_find_purpose19esp_efuse_purpose_tP17esp_efuse_block_t">
<span id="_CPPv322esp_efuse_find_purpose19esp_efuse_purpose_tP17esp_efuse_block_t"></span><span id="_CPPv222esp_efuse_find_purpose19esp_efuse_purpose_tP17esp_efuse_block_t"></span><span id="esp_efuse_find_purpose__esp_efuse_purpose_t.esp_efuse_block_tP"></span><span class="target" id="esp__efuse_8h_1a8eb1cc5db2928000d4b9413e3deffea0"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_find_purpose</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419esp_efuse_purpose_t" title="esp_efuse_purpose_t"><span class="n"><span class="pre">esp_efuse_purpose_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">purpose</span></span>, <a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422esp_efuse_find_purpose19esp_efuse_purpose_tP17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Find a key block with the particular purpose set. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>purpose</strong> -- <strong>[in]</strong> Purpose to search for. </p></li>
<li><p><strong>block</strong> -- <strong>[out]</strong> Pointer in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX which will be set to the key block if found. Can be NULL, if only need to test the key block exists.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>True: If found,</p></li>
<li><p>False: If not found (value at block pointer is unchanged). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv434esp_efuse_get_keypurpose_dis_write17esp_efuse_block_t">
<span id="_CPPv334esp_efuse_get_keypurpose_dis_write17esp_efuse_block_t"></span><span id="_CPPv234esp_efuse_get_keypurpose_dis_write17esp_efuse_block_t"></span><span id="esp_efuse_get_keypurpose_dis_write__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1afa1976aba982cd775e00e27a61d620c2"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_get_keypurpose_dis_write</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434esp_efuse_get_keypurpose_dis_write17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns a write protection of the key purpose field for an efuse key block. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For ESP32: no keypurpose, it returns always True.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>block</strong> -- <strong>[in]</strong> A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True: The key purpose is write protected. False: The key purpose is writeable. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425esp_efuse_get_key_purpose17esp_efuse_block_t">
<span id="_CPPv325esp_efuse_get_key_purpose17esp_efuse_block_t"></span><span id="_CPPv225esp_efuse_get_key_purpose17esp_efuse_block_t"></span><span id="esp_efuse_get_key_purpose__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1a83abb9d056f9e9f37b22040d1e2d9b2f"></span><a class="reference internal" href="#_CPPv419esp_efuse_purpose_t" title="esp_efuse_purpose_t"><span class="n"><span class="pre">esp_efuse_purpose_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_get_key_purpose</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425esp_efuse_get_key_purpose17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the current purpose set for an efuse key block. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>block</strong> -- <strong>[in]</strong> A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>Value: If Successful, it returns the value of the purpose related to the given key block.</p></li>
<li><p>ESP_EFUSE_KEY_PURPOSE_MAX: Otherwise. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419esp_efuse_write_key17esp_efuse_block_t19esp_efuse_purpose_tPKv6size_t">
<span id="_CPPv319esp_efuse_write_key17esp_efuse_block_t19esp_efuse_purpose_tPKv6size_t"></span><span id="_CPPv219esp_efuse_write_key17esp_efuse_block_t19esp_efuse_purpose_tPKv6size_t"></span><span id="esp_efuse_write_key__esp_efuse_block_t.esp_efuse_purpose_t.voidCP.s"></span><span class="target" id="esp__efuse_8h_1ad5d3a18464ed549ba571ae180ba9f2de"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_write_key</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span>, <a class="reference internal" href="#_CPPv419esp_efuse_purpose_t" title="esp_efuse_purpose_t"><span class="n"><span class="pre">esp_efuse_purpose_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">purpose</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">key_size_bytes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419esp_efuse_write_key17esp_efuse_block_t19esp_efuse_purpose_tPKv6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Program a block of key data to an efuse block. </p>
<p>The burn of a key, protection bits, and a purpose happens in batch mode.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This API also enables the read protection efuse bit for certain key blocks like XTS-AES, HMAC, ECDSA etc. This ensures that the key is only accessible to hardware peripheral.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For SoC's with capability <code class="docutils literal notranslate"><span class="pre">SOC_EFUSE_ECDSA_USE_HARDWARE_K</span></code> (e.g., ESP32-H2), this API writes an additional efuse bit for ECDSA key purpose to enforce hardware TRNG generated k mode in the peripheral.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>block</strong> -- <strong>[in]</strong> Block to read purpose for. Must be in range EFUSE_BLK_KEY0 to EFUSE_BLK_KEY_MAX. Key block must be unused (esp_efuse_key_block_unused). </p></li>
<li><p><strong>purpose</strong> -- <strong>[in]</strong> Purpose to set for this key. Purpose must be already unset. </p></li>
<li><p><strong>key</strong> -- <strong>[in]</strong> Pointer to data to write. </p></li>
<li><p><strong>key_size_bytes</strong> -- <strong>[in]</strong> Bytes length of data to write.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Successful.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_INVALID_STATE: Error in efuses state, unused block not found.</p></li>
<li><p>ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.</p></li>
<li><p>ESP_ERR_CODING: Error range of data does not match the coding scheme. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420esp_efuse_write_keysA_K19esp_efuse_purpose_tA_AL32E_7uint8_tj">
<span id="_CPPv320esp_efuse_write_keysA_K19esp_efuse_purpose_tA_AL32E_7uint8_tj"></span><span id="_CPPv220esp_efuse_write_keysA_K19esp_efuse_purpose_tA_A32_7uint8_tj"></span><span id="esp_efuse_write_keys__esp_efuse_purpose_tCA.uint8_tAA.unsigned"></span><span class="target" id="esp__efuse_8h_1ac2ad2f61627b85af0f5c75a0405ecf38"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_write_keys</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv419esp_efuse_purpose_t" title="esp_efuse_purpose_t"><span class="n"><span class="pre">esp_efuse_purpose_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">purposes</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">keys</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">32</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">number_of_keys</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420esp_efuse_write_keysA_K19esp_efuse_purpose_tA_AL32E_7uint8_tj" title="Permalink to this definition"></a><br /></dt>
<dd><p>Program keys to unused efuse blocks. </p>
<p>The burn of keys, protection bits, and purposes happens in batch mode.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This API also enables the read protection efuse bit for certain key blocks like XTS-AES, HMAC, ECDSA etc. This ensures that the key is only accessible to hardware peripheral.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For SoC's with capability <code class="docutils literal notranslate"><span class="pre">SOC_EFUSE_ECDSA_USE_HARDWARE_K</span></code> (e.g., ESP32-H2), this API writes an additional efuse bit for ECDSA key purpose to enforce hardware TRNG generated k mode in the peripheral.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>purposes</strong> -- <strong>[in]</strong> Array of purposes (purpose[number_of_keys]). </p></li>
<li><p><strong>keys</strong> -- <strong>[in]</strong> Array of keys (uint8_t keys[number_of_keys][32]). Each key is 32 bytes long. </p></li>
<li><p><strong>number_of_keys</strong> -- <strong>[in]</strong> The number of keys to write (up to 6 keys).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Successful.</p></li>
<li><p>ESP_ERR_INVALID_ARG: Error in the passed arguments.</p></li>
<li><p>ESP_ERR_INVALID_STATE: Error in efuses state, unused block not found.</p></li>
<li><p>ESP_ERR_NOT_ENOUGH_UNUSED_KEY_BLOCKS: Error not enough unused key blocks available</p></li>
<li><p>ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.</p></li>
<li><p>ESP_ERR_CODING: Error range of data does not match the coding scheme. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422esp_efuse_check_errorsv">
<span id="_CPPv322esp_efuse_check_errorsv"></span><span id="_CPPv222esp_efuse_check_errorsv"></span><span id="esp_efuse_check_errors__void"></span><span class="target" id="esp__efuse_8h_1aab9dbe7a901666ef25adc3d2ec7e4da3"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_check_errors</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422esp_efuse_check_errorsv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Checks eFuse errors in BLOCK0. </p>
<p>
It does a BLOCK0 check if eFuse EFUSE_ERR_RST_ENABLE is set. If BLOCK0 has an error, it prints the error and returns ESP_FAIL, which should be treated as esp_restart.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Refers to ESP32-C3 only.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_OK: No errors in BLOCK0.</p></li>
<li><p>ESP_FAIL: Error in BLOCK0 requiring reboot. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423esp_efuse_destroy_block17esp_efuse_block_t">
<span id="_CPPv323esp_efuse_destroy_block17esp_efuse_block_t"></span><span id="_CPPv223esp_efuse_destroy_block17esp_efuse_block_t"></span><span id="esp_efuse_destroy_block__esp_efuse_block_t"></span><span class="target" id="esp__efuse_8h_1a20c303d83ba82fdf507d3fc4ec2fd0a7"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_destroy_block</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423esp_efuse_destroy_block17esp_efuse_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Destroys the data in the given efuse block, if possible. </p>
<p>Data destruction occurs through the following steps: 1) Destroy data in the block:<ul class="simple">
<li><p>If write protection is inactive for the block, then unset bits are burned.</p></li>
<li><p>If write protection is active, the block remains unaltered. 2) Set read protection for the block if possible (check write-protection for RD_DIS). In this case, data becomes inaccessible, and the software reads it as all zeros. If write protection is enabled and read protection can not be set, data in the block remains readable (returns an error).</p></li>
</ul>
</p>
<p>Do not use the batch mode with this function as it does the burning itself!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>block</strong> -- <strong>[in]</strong> A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Successful.</p></li>
<li><p>ESP_FAIL: Data remained readable because the block is write-protected and read protection can not be set. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv416esp_efuse_desc_t">
<span id="_CPPv316esp_efuse_desc_t"></span><span id="_CPPv216esp_efuse_desc_t"></span><span id="esp_efuse_desc_t"></span><span class="target" id="structesp__efuse__desc__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_desc_t</span></span></span><a class="headerlink" href="#_CPPv416esp_efuse_desc_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type definition for an eFuse field. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16esp_efuse_desc_t11efuse_blockE">
<span id="_CPPv3N16esp_efuse_desc_t11efuse_blockE"></span><span id="_CPPv2N16esp_efuse_desc_t11efuse_blockE"></span><span id="esp_efuse_desc_t::efuse_block__esp_efuse_block_t"></span><span class="target" id="structesp__efuse__desc__t_1ab2479dfecbb7b103f2d339f038d1af77"></span><a class="reference internal" href="#_CPPv417esp_efuse_block_t" title="esp_efuse_block_t"><span class="n"><span class="pre">esp_efuse_block_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">efuse_block</span></span></span><a class="headerlink" href="#_CPPv4N16esp_efuse_desc_t11efuse_blockE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Block of eFuse </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16esp_efuse_desc_t9bit_startE">
<span id="_CPPv3N16esp_efuse_desc_t9bit_startE"></span><span id="_CPPv2N16esp_efuse_desc_t9bit_startE"></span><span id="esp_efuse_desc_t::bit_start__uint8_t"></span><span class="target" id="structesp__efuse__desc__t_1a864f09bd1526ea1bd253152d7a17cd63"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bit_start</span></span></span><a class="headerlink" href="#_CPPv4N16esp_efuse_desc_t9bit_startE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Start bit [0..255] </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16esp_efuse_desc_t9bit_countE">
<span id="_CPPv3N16esp_efuse_desc_t9bit_countE"></span><span id="_CPPv2N16esp_efuse_desc_t9bit_countE"></span><span id="esp_efuse_desc_t::bit_count__uint16_t"></span><span class="target" id="structesp__efuse__desc__t_1ac5756900c15e0cbe25f06aaa91fdeffe"></span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bit_count</span></span></span><a class="headerlink" href="#_CPPv4N16esp_efuse_desc_t9bit_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Length of bit field [1..-] </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_EFUSE">
<span class="target" id="esp__efuse_8h_1ab2ba58b44c71baf2ce5bbc41825539cd"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_EFUSE</span></span></span><a class="headerlink" href="#c.ESP_ERR_EFUSE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Base error code for efuse api. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_OK_EFUSE_CNT">
<span class="target" id="esp__efuse_8h_1a6cf3e753a7e05e36076f74631d31aacd"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_OK_EFUSE_CNT</span></span></span><a class="headerlink" href="#c.ESP_OK_EFUSE_CNT" title="Permalink to this definition"></a><br /></dt>
<dd><p>OK the required number of bits is set. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_EFUSE_CNT_IS_FULL">
<span class="target" id="esp__efuse_8h_1a4d466033c1b81ef3de54b82f09721eba"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_EFUSE_CNT_IS_FULL</span></span></span><a class="headerlink" href="#c.ESP_ERR_EFUSE_CNT_IS_FULL" title="Permalink to this definition"></a><br /></dt>
<dd><p>Error field is full. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_EFUSE_REPEATED_PROG">
<span class="target" id="esp__efuse_8h_1a1ccf71a2889ed1c214e4f34de221b8c4"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_EFUSE_REPEATED_PROG</span></span></span><a class="headerlink" href="#c.ESP_ERR_EFUSE_REPEATED_PROG" title="Permalink to this definition"></a><br /></dt>
<dd><p>Error repeated programming of programmed bits is strictly forbidden. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_CODING">
<span class="target" id="esp__efuse_8h_1ab21a4b218c1f01541e9b34e939706d5f"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_CODING</span></span></span><a class="headerlink" href="#c.ESP_ERR_CODING" title="Permalink to this definition"></a><br /></dt>
<dd><p>Error while a encoding operation. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NOT_ENOUGH_UNUSED_KEY_BLOCKS">
<span class="target" id="esp__efuse_8h_1abb70858b62699588c4d4c241c22fa35b"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NOT_ENOUGH_UNUSED_KEY_BLOCKS</span></span></span><a class="headerlink" href="#c.ESP_ERR_NOT_ENOUGH_UNUSED_KEY_BLOCKS" title="Permalink to this definition"></a><br /></dt>
<dd><p>Error not enough unused key blocks available </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_DAMAGED_READING">
<span class="target" id="esp__efuse_8h_1a31d76c82db4ebc471c7ca018fa491aae"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_DAMAGED_READING</span></span></span><a class="headerlink" href="#c.ESP_ERR_DAMAGED_READING" title="Permalink to this definition"></a><br /></dt>
<dd><p>Error. Burn or reset was done during a reading operation leads to damage read data. This error is internal to the efuse component and not returned by any public API. </p>
</dd></dl>

</section>
<section id="id6">
<h3>Enumerations<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv426esp_efuse_rom_log_scheme_t">
<span id="_CPPv326esp_efuse_rom_log_scheme_t"></span><span id="_CPPv226esp_efuse_rom_log_scheme_t"></span><span class="target" id="esp__efuse_8h_1af0e3cb0f9af3886f7ffb4d193419a429"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_efuse_rom_log_scheme_t</span></span></span><a class="headerlink" href="#_CPPv426esp_efuse_rom_log_scheme_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type definition for ROM log scheme. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N26esp_efuse_rom_log_scheme_t27ESP_EFUSE_ROM_LOG_ALWAYS_ONE">
<span id="_CPPv3N26esp_efuse_rom_log_scheme_t27ESP_EFUSE_ROM_LOG_ALWAYS_ONE"></span><span id="_CPPv2N26esp_efuse_rom_log_scheme_t27ESP_EFUSE_ROM_LOG_ALWAYS_ONE"></span><span class="target" id="esp__efuse_8h_1af0e3cb0f9af3886f7ffb4d193419a429a8cbca3d409c1c1fbaa044165bb561b75"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ESP_EFUSE_ROM_LOG_ALWAYS_ON</span></span></span><a class="headerlink" href="#_CPPv4N26esp_efuse_rom_log_scheme_t27ESP_EFUSE_ROM_LOG_ALWAYS_ONE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Always enable ROM logging </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N26esp_efuse_rom_log_scheme_t29ESP_EFUSE_ROM_LOG_ON_GPIO_LOWE">
<span id="_CPPv3N26esp_efuse_rom_log_scheme_t29ESP_EFUSE_ROM_LOG_ON_GPIO_LOWE"></span><span id="_CPPv2N26esp_efuse_rom_log_scheme_t29ESP_EFUSE_ROM_LOG_ON_GPIO_LOWE"></span><span class="target" id="esp__efuse_8h_1af0e3cb0f9af3886f7ffb4d193419a429ace6b6e8285172470e6e87f2659dfbcfc"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ESP_EFUSE_ROM_LOG_ON_GPIO_LOW</span></span></span><a class="headerlink" href="#_CPPv4N26esp_efuse_rom_log_scheme_t29ESP_EFUSE_ROM_LOG_ON_GPIO_LOWE" title="Permalink to this definition"></a><br /></dt>
<dd><p>ROM logging is enabled when specific GPIO level is low during start up </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N26esp_efuse_rom_log_scheme_t30ESP_EFUSE_ROM_LOG_ON_GPIO_HIGHE">
<span id="_CPPv3N26esp_efuse_rom_log_scheme_t30ESP_EFUSE_ROM_LOG_ON_GPIO_HIGHE"></span><span id="_CPPv2N26esp_efuse_rom_log_scheme_t30ESP_EFUSE_ROM_LOG_ON_GPIO_HIGHE"></span><span class="target" id="esp__efuse_8h_1af0e3cb0f9af3886f7ffb4d193419a429ad29f0415d12faf7aecfa35634df6df78"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ESP_EFUSE_ROM_LOG_ON_GPIO_HIGH</span></span></span><a class="headerlink" href="#_CPPv4N26esp_efuse_rom_log_scheme_t30ESP_EFUSE_ROM_LOG_ON_GPIO_HIGHE" title="Permalink to this definition"></a><br /></dt>
<dd><p>ROM logging is enabled when specific GPIO level is high during start up </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N26esp_efuse_rom_log_scheme_t28ESP_EFUSE_ROM_LOG_ALWAYS_OFFE">
<span id="_CPPv3N26esp_efuse_rom_log_scheme_t28ESP_EFUSE_ROM_LOG_ALWAYS_OFFE"></span><span id="_CPPv2N26esp_efuse_rom_log_scheme_t28ESP_EFUSE_ROM_LOG_ALWAYS_OFFE"></span><span class="target" id="esp__efuse_8h_1af0e3cb0f9af3886f7ffb4d193419a429a25d8f9bb5e7830180f1d477dfcbd2e4e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ESP_EFUSE_ROM_LOG_ALWAYS_OFF</span></span></span><a class="headerlink" href="#_CPPv4N26esp_efuse_rom_log_scheme_t28ESP_EFUSE_ROM_LOG_ALWAYS_OFFE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Disable ROM logging permanently </p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=eFuse Manager (api-reference/system/efuse)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=eFuse Manager (api-reference/system/efuse)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="console.html" class="btn btn-neutral float-left" title="Console" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="esp_err.html" class="btn btn-neutral float-right" title="Error Code and Helper Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>