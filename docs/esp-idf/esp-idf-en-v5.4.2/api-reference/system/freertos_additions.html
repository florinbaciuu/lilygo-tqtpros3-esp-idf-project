<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FreeRTOS (Supplemental Features) - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/freertos_additions.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/system/freertos_additions';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Heap Memory Allocation" href="mem_alloc.html" />
    <link rel="prev" title="FreeRTOS (IDF)" href="freertos_idf.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth® API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Project Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">System API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">App Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="bootloader_image_format.html">Bootloader Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">Application Level Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_function_with_shared_stack.html">Call Function with External Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="chip_revision.html">Chip Revision</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console</a></li>
<li class="toctree-l3"><a class="reference internal" href="efuse.html">eFuse Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">Error Code and Helper Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">Event Loop Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos.html">FreeRTOS Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_idf.html">FreeRTOS (IDF)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">FreeRTOS (Supplemental Features)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ring-buffers">Ring Buffers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#esp-idf-tick-and-idle-hooks">ESP-IDF Tick and Idle Hooks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tlsp-deletion-callbacks">TLSP Deletion Callbacks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#freertos-idf-additional-api">IDF Additional API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#component-specific-properties">Component Specific Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mem_alloc.html">Heap Memory Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm.html">Memory Management for MMU Supported Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="heap_debug.html">Heap Memory Debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">ESP Timer (High Resolution Timer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="internal-unstable.html">Internal and Unstable APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">Inter-Processor Call (IPC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">Interrupt Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">Logging library</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_system_api.html">Miscellaneous System APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">Over The Air Updates (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">Performance Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="pthread.html">POSIX Support (Including POSIX Threads Support)</a></li>
<li class="toctree-l3"><a class="reference internal" href="random.html">Random Number Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">Sleep Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="soc_caps.html">SoC Capabilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">System Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ulp.html">ULP Coprocessor Programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">Watchdogs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">System API</a></li>
      <li class="breadcrumb-item active">FreeRTOS (Supplemental Features)</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-reference/system/freertos_additions.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="freertos-supplemental-features">
<h1><a class="toc-backref" href="#id15" role="doc-backlink">FreeRTOS (Supplemental Features)</a><a class="headerlink" href="#freertos-supplemental-features" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/v5.4.2/esp32/api-reference/system/freertos_additions.html">[中文]</a></p>
<p>ESP-IDF provides multiple features to supplement the features offered by FreeRTOS. These supplemental features are available on all FreeRTOS implementations supported by ESP-IDF (i.e., ESP-IDF FreeRTOS and Amazon SMP FreeRTOS). This document describes these supplemental features and is split into the following sections:</p>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#freertos-supplemental-features" id="id15">FreeRTOS (Supplemental Features)</a></p>
<ul>
<li><p><a class="reference internal" href="#overview" id="id16">Overview</a></p></li>
<li><p><a class="reference internal" href="#ring-buffers" id="id17">Ring Buffers</a></p></li>
<li><p><a class="reference internal" href="#esp-idf-tick-and-idle-hooks" id="id18">ESP-IDF Tick and Idle Hooks</a></p></li>
<li><p><a class="reference internal" href="#tlsp-deletion-callbacks" id="id19">TLSP Deletion Callbacks</a></p></li>
<li><p><a class="reference internal" href="#freertos-idf-additional-api" id="id20">IDF Additional API</a></p></li>
<li><p><a class="reference internal" href="#component-specific-properties" id="id21">Component Specific Properties</a></p></li>
<li><p><a class="reference internal" href="#api-reference" id="id22">API Reference</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="overview">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Overview</a><a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>ESP-IDF adds various new features to supplement the capabilities of FreeRTOS as follows:</p>
<ul class="simple">
<li><p><strong>Ring buffers</strong>: Ring buffers provide a FIFO buffer that can accept entries of arbitrary lengths.</p></li>
<li><p><strong>ESP-IDF Tick and Idle Hooks</strong>: ESP-IDF provides multiple custom tick interrupt hooks and idle task hooks that are more numerous and more flexible when compared to FreeRTOS tick and idle hooks.</p></li>
<li><p><strong>Thread Local Storage Pointer (TLSP) Deletion Callbacks</strong>: TLSP Deletion callbacks are run automatically when a task is deleted, thus allowing users to clean up their TLSPs automatically.</p></li>
<li><p><strong>IDF Additional API</strong>: ESP-IDF specific functions added to augment the features of FreeRTOS.</p></li>
<li><p><strong>Component Specific Properties</strong>: Currently added only one component specific property <code class="docutils literal notranslate"><span class="pre">ORIG_INCLUDE_PATH</span></code>.</p></li>
</ul>
</section>
<section id="ring-buffers">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">Ring Buffers</a><a class="headerlink" href="#ring-buffers" title="Permalink to this heading"></a></h2>
<p>FreeRTOS provides stream buffers and message buffers as the primary mechanisms to send arbitrarily sized data between tasks and ISRs. However, FreeRTOS stream buffers and message buffers have the following limitations:</p>
<ul class="simple">
<li><p>Strictly single sender and single receiver</p></li>
<li><p>Data is passed by copy</p></li>
<li><p>Unable to reserve buffer space for a deferred send (i.e., send acquire)</p></li>
</ul>
<p>Therefore, ESP-IDF provides a separate ring buffer implementation to address the issues above.</p>
<p>ESP-IDF ring buffers are strictly FIFO buffers that supports arbitrarily sized items. Ring buffers are a more memory efficient alternative to FreeRTOS queues in situations where the size of items is variable. The capacity of a ring buffer is not measured by the number of items it can store, but rather by the amount of memory used for storing items.</p>
<p>The ring buffer provides APIs to send an item, or to allocate space for an item in the ring buffer to be filled manually by the user. For efficiency reasons, <strong>items are always retrieved from the ring buffer by reference</strong>. As a result, all retrieved items <strong>must also be returned</strong> to the ring buffer by using <a class="reference internal" href="#_CPPv421vRingbufferReturnItem15RingbufHandle_tPv" title="vRingbufferReturnItem"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vRingbufferReturnItem()</span></code></a> or <a class="reference internal" href="#_CPPv428vRingbufferReturnItemFromISR15RingbufHandle_tPvP10BaseType_t" title="vRingbufferReturnItemFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vRingbufferReturnItemFromISR()</span></code></a>, in order for them to be removed from the ring buffer completely.</p>
<p>The ring buffers are split into the three following types:</p>
<p><strong>No-Split buffers</strong> guarantee that an item is stored in contiguous memory and does not attempt to split an item under any circumstances. Use No-Split buffers when items must occupy contiguous memory. <strong>Only this buffer type allows reserving buffer space for deferred sending.</strong> Refer to the documentation of the functions <a class="reference internal" href="#_CPPv422xRingbufferSendAcquire15RingbufHandle_tPPv6size_t10TickType_t" title="xRingbufferSendAcquire"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferSendAcquire()</span></code></a> and <a class="reference internal" href="#_CPPv423xRingbufferSendComplete15RingbufHandle_tPv" title="xRingbufferSendComplete"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferSendComplete()</span></code></a> for more details.</p>
<p><strong>Allow-Split buffers</strong> allow an item to be split in two parts when wrapping around the end of the buffer if there is enough space at the tail and the head of the buffer combined to store the item. Allow-Split buffers are more memory efficient than No-Split buffers but can return an item in two parts when retrieving.</p>
<p><strong>Byte buffers</strong> do not store data as separate items. All data is stored as a sequence of bytes, and any number of bytes can be sent or retrieved each time. Use byte buffers when separate items do not need to be maintained, e.g., a byte stream.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No-Split buffers and Allow-Split buffers always store items at 32-bit aligned addresses. Therefore, when retrieving an item, the item pointer is guaranteed to be 32-bit aligned. This is useful especially when you need to send some data to the DMA.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each item stored in No-Split or Allow-Split buffers <strong>requires an additional 8 bytes for a header</strong>. Item sizes are also rounded up to a 32-bit aligned size, i.e., multiple of 4 bytes. However the true item size is recorded within the header. The sizes of No-Split and Allow-Split buffers will also be rounded up when created.</p>
</div>
<section id="usage">
<h3>Usage<a class="headerlink" href="#usage" title="Permalink to this heading"></a></h3>
<p>The following example demonstrates the usage of <a class="reference internal" href="#_CPPv417xRingbufferCreate6size_t16RingbufferType_t" title="xRingbufferCreate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferCreate()</span></code></a> and <a class="reference internal" href="#_CPPv415xRingbufferSend15RingbufHandle_tPKv6size_t10TickType_t" title="xRingbufferSend"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferSend()</span></code></a> to create a ring buffer and then send an item to it:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/ringbuf.h&quot;</span>
<span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">tx_item</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;test_item&quot;</span><span class="p">;</span>

<span class="p">...</span>

<span class="w">    </span><span class="c1">//Create ring buffer</span>
<span class="w">    </span><span class="n">RingbufHandle_t</span><span class="w"> </span><span class="n">buf_handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">buf_handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xRingbufferCreate</span><span class="p">(</span><span class="mi">1028</span><span class="p">,</span><span class="w"> </span><span class="n">RINGBUF_TYPE_NOSPLIT</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf_handle</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to create ring buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//Send an item</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">xRingbufferSend</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="n">tx_item</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tx_item</span><span class="p">),</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to send item</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>The following example demonstrates the usage of <a class="reference internal" href="#_CPPv422xRingbufferSendAcquire15RingbufHandle_tPPv6size_t10TickType_t" title="xRingbufferSendAcquire"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferSendAcquire()</span></code></a> and <a class="reference internal" href="#_CPPv423xRingbufferSendComplete15RingbufHandle_tPv" title="xRingbufferSendComplete"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferSendComplete()</span></code></a> instead of <a class="reference internal" href="#_CPPv415xRingbufferSend15RingbufHandle_tPKv6size_t10TickType_t" title="xRingbufferSend"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferSend()</span></code></a> to acquire memory on the ring buffer (of type <a class="reference internal" href="#_CPPv4N16RingbufferType_t20RINGBUF_TYPE_NOSPLITE" title="RINGBUF_TYPE_NOSPLIT"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">RINGBUF_TYPE_NOSPLIT</span></code></a>) and then send an item to it. This adds one more step, but allows getting the address of the memory to write to, and writing to the memory yourself.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/ringbuf.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;soc/lldesc.h&quot;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">lldesc_t</span><span class="w"> </span><span class="n">dma_desc</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">dma_item_t</span><span class="p">;</span>

<span class="cp">#define DMA_ITEM_SIZE(N) (sizeof(lldesc_t)+(((N)+3)&amp;(~3)))</span>

<span class="p">...</span>

<span class="w">    </span><span class="c1">//Retrieve space for DMA descriptor and corresponding data buffer</span>
<span class="w">    </span><span class="c1">//This has to be done with SendAcquire, or the address may be different when we copy</span>
<span class="w">    </span><span class="n">dma_item_t</span><span class="w"> </span><span class="o">*</span><span class="n">item</span><span class="p">;</span>
<span class="w">    </span><span class="n">UBaseType_t</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">xRingbufferSendAcquire</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span>
<span class="w">                        </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_ITEM_SIZE</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">),</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to acquire memory for item</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">item</span><span class="o">-&gt;</span><span class="n">dma_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lldesc_t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">eof</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">//Actually send to the ring buffer for consumer to use</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xRingbufferSendComplete</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to send item</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>The following example demonstrates retrieving and returning an item from a <strong>No-Split ring buffer</strong> using <a class="reference internal" href="#_CPPv418xRingbufferReceive15RingbufHandle_tP6size_t10TickType_t" title="xRingbufferReceive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceive()</span></code></a> and <a class="reference internal" href="#_CPPv421vRingbufferReturnItem15RingbufHandle_tPv" title="vRingbufferReturnItem"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vRingbufferReturnItem()</span></code></a></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>

<span class="w">    </span><span class="c1">//Receive an item from no-split ring buffer</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">item_size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">xRingbufferReceive</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_size</span><span class="p">,</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>

<span class="w">    </span><span class="c1">//Check received item</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">item</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//Print item</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">item_size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//Return Item</span>
<span class="w">        </span><span class="n">vRingbufferReturnItem</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">item</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//Failed to receive item</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to receive item</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>The following example demonstrates retrieving and returning an item from an <strong>Allow-Split ring buffer</strong> using <a class="reference internal" href="#_CPPv423xRingbufferReceiveSplit15RingbufHandle_tPPvPPvP6size_tP6size_t10TickType_t" title="xRingbufferReceiveSplit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveSplit()</span></code></a> and <a class="reference internal" href="#_CPPv421vRingbufferReturnItem15RingbufHandle_tPv" title="vRingbufferReturnItem"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vRingbufferReturnItem()</span></code></a></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>

<span class="w">    </span><span class="c1">//Receive an item from allow-split ring buffer</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">item_size1</span><span class="p">,</span><span class="w"> </span><span class="n">item_size2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">item1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">item2</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType_t</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xRingbufferReceiveSplit</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_size1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_size2</span><span class="p">,</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>

<span class="w">    </span><span class="c1">//Check received item</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdTRUE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">item1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">item_size1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">item1</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">vRingbufferReturnItem</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">item1</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//Check if item was split</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">item2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">item_size2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">item2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">vRingbufferReturnItem</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">item2</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//Failed to receive item</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to receive item</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>The following example demonstrates retrieving and returning an item from a <strong>byte buffer</strong> using <a class="reference internal" href="#_CPPv422xRingbufferReceiveUpTo15RingbufHandle_tP6size_t10TickType_t6size_t" title="xRingbufferReceiveUpTo"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveUpTo()</span></code></a> and <a class="reference internal" href="#_CPPv421vRingbufferReturnItem15RingbufHandle_tPv" title="vRingbufferReturnItem"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vRingbufferReturnItem()</span></code></a></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>

<span class="w">    </span><span class="c1">//Receive data from byte buffer</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">item_size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">xRingbufferReceiveUpTo</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_size</span><span class="p">,</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tx_item</span><span class="p">));</span>

<span class="w">    </span><span class="c1">//Check received data</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">item</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//Print item</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">item_size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//Return Item</span>
<span class="w">        </span><span class="n">vRingbufferReturnItem</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">item</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//Failed to receive item</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to receive item</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>For ISR safe versions of the functions used above, call <a class="reference internal" href="#_CPPv422xRingbufferSendFromISR15RingbufHandle_tPKv6size_tP10BaseType_t" title="xRingbufferSendFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferSendFromISR()</span></code></a>, <a class="reference internal" href="#_CPPv425xRingbufferReceiveFromISR15RingbufHandle_tP6size_t" title="xRingbufferReceiveFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveFromISR()</span></code></a>, <a class="reference internal" href="#_CPPv430xRingbufferReceiveSplitFromISR15RingbufHandle_tPPvPPvP6size_tP6size_t" title="xRingbufferReceiveSplitFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveSplitFromISR()</span></code></a>, <a class="reference internal" href="#_CPPv429xRingbufferReceiveUpToFromISR15RingbufHandle_tP6size_t6size_t" title="xRingbufferReceiveUpToFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveUpToFromISR()</span></code></a>, and <a class="reference internal" href="#_CPPv428vRingbufferReturnItemFromISR15RingbufHandle_tPvP10BaseType_t" title="vRingbufferReturnItemFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vRingbufferReturnItemFromISR()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Two calls to <code class="docutils literal notranslate"><span class="pre">RingbufferReceive[UpTo][FromISR]()</span></code> are required if the bytes wraps around the end of the ring buffer.</p>
</div>
</section>
<section id="sending-to-ring-buffer">
<h3>Sending to Ring Buffer<a class="headerlink" href="#sending-to-ring-buffer" title="Permalink to this heading"></a></h3>
<p>The following diagrams illustrate the differences between No-Split and Allow-Split buffers as compared to byte buffers with regard to sending items or data. The diagrams assume that three items of sizes <strong>18, 3, and 27 bytes</strong> are sent respectively to a <strong>buffer of 128 bytes</strong>:</p>
<figure class="align-center" id="id7">
<div><img height="192" src="../../_images/packetdiag-c15b5a9dd6dd1104956203a1fe05fa27b88f4fa6.png" width="896" /></div><figcaption>
<p><span class="caption-text">Sending items to No-Split or Allow-Split ring buffers</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>For No-Split and Allow-Split buffers, a header of 8 bytes precedes every data item. Furthermore, the space occupied by each item is <strong>rounded up to the nearest 32-bit aligned size</strong> in order to maintain overall 32-bit alignment. However, the true size of the item is recorded inside the header which will be returned when the item is retrieved.</p>
<p>Referring to the diagram above, the 18, 3, and 27 byte items are <strong>rounded up to 20, 4, and 28 bytes</strong> respectively. An 8 byte header is then added in front of each item.</p>
<figure class="align-center" id="id8">
<div><img height="192" src="../../_images/packetdiag-b4600a129acb58dcbe64526d3d12d09147775d92.png" width="896" /></div><figcaption>
<p><span class="caption-text">Sending items to byte buffers</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Byte buffers treat data as a sequence of bytes and does not incur any overhead (no headers). As a result, all data sent to a byte buffer is merged into a single item.</p>
<p>Referring to the diagram above, the 18, 3, and 27 byte items are sequentially written to the byte buffer and <strong>merged into a single item of 48 bytes</strong>.</p>
</section>
<section id="using-sendacquire-and-sendcomplete">
<h3>Using SendAcquire and SendComplete<a class="headerlink" href="#using-sendacquire-and-sendcomplete" title="Permalink to this heading"></a></h3>
<p>Items in No-Split buffers are acquired (by <code class="docutils literal notranslate"><span class="pre">SendAcquire</span></code>) in strict FIFO order and must be sent to the buffer by <code class="docutils literal notranslate"><span class="pre">SendComplete</span></code> for the data to be accessible by the consumer. Multiple items can be sent or acquired without calling <code class="docutils literal notranslate"><span class="pre">SendComplete</span></code>, and the items do not necessarily need to be completed in the order they were acquired. However, the receiving of data items must occur in FIFO order, therefore not calling <code class="docutils literal notranslate"><span class="pre">SendComplete</span></code> for the earliest acquired item prevents the subsequent items from being received.</p>
<p>The following diagrams illustrate what will happen when <code class="docutils literal notranslate"><span class="pre">SendAcquire</span></code> and <code class="docutils literal notranslate"><span class="pre">SendComplete</span></code> do not happen in the same order. At the beginning, there is already a data item of 16 bytes sent to the ring buffer. Then <code class="docutils literal notranslate"><span class="pre">SendAcquire</span></code> is called to acquire space of 20, 8, 24 bytes on the ring buffer.</p>
<figure class="align-center" id="id9">
<div><img height="264" src="../../_images/packetdiag-e71b170129a0a1b285d22ebd9382d61fa20d72f1.png" width="896" /></div><figcaption>
<p><span class="caption-text">SendAcquire/SendComplete items in No-Split ring buffers</span><a class="headerlink" href="#id9" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>After that, we fill (use) the buffers, and send them to the ring buffer by <code class="docutils literal notranslate"><span class="pre">SendComplete</span></code> in the order of 8, 24, 20. When 8 bytes and 24 bytes data are sent, the consumer still can only get the 16 bytes data item. Hence, if <code class="docutils literal notranslate"><span class="pre">SendComplete</span></code> is not called for the 20 bytes, it will not be available, nor will the data items following the 20 bytes item.</p>
<p>When the 20 bytes item is finally completed, all the 3 data items can be received now, in the order of 20, 8, 24 bytes, right after the 16 bytes item existing in the buffer at the beginning.</p>
<p>Allow-Split buffers and byte buffers do not allow using <code class="docutils literal notranslate"><span class="pre">SendAcquire</span></code> or <code class="docutils literal notranslate"><span class="pre">SendComplete</span></code> since acquired buffers are required to be complete (not wrapped).</p>
</section>
<section id="wrap-around">
<h3>Wrap Around<a class="headerlink" href="#wrap-around" title="Permalink to this heading"></a></h3>
<p>The following diagrams illustrate the differences between No-Split, Allow-Split, and byte buffers when a sent item requires a wrap around. The diagrams assume a buffer of <strong>128 bytes</strong> with <strong>56 bytes of free space that wraps around</strong> and a sent item of <strong>28 bytes</strong>.</p>
<figure class="align-center" id="id10">
<div><img height="192" src="../../_images/packetdiag-97283de6c98756efe991704a46c30bc7cf4d81c0.png" width="896" /></div><figcaption>
<p><span class="caption-text">Wrap around in No-Split buffers</span><a class="headerlink" href="#id10" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>No-Split buffers <strong>only store an item in continuous free space and do not split an item under any circumstances</strong>. When the free space at the tail of the buffer is insufficient to completely store the item and its header, the free space at the tail will be <strong>marked as dummy data</strong>. The buffer will then wrap around and store the item in the free space at the head of the buffer.</p>
<p>Referring to the diagram above, the 16 bytes of free space at the tail of the buffer is insufficient to store the 28 byte item. Therefore, the 16 bytes is marked as dummy data and the item is written to the free space at the head of the buffer instead.</p>
<figure class="align-center" id="id11">
<div><img height="192" src="../../_images/packetdiag-6a4834a2d81b78ec7581a87a4dd3830b5f67398e.png" width="896" /></div><figcaption>
<p><span class="caption-text">Wrap around in Allow-Split buffers</span><a class="headerlink" href="#id11" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Allow-Split buffers will attempt to <strong>split the item into two parts</strong> when the free space at the tail of the buffer is insufficient to store the item data and its header. Both parts of the split item will have their own headers, therefore incurring an extra 8 bytes of overhead.</p>
<p>Referring to the diagram above, the 16 bytes of free space at the tail of the buffer is insufficient to store the 28 byte item. Therefore, the item is split into two parts (8 and 20 bytes) and written as two parts to the buffer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Allow-Split buffers treat both parts of the split item as two separate items, therefore call <a class="reference internal" href="#_CPPv423xRingbufferReceiveSplit15RingbufHandle_tPPvPPvP6size_tP6size_t10TickType_t" title="xRingbufferReceiveSplit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveSplit()</span></code></a> instead of <a class="reference internal" href="#_CPPv418xRingbufferReceive15RingbufHandle_tP6size_t10TickType_t" title="xRingbufferReceive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceive()</span></code></a> to receive both parts of a split item in a thread safe manner.</p>
</div>
<figure class="align-center" id="id12">
<div><img height="192" src="../../_images/packetdiag-1aa58ad92c998af572f566aa3e37e8fa57ff8084.png" width="896" /></div><figcaption>
<p><span class="caption-text">Wrap around in byte buffers</span><a class="headerlink" href="#id12" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Byte buffers <strong>store as much data as possible into the free space at the tail of buffer</strong>. The remaining data will then be stored in the free space at the head of the buffer. No overhead is incurred when wrapping around in byte buffers.</p>
<p>Referring to the diagram above, the 16 bytes of free space at the tail of the buffer is insufficient to completely store the 28 bytes of data. Therefore, the 16 bytes of free space is filled with data, and the remaining 12 bytes are written to the free space at the head of the buffer. The buffer now contains data in two separate continuous parts, and each continuous part is treated as a separate item by the byte buffer.</p>
</section>
<section id="retrieving-returning">
<h3>Retrieving/Returning<a class="headerlink" href="#retrieving-returning" title="Permalink to this heading"></a></h3>
<p>The following diagrams illustrate the differences between No-Split and Allow-Split buffers as compared to byte buffers in retrieving and returning data:</p>
<figure class="align-center" id="id13">
<div><img height="312" src="../../_images/packetdiag-970f3d268273fc1111b3f20bc6abadcefdad7c7e.png" width="896" /></div><figcaption>
<p><span class="caption-text">Retrieving/Returning items in No-Split and Allow-Split ring buffers</span><a class="headerlink" href="#id13" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Items in No-Split buffers and Allow-Split buffers are <strong>retrieved in strict FIFO order</strong> and <strong>must be returned</strong> for the occupied space to be freed. Multiple items can be retrieved before returning, and the items do not necessarily need to be returned in the order they were retrieved. However, the freeing of space must occur in FIFO order, therefore not returning the earliest retrieved item prevents the space of subsequent items from being freed.</p>
<p>Referring to the diagram above, the <strong>16, 20, and 8 byte items are retrieved in FIFO order</strong>. However, the items are not returned in the order they were retrieved. First, the 20 byte item is returned followed by the 8 byte and the 16 byte items. The space is not freed until the first item, i.e., the 16 byte item is returned.</p>
<figure class="align-center" id="id14">
<div><img height="240" src="../../_images/packetdiag-484c154666dc9c0343ffcc9cb3ff3f6987eb5f87.png" width="896" /></div><figcaption>
<p><span class="caption-text">Retrieving/Returning data in byte buffers</span><a class="headerlink" href="#id14" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Byte buffers <strong>do not allow multiple retrievals before returning</strong> (every retrieval must be followed by a return before another retrieval is permitted). When using <a class="reference internal" href="#_CPPv418xRingbufferReceive15RingbufHandle_tP6size_t10TickType_t" title="xRingbufferReceive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceive()</span></code></a> or <a class="reference internal" href="#_CPPv425xRingbufferReceiveFromISR15RingbufHandle_tP6size_t" title="xRingbufferReceiveFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveFromISR()</span></code></a>, all continuous stored data will be retrieved. <a class="reference internal" href="#_CPPv422xRingbufferReceiveUpTo15RingbufHandle_tP6size_t10TickType_t6size_t" title="xRingbufferReceiveUpTo"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveUpTo()</span></code></a> or <a class="reference internal" href="#_CPPv429xRingbufferReceiveUpToFromISR15RingbufHandle_tP6size_t6size_t" title="xRingbufferReceiveUpToFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveUpToFromISR()</span></code></a> can be used to restrict the maximum number of bytes retrieved. Since every retrieval must be followed by a return, the space is freed as soon as the data is returned.</p>
<p>Referring to the diagram above, the 38 bytes of continuous stored data at the tail of the buffer is retrieved, returned, and freed. The next call to <a class="reference internal" href="#_CPPv418xRingbufferReceive15RingbufHandle_tP6size_t10TickType_t" title="xRingbufferReceive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceive()</span></code></a> or <a class="reference internal" href="#_CPPv425xRingbufferReceiveFromISR15RingbufHandle_tP6size_t" title="xRingbufferReceiveFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveFromISR()</span></code></a> then wraps around and does the same to the 30 bytes of continuous stored data at the head of the buffer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Retrieving items from Allow-Split buffers must be done via <a class="reference internal" href="#_CPPv423xRingbufferReceiveSplit15RingbufHandle_tPPvPPvP6size_tP6size_t10TickType_t" title="xRingbufferReceiveSplit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveSplit()</span></code></a> or <a class="reference internal" href="#_CPPv430xRingbufferReceiveSplitFromISR15RingbufHandle_tPPvPPvP6size_tP6size_t" title="xRingbufferReceiveSplitFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveSplitFromISR()</span></code></a> instead of <a class="reference internal" href="#_CPPv418xRingbufferReceive15RingbufHandle_tP6size_t10TickType_t" title="xRingbufferReceive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceive()</span></code></a> or <a class="reference internal" href="#_CPPv425xRingbufferReceiveFromISR15RingbufHandle_tP6size_t" title="xRingbufferReceiveFromISR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferReceiveFromISR()</span></code></a>.</p>
</div>
</section>
<section id="ring-buffers-with-queue-sets">
<h3>Ring Buffers with Queue Sets<a class="headerlink" href="#ring-buffers-with-queue-sets" title="Permalink to this heading"></a></h3>
<p>Ring buffers can be added to FreeRTOS queue sets using <a class="reference internal" href="#_CPPv428xRingbufferAddToQueueSetRead15RingbufHandle_t16QueueSetHandle_t" title="xRingbufferAddToQueueSetRead"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferAddToQueueSetRead()</span></code></a> such that every time a ring buffer receives an item or data, the queue set is notified. Once added to a queue set, every attempt to retrieve an item from a ring buffer should be preceded by a call to <a class="reference internal" href="freertos_idf.html#_CPPv419xQueueSelectFromSet16QueueSetHandle_tK10TickType_t" title="xQueueSelectFromSet"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xQueueSelectFromSet()</span></code></a>. To check whether the selected queue set member is the ring buffer, call <a class="reference internal" href="#_CPPv418xRingbufferCanRead15RingbufHandle_t22QueueSetMemberHandle_t" title="xRingbufferCanRead"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferCanRead()</span></code></a>.</p>
<p>The following example demonstrates queue set usage with ring buffers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/queue.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/ringbuf.h&quot;</span>

<span class="p">...</span>

<span class="w">    </span><span class="c1">//Create ring buffer and queue set</span>
<span class="w">    </span><span class="n">RingbufHandle_t</span><span class="w"> </span><span class="n">buf_handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xRingbufferCreate</span><span class="p">(</span><span class="mi">1028</span><span class="p">,</span><span class="w"> </span><span class="n">RINGBUF_TYPE_NOSPLIT</span><span class="p">);</span>
<span class="w">    </span><span class="n">QueueSetHandle_t</span><span class="w"> </span><span class="n">queue_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueCreateSet</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//Add ring buffer to queue set</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xRingbufferAddToQueueSetRead</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="n">queue_set</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to add to queue set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">...</span>

<span class="w">    </span><span class="c1">//Block on queue set</span>
<span class="w">    </span><span class="n">QueueSetMemberHandle_t</span><span class="w"> </span><span class="n">member</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xQueueSelectFromSet</span><span class="p">(</span><span class="n">queue_set</span><span class="p">,</span><span class="w"> </span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>

<span class="w">    </span><span class="c1">//Check if member is ring buffer</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">member</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">xRingbufferCanRead</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="n">member</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pdTRUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//Member is ring buffer, receive item from ring buffer</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">item_size</span><span class="p">;</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">xRingbufferReceive</span><span class="p">(</span><span class="n">buf_handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">        </span><span class="c1">//Handle item</span>
<span class="w">        </span><span class="p">...</span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="ring-buffers-with-static-allocation">
<h3>Ring Buffers with Static Allocation<a class="headerlink" href="#ring-buffers-with-static-allocation" title="Permalink to this heading"></a></h3>
<p>The <a class="reference internal" href="#_CPPv423xRingbufferCreateStatic6size_t16RingbufferType_tP7uint8_tP18StaticRingbuffer_t" title="xRingbufferCreateStatic"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferCreateStatic()</span></code></a> can be used to create ring buffers with specific memory requirements (such as a ring buffer being allocated in external RAM). All blocks of memory used by a ring buffer must be manually allocated beforehand, then passed to the <a class="reference internal" href="#_CPPv423xRingbufferCreateStatic6size_t16RingbufferType_tP7uint8_tP18StaticRingbuffer_t" title="xRingbufferCreateStatic"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferCreateStatic()</span></code></a> to be initialized as a ring buffer. These blocks include the following:</p>
<ul class="simple">
<li><p>The ring buffer's data structure of type <a class="reference internal" href="#_CPPv418StaticRingbuffer_t" title="StaticRingbuffer_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">StaticRingbuffer_t</span></code></a>.</p></li>
<li><p>The ring buffer's storage area of size <code class="docutils literal notranslate"><span class="pre">xBufferSize</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">xBufferSize</span></code> must be 32-bit aligned for No-Split and Allow-Split buffers.</p></li>
</ul>
<p>The manner in which these blocks are allocated depends on the users requirements (e.g., all blocks being statically declared, or dynamically allocated with specific capabilities such as external RAM).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When deleting a ring buffer created via <a class="reference internal" href="#_CPPv423xRingbufferCreateStatic6size_t16RingbufferType_tP7uint8_tP18StaticRingbuffer_t" title="xRingbufferCreateStatic"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xRingbufferCreateStatic()</span></code></a>, the function <a class="reference internal" href="#_CPPv417vRingbufferDelete15RingbufHandle_t" title="vRingbufferDelete"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vRingbufferDelete()</span></code></a> will not free any of the memory blocks. This must be done manually by the user after <a class="reference internal" href="#_CPPv417vRingbufferDelete15RingbufHandle_t" title="vRingbufferDelete"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vRingbufferDelete()</span></code></a> is called.</p>
</div>
<p>The code snippet below demonstrates a ring buffer being allocated entirely in external RAM.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/ringbuf.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/semphr.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_caps.h&quot;</span>

<span class="cp">#define BUFFER_SIZE     400      </span><span class="c1">//32-bit aligned size</span>
<span class="cp">#define BUFFER_TYPE     RINGBUF_TYPE_NOSPLIT</span>
<span class="p">...</span>

<span class="c1">//Allocate ring buffer data structure and storage area into external RAM</span>
<span class="n">StaticRingbuffer_t</span><span class="w"> </span><span class="o">*</span><span class="n">buffer_struct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">StaticRingbuffer_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">heap_caps_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">StaticRingbuffer_t</span><span class="p">),</span><span class="w"> </span><span class="n">MALLOC_CAP_SPIRAM</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buffer_storage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">heap_caps_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="o">*</span><span class="n">BUFFER_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">MALLOC_CAP_SPIRAM</span><span class="p">);</span>

<span class="c1">//Create a ring buffer with manually allocated memory</span>
<span class="n">RingbufHandle_t</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xRingbufferCreateStatic</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">BUFFER_TYPE</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_storage</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_struct</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//Delete the ring buffer after used</span>
<span class="n">vRingbufferDelete</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

<span class="c1">//Manually free all blocks of memory</span>
<span class="n">free</span><span class="p">(</span><span class="n">buffer_struct</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">buffer_storage</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="esp-idf-tick-and-idle-hooks">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">ESP-IDF Tick and Idle Hooks</a><a class="headerlink" href="#esp-idf-tick-and-idle-hooks" title="Permalink to this heading"></a></h2>
<p>FreeRTOS allows applications to provide a tick hook and an idle hook at compile time:</p>
<ul class="simple">
<li><p>FreeRTOS tick hook can be enabled via the <a class="reference internal" href="../kconfig.html#config-freertos-use-tick-hook"><span class="std std-ref">CONFIG_FREERTOS_USE_TICK_HOOK</span></a> option. The application must provide the <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">vApplicationTickHook(</span> <span class="pre">void</span> <span class="pre">)</span></code> callback.</p></li>
<li><p>FreeRTOS idle hook can be enabled via the <a class="reference internal" href="../kconfig.html#config-freertos-use-idle-hook"><span class="std std-ref">CONFIG_FREERTOS_USE_IDLE_HOOK</span></a> option. The application must provide the <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">vApplicationIdleHook(</span> <span class="pre">void</span> <span class="pre">)</span></code> callback.</p></li>
</ul>
<p>However, the FreeRTOS tick hook and idle hook have the following draw backs:</p>
<ul class="simple">
<li><p>The FreeRTOS hooks are registered at compile time</p></li>
<li><p>Only one of each hook can be registered</p></li>
<li><p>On multi-core targets, the FreeRTOS hooks are symmetric, meaning each core's tick interrupt and idle tasks ends up calling the same hook</p></li>
</ul>
<p>Therefore, ESP-IDF tick and idle hooks are provided to supplement the features of FreeRTOS tick and idle hooks. The ESP-IDF hooks have the following features:</p>
<ul class="simple">
<li><p>The hooks can be registered and deregistered at run-time</p></li>
<li><p>Multiple hooks can be registered (with a maximum of 8 hooks of each type per core)</p></li>
<li><p>On multi-core targets, the hooks can be asymmetric, meaning different hooks can be registered to each core</p></li>
</ul>
<p>ESP-IDF hooks can be registered and deregistered using the following APIs:</p>
<ul>
<li><p>For tick hooks:</p>
<blockquote>
<div><ul class="simple">
<li><p>Register using <a class="reference internal" href="#_CPPv431esp_register_freertos_tick_hook22esp_freertos_tick_cb_t" title="esp_register_freertos_tick_hook"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_register_freertos_tick_hook()</span></code></a> or <a class="reference internal" href="#_CPPv439esp_register_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t" title="esp_register_freertos_tick_hook_for_cpu"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_register_freertos_tick_hook_for_cpu()</span></code></a></p></li>
<li><p>Deregister using <a class="reference internal" href="#_CPPv433esp_deregister_freertos_tick_hook22esp_freertos_tick_cb_t" title="esp_deregister_freertos_tick_hook"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_deregister_freertos_tick_hook()</span></code></a> or <a class="reference internal" href="#_CPPv441esp_deregister_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t" title="esp_deregister_freertos_tick_hook_for_cpu"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_deregister_freertos_tick_hook_for_cpu()</span></code></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>For idle hooks:</p>
<blockquote>
<div><ul class="simple">
<li><p>Register using <a class="reference internal" href="#_CPPv431esp_register_freertos_idle_hook22esp_freertos_idle_cb_t" title="esp_register_freertos_idle_hook"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_register_freertos_idle_hook()</span></code></a> or <a class="reference internal" href="#_CPPv439esp_register_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t" title="esp_register_freertos_idle_hook_for_cpu"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_register_freertos_idle_hook_for_cpu()</span></code></a></p></li>
<li><p>Deregister using <a class="reference internal" href="#_CPPv433esp_deregister_freertos_idle_hook22esp_freertos_idle_cb_t" title="esp_deregister_freertos_idle_hook"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_deregister_freertos_idle_hook()</span></code></a> or <a class="reference internal" href="#_CPPv441esp_deregister_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t" title="esp_deregister_freertos_idle_hook_for_cpu"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_deregister_freertos_idle_hook_for_cpu()</span></code></a></p></li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The tick interrupt stays active while the cache is disabled, therefore any tick hook (FreeRTOS or ESP-IDF) functions must be placed in internal RAM. Please refer to the <a class="reference internal" href="../peripherals/spi_flash/spi_flash_concurrency.html#iram-safe-interrupt-handlers"><span class="std std-ref">SPI flash API documentation</span></a> for more details.</p>
</div>
</section>
<section id="tlsp-deletion-callbacks">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">TLSP Deletion Callbacks</a><a class="headerlink" href="#tlsp-deletion-callbacks" title="Permalink to this heading"></a></h2>
<p>Vanilla FreeRTOS provides a Thread Local Storage Pointers (TLSP) feature. These are pointers stored directly in the Task Control Block (TCB) of a particular task. TLSPs allow each task to have its own unique set of pointers to data structures. Vanilla FreeRTOS expects users to:</p>
<ul class="simple">
<li><p>set a task's TLSPs by calling <a class="reference internal" href="freertos_idf.html#_CPPv433vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv" title="vTaskSetThreadLocalStoragePointer"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskSetThreadLocalStoragePointer()</span></code></a> after the task has been created.</p></li>
<li><p>get a task's TLSPs by calling <a class="reference internal" href="freertos_idf.html#_CPPv434pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t" title="pvTaskGetThreadLocalStoragePointer"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">pvTaskGetThreadLocalStoragePointer()</span></code></a> during the task's lifetime.</p></li>
<li><p>free the memory pointed to by the TLSPs before the task is deleted.</p></li>
</ul>
<p>However, there can be instances where users may want the freeing of TLSP memory to be automatic. Therefore, ESP-IDF provides the additional feature of TLSP deletion callbacks. These user-provided deletion callbacks are called automatically when a task is deleted, thus allowing the TLSP memory to be cleaned up without needing to add the cleanup logic explicitly to the code of every task.</p>
<p>The TLSP deletion callbacks are set in a similar fashion to the TLSPs themselves.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv447vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t" title="vTaskSetThreadLocalStoragePointerAndDelCallback"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskSetThreadLocalStoragePointerAndDelCallback()</span></code></a> sets both a particular TLSP and its associated callback.</p></li>
<li><p>Calling the Vanilla FreeRTOS function <a class="reference internal" href="freertos_idf.html#_CPPv433vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv" title="vTaskSetThreadLocalStoragePointer"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskSetThreadLocalStoragePointer()</span></code></a> simply sets the TLSP's associated Deletion Callback to <cite>NULL</cite>, meaning that no callback is called for that TLSP during task deletion.</p></li>
</ul>
<p>When implementing TLSP callbacks, users should note the following:</p>
<ul class="simple">
<li><p>The callback <strong>must never attempt to block or yield</strong> and critical sections should be kept as short as possible.</p></li>
<li><p>The callback is called shortly before a deleted task's memory is freed. Thus, the callback can either be called from <a class="reference internal" href="freertos_idf.html#_CPPv411vTaskDelete12TaskHandle_t" title="vTaskDelete"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">vTaskDelete()</span></code></a> itself, or from the idle task.</p></li>
</ul>
</section>
<section id="freertos-idf-additional-api">
<span id="idf-additional-api"></span><h2><a class="toc-backref" href="#id20" role="doc-backlink">IDF Additional API</a><a class="headerlink" href="#freertos-idf-additional-api" title="Permalink to this heading"></a></h2>
<p>The <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/freertos/esp_additions/include/freertos/idf_additions.h">freertos/esp_additions/include/freertos/idf_additions.h</a> header contains FreeRTOS-related helper functions added by ESP-IDF. Users can include this header via <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;freertos/idf_additions.h&quot;</span></code>.</p>
</section>
<section id="component-specific-properties">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Component Specific Properties</a><a class="headerlink" href="#component-specific-properties" title="Permalink to this heading"></a></h2>
<p>Besides standard component variables that are available with basic cmake build properties, FreeRTOS component also provides arguments (only one so far) for simpler integration with other modules:</p>
<ul class="simple">
<li><p><cite>ORIG_INCLUDE_PATH</cite> -  contains an absolute path to freertos root include folder. Thus instead of <cite>#include &quot;freertos/FreeRTOS.h&quot;</cite> you can refer to headers directly: <cite>#include &quot;FreeRTOS.h&quot;</cite>.</p></li>
</ul>
</section>
<section id="api-reference">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h2>
<section id="ring-buffer-api">
<h3>Ring Buffer API<a class="headerlink" href="#ring-buffer-api" title="Permalink to this heading"></a></h3>
</section>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_ringbuf/include/freertos/ringbuf.h">components/esp_ringbuf/include/freertos/ringbuf.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/ringbuf.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_ringbuf</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_ringbuf</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_ringbuf
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_ringbuf
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417xRingbufferCreate6size_t16RingbufferType_t">
<span id="_CPPv317xRingbufferCreate6size_t16RingbufferType_t"></span><span id="_CPPv217xRingbufferCreate6size_t16RingbufferType_t"></span><span id="xRingbufferCreate__s.RingbufferType_t"></span><span class="target" id="ringbuf_8h_1ac37bae961feef2406fb91d65382b2138"></span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferCreate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferSize</span></span>, <a class="reference internal" href="#_CPPv416RingbufferType_t" title="RingbufferType_t"><span class="n"><span class="pre">RingbufferType_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferType</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xRingbufferCreate6size_t16RingbufferType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a ring buffer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>xBufferSize of no-split/allow-split buffers will be rounded up to the nearest 32-bit aligned size.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xBufferSize</strong> -- <strong>[in]</strong> Size of the buffer in bytes. Note that items require space for a header in no-split/allow-split buffers </p></li>
<li><p><strong>xBufferType</strong> -- <strong>[in]</strong> Type of ring buffer, see documentation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A handle to the created ring buffer, or NULL in case of error. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424xRingbufferCreateNoSplit6size_t6size_t">
<span id="_CPPv324xRingbufferCreateNoSplit6size_t6size_t"></span><span id="_CPPv224xRingbufferCreateNoSplit6size_t6size_t"></span><span id="xRingbufferCreateNoSplit__s.s"></span><span class="target" id="ringbuf_8h_1adc44b9f85cf0b59566a8281a09010e4f"></span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferCreateNoSplit</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xItemSize</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xItemNum</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424xRingbufferCreateNoSplit6size_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a ring buffer of type RINGBUF_TYPE_NOSPLIT for a fixed item_size. </p>
<p>This API is similar to xRingbufferCreate(), but it will internally allocate additional space for the headers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xItemSize</strong> -- <strong>[in]</strong> Size of each item to be put into the ring buffer </p></li>
<li><p><strong>xItemNum</strong> -- <strong>[in]</strong> Maximum number of items the buffer needs to hold simultaneously</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A RingbufHandle_t handle to the created ring buffer, or NULL in case of error. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423xRingbufferCreateStatic6size_t16RingbufferType_tP7uint8_tP18StaticRingbuffer_t">
<span id="_CPPv323xRingbufferCreateStatic6size_t16RingbufferType_tP7uint8_tP18StaticRingbuffer_t"></span><span id="_CPPv223xRingbufferCreateStatic6size_t16RingbufferType_tP7uint8_tP18StaticRingbuffer_t"></span><span id="xRingbufferCreateStatic__s.RingbufferType_t.uint8_tP.StaticRingbuffer_tP"></span><span class="target" id="ringbuf_8h_1a32e2a9f97904e382d09af92a460e5335"></span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferCreateStatic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferSize</span></span>, <a class="reference internal" href="#_CPPv416RingbufferType_t" title="RingbufferType_t"><span class="n"><span class="pre">RingbufferType_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferType</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pucRingbufferStorage</span></span>, <a class="reference internal" href="#_CPPv418StaticRingbuffer_t" title="StaticRingbuffer_t"><span class="n"><span class="pre">StaticRingbuffer_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxStaticRingbuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423xRingbufferCreateStatic6size_t16RingbufferType_tP7uint8_tP18StaticRingbuffer_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a ring buffer but manually provide the required memory. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>xBufferSize of no-split/allow-split buffers MUST be 32-bit aligned.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xBufferSize</strong> -- <strong>[in]</strong> Size of the buffer in bytes. </p></li>
<li><p><strong>xBufferType</strong> -- <strong>[in]</strong> Type of ring buffer, see documentation </p></li>
<li><p><strong>pucRingbufferStorage</strong> -- <strong>[in]</strong> Pointer to the ring buffer's storage area. Storage area must have the same size as specified by xBufferSize </p></li>
<li><p><strong>pxStaticRingbuffer</strong> -- <strong>[in]</strong> Pointed to a struct of type StaticRingbuffer_t which will be used to hold the ring buffer's data structure</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A handle to the created ring buffer </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415xRingbufferSend15RingbufHandle_tPKv6size_t10TickType_t">
<span id="_CPPv315xRingbufferSend15RingbufHandle_tPKv6size_t10TickType_t"></span><span id="_CPPv215xRingbufferSend15RingbufHandle_tPKv6size_t10TickType_t"></span><span id="xRingbufferSend__RingbufHandle_t.voidCP.s.TickType_t"></span><span class="target" id="ringbuf_8h_1aae76440d60927e71bfe69ba8b06a6f00"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferSend</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvItem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xItemSize</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xRingbufferSend15RingbufHandle_tPKv6size_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Insert an item into the ring buffer. </p>
<p>Attempt to insert an item into the ring buffer. This function will block until enough free space is available or until it times out.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For no-split/allow-split ring buffers, the actual size of memory that the item will occupy will be rounded up to the nearest 32-bit aligned size. This is done to ensure all items are always stored in 32-bit aligned fashion. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For no-split/allow-split buffers, an xItemSize of 0 will result in an item with no data being set (i.e., item only contains the header). For byte buffers, an xItemSize of 0 will simply return pdTRUE without copying any data.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to insert the item into </p></li>
<li><p><strong>pvItem</strong> -- <strong>[in]</strong> Pointer to data to insert. NULL is allowed if xItemSize is 0. </p></li>
<li><p><strong>xItemSize</strong> -- <strong>[in]</strong> Size of data to insert. </p></li>
<li><p><strong>xTicksToWait</strong> -- <strong>[in]</strong> Ticks to wait for room in the ring buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>pdTRUE if succeeded</p></li>
<li><p>pdFALSE on time-out or when the data is larger than the maximum permissible size of the buffer </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422xRingbufferSendFromISR15RingbufHandle_tPKv6size_tP10BaseType_t">
<span id="_CPPv322xRingbufferSendFromISR15RingbufHandle_tPKv6size_tP10BaseType_t"></span><span id="_CPPv222xRingbufferSendFromISR15RingbufHandle_tPKv6size_tP10BaseType_t"></span><span id="xRingbufferSendFromISR__RingbufHandle_t.voidCP.s.BaseType_tP"></span><span class="target" id="ringbuf_8h_1ae2fd4a03b4aa32d21dd01039b3371fb0"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferSendFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvItem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xItemSize</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422xRingbufferSendFromISR15RingbufHandle_tPKv6size_tP10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Insert an item into the ring buffer in an ISR. </p>
<p>Attempt to insert an item into the ring buffer from an ISR. This function will return immediately if there is insufficient free space in the buffer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For no-split/allow-split ring buffers, the actual size of memory that the item will occupy will be rounded up to the nearest 32-bit aligned size. This is done to ensure all items are always stored in 32-bit aligned fashion. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For no-split/allow-split buffers, an xItemSize of 0 will result in an item with no data being set (i.e., item only contains the header). For byte buffers, an xItemSize of 0 will simply return pdTRUE without copying any data.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to insert the item into </p></li>
<li><p><strong>pvItem</strong> -- <strong>[in]</strong> Pointer to data to insert. NULL is allowed if xItemSize is 0. </p></li>
<li><p><strong>xItemSize</strong> -- <strong>[in]</strong> Size of data to insert. </p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- <strong>[out]</strong> Value pointed to will be set to pdTRUE if the function woke up a higher priority task.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>pdTRUE if succeeded</p></li>
<li><p>pdFALSE when the ring buffer does not have space. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422xRingbufferSendAcquire15RingbufHandle_tPPv6size_t10TickType_t">
<span id="_CPPv322xRingbufferSendAcquire15RingbufHandle_tPPv6size_t10TickType_t"></span><span id="_CPPv222xRingbufferSendAcquire15RingbufHandle_tPPv6size_t10TickType_t"></span><span id="xRingbufferSendAcquire__RingbufHandle_t.voidPP.s.TickType_t"></span><span class="target" id="ringbuf_8h_1a57a5ca9c2fb4c4c01b80377c57bf8da3"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferSendAcquire</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppvItem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xItemSize</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422xRingbufferSendAcquire15RingbufHandle_tPPv6size_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Acquire memory from the ring buffer to be written to by an external source and to be sent later. </p>
<p>Attempt to allocate buffer for an item to be sent into the ring buffer. This function will block until enough free space is available or until it times out.</p>
<p>The item, as well as the following items <code class="docutils literal notranslate"><span class="pre">SendAcquire</span></code> or <code class="docutils literal notranslate"><span class="pre">Send</span></code> after it, will not be able to be read from the ring buffer until this item is actually sent into the ring buffer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only applicable for no-split ring buffers now, the actual size of memory that the item will occupy will be rounded up to the nearest 32-bit aligned size. This is done to ensure all items are always stored in 32-bit aligned fashion. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An xItemSize of 0 will result in a buffer being acquired, but the buffer will have a size of 0.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to allocate the memory </p></li>
<li><p><strong>ppvItem</strong> -- <strong>[out]</strong> Double pointer to memory acquired (set to NULL if no memory were retrieved) </p></li>
<li><p><strong>xItemSize</strong> -- <strong>[in]</strong> Size of item to acquire. </p></li>
<li><p><strong>xTicksToWait</strong> -- <strong>[in]</strong> Ticks to wait for room in the ring buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>pdTRUE if succeeded</p></li>
<li><p>pdFALSE on time-out or when the data is larger than the maximum permissible size of the buffer </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423xRingbufferSendComplete15RingbufHandle_tPv">
<span id="_CPPv323xRingbufferSendComplete15RingbufHandle_tPv"></span><span id="_CPPv223xRingbufferSendComplete15RingbufHandle_tPv"></span><span id="xRingbufferSendComplete__RingbufHandle_t.voidP"></span><span class="target" id="ringbuf_8h_1ace112765fb813e04e07f4b001a7ec04d"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferSendComplete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvItem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423xRingbufferSendComplete15RingbufHandle_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Actually send an item into the ring buffer allocated before by <code class="docutils literal notranslate"><span class="pre">xRingbufferSendAcquire</span></code>. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only applicable for no-split ring buffers. Only call for items allocated by <code class="docutils literal notranslate"><span class="pre">xRingbufferSendAcquire</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to insert the item into </p></li>
<li><p><strong>pvItem</strong> -- <strong>[in]</strong> Pointer to item in allocated memory to insert.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>pdTRUE if succeeded</p></li>
<li><p>pdFALSE if fail for some reason. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418xRingbufferReceive15RingbufHandle_tP6size_t10TickType_t">
<span id="_CPPv318xRingbufferReceive15RingbufHandle_tP6size_t10TickType_t"></span><span id="_CPPv218xRingbufferReceive15RingbufHandle_tP6size_t10TickType_t"></span><span id="xRingbufferReceive__RingbufHandle_t.sP.TickType_t"></span><span class="target" id="ringbuf_8h_1a04b8c5a4656ca305f51598b77218cf98"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferReceive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxItemSize</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xRingbufferReceive15RingbufHandle_tP6size_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve an item from the ring buffer. </p>
<p>Attempt to retrieve an item from the ring buffer. This function will block until an item is available or until it times out.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A call to vRingbufferReturnItem() is required after this to free the item retrieved. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible to receive items with a pxItemSize of 0 on no-split buffers. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To retrieve an item from an allow-split buffer, use <code class="docutils literal notranslate"><span class="pre">xRingbufferReceiveSplit()</span></code> instead.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to retrieve the item from </p></li>
<li><p><strong>pxItemSize</strong> -- <strong>[out]</strong> Pointer to a variable to which the size of the retrieved item will be written. </p></li>
<li><p><strong>xTicksToWait</strong> -- <strong>[in]</strong> Ticks to wait for items in the ring buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>Pointer to the retrieved item on success; *pxItemSize filled with the length of the item.</p></li>
<li><p>NULL on timeout, *pxItemSize is untouched in that case. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425xRingbufferReceiveFromISR15RingbufHandle_tP6size_t">
<span id="_CPPv325xRingbufferReceiveFromISR15RingbufHandle_tP6size_t"></span><span id="_CPPv225xRingbufferReceiveFromISR15RingbufHandle_tP6size_t"></span><span id="xRingbufferReceiveFromISR__RingbufHandle_t.sP"></span><span class="target" id="ringbuf_8h_1aad1b1677260a50d1d7487557decb1f71"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferReceiveFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxItemSize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xRingbufferReceiveFromISR15RingbufHandle_tP6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve an item from the ring buffer in an ISR. </p>
<p>Attempt to retrieve an item from the ring buffer. This function returns immediately if there are no items available for retrieval</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A call to vRingbufferReturnItemFromISR() is required after this to free the item retrieved. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Byte buffers do not allow multiple retrievals before returning an item </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Two calls to RingbufferReceiveFromISR() are required if the bytes wrap around the end of the ring buffer. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible to receive items with a pxItemSize of 0 on no-split buffers. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To retrieve an item from an allow-split buffer, use <code class="docutils literal notranslate"><span class="pre">xRingbufferReceiveSplitFromISR()</span></code> instead.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to retrieve the item from </p></li>
<li><p><strong>pxItemSize</strong> -- <strong>[out]</strong> Pointer to a variable to which the size of the retrieved item will be written.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>Pointer to the retrieved item on success; *pxItemSize filled with the length of the item.</p></li>
<li><p>NULL when the ring buffer is empty, *pxItemSize is untouched in that case. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423xRingbufferReceiveSplit15RingbufHandle_tPPvPPvP6size_tP6size_t10TickType_t">
<span id="_CPPv323xRingbufferReceiveSplit15RingbufHandle_tPPvPPvP6size_tP6size_t10TickType_t"></span><span id="_CPPv223xRingbufferReceiveSplit15RingbufHandle_tPPvPPvP6size_tP6size_t10TickType_t"></span><span id="xRingbufferReceiveSplit__RingbufHandle_t.voidPP.voidPP.sP.sP.TickType_t"></span><span class="target" id="ringbuf_8h_1ac7312fcb3449a244e651d7a977063340"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferReceiveSplit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppvHeadItem</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppvTailItem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxHeadItemSize</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxTailItemSize</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423xRingbufferReceiveSplit15RingbufHandle_tPPvPPvP6size_tP6size_t10TickType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve a split item from an allow-split ring buffer. </p>
<p>Attempt to retrieve a split item from an allow-split ring buffer. If the item is not split, only a single item is retried. If the item is split, both parts will be retrieved. This function will block until an item is available or until it times out.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Call(s) to vRingbufferReturnItem() is required after this to free up the item(s) retrieved. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should only be called on allow-split buffers </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible to receive items with a pxItemSize of 0 on allow split buffers.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to retrieve the item from </p></li>
<li><p><strong>ppvHeadItem</strong> -- <strong>[out]</strong> Double pointer to first part (set to NULL if no items were retrieved) </p></li>
<li><p><strong>ppvTailItem</strong> -- <strong>[out]</strong> Double pointer to second part (set to NULL if item is not split) </p></li>
<li><p><strong>pxHeadItemSize</strong> -- <strong>[out]</strong> Pointer to size of first part (unmodified if no items were retrieved) </p></li>
<li><p><strong>pxTailItemSize</strong> -- <strong>[out]</strong> Pointer to size of second part (unmodified if item is not split) </p></li>
<li><p><strong>xTicksToWait</strong> -- <strong>[in]</strong> Ticks to wait for items in the ring buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>pdTRUE if an item (split or unsplit) was retrieved</p></li>
<li><p>pdFALSE when no item was retrieved </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430xRingbufferReceiveSplitFromISR15RingbufHandle_tPPvPPvP6size_tP6size_t">
<span id="_CPPv330xRingbufferReceiveSplitFromISR15RingbufHandle_tPPvPPvP6size_tP6size_t"></span><span id="_CPPv230xRingbufferReceiveSplitFromISR15RingbufHandle_tPPvPPvP6size_tP6size_t"></span><span id="xRingbufferReceiveSplitFromISR__RingbufHandle_t.voidPP.voidPP.sP.sP"></span><span class="target" id="ringbuf_8h_1ad0c7f63214e32ce6edc8e69cc261b305"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferReceiveSplitFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppvHeadItem</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppvTailItem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxHeadItemSize</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxTailItemSize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430xRingbufferReceiveSplitFromISR15RingbufHandle_tPPvPPvP6size_tP6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve a split item from an allow-split ring buffer in an ISR. </p>
<p>Attempt to retrieve a split item from an allow-split ring buffer. If the item is not split, only a single item is retried. If the item is split, both parts will be retrieved. This function returns immediately if there are no items available for retrieval</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls to vRingbufferReturnItemFromISR() is required after this to free up the item(s) retrieved. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should only be called on allow-split buffers </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible to receive items with a pxItemSize of 0 on allow split buffers.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to retrieve the item from </p></li>
<li><p><strong>ppvHeadItem</strong> -- <strong>[out]</strong> Double pointer to first part (set to NULL if no items were retrieved) </p></li>
<li><p><strong>ppvTailItem</strong> -- <strong>[out]</strong> Double pointer to second part (set to NULL if item is not split) </p></li>
<li><p><strong>pxHeadItemSize</strong> -- <strong>[out]</strong> Pointer to size of first part (unmodified if no items were retrieved) </p></li>
<li><p><strong>pxTailItemSize</strong> -- <strong>[out]</strong> Pointer to size of second part (unmodified if item is not split)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>pdTRUE if an item (split or unsplit) was retrieved</p></li>
<li><p>pdFALSE when no item was retrieved </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422xRingbufferReceiveUpTo15RingbufHandle_tP6size_t10TickType_t6size_t">
<span id="_CPPv322xRingbufferReceiveUpTo15RingbufHandle_tP6size_t10TickType_t6size_t"></span><span id="_CPPv222xRingbufferReceiveUpTo15RingbufHandle_tP6size_t10TickType_t6size_t"></span><span id="xRingbufferReceiveUpTo__RingbufHandle_t.sP.TickType_t.s"></span><span class="target" id="ringbuf_8h_1a6fe0eadda50464a8b16b09b38836214c"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferReceiveUpTo</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxItemSize</span></span>, <span class="n"><span class="pre">TickType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTicksToWait</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xMaxSize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422xRingbufferReceiveUpTo15RingbufHandle_tP6size_t10TickType_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve bytes from a byte buffer, specifying the maximum amount of bytes to retrieve. </p>
<p>Attempt to retrieve data from a byte buffer whilst specifying a maximum number of bytes to retrieve. This function will block until there is data available for retrieval or until it times out.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A call to vRingbufferReturnItem() is required after this to free up the data retrieved. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should only be called on byte buffers </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Byte buffers do not allow multiple retrievals before returning an item </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Two calls to RingbufferReceiveUpTo() are required if the bytes wrap around the end of the ring buffer.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to retrieve the item from </p></li>
<li><p><strong>pxItemSize</strong> -- <strong>[out]</strong> Pointer to a variable to which the size of the retrieved item will be written. </p></li>
<li><p><strong>xTicksToWait</strong> -- <strong>[in]</strong> Ticks to wait for items in the ring buffer. </p></li>
<li><p><strong>xMaxSize</strong> -- <strong>[in]</strong> Maximum number of bytes to return.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>Pointer to the retrieved item on success; *pxItemSize filled with the length of the item.</p></li>
<li><p>NULL on timeout, *pxItemSize is untouched in that case. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429xRingbufferReceiveUpToFromISR15RingbufHandle_tP6size_t6size_t">
<span id="_CPPv329xRingbufferReceiveUpToFromISR15RingbufHandle_tP6size_t6size_t"></span><span id="_CPPv229xRingbufferReceiveUpToFromISR15RingbufHandle_tP6size_t6size_t"></span><span id="xRingbufferReceiveUpToFromISR__RingbufHandle_t.sP.s"></span><span class="target" id="ringbuf_8h_1ae40574d4c2728c7c6c351e8dd47f3ae5"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferReceiveUpToFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxItemSize</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xMaxSize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429xRingbufferReceiveUpToFromISR15RingbufHandle_tP6size_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve bytes from a byte buffer, specifying the maximum amount of bytes to retrieve. Call this from an ISR. </p>
<p>Attempt to retrieve bytes from a byte buffer whilst specifying a maximum number of bytes to retrieve. This function will return immediately if there is no data available for retrieval.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A call to vRingbufferReturnItemFromISR() is required after this to free up the data received. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should only be called on byte buffers </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Byte buffers do not allow multiple retrievals before returning an item</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to retrieve the item from </p></li>
<li><p><strong>pxItemSize</strong> -- <strong>[out]</strong> Pointer to a variable to which the size of the retrieved item will be written. </p></li>
<li><p><strong>xMaxSize</strong> -- <strong>[in]</strong> Maximum number of bytes to return. Size of 0 simply returns NULL.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>Pointer to the retrieved item on success; *pxItemSize filled with the length of the item.</p></li>
<li><p>NULL when the ring buffer is empty, *pxItemSize is untouched in that case. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421vRingbufferReturnItem15RingbufHandle_tPv">
<span id="_CPPv321vRingbufferReturnItem15RingbufHandle_tPv"></span><span id="_CPPv221vRingbufferReturnItem15RingbufHandle_tPv"></span><span id="vRingbufferReturnItem__RingbufHandle_t.voidP"></span><span class="target" id="ringbuf_8h_1af722538176b8c698127696f09a1ee212"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vRingbufferReturnItem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvItem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421vRingbufferReturnItem15RingbufHandle_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return a previously-retrieved item to the ring buffer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a split item is retrieved, both parts should be returned by calling this function twice </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer the item was retrieved from </p></li>
<li><p><strong>pvItem</strong> -- <strong>[in]</strong> Item that was received earlier</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428vRingbufferReturnItemFromISR15RingbufHandle_tPvP10BaseType_t">
<span id="_CPPv328vRingbufferReturnItemFromISR15RingbufHandle_tPvP10BaseType_t"></span><span id="_CPPv228vRingbufferReturnItemFromISR15RingbufHandle_tPvP10BaseType_t"></span><span id="vRingbufferReturnItemFromISR__RingbufHandle_t.voidP.BaseType_tP"></span><span class="target" id="ringbuf_8h_1a004bf9e68ca952be9da948dd20cd841a"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vRingbufferReturnItemFromISR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvItem</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pxHigherPriorityTaskWoken</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428vRingbufferReturnItemFromISR15RingbufHandle_tPvP10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return a previously-retrieved item to the ring buffer from an ISR. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a split item is retrieved, both parts should be returned by calling this function twice </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer the item was retrieved from </p></li>
<li><p><strong>pvItem</strong> -- <strong>[in]</strong> Item that was received earlier </p></li>
<li><p><strong>pxHigherPriorityTaskWoken</strong> -- <strong>[out]</strong> Value pointed to will be set to pdTRUE if the function woke up a higher priority task.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417vRingbufferDelete15RingbufHandle_t">
<span id="_CPPv317vRingbufferDelete15RingbufHandle_t"></span><span id="_CPPv217vRingbufferDelete15RingbufHandle_t"></span><span id="vRingbufferDelete__RingbufHandle_t"></span><span class="target" id="ringbuf_8h_1aa0cb4958a06ba0051ea55de85e2e05fb"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vRingbufferDelete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417vRingbufferDelete15RingbufHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delete a ring buffer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will not deallocate any memory if the ring buffer was created using xRingbufferCreateStatic(). Deallocation must be done manually be the user. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to delete</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425xRingbufferGetMaxItemSize15RingbufHandle_t">
<span id="_CPPv325xRingbufferGetMaxItemSize15RingbufHandle_t"></span><span id="_CPPv225xRingbufferGetMaxItemSize15RingbufHandle_t"></span><span id="xRingbufferGetMaxItemSize__RingbufHandle_t"></span><span class="target" id="ringbuf_8h_1a3405e9d1e40962ac48398e1f666358da"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferGetMaxItemSize</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xRingbufferGetMaxItemSize15RingbufHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get maximum size of an item that can be placed in the ring buffer. </p>
<p>This function returns the maximum size an item can have if it was placed in an empty ring buffer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The max item size for a no-split buffer is limited to ((buffer_size/2)-header_size). This limit is imposed so that an item of max item size can always be sent to an empty no-split buffer regardless of the internal positions of the buffer's read/write/free pointers.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to query</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Maximum size, in bytes, of an item that can be placed in a ring buffer. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425xRingbufferGetCurFreeSize15RingbufHandle_t">
<span id="_CPPv325xRingbufferGetCurFreeSize15RingbufHandle_t"></span><span id="_CPPv225xRingbufferGetCurFreeSize15RingbufHandle_t"></span><span id="xRingbufferGetCurFreeSize__RingbufHandle_t"></span><span class="target" id="ringbuf_8h_1a60948d94cba0fd760393bbee276f827b"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferGetCurFreeSize</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xRingbufferGetCurFreeSize15RingbufHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get current free size available for an item/data in the buffer. </p>
<p>This gives the real time free space available for an item/data in the ring buffer. This represents the maximum size an item/data can have if it was currently sent to the ring buffer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An empty no-split buffer has a max current free size for an item that is limited to ((buffer_size/2)-header_size). See API reference for xRingbufferGetMaxItemSize().</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is not thread safe. So, if multiple threads are accessing the same ring buffer, it is the application's responsibility to ensure atomic access to this API and the subsequent Send</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to query</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Current free size, in bytes, available for an entry </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428xRingbufferAddToQueueSetRead15RingbufHandle_t16QueueSetHandle_t">
<span id="_CPPv328xRingbufferAddToQueueSetRead15RingbufHandle_t16QueueSetHandle_t"></span><span id="_CPPv228xRingbufferAddToQueueSetRead15RingbufHandle_t16QueueSetHandle_t"></span><span id="xRingbufferAddToQueueSetRead__RingbufHandle_t.QueueSetHandle_t"></span><span class="target" id="ringbuf_8h_1ae0ee852c502fdfa3e1a2dc7057200dbc"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferAddToQueueSetRead</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t"><span class="n"><span class="pre">QueueSetHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueueSet</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428xRingbufferAddToQueueSetRead15RingbufHandle_t16QueueSetHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Add the ring buffer to a queue set. Notified when data has been written to the ring buffer. </p>
<p>This function adds the ring buffer to a queue set, thus allowing a task to block on multiple queues/ring buffers. The queue set is notified when the new data becomes available to read on the ring buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to add to the queue set </p></li>
<li><p><strong>xQueueSet</strong> -- <strong>[in]</strong> Queue set to add the ring buffer to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>pdTRUE on success, pdFALSE otherwise </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418xRingbufferCanRead15RingbufHandle_t22QueueSetMemberHandle_t">
<span id="_CPPv318xRingbufferCanRead15RingbufHandle_t22QueueSetMemberHandle_t"></span><span id="_CPPv218xRingbufferCanRead15RingbufHandle_t22QueueSetMemberHandle_t"></span><span id="xRingbufferCanRead__RingbufHandle_t.QueueSetMemberHandle_t"></span><span class="target" id="ringbuf_8h_1af223ffcbd166779115f4566e2de540ab"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferCanRead</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t"><span class="n"><span class="pre">QueueSetMemberHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xMember</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xRingbufferCanRead15RingbufHandle_t22QueueSetMemberHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Check if the selected queue set member is a particular ring buffer. </p>
<p>This API checks if queue set member returned from xQueueSelectFromSet() is a particular ring buffer. If so, this indicates the ring buffer has items waiting to be retrieved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to check </p></li>
<li><p><strong>xMember</strong> -- <strong>[in]</strong> Member returned from xQueueSelectFromSet</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>pdTRUE when selected queue set member is the ring buffer</p></li>
<li><p>pdFALSE otherwise. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv433xRingbufferRemoveFromQueueSetRead15RingbufHandle_t16QueueSetHandle_t">
<span id="_CPPv333xRingbufferRemoveFromQueueSetRead15RingbufHandle_t16QueueSetHandle_t"></span><span id="_CPPv233xRingbufferRemoveFromQueueSetRead15RingbufHandle_t16QueueSetHandle_t"></span><span id="xRingbufferRemoveFromQueueSetRead__RingbufHandle_t.QueueSetHandle_t"></span><span class="target" id="ringbuf_8h_1a0723ed44659445f38f256bdae6ef6d68"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferRemoveFromQueueSetRead</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t"><span class="n"><span class="pre">QueueSetHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueueSet</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433xRingbufferRemoveFromQueueSetRead15RingbufHandle_t16QueueSetHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Remove the ring buffer from a queue set. </p>
<p>This function removes a ring buffer from a queue set. The ring buffer must have been previously added to the queue set using xRingbufferAddToQueueSetRead().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer to remove from the queue set </p></li>
<li><p><strong>xQueueSet</strong> -- <strong>[in]</strong> Queue set to remove the ring buffer from</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>pdTRUE on success</p></li>
<li><p>pdFALSE otherwise </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418vRingbufferGetInfo15RingbufHandle_tP11UBaseType_tP11UBaseType_tP11UBaseType_tP11UBaseType_tP11UBaseType_t">
<span id="_CPPv318vRingbufferGetInfo15RingbufHandle_tP11UBaseType_tP11UBaseType_tP11UBaseType_tP11UBaseType_tP11UBaseType_t"></span><span id="_CPPv218vRingbufferGetInfo15RingbufHandle_tP11UBaseType_tP11UBaseType_tP11UBaseType_tP11UBaseType_tP11UBaseType_t"></span><span id="vRingbufferGetInfo__RingbufHandle_t.UBaseType_tP.UBaseType_tP.UBaseType_tP.UBaseType_tP.UBaseType_tP"></span><span class="target" id="ringbuf_8h_1adbc87321875905b679740dc0beaa965d"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vRingbufferGetInfo</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">uxFree</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">uxRead</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">uxWrite</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">uxAcquire</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">uxItemsWaiting</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418vRingbufferGetInfo15RingbufHandle_tP11UBaseType_tP11UBaseType_tP11UBaseType_tP11UBaseType_tP11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get information about ring buffer status. </p>
<p>Get information of a ring buffer's current status such as free/read/write/acquire pointer positions, and number of items waiting to be retrieved. Arguments can be set to NULL if they are not required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer handle </p></li>
<li><p><strong>uxFree</strong> -- <strong>[out]</strong> Pointer use to store free pointer position </p></li>
<li><p><strong>uxRead</strong> -- <strong>[out]</strong> Pointer use to store read pointer position </p></li>
<li><p><strong>uxWrite</strong> -- <strong>[out]</strong> Pointer use to store write pointer position </p></li>
<li><p><strong>uxAcquire</strong> -- <strong>[out]</strong> Pointer use to store acquire pointer position </p></li>
<li><p><strong>uxItemsWaiting</strong> -- <strong>[out]</strong> Pointer use to store number of items (bytes for byte buffer) waiting to be retrieved </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420xRingbufferPrintInfo15RingbufHandle_t">
<span id="_CPPv320xRingbufferPrintInfo15RingbufHandle_t"></span><span id="_CPPv220xRingbufferPrintInfo15RingbufHandle_t"></span><span id="xRingbufferPrintInfo__RingbufHandle_t"></span><span class="target" id="ringbuf_8h_1a37d2f839cf6cc1bc3eaea0f5e360214a"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferPrintInfo</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xRingbufferPrintInfo15RingbufHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Debugging function to print the internal pointers in the ring buffer. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xRingbuffer</strong> -- Ring buffer to show </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426xRingbufferGetStaticBuffer15RingbufHandle_tPP7uint8_tPP18StaticRingbuffer_t">
<span id="_CPPv326xRingbufferGetStaticBuffer15RingbufHandle_tPP7uint8_tPP18StaticRingbuffer_t"></span><span id="_CPPv226xRingbufferGetStaticBuffer15RingbufHandle_tPP7uint8_tPP18StaticRingbuffer_t"></span><span id="xRingbufferGetStaticBuffer__RingbufHandle_t.uint8_tPP.StaticRingbuffer_tPP"></span><span class="target" id="ringbuf_8h_1a77fa5c2cce4c607ef4cc488c3c7a5221"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferGetStaticBuffer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppucRingbufferStorage</span></span>, <a class="reference internal" href="#_CPPv418StaticRingbuffer_t" title="StaticRingbuffer_t"><span class="n"><span class="pre">StaticRingbuffer_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ppxStaticRingbuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426xRingbufferGetStaticBuffer15RingbufHandle_tPP7uint8_tPP18StaticRingbuffer_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Retrieve the pointers to a statically created ring buffer. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xRingbuffer</strong> -- <strong>[in]</strong> Ring buffer </p></li>
<li><p><strong>ppucRingbufferStorage</strong> -- <strong>[out]</strong> Used to return a pointer to the queue's storage area buffer </p></li>
<li><p><strong>ppxStaticRingbuffer</strong> -- <strong>[out]</strong> Used to return a pointer to the queue's data structure buffer </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdTRUE if buffers were retrieved, pdFALSE otherwise. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425xRingbufferCreateWithCaps6size_t16RingbufferType_t11UBaseType_t">
<span id="_CPPv325xRingbufferCreateWithCaps6size_t16RingbufferType_t11UBaseType_t"></span><span id="_CPPv225xRingbufferCreateWithCaps6size_t16RingbufferType_t11UBaseType_t"></span><span id="xRingbufferCreateWithCaps__s.RingbufferType_t.UBaseType_t"></span><span class="target" id="ringbuf_8h_1a923a58cd0d36b5658f13c1b523ceaa00"></span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xRingbufferCreateWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferSize</span></span>, <a class="reference internal" href="#_CPPv416RingbufferType_t" title="RingbufferType_t"><span class="n"><span class="pre">RingbufferType_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferType</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xRingbufferCreateWithCaps6size_t16RingbufferType_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a ring buffer with specific memory capabilities. </p>
<p>This function is similar to xRingbufferCreate(), except that it allows the memory allocated for the ring buffer to have specific capabilities (e.g., MALLOC_CAP_INTERNAL).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A queue created using this function must only be deleted using vRingbufferDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xBufferSize</strong> -- <strong>[in]</strong> Size of the buffer in bytes </p></li>
<li><p><strong>xBufferType</strong> -- <strong>[in]</strong> Type of ring buffer, see documentation. </p></li>
<li><p><strong>uxMemoryCaps</strong> -- <strong>[in]</strong> Memory capabilities of the queue's memory (see esp_heap_caps.h) </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created ring buffer or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425vRingbufferDeleteWithCaps15RingbufHandle_t">
<span id="_CPPv325vRingbufferDeleteWithCaps15RingbufHandle_t"></span><span id="_CPPv225vRingbufferDeleteWithCaps15RingbufHandle_t"></span><span id="vRingbufferDeleteWithCaps__RingbufHandle_t"></span><span class="target" id="ringbuf_8h_1a5229eb5f2cd5d2de49d118f8259cba07"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vRingbufferDeleteWithCaps</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415RingbufHandle_t" title="RingbufHandle_t"><span class="n"><span class="pre">RingbufHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xRingbuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425vRingbufferDeleteWithCaps15RingbufHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deletes a ring buffer previously created using xRingbufferCreateWithCaps() </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xRingbuffer</strong> -- Ring buffer </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv418xSTATIC_RINGBUFFER">
<span id="_CPPv318xSTATIC_RINGBUFFER"></span><span id="_CPPv218xSTATIC_RINGBUFFER"></span><span id="xSTATIC_RINGBUFFER"></span><span class="target" id="structxSTATIC__RINGBUFFER"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xSTATIC_RINGBUFFER</span></span></span><a class="headerlink" href="#_CPPv418xSTATIC_RINGBUFFER" title="Permalink to this definition"></a><br /></dt>
<dd><p>Struct that is equivalent in size to the ring buffer's data structure. </p>
<p>The contents of this struct are not meant to be used directly. This structure is meant to be used when creating a statically allocated ring buffer where this struct is of the exact size required to store a ring buffer's control data structure. </p>
</dd></dl>

</section>
<section id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv415RingbufHandle_t">
<span id="_CPPv315RingbufHandle_t"></span><span id="_CPPv215RingbufHandle_t"></span><span id="RingbufHandle_t"></span><span class="target" id="ringbuf_8h_1a57eefbea78587c4e9100305df739b9aa"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">RingbufHandle_t</span></span></span><a class="headerlink" href="#_CPPv415RingbufHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type by which ring buffers are referenced. For example, a call to xRingbufferCreate() returns a RingbufHandle_t variable that can then be used as a parameter to xRingbufferSend(), xRingbufferReceive(), etc. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv418StaticRingbuffer_t">
<span id="_CPPv318StaticRingbuffer_t"></span><span id="_CPPv218StaticRingbuffer_t"></span><span id="StaticRingbuffer_t"></span><span class="target" id="ringbuf_8h_1afa2f979059008ce5dd8fc6264d583f6c"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv418xSTATIC_RINGBUFFER" title="xSTATIC_RINGBUFFER"><span class="n"><span class="pre">xSTATIC_RINGBUFFER</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StaticRingbuffer_t</span></span></span><a class="headerlink" href="#_CPPv418StaticRingbuffer_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Struct that is equivalent in size to the ring buffer's data structure. </p>
<p>The contents of this struct are not meant to be used directly. This structure is meant to be used when creating a statically allocated ring buffer where this struct is of the exact size required to store a ring buffer's control data structure. </p>
</dd></dl>

</section>
<section id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv416RingbufferType_t">
<span id="_CPPv316RingbufferType_t"></span><span id="_CPPv216RingbufferType_t"></span><span class="target" id="ringbuf_8h_1a9b67bb7faec2a6c56a77dad316713601"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RingbufferType_t</span></span></span><a class="headerlink" href="#_CPPv416RingbufferType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16RingbufferType_t20RINGBUF_TYPE_NOSPLITE">
<span id="_CPPv3N16RingbufferType_t20RINGBUF_TYPE_NOSPLITE"></span><span id="_CPPv2N16RingbufferType_t20RINGBUF_TYPE_NOSPLITE"></span><span class="target" id="ringbuf_8h_1a9b67bb7faec2a6c56a77dad316713601a4700d6ba21034ff3879696f6dac47b20"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RINGBUF_TYPE_NOSPLIT</span></span></span><a class="headerlink" href="#_CPPv4N16RingbufferType_t20RINGBUF_TYPE_NOSPLITE" title="Permalink to this definition"></a><br /></dt>
<dd><p>No-split buffers will only store an item in contiguous memory and will never split an item. Each item requires an 8 byte overhead for a header and will always internally occupy a 32-bit aligned size of space. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16RingbufferType_t23RINGBUF_TYPE_ALLOWSPLITE">
<span id="_CPPv3N16RingbufferType_t23RINGBUF_TYPE_ALLOWSPLITE"></span><span id="_CPPv2N16RingbufferType_t23RINGBUF_TYPE_ALLOWSPLITE"></span><span class="target" id="ringbuf_8h_1a9b67bb7faec2a6c56a77dad316713601a7b750ce25a4aac338048d6fbd21d8aa3"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RINGBUF_TYPE_ALLOWSPLIT</span></span></span><a class="headerlink" href="#_CPPv4N16RingbufferType_t23RINGBUF_TYPE_ALLOWSPLITE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Allow-split buffers will split an item into two parts if necessary in order to store it. Each item requires an 8 byte overhead for a header, splitting incurs an extra header. Each item will always internally occupy a 32-bit aligned size of space. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16RingbufferType_t20RINGBUF_TYPE_BYTEBUFE">
<span id="_CPPv3N16RingbufferType_t20RINGBUF_TYPE_BYTEBUFE"></span><span id="_CPPv2N16RingbufferType_t20RINGBUF_TYPE_BYTEBUFE"></span><span class="target" id="ringbuf_8h_1a9b67bb7faec2a6c56a77dad316713601aba9f519440156ddcc5c0188baaf04978"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RINGBUF_TYPE_BYTEBUF</span></span></span><a class="headerlink" href="#_CPPv4N16RingbufferType_t20RINGBUF_TYPE_BYTEBUFE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Byte buffers store data as a sequence of bytes and do not maintain separate items, therefore byte buffers have no overhead. All data is stored as a sequence of byte and any number of bytes can be sent or retrieved each time. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N16RingbufferType_t16RINGBUF_TYPE_MAXE">
<span id="_CPPv3N16RingbufferType_t16RINGBUF_TYPE_MAXE"></span><span id="_CPPv2N16RingbufferType_t16RINGBUF_TYPE_MAXE"></span><span class="target" id="ringbuf_8h_1a9b67bb7faec2a6c56a77dad316713601aab942f5bceafde09595cf0154d712118"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RINGBUF_TYPE_MAX</span></span></span><a class="headerlink" href="#_CPPv4N16RingbufferType_t16RINGBUF_TYPE_MAXE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="hooks-api">
<h3>Hooks API<a class="headerlink" href="#hooks-api" title="Permalink to this heading"></a></h3>
</section>
<section id="id1">
<h3>Header File<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/esp_system/include/esp_freertos_hooks.h">components/esp_system/include/esp_freertos_hooks.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_freertos_hooks.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id2">
<h3>Functions<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv439esp_register_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t">
<span id="_CPPv339esp_register_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t"></span><span id="_CPPv239esp_register_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t"></span><span id="esp_register_freertos_idle_hook_for_cpu__esp_freertos_idle_cb_t.UBaseType_t"></span><span class="target" id="esp__freertos__hooks_8h_1a87dc39c473fc99a7f2a2b6e501dc10da"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_register_freertos_idle_hook_for_cpu</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422esp_freertos_idle_cb_t" title="esp_freertos_idle_cb_t"><span class="n"><span class="pre">esp_freertos_idle_cb_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">new_idle_cb</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">cpuid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv439esp_register_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Register a callback to be called from the specified core's idle hook. The callback should return true if it should be called by the idle hook once per interrupt (or FreeRTOS tick), and return false if it should be called repeatedly as fast as possible by the idle hook. </p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Idle callbacks MUST NOT, UNDER ANY CIRCUMSTANCES, CALL A FUNCTION THAT MIGHT BLOCK.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_idle_cb</strong> -- <strong>[in]</strong> Callback to be called </p></li>
<li><p><strong>cpuid</strong> -- <strong>[in]</strong> id of the core</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Callback registered to the specified core's idle hook</p></li>
<li><p>ESP_ERR_NO_MEM: No more space on the specified core's idle hook to register callback</p></li>
<li><p>ESP_ERR_INVALID_ARG: cpuid is invalid </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431esp_register_freertos_idle_hook22esp_freertos_idle_cb_t">
<span id="_CPPv331esp_register_freertos_idle_hook22esp_freertos_idle_cb_t"></span><span id="_CPPv231esp_register_freertos_idle_hook22esp_freertos_idle_cb_t"></span><span id="esp_register_freertos_idle_hook__esp_freertos_idle_cb_t"></span><span class="target" id="esp__freertos__hooks_8h_1ab55049fb96c8f817891fe37f103f1c6e"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_register_freertos_idle_hook</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422esp_freertos_idle_cb_t" title="esp_freertos_idle_cb_t"><span class="n"><span class="pre">esp_freertos_idle_cb_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">new_idle_cb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431esp_register_freertos_idle_hook22esp_freertos_idle_cb_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Register a callback to the idle hook of the core that calls this function. The callback should return true if it should be called by the idle hook once per interrupt (or FreeRTOS tick), and return false if it should be called repeatedly as fast as possible by the idle hook. </p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Idle callbacks MUST NOT, UNDER ANY CIRCUMSTANCES, CALL A FUNCTION THAT MIGHT BLOCK.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>new_idle_cb</strong> -- <strong>[in]</strong> Callback to be called</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Callback registered to the calling core's idle hook</p></li>
<li><p>ESP_ERR_NO_MEM: No more space on the calling core's idle hook to register callback </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv439esp_register_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t">
<span id="_CPPv339esp_register_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t"></span><span id="_CPPv239esp_register_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t"></span><span id="esp_register_freertos_tick_hook_for_cpu__esp_freertos_tick_cb_t.UBaseType_t"></span><span class="target" id="esp__freertos__hooks_8h_1a9024955b8cc10aeca2623da338095fb6"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_register_freertos_tick_hook_for_cpu</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422esp_freertos_tick_cb_t" title="esp_freertos_tick_cb_t"><span class="n"><span class="pre">esp_freertos_tick_cb_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">new_tick_cb</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">cpuid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv439esp_register_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Register a callback to be called from the specified core's tick hook. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_tick_cb</strong> -- <strong>[in]</strong> Callback to be called </p></li>
<li><p><strong>cpuid</strong> -- <strong>[in]</strong> id of the core</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Callback registered to specified core's tick hook</p></li>
<li><p>ESP_ERR_NO_MEM: No more space on the specified core's tick hook to register the callback</p></li>
<li><p>ESP_ERR_INVALID_ARG: cpuid is invalid </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431esp_register_freertos_tick_hook22esp_freertos_tick_cb_t">
<span id="_CPPv331esp_register_freertos_tick_hook22esp_freertos_tick_cb_t"></span><span id="_CPPv231esp_register_freertos_tick_hook22esp_freertos_tick_cb_t"></span><span id="esp_register_freertos_tick_hook__esp_freertos_tick_cb_t"></span><span class="target" id="esp__freertos__hooks_8h_1a47511f75aba5a67833f1b8edeb4d32de"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_register_freertos_tick_hook</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422esp_freertos_tick_cb_t" title="esp_freertos_tick_cb_t"><span class="n"><span class="pre">esp_freertos_tick_cb_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">new_tick_cb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431esp_register_freertos_tick_hook22esp_freertos_tick_cb_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Register a callback to be called from the calling core's tick hook. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>new_tick_cb</strong> -- <strong>[in]</strong> Callback to be called</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Callback registered to the calling core's tick hook</p></li>
<li><p>ESP_ERR_NO_MEM: No more space on the calling core's tick hook to register the callback </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv441esp_deregister_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t">
<span id="_CPPv341esp_deregister_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t"></span><span id="_CPPv241esp_deregister_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t"></span><span id="esp_deregister_freertos_idle_hook_for_cpu__esp_freertos_idle_cb_t.UBaseType_t"></span><span class="target" id="esp__freertos__hooks_8h_1a45641edb39639eafea05008636295f52"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_deregister_freertos_idle_hook_for_cpu</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422esp_freertos_idle_cb_t" title="esp_freertos_idle_cb_t"><span class="n"><span class="pre">esp_freertos_idle_cb_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">old_idle_cb</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">cpuid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv441esp_deregister_freertos_idle_hook_for_cpu22esp_freertos_idle_cb_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Unregister an idle callback from the idle hook of the specified core. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>old_idle_cb</strong> -- <strong>[in]</strong> Callback to be unregistered </p></li>
<li><p><strong>cpuid</strong> -- <strong>[in]</strong> id of the core </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv433esp_deregister_freertos_idle_hook22esp_freertos_idle_cb_t">
<span id="_CPPv333esp_deregister_freertos_idle_hook22esp_freertos_idle_cb_t"></span><span id="_CPPv233esp_deregister_freertos_idle_hook22esp_freertos_idle_cb_t"></span><span id="esp_deregister_freertos_idle_hook__esp_freertos_idle_cb_t"></span><span class="target" id="esp__freertos__hooks_8h_1ae2769a1322cae5d34f64ed495d1d9528"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_deregister_freertos_idle_hook</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422esp_freertos_idle_cb_t" title="esp_freertos_idle_cb_t"><span class="n"><span class="pre">esp_freertos_idle_cb_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">old_idle_cb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433esp_deregister_freertos_idle_hook22esp_freertos_idle_cb_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Unregister an idle callback. If the idle callback is registered to the idle hooks of both cores, the idle hook will be unregistered from both cores. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>old_idle_cb</strong> -- <strong>[in]</strong> Callback to be unregistered </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv441esp_deregister_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t">
<span id="_CPPv341esp_deregister_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t"></span><span id="_CPPv241esp_deregister_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t"></span><span id="esp_deregister_freertos_tick_hook_for_cpu__esp_freertos_tick_cb_t.UBaseType_t"></span><span class="target" id="esp__freertos__hooks_8h_1abe394025617a8d2bf65d8409267d3a81"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_deregister_freertos_tick_hook_for_cpu</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422esp_freertos_tick_cb_t" title="esp_freertos_tick_cb_t"><span class="n"><span class="pre">esp_freertos_tick_cb_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">old_tick_cb</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">cpuid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv441esp_deregister_freertos_tick_hook_for_cpu22esp_freertos_tick_cb_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Unregister a tick callback from the tick hook of the specified core. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>old_tick_cb</strong> -- <strong>[in]</strong> Callback to be unregistered </p></li>
<li><p><strong>cpuid</strong> -- <strong>[in]</strong> id of the core </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv433esp_deregister_freertos_tick_hook22esp_freertos_tick_cb_t">
<span id="_CPPv333esp_deregister_freertos_tick_hook22esp_freertos_tick_cb_t"></span><span id="_CPPv233esp_deregister_freertos_tick_hook22esp_freertos_tick_cb_t"></span><span id="esp_deregister_freertos_tick_hook__esp_freertos_tick_cb_t"></span><span class="target" id="esp__freertos__hooks_8h_1a60462b97f1ae4e7eb4a779584025b344"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">esp_deregister_freertos_tick_hook</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422esp_freertos_tick_cb_t" title="esp_freertos_tick_cb_t"><span class="n"><span class="pre">esp_freertos_tick_cb_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">old_tick_cb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433esp_deregister_freertos_tick_hook22esp_freertos_tick_cb_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Unregister a tick callback. If the tick callback is registered to the tick hooks of both cores, the tick hook will be unregistered from both cores. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>old_tick_cb</strong> -- <strong>[in]</strong> Callback to be unregistered </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id3">
<h3>Type Definitions<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv422esp_freertos_idle_cb_t">
<span id="_CPPv322esp_freertos_idle_cb_t"></span><span id="_CPPv222esp_freertos_idle_cb_t"></span><span id="esp_freertos_idle_cb_t"></span><span class="target" id="esp__freertos__hooks_8h_1ae00fd6bd0ddcd1d133085a3a9b7a2e7c"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">esp_freertos_idle_cb_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv422esp_freertos_idle_cb_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv422esp_freertos_tick_cb_t">
<span id="_CPPv322esp_freertos_tick_cb_t"></span><span id="_CPPv222esp_freertos_tick_cb_t"></span><span id="esp_freertos_tick_cb_t"></span><span class="target" id="esp__freertos__hooks_8h_1a244a5807ba8e23331818b8bd5e0340f3"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">esp_freertos_tick_cb_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv422esp_freertos_tick_cb_t" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
<section id="additional-api">
<h3>Additional API<a class="headerlink" href="#additional-api" title="Permalink to this heading"></a></h3>
</section>
<section id="id4">
<h3>Header File<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/freertos/esp_additions/include/freertos/idf_additions.h">components/freertos/esp_additions/include/freertos/idf_additions.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;freertos/idf_additions.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id5">
<h3>Functions<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t">
<span id="_CPPv323xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t"></span><span id="_CPPv223xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t"></span><span id="xTaskCreatePinnedToCore__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.TaskHandle_tPC.BaseType_tC"></span><span class="target" id="idf__additions_8h_1acda690830b570d0be14b3f29927f1429"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskCreatePinnedToCore</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TaskFunction_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTaskCode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pcName</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ulStackDepth</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvParameters</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxPriority</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxCreatedTask</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xCoreID</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a new task that is pinned to a particular core. </p>
<p>This function is similar to xTaskCreate(), but allows the creation of a pinned task. The task's pinned core is specified by the xCoreID argument. If xCoreID is set to tskNO_AFFINITY, then the task is unpinned and can run on any core.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If ( configNUMBER_OF_CORES == 1 ), setting xCoreID to tskNO_AFFINITY will be be treated as 0.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxTaskCode</strong> -- Pointer to the task entry function. </p></li>
<li><p><strong>pcName</strong> -- A descriptive name for the task. </p></li>
<li><p><strong>ulStackDepth</strong> -- The size of the task stack specified as the NUMBER OF BYTES. Note that this differs from vanilla FreeRTOS. </p></li>
<li><p><strong>pvParameters</strong> -- Pointer that will be used as the parameter for the task being created. </p></li>
<li><p><strong>uxPriority</strong> -- The priority at which the task should run. </p></li>
<li><p><strong>pxCreatedTask</strong> -- Used to pass back a handle by which the created task can be referenced. </p></li>
<li><p><strong>xCoreID</strong> -- The core to which the task is pinned to, or tskNO_AFFINITY if the task has no core affinity. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t">
<span id="_CPPv329xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t"></span><span id="_CPPv229xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t"></span><span id="xTaskCreateStaticPinnedToCore__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.StackType_tPC.StaticTask_tPC.BaseType_tC"></span><span class="target" id="idf__additions_8h_1a2cc11e3a87fa5d3ee5ab20c4b493e384"></span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskCreateStaticPinnedToCore</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TaskFunction_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTaskCode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pcName</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ulStackDepth</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvParameters</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxPriority</span></span>, <span class="n"><span class="pre">StackType_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">puxStackBuffer</span></span>, <span class="n"><span class="pre">StaticTask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pxTaskBuffer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xCoreID</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a new static task that is pinned to a particular core. </p>
<p>This function is similar to xTaskCreateStatic(), but allows the creation of a pinned task. The task's pinned core is specified by the xCoreID argument. If xCoreID is set to tskNO_AFFINITY, then the task is unpinned and can run on any core.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If ( configNUMBER_OF_CORES == 1 ), setting xCoreID to tskNO_AFFINITY will be be treated as 0.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxTaskCode</strong> -- Pointer to the task entry function. </p></li>
<li><p><strong>pcName</strong> -- A descriptive name for the task. </p></li>
<li><p><strong>ulStackDepth</strong> -- The size of the task stack specified as the NUMBER OF BYTES. Note that this differs from vanilla FreeRTOS. </p></li>
<li><p><strong>pvParameters</strong> -- Pointer that will be used as the parameter for the task being created. </p></li>
<li><p><strong>uxPriority</strong> -- The priority at which the task should run. </p></li>
<li><p><strong>puxStackBuffer</strong> -- Must point to a StackType_t array that has at least ulStackDepth indexes </p></li>
<li><p><strong>pxTaskBuffer</strong> -- Must point to a variable of type StaticTask_t, which will then be used to hold the task's data structures, </p></li>
<li><p><strong>xCoreID</strong> -- The core to which the task is pinned to, or tskNO_AFFINITY if the task has no core affinity. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The task handle if the task was created, NULL otherwise. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414xTaskGetCoreID12TaskHandle_t">
<span id="_CPPv314xTaskGetCoreID12TaskHandle_t"></span><span id="_CPPv214xTaskGetCoreID12TaskHandle_t"></span><span id="xTaskGetCoreID__TaskHandle_t"></span><span class="target" id="idf__additions_8h_1a58eee914f1591b220693f71fb242fc0e"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGetCoreID</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414xTaskGetCoreID12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get the current core ID of a particular task. </p>
<p>Helper function to get the core ID of a particular task. If the task is pinned to a particular core, the core ID is returned. If the task is not pinned to a particular core, tskNO_AFFINITY is returned.</p>
<p>If CONFIG_FREERTOS_UNICORE is enabled, this function simply returns 0.</p>
<p>[refactor-todo] See if this needs to be deprecated (IDF-8145)(IDF-8164)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If CONFIG_FREERTOS_SMP is enabled, please call vTaskCoreAffinityGet() instead. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In IDF FreerTOS when configNUMBER_OF_CORES == 1, this function will always return 0, </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTask</strong> -- The task to query </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The task's core ID or tskNO_AFFINITY </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv432xTaskGetCurrentTaskHandleForCore10BaseType_t">
<span id="_CPPv332xTaskGetCurrentTaskHandleForCore10BaseType_t"></span><span id="_CPPv232xTaskGetCurrentTaskHandleForCore10BaseType_t"></span><span id="xTaskGetCurrentTaskHandleForCore__BaseType_t"></span><span class="target" id="idf__additions_8h_1ac6c0f4e5673ef049871e6968d5d4bf78"></span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskGetCurrentTaskHandleForCore</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xCoreID</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432xTaskGetCurrentTaskHandleForCore10BaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get the handle of the task currently running on a certain core. </p>
<p>Because of the nature of SMP processing, there is no guarantee that this value will still be valid on return and should only be used for debugging purposes.</p>
<p>[refactor-todo] See if this needs to be deprecated (IDF-8145)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xCoreID</strong> -- The core to query </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle of the current task running on the queried core </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419pxTaskGetStackStart12TaskHandle_t">
<span id="_CPPv319pxTaskGetStackStart12TaskHandle_t"></span><span id="_CPPv219pxTaskGetStackStart12TaskHandle_t"></span><span id="pxTaskGetStackStart__TaskHandle_t"></span><span class="target" id="idf__additions_8h_1a63547e6347bfe6117dc2e9b403399810"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pxTaskGetStackStart</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419pxTaskGetStackStart12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Returns the start of the stack associated with xTask.</p>
<p>Returns the lowest stack memory address, regardless of whether the stack grows up or down.</p>
<p>[refactor-todo] Change return type to StackType_t (IDF-8158)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTask</strong> -- Handle of the task associated with the stack returned. Set xTask to NULL to return the stack of the calling task.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pointer to the start of the stack. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv447vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t">
<span id="_CPPv347vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t"></span><span id="_CPPv247vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t"></span><span id="vTaskSetThreadLocalStoragePointerAndDelCallback__TaskHandle_t.BaseType_t.voidP.TlsDeleteCallbackFunction_t"></span><span class="target" id="idf__additions_8h_1ae29bfc51bcf923b80f2d2598c3b51dcd"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskSetThreadLocalStoragePointerAndDelCallback</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToSet</span></span>, <span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xIndex</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvValue</span></span>, <a class="reference internal" href="#_CPPv427TlsDeleteCallbackFunction_t" title="TlsDeleteCallbackFunction_t"><span class="n"><span class="pre">TlsDeleteCallbackFunction_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pvDelCallback</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv447vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set local storage pointer and deletion callback.</p>
<p>Each task contains an array of pointers that is dimensioned by the configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h. The kernel does not use the pointers itself, so the application writer can use the pointers for any purpose they wish.</p>
<p>Local storage pointers set for a task can reference dynamically allocated resources. This function is similar to vTaskSetThreadLocalStoragePointer, but provides a way to release these resources when the task gets deleted. For each pointer, a callback function can be set. This function will be called when task is deleted, with the local storage pointer index and value as arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xTaskToSet</strong> -- Task to set thread local storage pointer for </p></li>
<li><p><strong>xIndex</strong> -- The index of the pointer to set, from 0 to configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1. </p></li>
<li><p><strong>pvValue</strong> -- Pointer value to set. </p></li>
<li><p><strong>pvDelCallback</strong> -- Function to call to dispose of the local storage pointer when the task is deleted. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431xTaskCreatePinnedToCoreWithCaps14TaskFunction_tPCKcK22configSTACK_DEPTH_TYPEPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t11UBaseType_t">
<span id="_CPPv331xTaskCreatePinnedToCoreWithCaps14TaskFunction_tPCKcK22configSTACK_DEPTH_TYPEPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t11UBaseType_t"></span><span id="_CPPv231xTaskCreatePinnedToCoreWithCaps14TaskFunction_tPCKcK22configSTACK_DEPTH_TYPEPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t11UBaseType_t"></span><span id="xTaskCreatePinnedToCoreWithCaps__TaskFunction_t.cCPC.configSTACK_DEPTH_TYPEC.voidPC.UBaseType_t.TaskHandle_tPC.BaseType_tC.UBaseType_t"></span><span class="target" id="idf__additions_8h_1a00023c3d2485fda2bda6fbed3647509a"></span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskCreatePinnedToCoreWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TaskFunction_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvTaskCode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pcName</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">configSTACK_DEPTH_TYPE</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">usStackDepth</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvParameters</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxPriority</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvCreatedTask</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xCoreID</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431xTaskCreatePinnedToCoreWithCaps14TaskFunction_tPCKcK22configSTACK_DEPTH_TYPEPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a pinned task where its stack has specific memory capabilities. </p>
<p>This function is similar to xTaskCreatePinnedToCore(), except that it allows the memory allocated for the task's stack to have specific capabilities (e.g., MALLOC_CAP_SPIRAM).</p>
<p>However, the specified capabilities will NOT apply to the task's TCB as a TCB must always be in internal RAM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pvTaskCode</strong> -- Pointer to the task entry function </p></li>
<li><p><strong>pcName</strong> -- A descriptive name for the task </p></li>
<li><p><strong>usStackDepth</strong> -- The size of the task stack specified as the number of bytes </p></li>
<li><p><strong>pvParameters</strong> -- Pointer that will be used as the parameter for the task being created. </p></li>
<li><p><strong>uxPriority</strong> -- The priority at which the task should run. </p></li>
<li><p><strong>pvCreatedTask</strong> -- Used to pass back a handle by which the created task can be referenced. </p></li>
<li><p><strong>xCoreID</strong> -- Core to which the task is pinned to, or tskNO_AFFINITY if unpinned. </p></li>
<li><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the task stack's memory (see esp_heap_caps.h) </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419xTaskCreateWithCaps14TaskFunction_tPCKc22configSTACK_DEPTH_TYPEPCv11UBaseType_tP12TaskHandle_t11UBaseType_t">
<span id="_CPPv319xTaskCreateWithCaps14TaskFunction_tPCKc22configSTACK_DEPTH_TYPEPCv11UBaseType_tP12TaskHandle_t11UBaseType_t"></span><span id="_CPPv219xTaskCreateWithCaps14TaskFunction_tPCKc22configSTACK_DEPTH_TYPEPCv11UBaseType_tP12TaskHandle_t11UBaseType_t"></span><span id="xTaskCreateWithCaps__TaskFunction_t.cCPC.configSTACK_DEPTH_TYPE.voidPC.UBaseType_t.TaskHandle_tP.UBaseType_t"></span><span class="target" id="idf__additions_8h_1a71c5683bcc2aee371689b4d446d7c319"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">BaseType_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xTaskCreateWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TaskFunction_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvTaskCode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pcName</span></span>, <span class="n"><span class="pre">configSTACK_DEPTH_TYPE</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">usStackDepth</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pvParameters</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxPriority</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pvCreatedTask</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xTaskCreateWithCaps14TaskFunction_tPCKc22configSTACK_DEPTH_TYPEPCv11UBaseType_tP12TaskHandle_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a task where its stack has specific memory capabilities. </p>
<p>This function is similar to xTaskCreate(), except that it allows the memory allocated for the task's stack to have specific capabilities (e.g., MALLOC_CAP_SPIRAM).</p>
<p>However, the specified capabilities will NOT apply to the task's TCB as a TCB must always be in internal RAM.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A task created using this function must only be deleted using vTaskDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pvTaskCode</strong> -- Pointer to the task entry function </p></li>
<li><p><strong>pcName</strong> -- A descriptive name for the task </p></li>
<li><p><strong>usStackDepth</strong> -- The size of the task stack specified as the number of bytes </p></li>
<li><p><strong>pvParameters</strong> -- Pointer that will be used as the parameter for the task being created. </p></li>
<li><p><strong>uxPriority</strong> -- The priority at which the task should run. </p></li>
<li><p><strong>pvCreatedTask</strong> -- Used to pass back a handle by which the created task can be referenced. </p></li>
<li><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the task stack's memory (see esp_heap_caps.h) </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419vTaskDeleteWithCaps12TaskHandle_t">
<span id="_CPPv319vTaskDeleteWithCaps12TaskHandle_t"></span><span id="_CPPv219vTaskDeleteWithCaps12TaskHandle_t"></span><span id="vTaskDeleteWithCaps__TaskHandle_t"></span><span class="target" id="idf__additions_8h_1a013264bd81abfab166735c593bf2e901"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vTaskDeleteWithCaps</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xTaskToDelete</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419vTaskDeleteWithCaps12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deletes a task previously created using xTaskCreateWithCaps() or xTaskCreatePinnedToCoreWithCaps() </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is recommended to use this API to delete tasks from another task's context, rather than self-deletion. When the task is being deleted, it is vital to ensure that it is not running on another core. This API must not be called from an interrupt context.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xTaskToDelete</strong> -- A handle to the task to be deleted </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420xQueueCreateWithCaps11UBaseType_t11UBaseType_t11UBaseType_t">
<span id="_CPPv320xQueueCreateWithCaps11UBaseType_t11UBaseType_t11UBaseType_t"></span><span id="_CPPv220xQueueCreateWithCaps11UBaseType_t11UBaseType_t11UBaseType_t"></span><span id="xQueueCreateWithCaps__UBaseType_t.UBaseType_t.UBaseType_t"></span><span class="target" id="idf__additions_8h_1a125c58bb67aee22a6b2627eae716f9ac"></span><a class="reference internal" href="freertos_idf.html#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xQueueCreateWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxQueueLength</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxItemSize</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xQueueCreateWithCaps11UBaseType_t11UBaseType_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a queue with specific memory capabilities. </p>
<p>This function is similar to xQueueCreate(), except that it allows the memory allocated for the queue to have specific capabilities (e.g., MALLOC_CAP_INTERNAL).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A queue created using this function must only be deleted using vQueueDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uxQueueLength</strong> -- The maximum number of items that the queue can contain. </p></li>
<li><p><strong>uxItemSize</strong> -- The number of bytes each item in the queue will require. </p></li>
<li><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the queue's memory (see esp_heap_caps.h) </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created queue or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420vQueueDeleteWithCaps13QueueHandle_t">
<span id="_CPPv320vQueueDeleteWithCaps13QueueHandle_t"></span><span id="_CPPv220vQueueDeleteWithCaps13QueueHandle_t"></span><span id="vQueueDeleteWithCaps__QueueHandle_t"></span><span class="target" id="idf__additions_8h_1a77ac787a59526cab4f878e1e85cf470b"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vQueueDeleteWithCaps</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="freertos_idf.html#_CPPv413QueueHandle_t" title="QueueHandle_t"><span class="n"><span class="pre">QueueHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xQueue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420vQueueDeleteWithCaps13QueueHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deletes a queue previously created using xQueueCreateWithCaps() </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xQueue</strong> -- A handle to the queue to be deleted. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430xSemaphoreCreateBinaryWithCaps11UBaseType_t">
<span id="_CPPv330xSemaphoreCreateBinaryWithCaps11UBaseType_t"></span><span id="_CPPv230xSemaphoreCreateBinaryWithCaps11UBaseType_t"></span><span id="xSemaphoreCreateBinaryWithCaps__UBaseType_t"></span><span class="target" id="idf__additions_8h_1ac7ef22c94e4179f946940c7782b70ce5"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="freertos_idf.html#_CPPv417SemaphoreHandle_t" title="SemaphoreHandle_t"><span class="n"><span class="pre">SemaphoreHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateBinaryWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430xSemaphoreCreateBinaryWithCaps11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a binary semaphore with specific memory capabilities. </p>
<p>This function is similar to vSemaphoreCreateBinary(), except that it allows the memory allocated for the binary semaphore to have specific capabilities (e.g., MALLOC_CAP_INTERNAL).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A binary semaphore created using this function must only be deleted using vSemaphoreDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the binary semaphore's memory (see esp_heap_caps.h) </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created binary semaphore or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv432xSemaphoreCreateCountingWithCaps11UBaseType_t11UBaseType_t11UBaseType_t">
<span id="_CPPv332xSemaphoreCreateCountingWithCaps11UBaseType_t11UBaseType_t11UBaseType_t"></span><span id="_CPPv232xSemaphoreCreateCountingWithCaps11UBaseType_t11UBaseType_t11UBaseType_t"></span><span id="xSemaphoreCreateCountingWithCaps__UBaseType_t.UBaseType_t.UBaseType_t"></span><span class="target" id="idf__additions_8h_1a4037b31c0bbd999e8c2ec109fa1cd10d"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="freertos_idf.html#_CPPv417SemaphoreHandle_t" title="SemaphoreHandle_t"><span class="n"><span class="pre">SemaphoreHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateCountingWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMaxCount</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxInitialCount</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432xSemaphoreCreateCountingWithCaps11UBaseType_t11UBaseType_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a counting semaphore with specific memory capabilities. </p>
<p>This function is similar to xSemaphoreCreateCounting(), except that it allows the memory allocated for the counting semaphore to have specific capabilities (e.g., MALLOC_CAP_INTERNAL).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A counting semaphore created using this function must only be deleted using vSemaphoreDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uxMaxCount</strong> -- The maximum count value that can be reached. </p></li>
<li><p><strong>uxInitialCount</strong> -- The count value assigned to the semaphore when it is created. </p></li>
<li><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the counting semaphore's memory (see esp_heap_caps.h) </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created counting semaphore or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429xSemaphoreCreateMutexWithCaps11UBaseType_t">
<span id="_CPPv329xSemaphoreCreateMutexWithCaps11UBaseType_t"></span><span id="_CPPv229xSemaphoreCreateMutexWithCaps11UBaseType_t"></span><span id="xSemaphoreCreateMutexWithCaps__UBaseType_t"></span><span class="target" id="idf__additions_8h_1ac4c8919e4e4ba7818e8580d79dbbd349"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="freertos_idf.html#_CPPv417SemaphoreHandle_t" title="SemaphoreHandle_t"><span class="n"><span class="pre">SemaphoreHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateMutexWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429xSemaphoreCreateMutexWithCaps11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a mutex semaphore with specific memory capabilities. </p>
<p>This function is similar to xSemaphoreCreateMutex(), except that it allows the memory allocated for the mutex semaphore to have specific capabilities (e.g., MALLOC_CAP_INTERNAL).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A mutex semaphore created using this function must only be deleted using vSemaphoreDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the mutex semaphore's memory (see esp_heap_caps.h) </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created mutex semaphore or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv438xSemaphoreCreateRecursiveMutexWithCaps11UBaseType_t">
<span id="_CPPv338xSemaphoreCreateRecursiveMutexWithCaps11UBaseType_t"></span><span id="_CPPv238xSemaphoreCreateRecursiveMutexWithCaps11UBaseType_t"></span><span id="xSemaphoreCreateRecursiveMutexWithCaps__UBaseType_t"></span><span class="target" id="idf__additions_8h_1a7c70c3cb73326baddecf36330dc927d2"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="freertos_idf.html#_CPPv417SemaphoreHandle_t" title="SemaphoreHandle_t"><span class="n"><span class="pre">SemaphoreHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xSemaphoreCreateRecursiveMutexWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv438xSemaphoreCreateRecursiveMutexWithCaps11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a recursive mutex with specific memory capabilities. </p>
<p>This function is similar to xSemaphoreCreateRecursiveMutex(), except that it allows the memory allocated for the recursive mutex to have specific capabilities (e.g., MALLOC_CAP_INTERNAL).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A recursive mutex created using this function must only be deleted using vSemaphoreDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the recursive mutex's memory (see esp_heap_caps.h) </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created recursive mutex or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424vSemaphoreDeleteWithCaps17SemaphoreHandle_t">
<span id="_CPPv324vSemaphoreDeleteWithCaps17SemaphoreHandle_t"></span><span id="_CPPv224vSemaphoreDeleteWithCaps17SemaphoreHandle_t"></span><span id="vSemaphoreDeleteWithCaps__SemaphoreHandle_t"></span><span class="target" id="idf__additions_8h_1ace101a82a57128d8c84d3bc99bd2903a"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vSemaphoreDeleteWithCaps</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="freertos_idf.html#_CPPv417SemaphoreHandle_t" title="SemaphoreHandle_t"><span class="n"><span class="pre">SemaphoreHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xSemaphore</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424vSemaphoreDeleteWithCaps17SemaphoreHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deletes a semaphore previously created using one of the xSemaphoreCreate...WithCaps() functions. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xSemaphore</strong> -- A handle to the semaphore to be deleted. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427xStreamBufferCreateWithCaps6size_t6size_t11UBaseType_t">
<span id="_CPPv327xStreamBufferCreateWithCaps6size_t6size_t11UBaseType_t"></span><span id="_CPPv227xStreamBufferCreateWithCaps6size_t6size_t11UBaseType_t"></span><span id="xStreamBufferCreateWithCaps__s.s.UBaseType_t"></span><span class="target" id="idf__additions_8h_1abddc72619f9600ff7e24f3ec3e3f51ce"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="freertos_idf.html#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xStreamBufferCreateWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferSizeBytes</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xTriggerLevelBytes</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427xStreamBufferCreateWithCaps6size_t6size_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a stream buffer with specific memory capabilities. </p>
<p>This function is similar to xStreamBufferCreate(), except that it allows the memory allocated for the stream buffer to have specific capabilities (e.g., MALLOC_CAP_INTERNAL).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A stream buffer created using this function must only be deleted using vStreamBufferDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xBufferSizeBytes</strong> -- The total number of bytes the stream buffer will be able to hold at any one time. </p></li>
<li><p><strong>xTriggerLevelBytes</strong> -- The number of bytes that must be in the stream buffer before unblocking </p></li>
<li><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the stream buffer's memory (see esp_heap_caps.h) </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created stream buffer or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427vStreamBufferDeleteWithCaps20StreamBufferHandle_t">
<span id="_CPPv327vStreamBufferDeleteWithCaps20StreamBufferHandle_t"></span><span id="_CPPv227vStreamBufferDeleteWithCaps20StreamBufferHandle_t"></span><span id="vStreamBufferDeleteWithCaps__StreamBufferHandle_t"></span><span class="target" id="idf__additions_8h_1a02c431ecb6b03f015727cf886a4baf82"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vStreamBufferDeleteWithCaps</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="freertos_idf.html#_CPPv420StreamBufferHandle_t" title="StreamBufferHandle_t"><span class="n"><span class="pre">StreamBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xStreamBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427vStreamBufferDeleteWithCaps20StreamBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deletes a stream buffer previously created using xStreamBufferCreateWithCaps() </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xStreamBuffer</strong> -- A handle to the stream buffer to be deleted. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428xMessageBufferCreateWithCaps6size_t11UBaseType_t">
<span id="_CPPv328xMessageBufferCreateWithCaps6size_t11UBaseType_t"></span><span id="_CPPv228xMessageBufferCreateWithCaps6size_t11UBaseType_t"></span><span id="xMessageBufferCreateWithCaps__s.UBaseType_t"></span><span class="target" id="idf__additions_8h_1a9bbe0c58845b37c3c88c4a72f75a36f5"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="freertos_idf.html#_CPPv421MessageBufferHandle_t" title="MessageBufferHandle_t"><span class="n"><span class="pre">MessageBufferHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xMessageBufferCreateWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">xBufferSizeBytes</span></span>, <span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428xMessageBufferCreateWithCaps6size_t11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates a message buffer with specific memory capabilities. </p>
<p>This function is similar to xMessageBufferCreate(), except that it allows the memory allocated for the message buffer to have specific capabilities (e.g., MALLOC_CAP_INTERNAL).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A message buffer created using this function must only be deleted using vMessageBufferDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xBufferSizeBytes</strong> -- The total number of bytes (not messages) the message buffer will be able to hold at any one time. </p></li>
<li><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the message buffer's memory (see esp_heap_caps.h) </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created message buffer or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428vMessageBufferDeleteWithCaps21MessageBufferHandle_t">
<span id="_CPPv328vMessageBufferDeleteWithCaps21MessageBufferHandle_t"></span><span id="_CPPv228vMessageBufferDeleteWithCaps21MessageBufferHandle_t"></span><span id="vMessageBufferDeleteWithCaps__MessageBufferHandle_t"></span><span class="target" id="idf__additions_8h_1afeaf8dcdf5b0cebef9dd2f991dbf2410"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vMessageBufferDeleteWithCaps</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="freertos_idf.html#_CPPv421MessageBufferHandle_t" title="MessageBufferHandle_t"><span class="n"><span class="pre">MessageBufferHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xMessageBuffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428vMessageBufferDeleteWithCaps21MessageBufferHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deletes a stream buffer previously created using xMessageBufferCreateWithCaps() </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xMessageBuffer</strong> -- A handle to the message buffer to be deleted. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425xEventGroupCreateWithCaps11UBaseType_t">
<span id="_CPPv325xEventGroupCreateWithCaps11UBaseType_t"></span><span id="_CPPv225xEventGroupCreateWithCaps11UBaseType_t"></span><span id="xEventGroupCreateWithCaps__UBaseType_t"></span><span class="target" id="idf__additions_8h_1af362079b6e6565b886d09d3d40e82e20"></span><a class="reference internal" href="freertos_idf.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xEventGroupCreateWithCaps</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">UBaseType_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">uxMemoryCaps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xEventGroupCreateWithCaps11UBaseType_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Creates an event group with specific memory capabilities. </p>
<p>This function is similar to xEventGroupCreate(), except that it allows the memory allocated for the event group to have specific capabilities (e.g., MALLOC_CAP_INTERNAL).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An event group created using this function must only be deleted using vEventGroupDeleteWithCaps() </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>uxMemoryCaps</strong> -- Memory capabilities of the event group's memory (see esp_heap_caps.h) </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Handle to the created event group or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425vEventGroupDeleteWithCaps18EventGroupHandle_t">
<span id="_CPPv325vEventGroupDeleteWithCaps18EventGroupHandle_t"></span><span id="_CPPv225vEventGroupDeleteWithCaps18EventGroupHandle_t"></span><span id="vEventGroupDeleteWithCaps__EventGroupHandle_t"></span><span class="target" id="idf__additions_8h_1a365a7a0e812167e0a29e7c4ecdcb65c5"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vEventGroupDeleteWithCaps</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="freertos_idf.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t"><span class="n"><span class="pre">EventGroupHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">xEventGroup</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425vEventGroupDeleteWithCaps18EventGroupHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deletes an event group previously created using xEventGroupCreateWithCaps() </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xEventGroup</strong> -- A handle to the event group to be deleted. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id6">
<h3>Type Definitions<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv427TlsDeleteCallbackFunction_t">
<span id="_CPPv327TlsDeleteCallbackFunction_t"></span><span id="_CPPv227TlsDeleteCallbackFunction_t"></span><span id="TlsDeleteCallbackFunction_t"></span><span class="target" id="idf__additions_8h_1aca1c0ef91ef0f8e2610e326e07747a49"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">TlsDeleteCallbackFunction_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">int</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv427TlsDeleteCallbackFunction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Prototype of local storage pointer deletion callback. </p>
</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=FreeRTOS (Supplemental Features) (api-reference/system/freertos_additions)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=FreeRTOS (Supplemental Features) (api-reference/system/freertos_additions)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="freertos_idf.html" class="btn btn-neutral float-left" title="FreeRTOS (IDF)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="mem_alloc.html" class="btn btn-neutral float-right" title="Heap Memory Allocation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>