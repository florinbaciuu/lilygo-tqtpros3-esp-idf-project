<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Non-Volatile Storage Library - ESP32 -  &mdash; ESP-IDF Programming Guide v5.4.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/storage/nvs_flash.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=c241bbaf"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/storage/nvs_flash';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'v5.4.2';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="NVS Bootloader" href="nvs_bootloader.html" />
    <link rel="prev" title="Manufacturing Utility" href="mass_mfg.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth® API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Project Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Storage API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="fatfs.html">FAT Filesystem Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="fatfsgen.html">Generating and Parsing FATFS on Host</a></li>
<li class="toctree-l3"><a class="reference internal" href="mass_mfg.html">Manufacturing Utility</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Non-Volatile Storage Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-of-nvs-in-bootloader-code">Use of NVS in Bootloader code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nvs-encryption">NVS Encryption</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nvs-partition-generator-utility">NVS Partition Generator Utility</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-example">Application Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#internals">Internals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="nvs_bootloader.html">NVS Bootloader</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvs_encryption.html">NVS Encryption</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvs_partition_gen.html">NVS Partition Generator Utility</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvs_partition_parse.html">NVS Partition Parser Utility</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc.html">SD/SDIO/MMC Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="partition.html">Partitions API</a></li>
<li class="toctree-l3"><a class="reference internal" href="spiffs.html">SPIFFS Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfs.html">Virtual Filesystem Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="wear-levelling.html">Wear Levelling API</a></li>
<li class="toctree-l3"><a class="reference internal" href="storage-security.html">Storage Security</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">System API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">Storage API</a></li>
      <li class="breadcrumb-item active">Non-Volatile Storage Library</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/v5.4.2/docs/en/api-reference/storage/nvs_flash.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="non-volatile-storage-library">
<h1>Non-Volatile Storage Library<a class="headerlink" href="#non-volatile-storage-library" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/v5.4.2/esp32/api-reference/storage/nvs_flash.html">[中文]</a></p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>Non-volatile storage (NVS) library is designed to store key-value pairs in flash. This section introduces some concepts used by NVS.</p>
<section id="underlying-storage">
<h3>Underlying Storage<a class="headerlink" href="#underlying-storage" title="Permalink to this heading"></a></h3>
<p>Currently, NVS uses a portion of main flash memory through the <a class="reference internal" href="partition.html#flash-partition-apis"><span class="std std-ref">esp_partition</span></a> API. The library uses all the partitions with <code class="docutils literal notranslate"><span class="pre">data</span></code> type and <code class="docutils literal notranslate"><span class="pre">nvs</span></code> subtype.  The application can choose to use the partition with the label <code class="docutils literal notranslate"><span class="pre">nvs</span></code> through the <a class="reference internal" href="#_CPPv48nvs_openPKc15nvs_open_mode_tP12nvs_handle_t" title="nvs_open"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_open()</span></code></a> API function or any other partition by specifying its name using the <a class="reference internal" href="#_CPPv423nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t" title="nvs_open_from_partition"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_open_from_partition()</span></code></a> API function.</p>
<p>Future versions of this library may have other storage backends to keep data in another flash chip (SPI or I2C), RTC, FRAM, etc.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if an NVS partition is truncated (for example, when the partition table layout is changed), its contents should be erased. ESP-IDF build system provides a <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">erase-flash</span></code> target to erase all contents of the flash chip.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NVS works best for storing many small values, rather than a few large values of the type 'string' and 'blob'. If you need to store large blobs or strings, consider using the facilities provided by the FAT filesystem on top of the wear levelling library.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NVS component includes flash wear levelling by design. Set operations are appending new data to the free space after existing entries. Invalidation of old values doesn't require immediate flash erase operations. The organization of NVS space to pages and entries effectively reduces the frequency of flash erase to flash write operations by a factor of 126.</p>
</div>
</section>
<section id="large-amount-of-data-in-nvs">
<h3>Large Amount of Data in NVS<a class="headerlink" href="#large-amount-of-data-in-nvs" title="Permalink to this heading"></a></h3>
<p>Although not recommended, NVS can store tens of thousands of keys and NVS partition can reach up to megabytes in size.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NVS component leaves RAM footprint on the heap. The footprint depends on the size of the NVS partition on flash and the number of keys in use. For RAM usage estimation, please use the following approximate figures: each 1 MB of NVS flash partition consumes 22 KB of RAM and each 1000 keys consumes 5.5 KB of RAM.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Duration of NVS initialization using <a class="reference internal" href="#_CPPv414nvs_flash_initv" title="nvs_flash_init"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_flash_init()</span></code></a> is proportional to the number of existing keys. Initialization of NVS requires approximately 0.5 seconds per 1000 keys.</p>
</div>
<p>By default, internal NVS allocates a heap in internal RAM. With a large NVS partition or big number of keys, the application can exhaust the internal RAM heap just on NVS overhead.
Applications using modules with SPI-connected PSRAM can overcome this limitation by enabling the Kconfig option <a class="reference internal" href="../kconfig.html#config-nvs-allocate-cache-in-spiram"><span class="std std-ref">CONFIG_NVS_ALLOCATE_CACHE_IN_SPIRAM</span></a> which redirects RAM allocation to the SPI-connected PSRAM.
This option is available in the nvs_flash component of the menuconfig menu when SPIRAM is enabled and and <a class="reference internal" href="../kconfig.html#config-spiram-use"><span class="std std-ref">CONFIG_SPIRAM_USE</span></a> is set to <code class="docutils literal notranslate"><span class="pre">CONFIG_SPIRAM_USE_CAPS_ALLOC</span></code>.
.. note:: Using SPI-connected PSRAM slows down NVS API for integer operations by an approximate factor of 2.5.</p>
</section>
</section>
<section id="use-of-nvs-in-bootloader-code">
<span id="nvs-bootloader"></span><h2>Use of NVS in Bootloader code<a class="headerlink" href="#use-of-nvs-in-bootloader-code" title="Permalink to this heading"></a></h2>
<p>The standard NVS API described in this guide is available to the running application. It is also possible to read data from NVS in the custom bootloader code. More information can be found in the <a class="reference internal" href="nvs_bootloader.html"><span class="doc">NVS Bootloader</span></a> guide.</p>
<section id="keys-and-values">
<h3>Keys and Values<a class="headerlink" href="#keys-and-values" title="Permalink to this heading"></a></h3>
<p>NVS operates on key-value pairs. Keys are ASCII strings; the maximum key length is currently 15 characters. Values can have one of the following types:</p>
<ul class="simple">
<li><p>integer types: <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int8_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int32_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int64_t</span></code></p></li>
<li><p>zero-terminated string</p></li>
<li><p>variable length binary data (blob)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>String values are currently limited to 4000 bytes. This includes the null terminator. Blob values are limited to 508,000 bytes or 97.6% of the partition size - 4000 bytes, whichever is lower.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before setting new or updating existing key-value pair, free entries in nvs pages have to be available. For integer types, at least one free entry has to be available. For the String value, at least one page capable of keeping the whole string in a contiguous row of free entries has to be available. For the Blob value, the size of new data has to be available in free entries.</p>
</div>
<p>Additional types, such as <code class="docutils literal notranslate"><span class="pre">float</span></code> and <code class="docutils literal notranslate"><span class="pre">double</span></code> might be added later.</p>
<p>Keys are required to be unique. Assigning a new value to an existing key replaces the old value and data type with the value and data type specified by a write operation.</p>
<p>A data type check is performed when reading a value. An error is returned if the data type expected by read operation does not match the data type of entry found for the key provided.</p>
</section>
<section id="namespaces">
<h3>Namespaces<a class="headerlink" href="#namespaces" title="Permalink to this heading"></a></h3>
<p>To mitigate potential conflicts in key names between different components, NVS assigns each key-value pair to one of namespaces. Namespace names follow the same rules as key names, i.e., the maximum length is 15 characters. Furthermore, there can be no more than 254 different namespaces in one NVS partition. Namespace name is specified in the <a class="reference internal" href="#_CPPv48nvs_openPKc15nvs_open_mode_tP12nvs_handle_t" title="nvs_open"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_open()</span></code></a> or <a class="reference internal" href="#_CPPv423nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t" title="nvs_open_from_partition"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">nvs_open_from_partition</span></code></a> call. This call returns an opaque handle, which is used in subsequent calls to the <code class="docutils literal notranslate"><span class="pre">nvs_get_*</span></code>, <code class="docutils literal notranslate"><span class="pre">nvs_set_*</span></code>, and <a class="reference internal" href="#_CPPv410nvs_commit12nvs_handle_t" title="nvs_commit"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_commit()</span></code></a> functions. This way, a handle is associated with a namespace, and key names will not collide with same names in other namespaces. Please note that the namespaces with the same name in different NVS partitions are considered as separate namespaces.</p>
</section>
<section id="nvs-iterators">
<h3>NVS Iterators<a class="headerlink" href="#nvs-iterators" title="Permalink to this heading"></a></h3>
<p>Iterators allow to list key-value pairs stored in NVS, based on specified partition name, namespace, and data type.</p>
<p>There are the following functions available:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv414nvs_entry_findPKcPKc10nvs_type_tP14nvs_iterator_t" title="nvs_entry_find"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_entry_find()</span></code></a> creates an opaque handle, which is used in subsequent calls to the <a class="reference internal" href="#_CPPv414nvs_entry_nextP14nvs_iterator_t" title="nvs_entry_next"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_entry_next()</span></code></a> and <a class="reference internal" href="#_CPPv414nvs_entry_infoK14nvs_iterator_tP16nvs_entry_info_t" title="nvs_entry_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_entry_info()</span></code></a> functions.</p></li>
<li><p><a class="reference internal" href="#_CPPv414nvs_entry_nextP14nvs_iterator_t" title="nvs_entry_next"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_entry_next()</span></code></a> advances an iterator to the next key-value pair.</p></li>
<li><p><a class="reference internal" href="#_CPPv414nvs_entry_infoK14nvs_iterator_tP16nvs_entry_info_t" title="nvs_entry_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_entry_info()</span></code></a> returns information about each key-value pair</p></li>
</ul>
<p>In general, all iterators obtained via <a class="reference internal" href="#_CPPv414nvs_entry_findPKcPKc10nvs_type_tP14nvs_iterator_t" title="nvs_entry_find"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_entry_find()</span></code></a> have to be released using <a class="reference internal" href="#_CPPv420nvs_release_iterator14nvs_iterator_t" title="nvs_release_iterator"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_release_iterator()</span></code></a>, which also tolerates <code class="docutils literal notranslate"><span class="pre">NULL</span></code> iterators.</p>
<p><a class="reference internal" href="#_CPPv414nvs_entry_findPKcPKc10nvs_type_tP14nvs_iterator_t" title="nvs_entry_find"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_entry_find()</span></code></a> and <a class="reference internal" href="#_CPPv414nvs_entry_nextP14nvs_iterator_t" title="nvs_entry_next"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_entry_next()</span></code></a> set the given iterator to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or a valid iterator in all cases except a parameter error occurred (i.e., return <code class="docutils literal notranslate"><span class="pre">ESP_ERR_NVS_NOT_FOUND</span></code>). In case of a parameter error, the given iterator will not be modified. Hence, it is best practice to initialize the iterator to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> before calling <a class="reference internal" href="#_CPPv414nvs_entry_findPKcPKc10nvs_type_tP14nvs_iterator_t" title="nvs_entry_find"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nvs_entry_find()</span></code></a> to avoid complicated error checking before releasing the iterator.</p>
</section>
<section id="security-tampering-and-robustness">
<h3>Security, Tampering, and Robustness<a class="headerlink" href="#security-tampering-and-robustness" title="Permalink to this heading"></a></h3>
<p>NVS is not directly compatible with the ESP32 flash encryption system. However, data can still be stored in encrypted form if NVS encryption is used together with ESP32 flash encryption. Please refer to <a class="reference internal" href="nvs_encryption.html"><span class="doc">NVS Encryption</span></a> for more details.</p>
<p>If NVS encryption is not used, it is possible for anyone with physical access to the flash chip to alter, erase, or add key-value pairs. With NVS encryption enabled, it is not possible to alter or add a key-value pair and get recognized as a valid pair without knowing corresponding NVS encryption keys. However, there is no tamper-resistance against the erase operation.</p>
<p>The library does try to recover from conditions when flash memory is in an inconsistent state. In particular, one should be able to power off the device at any point and time and then power it back on. This should not result in loss of data, except for the new key-value pair if it was being written at the moment of powering off. The library should also be able to initialize properly with any random data present in flash memory.</p>
</section>
</section>
<section id="nvs-encryption">
<span id="id1"></span><h2>NVS Encryption<a class="headerlink" href="#nvs-encryption" title="Permalink to this heading"></a></h2>
<p>Please refer to the <a class="reference internal" href="nvs_encryption.html"><span class="doc">NVS Encryption</span></a> guide for more details.</p>
</section>
<section id="nvs-partition-generator-utility">
<h2>NVS Partition Generator Utility<a class="headerlink" href="#nvs-partition-generator-utility" title="Permalink to this heading"></a></h2>
<p>This utility helps generate NVS partition binary files which can be flashed separately on a dedicated partition via a flashing utility. Key-value pairs to be flashed onto the partition can be provided via a CSV file. For more details, please refer to <a class="reference internal" href="nvs_partition_gen.html"><span class="doc">NVS Partition Generator Utility</span></a>.</p>
<p>Instead of calling the <code class="docutils literal notranslate"><span class="pre">nvs_partition_gen.py</span></code> tool manually, the creation of the partition binary files can also be done directly from CMake using the function <code class="docutils literal notranslate"><span class="pre">nvs_create_partition_image</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nvs_create_partition_image</span><span class="p">(</span><span class="o">&lt;</span><span class="n">partition</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">csv</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">FLASH_IN_PROJECT</span><span class="p">]</span> <span class="p">[</span><span class="n">DEPENDS</span>  <span class="n">dep</span> <span class="n">dep</span> <span class="n">dep</span> <span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Positional Arguments</strong>:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">partition</span></code></p></td>
<td><p>Name of the NVS partition</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">csv</span></code></p></td>
<td><p>Path to CSV file to parse</p></td>
</tr>
</tbody>
</table>
<p><strong>Optional Arguments</strong>:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FLASH_IN_PROJECT</span></code></p></td>
<td><p>Name of the NVS partition</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DEPENDS</span></code></p></td>
<td><p>Specify files on which the command depends</p></td>
</tr>
</tbody>
</table>
<p>If <code class="docutils literal notranslate"><span class="pre">FLASH_IN_PROJECT</span></code> is not specified, the image will still be generated, but you will have to flash it manually using <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">&lt;partition&gt;-flash</span></code> (e.g., if your partition name is <code class="docutils literal notranslate"><span class="pre">nvs</span></code>, then use <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">nvs-flash</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">nvs_create_partition_image</span></code> must be called from one of the component <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> files. Currently, only non-encrypted partitions are supported.</p>
</section>
<section id="application-example">
<h2>Application Example<a class="headerlink" href="#application-example" title="Permalink to this heading"></a></h2>
<p>You can find code examples in the <a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/storage">storage</a> directory of ESP-IDF examples:</p>
<p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/storage/nvs_rw_value">storage/nvs_rw_value</a></p>
<blockquote>
<div><p>Demonstrates how to read a single integer value from, and write it to NVS.</p>
<p>The value checked in this example holds the number of the ESP32 module restarts. The value's function as a counter is only possible due to its storing in NVS.</p>
<p>The example also shows how to check if a read/write operation was successful, or if a certain value has not been initialized in NVS. The diagnostic procedure is provided in plain text to help you track the program flow and capture any issues on the way.</p>
</div></blockquote>
<p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/storage/nvs_rw_blob">storage/nvs_rw_blob</a></p>
<blockquote>
<div><p>Demonstrates how to read a single integer value and a blob (binary large object), and write them to NVS to preserve this value between ESP32 module restarts.</p>
<blockquote>
<div><ul class="simple">
<li><p>value - tracks the number of the ESP32 module soft and hard restarts.</p></li>
<li><p>blob - contains a table with module run times. The table is read from NVS to dynamically allocated RAM. A new run time is added to the table on each manually triggered soft restart, and then the added run time is written to NVS. Triggering is done by pulling down GPIO0.</p></li>
</ul>
</div></blockquote>
<p>The example also shows how to implement the diagnostic procedure to check if the read/write operation was successful.</p>
</div></blockquote>
<p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/storage/nvs_rw_value_cxx">storage/nvs_rw_value_cxx</a></p>
<blockquote>
<div><p>This example does exactly the same as <a class="reference external" href="https://github.com/espressif/esp-idf/tree/v5.4.2/examples/storage/nvs_rw_value">storage/nvs_rw_value</a>, except that it uses the C++ NVS handle class.</p>
</div></blockquote>
</section>
<section id="internals">
<h2>Internals<a class="headerlink" href="#internals" title="Permalink to this heading"></a></h2>
<section id="log-of-key-value-pairs">
<h3>Log of Key-Value Pairs<a class="headerlink" href="#log-of-key-value-pairs" title="Permalink to this heading"></a></h3>
<p>NVS stores key-value pairs sequentially, with new key-value pairs being added at the end. When a value of any given key has to be updated, a new key-value pair is added at the end of the log and the old key-value pair is marked as erased.</p>
</section>
<section id="pages-and-entries">
<h3>Pages and Entries<a class="headerlink" href="#pages-and-entries" title="Permalink to this heading"></a></h3>
<p>NVS library uses two main entities in its operation: pages and entries. Page is a logical structure which stores a portion of the overall log. Logical page corresponds to one physical sector of flash memory. Pages which are in use have a <em>sequence number</em> associated with them. Sequence numbers impose an ordering on pages. Higher sequence numbers correspond to pages which were created later. Each page can be in one of the following states:</p>
<dl class="simple">
<dt>Empty/uninitialized</dt><dd><p>Flash storage for the page is empty (all bytes are <code class="docutils literal notranslate"><span class="pre">0xff</span></code>). Page is not used to store any data at this point and does not have a sequence number.</p>
</dd>
<dt>Active</dt><dd><p>Flash storage is initialized, page header has been written to flash, page has a valid sequence number. Page has some empty entries and data can be written there. No more than one page can be in this state at any given moment.</p>
</dd>
<dt>Full</dt><dd><p>Flash storage is in a consistent state and is filled with key-value pairs.
Writing new key-value pairs into this page is not possible. It is still possible to mark some key-value pairs as erased.</p>
</dd>
<dt>Erasing</dt><dd><p>Non-erased key-value pairs are being moved into another page so that the current page can be erased. This is a transient state, i.e., page should never stay in this state at the time when any API call returns. In case of a sudden power off, the move-and-erase process will be completed upon the next power-on.</p>
</dd>
<dt>Corrupted</dt><dd><p>Page header contains invalid data, and further parsing of page data was canceled. Any items previously written into this page will not be accessible. The corresponding flash sector will not be erased immediately and will be kept along with sectors in <strong>uninitialized</strong> state for later use. This may be useful for debugging.</p>
</dd>
</dl>
<p>Mapping from flash sectors to logical pages does not have any particular order. The library will inspect sequence numbers of pages found in each flash sector and organize pages in a list based on these numbers.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+--------+</span>     <span class="o">+--------+</span>     <span class="o">+--------+</span>     <span class="o">+--------+</span>
<span class="o">|</span> <span class="n">Page</span> <span class="mi">1</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Page</span> <span class="mi">2</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Page</span> <span class="mi">3</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Page</span> <span class="mi">4</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Full</span>   <span class="o">+---&gt;</span> <span class="o">|</span> <span class="n">Full</span>   <span class="o">+---&gt;</span> <span class="o">|</span> <span class="n">Active</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Empty</span>  <span class="o">|</span>   <span class="o">&lt;-</span> <span class="n">states</span>
<span class="o">|</span> <span class="c1">#11    |     | #12    |     | #14    |     |        |   &lt;- sequence numbers</span>
<span class="o">+---+----+</span>     <span class="o">+----+---+</span>     <span class="o">+----+---+</span>     <span class="o">+---+----+</span>
    <span class="o">|</span>               <span class="o">|</span>              <span class="o">|</span>             <span class="o">|</span>
    <span class="o">|</span>               <span class="o">|</span>              <span class="o">|</span>             <span class="o">|</span>
    <span class="o">|</span>               <span class="o">|</span>              <span class="o">|</span>             <span class="o">|</span>
<span class="o">+---</span><span class="n">v</span><span class="o">------+</span>  <span class="o">+-----</span><span class="n">v</span><span class="o">----+</span>  <span class="o">+------</span><span class="n">v</span><span class="o">---+</span>  <span class="o">+------</span><span class="n">v</span><span class="o">---+</span>
<span class="o">|</span> <span class="n">Sector</span> <span class="mi">3</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Sector</span> <span class="mi">0</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Sector</span> <span class="mi">2</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Sector</span> <span class="mi">1</span> <span class="o">|</span>    <span class="o">&lt;-</span> <span class="n">physical</span> <span class="n">sectors</span>
<span class="o">+----------+</span>  <span class="o">+----------+</span>  <span class="o">+----------+</span>  <span class="o">+----------+</span>
</pre></div>
</div>
</section>
<section id="structure-of-a-page">
<h3>Structure of a Page<a class="headerlink" href="#structure-of-a-page" title="Permalink to this heading"></a></h3>
<p>For now, we assume that flash sector size is 4096 bytes and that ESP32 flash encryption hardware operates on 32-byte blocks. It is possible to introduce some settings configurable at compile-time (e.g., via menuconfig) to accommodate flash chips with different sector sizes (although it is not clear if other components in the system, e.g., SPI flash driver and SPI flash cache can support these other sizes).</p>
<p>Page consists of three parts: header, entry state bitmap, and entries themselves. To be compatible with ESP32 flash encryption, the entry size is 32 bytes. For integer types, an entry holds one key-value pair. For strings and blobs, an entry holds part of key-value pair (more on that in the entry structure description).</p>
<p>The following diagram illustrates the page structure. Numbers in parentheses indicate the size of each part in bytes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-----------+--------------+-------------+-------------------------+</span>
<span class="o">|</span> <span class="n">State</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">Seq</span><span class="o">.</span> <span class="n">no</span><span class="o">.</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">version</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Unused</span> <span class="p">(</span><span class="mi">19</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRC32</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>   <span class="n">Header</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="o">+-----------+--------------+-------------+-------------------------+</span>
<span class="o">|</span>                <span class="n">Entry</span> <span class="n">state</span> <span class="n">bitmap</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                           <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">|</span>                       <span class="n">Entry</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                               <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">|</span>                       <span class="n">Entry</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                               <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">/</span>                                                                  <span class="o">/</span>
<span class="o">/</span>                                                                  <span class="o">/</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">|</span>                       <span class="n">Entry</span> <span class="mi">125</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                             <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
</pre></div>
</div>
<p>Page header and entry state bitmap are always written to flash unencrypted. Entries are encrypted if flash encryption feature of ESP32 is used.</p>
<p>Page state values are defined in such a way that changing state is possible by writing 0 into some of the bits. Therefore it is not necessary to erase the page to change its state unless that is a change to the <em>erased</em> state.</p>
<p>The version field in the header reflects the NVS format version used. For backward compatibility reasons, it is decremented for every version upgrade starting at 0xff (i.e., 0xff for version-1, 0xfe for version-2 and so on).</p>
<p>CRC32 value in the header is calculated over the part which does not include a state value (bytes 4 to 28). The unused part is currently filled with <code class="docutils literal notranslate"><span class="pre">0xff</span></code> bytes.</p>
<p>The following sections describe the structure of entry state bitmap and entry itself.</p>
</section>
<section id="entry-and-entry-state-bitmap">
<h3>Entry and Entry State Bitmap<a class="headerlink" href="#entry-and-entry-state-bitmap" title="Permalink to this heading"></a></h3>
<p>Each entry can be in one of the following three states represented with two bits in the entry state bitmap. The final four bits in the bitmap (256 - 2 * 126) are not used.</p>
<dl class="simple">
<dt>Empty (2'b11)</dt><dd><p>Nothing is written into the specific entry yet. It is in an uninitialized state (all bytes are <code class="docutils literal notranslate"><span class="pre">0xff</span></code>).</p>
</dd>
<dt>Written (2'b10)</dt><dd><p>A key-value pair (or part of key-value pair which spans multiple entries) has been written into the entry.</p>
</dd>
<dt>Erased (2'b00)</dt><dd><p>A key-value pair in this entry has been discarded. Contents of this entry will not be parsed anymore.</p>
</dd>
</dl>
</section>
<section id="structure-of-entry">
<span id="id2"></span><h3>Structure of Entry<a class="headerlink" href="#structure-of-entry" title="Permalink to this heading"></a></h3>
<p>For values of primitive types (currently integers from 1 to 8 bytes long), entry holds one key-value pair. For string and blob types, entry holds part of the whole key-value pair. For strings, in case when a key-value pair spans multiple entries, all entries are stored in the same page. Blobs are allowed to span over multiple pages by dividing them into smaller chunks. For tracking these chunks, an additional fixed length metadata entry is stored called &quot;blob index&quot;. Earlier formats of blobs are still supported (can be read and modified). However, once the blobs are modified, they are stored using the new format.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+--------+----------+----------+----------------+-----------+---------------+----------+</span>
<span class="o">|</span> <span class="n">NS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Type</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Span</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">ChunkIndex</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRC32</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>    <span class="n">Key</span> <span class="p">(</span><span class="mi">16</span><span class="p">)</span>   <span class="o">|</span> <span class="n">Data</span> <span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+--------+----------+----------+----------------+-----------+---------------+----------+</span>

                                         <span class="n">Primitive</span>  <span class="o">+--------------------------------+</span>
                                        <span class="o">+--------&gt;</span>  <span class="o">|</span>     <span class="n">Data</span> <span class="p">(</span><span class="mi">8</span><span class="p">)</span>                   <span class="o">|</span>
                                        <span class="o">|</span> <span class="n">Types</span>     <span class="o">+--------------------------------+</span>
                   <span class="o">+-&gt;</span> <span class="n">Fixed</span> <span class="n">length</span> <span class="o">--</span>
                   <span class="o">|</span>                    <span class="o">|</span>           <span class="o">+---------+--------------+---------------+-------+</span>
                   <span class="o">|</span>                    <span class="o">+--------&gt;</span>  <span class="o">|</span> <span class="n">Size</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">ChunkCount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span> <span class="n">ChunkStart</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Rsv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">|</span>
    <span class="n">Data</span> <span class="nb">format</span> <span class="o">---+</span>                    <span class="n">Blob</span> <span class="n">Index</span>  <span class="o">+---------+--------------+---------------+-------+</span>
                   <span class="o">|</span>
                   <span class="o">|</span>                             <span class="o">+----------+---------+-----------+</span>
                   <span class="o">+-&gt;</span>   <span class="n">Variable</span> <span class="n">length</span>   <span class="o">--&gt;</span>   <span class="o">|</span> <span class="n">Size</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Rsv</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRC32</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
                        <span class="p">(</span><span class="n">Strings</span><span class="p">,</span> <span class="n">Blob</span> <span class="n">Data</span><span class="p">)</span>     <span class="o">+----------+---------+-----------+</span>
</pre></div>
</div>
<p>Individual fields in entry structure have the following meanings:</p>
<dl>
<dt>NS</dt><dd><p>Namespace index for this entry. For more information on this value, see the section on namespaces implementation.</p>
</dd>
<dt>Type</dt><dd><p>One byte indicating the value data type. See the <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">ItemType</span></code> enumeration in <a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/nvs_flash/include/nvs_handle.hpp">nvs_flash/include/nvs_handle.hpp</a> for possible values.</p>
</dd>
<dt>Span</dt><dd><p>Number of entries used by this key-value pair. For integer types, this is equal to 1. For strings and blobs, this depends on value length.</p>
</dd>
<dt>ChunkIndex</dt><dd><p>Used to store the index of a blob-data chunk for blob types. For other types, this should be <code class="docutils literal notranslate"><span class="pre">0xff</span></code>.</p>
</dd>
<dt>CRC32</dt><dd><p>Checksum calculated over all the bytes in this entry, except for the CRC32 field itself.</p>
</dd>
<dt>Key</dt><dd><p>Zero-terminated ASCII string containing a key name. Maximum string length is 15 bytes, excluding a zero terminator.</p>
</dd>
<dt>Data</dt><dd><p>For integer types, this field contains the value itself. If the value itself is shorter than 8 bytes, it is padded to the right, with unused bytes filled with <code class="docutils literal notranslate"><span class="pre">0xff</span></code>.</p>
<p>For &quot;blob index&quot; entry, these 8 bytes hold the following information about data-chunks:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Size</dt><dd><p>(Only for blob index.) Size, in bytes, of complete blob data.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ChunkCount</dt><dd><p>(Only for blob index.) Total number of blob-data chunks into which the blob was divided during storage.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ChunkStart</dt><dd><p>(Only for blob index.) ChunkIndex of the first blob-data chunk of this blob. Subsequent chunks have chunkIndex incrementally allocated (step of 1).</p>
</dd>
</dl>
</li>
</ul>
<p>For string and blob data chunks, these 8 bytes hold additional data about the value, which are described below:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Size</dt><dd><p>(Only for strings and blobs.) Size, in bytes, of actual data. For strings, this includes zero terminators.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>CRC32</dt><dd><p>(Only for strings and blobs.) Checksum calculated over all bytes of data.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Variable length values (strings and blobs) are written into subsequent entries, 32 bytes per entry. The <code class="docutils literal notranslate"><span class="pre">Span</span></code> field of the first entry indicates how many entries are used.</p>
</section>
<section id="id3">
<h3>Namespaces<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<p>As mentioned above, each key-value pair belongs to one of the namespaces. Namespace identifiers (strings) are stored as keys of key-value pairs in namespace with index 0. Values corresponding to these keys are indexes of these namespaces.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">0</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint8_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">&quot;wifi&quot;</span> <span class="n">Value</span><span class="o">=</span><span class="mi">1</span>      <span class="o">|</span>   <span class="n">Entry</span> <span class="n">describing</span> <span class="n">namespace</span> <span class="s2">&quot;wifi&quot;</span>
<span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">1</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint32_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span> <span class="n">Value</span><span class="o">=</span><span class="mi">6</span>  <span class="o">|</span>   <span class="n">Key</span> <span class="s2">&quot;channel&quot;</span> <span class="ow">in</span> <span class="n">namespace</span> <span class="s2">&quot;wifi&quot;</span>
<span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">0</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint8_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">&quot;pwm&quot;</span> <span class="n">Value</span><span class="o">=</span><span class="mi">2</span>       <span class="o">|</span>   <span class="n">Entry</span> <span class="n">describing</span> <span class="n">namespace</span> <span class="s2">&quot;pwm&quot;</span>
<span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">2</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint16_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span> <span class="n">Value</span><span class="o">=</span><span class="mi">20</span> <span class="o">|</span>   <span class="n">Key</span> <span class="s2">&quot;channel&quot;</span> <span class="ow">in</span> <span class="n">namespace</span> <span class="s2">&quot;pwm&quot;</span>
<span class="o">+-------------------------------------------+</span>
</pre></div>
</div>
</section>
<section id="item-hash-list">
<h3>Item Hash List<a class="headerlink" href="#item-hash-list" title="Permalink to this heading"></a></h3>
<p>To reduce the number of reads from flash memory, each member of the Page class maintains a list of pairs: item index; item hash. This list makes searches much quicker. Instead of iterating over all entries, reading them from flash one at a time, <cite>Page::findItem</cite> first performs a search for the item hash in the hash list. This gives the item index within the page if such an item exists. Due to a hash collision, it is possible that a different item is found. This is handled by falling back to iteration over items in flash.</p>
<p>Each node in the hash list contains a 24-bit hash and 8-bit item index. Hash is calculated based on item namespace, key name, and ChunkIndex. CRC32 is used for calculation; the result is truncated to 24 bits. To reduce the overhead for storing 32-bit entries in a linked list, the list is implemented as a double-linked list of arrays. Each array holds 29 entries, for the total size of 128 bytes, together with linked list pointers and a 32-bit count field. The minimum amount of extra RAM usage per page is therefore 128 bytes; maximum is 640 bytes.</p>
</section>
</section>
<section id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h2>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/nvs_flash/include/nvs_flash.h">components/nvs_flash/include/nvs_flash.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;nvs_flash.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">nvs_flash</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">nvs_flash</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES nvs_flash
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES nvs_flash
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414nvs_flash_initv">
<span id="_CPPv314nvs_flash_initv"></span><span id="_CPPv214nvs_flash_initv"></span><span id="nvs_flash_init__void"></span><span class="target" id="nvs__flash_8h_1a0c37702eca98ffe39ff4d8a47a0e093f"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414nvs_flash_initv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize the default NVS partition. </p>
<p>This API initialises the default NVS partition. The default NVS partition is the one that is labeled &quot;nvs&quot; in the partition table.</p>
<p>When &quot;NVS_ENCRYPTION&quot; is enabled in the menuconfig, this API enables the NVS encryption for the default NVS partition as follows<ol class="loweralpha simple">
<li><p>Read security configurations from the first NVS key partition listed in the partition table. (NVS key partition is any &quot;data&quot; type partition which has the subtype value set to &quot;nvs_keys&quot;)</p></li>
<li><p>If the NVS key partition obtained in the previous step is empty, generate and store new keys in that NVS key partition.</p></li>
<li><p>Internally call &quot;nvs_flash_secure_init()&quot; with the security configurations obtained/generated in the previous steps.</p></li>
</ol>
</p>
<p>Post initialization NVS read/write APIs remain the same irrespective of NVS encryption.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_OK if storage was successfully initialized.</p></li>
<li><p>ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)</p></li>
<li><p>ESP_ERR_NOT_FOUND if no partition with label &quot;nvs&quot; is found in the partition table</p></li>
<li><p>ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures</p></li>
<li><p>one of the error codes from the underlying flash storage driver</p></li>
<li><p>error codes from nvs_flash_read_security_cfg API (when &quot;NVS_ENCRYPTION&quot; is enabled).</p></li>
<li><p>error codes from nvs_flash_generate_keys API (when &quot;NVS_ENCRYPTION&quot; is enabled).</p></li>
<li><p>error codes from nvs_flash_secure_init_partition API (when &quot;NVS_ENCRYPTION&quot; is enabled) . </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424nvs_flash_init_partitionPKc">
<span id="_CPPv324nvs_flash_init_partitionPKc"></span><span id="_CPPv224nvs_flash_init_partitionPKc"></span><span id="nvs_flash_init_partition__cCP"></span><span class="target" id="nvs__flash_8h_1ae744286f362cca501e9f3cf753d538ea"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_init_partition</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">partition_label</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424nvs_flash_init_partitionPKc" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize NVS flash storage for the specified partition. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>partition_label</strong> -- <strong>[in]</strong> Label of the partition. Must be no longer than 16 characters.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if storage was successfully initialized.</p></li>
<li><p>ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)</p></li>
<li><p>ESP_ERR_NOT_FOUND if specified partition is not found in the partition table</p></li>
<li><p>ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures</p></li>
<li><p>one of the error codes from the underlying flash storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428nvs_flash_init_partition_ptrPK15esp_partition_t">
<span id="_CPPv328nvs_flash_init_partition_ptrPK15esp_partition_t"></span><span id="_CPPv228nvs_flash_init_partition_ptrPK15esp_partition_t"></span><span id="nvs_flash_init_partition_ptr__esp_partition_tCP"></span><span class="target" id="nvs__flash_8h_1acf6f650bdf802a3cccfcd4feceef0a75"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_init_partition_ptr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="partition.html#_CPPv415esp_partition_t" title="esp_partition_t"><span class="n"><span class="pre">esp_partition_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">partition</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428nvs_flash_init_partition_ptrPK15esp_partition_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize NVS flash storage for the partition specified by partition pointer. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>partition</strong> -- <strong>[in]</strong> pointer to a partition obtained by the ESP partition API.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if storage was successfully initialized</p></li>
<li><p>ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)</p></li>
<li><p>ESP_ERR_INVALID_ARG in case partition is NULL</p></li>
<li><p>ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures</p></li>
<li><p>one of the error codes from the underlying flash storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416nvs_flash_deinitv">
<span id="_CPPv316nvs_flash_deinitv"></span><span id="_CPPv216nvs_flash_deinitv"></span><span id="nvs_flash_deinit__void"></span><span class="target" id="nvs__flash_8h_1ab0743d413ccfb038ea2cc78a151bbfb6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_deinit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416nvs_flash_deinitv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deinitialize NVS storage for the default NVS partition. </p>
<p>Default NVS partition is the partition with &quot;nvs&quot; label in the partition table.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_OK on success (storage was deinitialized)</p></li>
<li><p>ESP_ERR_NVS_NOT_INITIALIZED if the storage was not initialized prior to this call </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426nvs_flash_deinit_partitionPKc">
<span id="_CPPv326nvs_flash_deinit_partitionPKc"></span><span id="_CPPv226nvs_flash_deinit_partitionPKc"></span><span id="nvs_flash_deinit_partition__cCP"></span><span class="target" id="nvs__flash_8h_1a16c7e9782bc34910db1e2811034a113c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_deinit_partition</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">partition_label</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426nvs_flash_deinit_partitionPKc" title="Permalink to this definition"></a><br /></dt>
<dd><p>Deinitialize NVS storage for the given NVS partition. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>partition_label</strong> -- <strong>[in]</strong> Label of the partition</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK on success</p></li>
<li><p>ESP_ERR_NVS_NOT_INITIALIZED if the storage for given partition was not initialized prior to this call </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415nvs_flash_erasev">
<span id="_CPPv315nvs_flash_erasev"></span><span id="_CPPv215nvs_flash_erasev"></span><span id="nvs_flash_erase__void"></span><span class="target" id="nvs__flash_8h_1ac9e4c719ccdb0d92ba974012868435cf"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_erase</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415nvs_flash_erasev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Erase the default NVS partition. </p>
<p>Erases all contents of the default NVS partition (one with label &quot;nvs&quot;).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the partition is initialized, this function first de-initializes it. Afterwards, the partition has to be initialized again to be used.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_OK on success</p></li>
<li><p>ESP_ERR_NOT_FOUND if there is no NVS partition labeled &quot;nvs&quot; in the partition table</p></li>
<li><p>different error in case de-initialization fails (shouldn't happen) </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425nvs_flash_erase_partitionPKc">
<span id="_CPPv325nvs_flash_erase_partitionPKc"></span><span id="_CPPv225nvs_flash_erase_partitionPKc"></span><span id="nvs_flash_erase_partition__cCP"></span><span class="target" id="nvs__flash_8h_1aac0d1a70e1e4fb943c7a201bc27025b4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_erase_partition</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">part_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425nvs_flash_erase_partitionPKc" title="Permalink to this definition"></a><br /></dt>
<dd><p>Erase specified NVS partition. </p>
<p>Erase all content of a specified NVS partition</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the partition is initialized, this function first de-initializes it. Afterwards, the partition has to be initialized again to be used.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>part_name</strong> -- <strong>[in]</strong> Name (label) of the partition which should be erased</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK on success</p></li>
<li><p>ESP_ERR_NOT_FOUND if there is no NVS partition with the specified name in the partition table</p></li>
<li><p>different error in case de-initialization fails (shouldn't happen) </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429nvs_flash_erase_partition_ptrPK15esp_partition_t">
<span id="_CPPv329nvs_flash_erase_partition_ptrPK15esp_partition_t"></span><span id="_CPPv229nvs_flash_erase_partition_ptrPK15esp_partition_t"></span><span id="nvs_flash_erase_partition_ptr__esp_partition_tCP"></span><span class="target" id="nvs__flash_8h_1ab516ae0892bdec690ce1c47ce2bb20b5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_erase_partition_ptr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="partition.html#_CPPv415esp_partition_t" title="esp_partition_t"><span class="n"><span class="pre">esp_partition_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">partition</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429nvs_flash_erase_partition_ptrPK15esp_partition_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Erase custom partition. </p>
<p>Erase all content of specified custom partition.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the partition is initialized, this function first de-initializes it. Afterwards, the partition has to be initialized again to be used.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>partition</strong> -- <strong>[in]</strong> pointer to a partition obtained by the ESP partition API.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK on success</p></li>
<li><p>ESP_ERR_NOT_FOUND if there is no partition with the specified parameters in the partition table</p></li>
<li><p>ESP_ERR_INVALID_ARG in case partition is NULL</p></li>
<li><p>one of the error codes from the underlying flash storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421nvs_flash_secure_initP13nvs_sec_cfg_t">
<span id="_CPPv321nvs_flash_secure_initP13nvs_sec_cfg_t"></span><span id="_CPPv221nvs_flash_secure_initP13nvs_sec_cfg_t"></span><span id="nvs_flash_secure_init__nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1a0ab41aa24c30907de227cfb31535071c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_secure_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t"><span class="n"><span class="pre">nvs_sec_cfg_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cfg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421nvs_flash_secure_initP13nvs_sec_cfg_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize the default NVS partition. </p>
<p>This API initialises the default NVS partition. The default NVS partition is the one that is labeled &quot;nvs&quot; in the partition table.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cfg</strong> -- <strong>[in]</strong> Security configuration (keys) to be used for NVS encryption/decryption. If cfg is NULL, no encryption is used.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if storage has been initialized successfully.</p></li>
<li><p>ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)</p></li>
<li><p>ESP_ERR_NOT_FOUND if no partition with label &quot;nvs&quot; is found in the partition table</p></li>
<li><p>ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures</p></li>
<li><p>one of the error codes from the underlying flash storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t">
<span id="_CPPv331nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t"></span><span id="_CPPv231nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t"></span><span id="nvs_flash_secure_init_partition__cCP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1af14231de1efc20d250b0f953698350a5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_secure_init_partition</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">partition_label</span></span>, <a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t"><span class="n"><span class="pre">nvs_sec_cfg_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cfg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize NVS flash storage for the specified partition. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>partition_label</strong> -- <strong>[in]</strong> Label of the partition. Note that internally, a reference to passed value is kept and it should be accessible for future operations</p></li>
<li><p><strong>cfg</strong> -- <strong>[in]</strong> Security configuration (keys) to be used for NVS encryption/decryption. If cfg is null, no encryption/decryption is used. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if storage has been initialized successfully.</p></li>
<li><p>ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)</p></li>
<li><p>ESP_ERR_NOT_FOUND if specified partition is not found in the partition table</p></li>
<li><p>ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures</p></li>
<li><p>one of the error codes from the underlying flash storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t">
<span id="_CPPv323nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="_CPPv223nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="nvs_flash_generate_keys__esp_partition_tCP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1a1eb890121d0e1f76d9ba873783d53e51"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_generate_keys</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="partition.html#_CPPv415esp_partition_t" title="esp_partition_t"><span class="n"><span class="pre">esp_partition_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">partition</span></span>, <a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t"><span class="n"><span class="pre">nvs_sec_cfg_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cfg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Generate and store NVS keys in the provided esp partition. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>partition</strong> -- <strong>[in]</strong> Pointer to partition structure obtained using esp_partition_find_first or esp_partition_get. Must be non-NULL. </p></li>
<li><p><strong>cfg</strong> -- <strong>[out]</strong> Pointer to nvs security configuration structure. Pointer must be non-NULL. Generated keys will be populated in this structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK, if cfg was read successfully;</p></li>
<li><p>ESP_ERR_INVALID_ARG, if partition or cfg is NULL;</p></li>
<li><p>or error codes from esp_partition_write/erase APIs. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t">
<span id="_CPPv327nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="_CPPv227nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="nvs_flash_read_security_cfg__esp_partition_tCP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1ad2b9fc8e49a07eee8c83410686efad67"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_read_security_cfg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="partition.html#_CPPv415esp_partition_t" title="esp_partition_t"><span class="n"><span class="pre">esp_partition_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">partition</span></span>, <a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t"><span class="n"><span class="pre">nvs_sec_cfg_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cfg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Read NVS security configuration from a partition. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Provided partition is assumed to be marked 'encrypted'.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>partition</strong> -- <strong>[in]</strong> Pointer to partition structure obtained using esp_partition_find_first or esp_partition_get. Must be non-NULL. </p></li>
<li><p><strong>cfg</strong> -- <strong>[out]</strong> Pointer to nvs security configuration structure. Pointer must be non-NULL.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK, if cfg was read successfully;</p></li>
<li><p>ESP_ERR_INVALID_ARG, if partition or cfg is NULL</p></li>
<li><p>ESP_ERR_NVS_KEYS_NOT_INITIALIZED, if the partition is not yet written with keys.</p></li>
<li><p>ESP_ERR_NVS_CORRUPT_KEY_PART, if the partition containing keys is found to be corrupt</p></li>
<li><p>or error codes from esp_partition_read API. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv434nvs_flash_register_security_schemeP16nvs_sec_scheme_t">
<span id="_CPPv334nvs_flash_register_security_schemeP16nvs_sec_scheme_t"></span><span id="_CPPv234nvs_flash_register_security_schemeP16nvs_sec_scheme_t"></span><span id="nvs_flash_register_security_scheme__nvs_sec_scheme_tP"></span><span class="target" id="nvs__flash_8h_1ae89cc0413c99c807a8a0179dd1ec4d1b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_register_security_scheme</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416nvs_sec_scheme_t" title="nvs_sec_scheme_t"><span class="n"><span class="pre">nvs_sec_scheme_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">scheme_cfg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434nvs_flash_register_security_schemeP16nvs_sec_scheme_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Registers the given security scheme for NVS encryption The scheme registered with sec_scheme_id by this API be used as the default security scheme for the &quot;nvs&quot; partition. Users will have to call this API explicitly in their application. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>scheme_cfg</strong> -- <strong>[in]</strong> Pointer to the security scheme configuration structure that the user (or the nvs_key_provider) wants to register.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK, if security scheme registration succeeds;</p></li>
<li><p>ESP_ERR_INVALID_ARG, if scheme_cfg is NULL;</p></li>
<li><p>ESP_FAIL, if security scheme registration fails </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv437nvs_flash_get_default_security_schemev">
<span id="_CPPv337nvs_flash_get_default_security_schemev"></span><span id="_CPPv237nvs_flash_get_default_security_schemev"></span><span id="nvs_flash_get_default_security_scheme__void"></span><span class="target" id="nvs__flash_8h_1aa723bee32372d16f79b34e8a17859252"></span><a class="reference internal" href="#_CPPv416nvs_sec_scheme_t" title="nvs_sec_scheme_t"><span class="n"><span class="pre">nvs_sec_scheme_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_get_default_security_scheme</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv437nvs_flash_get_default_security_schemev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Fetch the configuration structure for the default active security scheme for NVS encryption. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to the default active security scheme configuration (NULL if no scheme is registered yet i.e. active) </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426nvs_flash_generate_keys_v2P16nvs_sec_scheme_tP13nvs_sec_cfg_t">
<span id="_CPPv326nvs_flash_generate_keys_v2P16nvs_sec_scheme_tP13nvs_sec_cfg_t"></span><span id="_CPPv226nvs_flash_generate_keys_v2P16nvs_sec_scheme_tP13nvs_sec_cfg_t"></span><span id="nvs_flash_generate_keys_v2__nvs_sec_scheme_tP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1ac360f6b1528e99f76e39b541134713b5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_generate_keys_v2</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416nvs_sec_scheme_t" title="nvs_sec_scheme_t"><span class="n"><span class="pre">nvs_sec_scheme_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">scheme_cfg</span></span>, <a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t"><span class="n"><span class="pre">nvs_sec_cfg_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cfg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426nvs_flash_generate_keys_v2P16nvs_sec_scheme_tP13nvs_sec_cfg_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Generate (and store) the NVS keys using the specified key-protection scheme. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scheme_cfg</strong> -- <strong>[in]</strong> Security scheme specific configuration</p></li>
<li><p><strong>cfg</strong> -- <strong>[out]</strong> Security configuration (encryption keys)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK, if cfg was populated successfully with generated encryption keys;</p></li>
<li><p>ESP_ERR_INVALID_ARG, if scheme_cfg or cfg is NULL;</p></li>
<li><p>ESP_FAIL, if the key generation process fails </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430nvs_flash_read_security_cfg_v2P16nvs_sec_scheme_tP13nvs_sec_cfg_t">
<span id="_CPPv330nvs_flash_read_security_cfg_v2P16nvs_sec_scheme_tP13nvs_sec_cfg_t"></span><span id="_CPPv230nvs_flash_read_security_cfg_v2P16nvs_sec_scheme_tP13nvs_sec_cfg_t"></span><span id="nvs_flash_read_security_cfg_v2__nvs_sec_scheme_tP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1a8dfe091d69cab783c825726e7e8746e0"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_read_security_cfg_v2</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416nvs_sec_scheme_t" title="nvs_sec_scheme_t"><span class="n"><span class="pre">nvs_sec_scheme_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">scheme_cfg</span></span>, <a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t"><span class="n"><span class="pre">nvs_sec_cfg_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cfg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430nvs_flash_read_security_cfg_v2P16nvs_sec_scheme_tP13nvs_sec_cfg_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Read NVS security configuration set by the specified security scheme. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scheme_cfg</strong> -- <strong>[in]</strong> Security scheme specific configuration</p></li>
<li><p><strong>cfg</strong> -- <strong>[out]</strong> Security configuration (encryption keys)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK, if cfg was read successfully;</p></li>
<li><p>ESP_ERR_INVALID_ARG, if scheme_cfg or cfg is NULL;</p></li>
<li><p>ESP_FAIL, if the key reading process fails </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv413nvs_sec_cfg_t">
<span id="_CPPv313nvs_sec_cfg_t"></span><span id="_CPPv213nvs_sec_cfg_t"></span><span id="nvs_sec_cfg_t"></span><span class="target" id="structnvs__sec__cfg__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_sec_cfg_t</span></span></span><a class="headerlink" href="#_CPPv413nvs_sec_cfg_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Key for encryption and decryption. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13nvs_sec_cfg_t3ekyE">
<span id="_CPPv3N13nvs_sec_cfg_t3ekyE"></span><span id="_CPPv2N13nvs_sec_cfg_t3ekyE"></span><span id="nvs_sec_cfg_t::eky__uint8_tA"></span><span class="target" id="structnvs__sec__cfg__t_1aca7c1ea3cb7735702e159dbbd7059c0f"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eky</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">NVS_KEY_SIZE</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N13nvs_sec_cfg_t3ekyE" title="Permalink to this definition"></a><br /></dt>
<dd><p>XTS encryption and decryption key </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13nvs_sec_cfg_t3tkyE">
<span id="_CPPv3N13nvs_sec_cfg_t3tkyE"></span><span id="_CPPv2N13nvs_sec_cfg_t3tkyE"></span><span id="nvs_sec_cfg_t::tky__uint8_tA"></span><span class="target" id="structnvs__sec__cfg__t_1a2bcd305f3bdc0b10ea93c6c983073774"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tky</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">NVS_KEY_SIZE</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N13nvs_sec_cfg_t3tkyE" title="Permalink to this definition"></a><br /></dt>
<dd><p>XTS tweak key </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv416nvs_sec_scheme_t">
<span id="_CPPv316nvs_sec_scheme_t"></span><span id="_CPPv216nvs_sec_scheme_t"></span><span id="nvs_sec_scheme_t"></span><span class="target" id="structnvs__sec__scheme__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_sec_scheme_t</span></span></span><a class="headerlink" href="#_CPPv416nvs_sec_scheme_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>NVS encryption: Security scheme configuration structure. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16nvs_sec_scheme_t9scheme_idE">
<span id="_CPPv3N16nvs_sec_scheme_t9scheme_idE"></span><span id="_CPPv2N16nvs_sec_scheme_t9scheme_idE"></span><span id="nvs_sec_scheme_t::scheme_id__i"></span><span class="target" id="structnvs__sec__scheme__t_1aaad30de031c70661ce71b1b734a6f196"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scheme_id</span></span></span><a class="headerlink" href="#_CPPv4N16nvs_sec_scheme_t9scheme_idE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Security Scheme ID (E.g. HMAC) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16nvs_sec_scheme_t11scheme_dataE">
<span id="_CPPv3N16nvs_sec_scheme_t11scheme_dataE"></span><span id="_CPPv2N16nvs_sec_scheme_t11scheme_dataE"></span><span id="nvs_sec_scheme_t::scheme_data__voidP"></span><span class="target" id="structnvs__sec__scheme__t_1a5fd93495757c1d9a482bea8b9998eff7"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scheme_data</span></span></span><a class="headerlink" href="#_CPPv4N16nvs_sec_scheme_t11scheme_dataE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Scheme-specific data (E.g. eFuse block for HMAC-based key generation) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16nvs_sec_scheme_t17nvs_flash_key_genE">
<span id="_CPPv3N16nvs_sec_scheme_t17nvs_flash_key_genE"></span><span id="_CPPv2N16nvs_sec_scheme_t17nvs_flash_key_genE"></span><span id="nvs_sec_scheme_t::nvs_flash_key_gen__nvs_flash_generate_keys_t"></span><span class="target" id="structnvs__sec__scheme__t_1a82cdfee1dffbb0d3e94697540649c17e"></span><a class="reference internal" href="#_CPPv425nvs_flash_generate_keys_t" title="nvs_flash_generate_keys_t"><span class="n"><span class="pre">nvs_flash_generate_keys_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_key_gen</span></span></span><a class="headerlink" href="#_CPPv4N16nvs_sec_scheme_t17nvs_flash_key_genE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback for the nvs_flash_key_gen implementation </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16nvs_sec_scheme_t18nvs_flash_read_cfgE">
<span id="_CPPv3N16nvs_sec_scheme_t18nvs_flash_read_cfgE"></span><span id="_CPPv2N16nvs_sec_scheme_t18nvs_flash_read_cfgE"></span><span id="nvs_sec_scheme_t::nvs_flash_read_cfg__nvs_flash_read_cfg_t"></span><span class="target" id="structnvs__sec__scheme__t_1ada877635afc4814af76fc75c8f0bd794"></span><a class="reference internal" href="#_CPPv420nvs_flash_read_cfg_t" title="nvs_flash_read_cfg_t"><span class="n"><span class="pre">nvs_flash_read_cfg_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_read_cfg</span></span></span><a class="headerlink" href="#_CPPv4N16nvs_sec_scheme_t18nvs_flash_read_cfgE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback for the nvs_flash_read_keys implementation </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.NVS_KEY_SIZE">
<span class="target" id="nvs__flash_8h_1a3c4e07a22cf5967ebf64fe7db4cec3bc"></span><span class="sig-name descname"><span class="n"><span class="pre">NVS_KEY_SIZE</span></span></span><a class="headerlink" href="#c.NVS_KEY_SIZE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
<section id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv425nvs_flash_generate_keys_t">
<span id="_CPPv325nvs_flash_generate_keys_t"></span><span id="_CPPv225nvs_flash_generate_keys_t"></span><span id="nvs_flash_generate_keys_t"></span><span class="target" id="nvs__flash_8h_1ab8d6e9500c9ff65cae686d2ac1ca7977"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_generate_keys_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scheme_data</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t"><span class="n"><span class="pre">nvs_sec_cfg_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cfg</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv425nvs_flash_generate_keys_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback function prototype for generating the NVS encryption keys. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv420nvs_flash_read_cfg_t">
<span id="_CPPv320nvs_flash_read_cfg_t"></span><span id="_CPPv220nvs_flash_read_cfg_t"></span><span id="nvs_flash_read_cfg_t"></span><span class="target" id="nvs__flash_8h_1ae763c0a176e29b6752ace1b7361b410d"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">nvs_flash_read_cfg_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scheme_data</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t"><span class="n"><span class="pre">nvs_sec_cfg_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cfg</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv420nvs_flash_read_cfg_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Callback function prototype for reading the NVS encryption keys. </p>
</dd></dl>

</section>
<section id="id4">
<h3>Header File<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/v5.4.2/components/nvs_flash/include/nvs.h">components/nvs_flash/include/nvs.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;nvs.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">nvs_flash</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">nvs_flash</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES nvs_flash
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES nvs_flash
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id5">
<h3>Functions<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410nvs_set_i812nvs_handle_tPKc6int8_t">
<span id="_CPPv310nvs_set_i812nvs_handle_tPKc6int8_t"></span><span id="_CPPv210nvs_set_i812nvs_handle_tPKc6int8_t"></span><span id="nvs_set_i8__nvs_handle_t.cCP.int8_t"></span><span class="target" id="nvs_8h_1a6a88f61dcb7d0dc2b76e0cbb019d1eca"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_i8</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">int8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_set_i812nvs_handle_tPKc6int8_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>set int8_t value for given key </p>
<p>Set value for the key, given its name. Note that the actual storage will not be updated until <code class="docutils literal notranslate"><span class="pre">nvs_commit</span></code> is called. Regardless whether key-value pair is created or updated, function always requires at least one nvs available entry. See <code class="docutils literal notranslate"><span class="pre">nvs_get_stats</span></code> . After create type of operation, the number of available entries is decreased by one. After update type of operation, the number of available entries remains the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> Handle obtained from nvs_open function. Handles that were opened read only cannot be used. </p></li>
<li><p><strong>key</strong> -- <strong>[in]</strong> Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty. </p></li>
<li><p><strong>value</strong> -- <strong>[in]</strong> The value to set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if value was set successfully</p></li>
<li><p>ESP_FAIL if there is an internal error; most likely due to corrupted NVS partition (only if NVS assertion checks are disabled)</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</p></li>
<li><p>ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only</p></li>
<li><p>ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints</p></li>
<li><p>ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the underlying storage to save the value</p></li>
<li><p>ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash write operation has failed. The value was written however, and update will be finished after re-initialization of nvs, provided that flash operation doesn't fail again. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410nvs_set_u812nvs_handle_tPKc7uint8_t">
<span id="_CPPv310nvs_set_u812nvs_handle_tPKc7uint8_t"></span><span id="_CPPv210nvs_set_u812nvs_handle_tPKc7uint8_t"></span><span id="nvs_set_u8__nvs_handle_t.cCP.uint8_t"></span><span class="target" id="nvs_8h_1a0305af52aebc7d263ca2403d22de69a9"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_u8</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_set_u812nvs_handle_tPKc7uint8_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>set uint8_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_set_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_set_i1612nvs_handle_tPKc7int16_t">
<span id="_CPPv311nvs_set_i1612nvs_handle_tPKc7int16_t"></span><span id="_CPPv211nvs_set_i1612nvs_handle_tPKc7int16_t"></span><span id="nvs_set_i16__nvs_handle_t.cCP.int16_t"></span><span class="target" id="nvs_8h_1ae2bb6637981f4d32bc29cdd200330aaf"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_i16</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">int16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_i1612nvs_handle_tPKc7int16_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>set int16_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_set_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_set_u1612nvs_handle_tPKc8uint16_t">
<span id="_CPPv311nvs_set_u1612nvs_handle_tPKc8uint16_t"></span><span id="_CPPv211nvs_set_u1612nvs_handle_tPKc8uint16_t"></span><span id="nvs_set_u16__nvs_handle_t.cCP.uint16_t"></span><span class="target" id="nvs_8h_1ae429cc09c14acb611a9f385480999de6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_u16</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_u1612nvs_handle_tPKc8uint16_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>set uint16_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_set_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_set_i3212nvs_handle_tPKc7int32_t">
<span id="_CPPv311nvs_set_i3212nvs_handle_tPKc7int32_t"></span><span id="_CPPv211nvs_set_i3212nvs_handle_tPKc7int32_t"></span><span id="nvs_set_i32__nvs_handle_t.cCP.int32_t"></span><span class="target" id="nvs_8h_1a3dae5d19be95ef744036ccd6684a0eea"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_i32</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_i3212nvs_handle_tPKc7int32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>set int32_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_set_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_set_u3212nvs_handle_tPKc8uint32_t">
<span id="_CPPv311nvs_set_u3212nvs_handle_tPKc8uint32_t"></span><span id="_CPPv211nvs_set_u3212nvs_handle_tPKc8uint32_t"></span><span id="nvs_set_u32__nvs_handle_t.cCP.uint32_t"></span><span class="target" id="nvs_8h_1a7e447c2369a1c2823ae01f653bef0bab"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_u32</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_u3212nvs_handle_tPKc8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>set uint32_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_set_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_set_i6412nvs_handle_tPKc7int64_t">
<span id="_CPPv311nvs_set_i6412nvs_handle_tPKc7int64_t"></span><span id="_CPPv211nvs_set_i6412nvs_handle_tPKc7int64_t"></span><span id="nvs_set_i64__nvs_handle_t.cCP.int64_t"></span><span class="target" id="nvs_8h_1a4f12f2d4d68a095278020b8c116a0f2d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_i64</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_i6412nvs_handle_tPKc7int64_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>set int64_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_set_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_set_u6412nvs_handle_tPKc8uint64_t">
<span id="_CPPv311nvs_set_u6412nvs_handle_tPKc8uint64_t"></span><span id="_CPPv211nvs_set_u6412nvs_handle_tPKc8uint64_t"></span><span id="nvs_set_u64__nvs_handle_t.cCP.uint64_t"></span><span class="target" id="nvs_8h_1ab45a7dd95b3b2ada70cd1bba809f20a4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_u64</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_u6412nvs_handle_tPKc8uint64_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>set uint64_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_set_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_set_str12nvs_handle_tPKcPKc">
<span id="_CPPv311nvs_set_str12nvs_handle_tPKcPKc"></span><span id="_CPPv211nvs_set_str12nvs_handle_tPKcPKc"></span><span id="nvs_set_str__nvs_handle_t.cCP.cCP"></span><span class="target" id="nvs_8h_1a66c6390e31cce9c4d59dc874d242ddac"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_str</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_str12nvs_handle_tPKcPKc" title="Permalink to this definition"></a><br /></dt>
<dd><p>set string for given key </p>
<p>Sets string value for the key. Function requires whole space for new data to be available as contiguous entries in same nvs page. Operation consumes 1 overhead entry and 1 entry per each 32 characters of new string including zero character to be set. In case of value update for existing key, entries occupied by the previous value and overhead entry are returned to the pool of available entries. Note that storage of long string values can fail due to fragmentation of nvs pages even if <code class="docutils literal notranslate"><span class="pre">available_entries</span></code> returned by <code class="docutils literal notranslate"><span class="pre">nvs_get_stats</span></code> suggests enough overall space available. Note that the underlying storage will not be updated until <code class="docutils literal notranslate"><span class="pre">nvs_commit</span></code> is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> Handle obtained from nvs_open function. Handles that were opened read only cannot be used. </p></li>
<li><p><strong>key</strong> -- <strong>[in]</strong> Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty. </p></li>
<li><p><strong>value</strong> -- <strong>[in]</strong> The value to set. For strings, the maximum length (including null character) is 4000 bytes, if there is one complete page free for writing. This decreases, however, if the free space is fragmented.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if value was set successfully</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</p></li>
<li><p>ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only</p></li>
<li><p>ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints</p></li>
<li><p>ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the underlying storage to save the value</p></li>
<li><p>ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash write operation has failed. The value was written however, and update will be finished after re-initialization of nvs, provided that flash operation doesn't fail again.</p></li>
<li><p>ESP_ERR_NVS_VALUE_TOO_LONG if the string value is too long </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410nvs_get_i812nvs_handle_tPKcP6int8_t">
<span id="_CPPv310nvs_get_i812nvs_handle_tPKcP6int8_t"></span><span id="_CPPv210nvs_get_i812nvs_handle_tPKcP6int8_t"></span><span id="nvs_get_i8__nvs_handle_t.cCP.int8_tP"></span><span class="target" id="nvs_8h_1a6ecc74483c38916ea9f66fc07d086333"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_i8</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">int8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_get_i812nvs_handle_tPKcP6int8_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get int8_t value for given key </p>
<p>These functions retrieve value for the key, given its name. If <code class="docutils literal notranslate"><span class="pre">key</span></code> does not exist, or the requested variable type doesn't match the type which was used when setting a value, an error is returned.</p>
<p>In case of any error, out_value is not modified.</p>
<p><code class="docutils literal notranslate"><span class="pre">out_value</span></code> has to be a pointer to an already allocated variable of the given type.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of using nvs_get_i32:</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">max_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">;</span><span class="w"> </span><span class="c1">// default value</span>
<span class="n">esp_err_t</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvs_get_i32</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;max_buffer_size&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max_buffer_size</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ESP_OK</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ESP_ERR_NVS_NOT_FOUND</span><span class="p">);</span>
<span class="c1">// if ESP_ERR_NVS_NOT_FOUND was returned, max_buffer_size will still</span>
<span class="c1">// have its default value.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> Handle obtained from nvs_open function. </p></li>
<li><p><strong>key</strong> -- <strong>[in]</strong> Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty. </p></li>
<li><p><strong>out_value</strong> -- Pointer to the output value. May be NULL for nvs_get_str and nvs_get_blob, in this case required length will be returned in length argument.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if the value was retrieved successfully</p></li>
<li><p>ESP_FAIL if there is an internal error; most likely due to corrupted NVS partition (only if NVS assertion checks are disabled)</p></li>
<li><p>ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</p></li>
<li><p>ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints</p></li>
<li><p>ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410nvs_get_u812nvs_handle_tPKcP7uint8_t">
<span id="_CPPv310nvs_get_u812nvs_handle_tPKcP7uint8_t"></span><span id="_CPPv210nvs_get_u812nvs_handle_tPKcP7uint8_t"></span><span id="nvs_get_u8__nvs_handle_t.cCP.uint8_tP"></span><span class="target" id="nvs_8h_1aee87db8410ac85302127351c817d6bae"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_u8</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_get_u812nvs_handle_tPKcP7uint8_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get uint8_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_get_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_get_i1612nvs_handle_tPKcP7int16_t">
<span id="_CPPv311nvs_get_i1612nvs_handle_tPKcP7int16_t"></span><span id="_CPPv211nvs_get_i1612nvs_handle_tPKcP7int16_t"></span><span id="nvs_get_i16__nvs_handle_t.cCP.int16_tP"></span><span class="target" id="nvs_8h_1a6394a84e240d897d184ad5fc539e2aed"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_i16</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">int16_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_i1612nvs_handle_tPKcP7int16_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get int16_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_get_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_get_u1612nvs_handle_tPKcP8uint16_t">
<span id="_CPPv311nvs_get_u1612nvs_handle_tPKcP8uint16_t"></span><span id="_CPPv211nvs_get_u1612nvs_handle_tPKcP8uint16_t"></span><span id="nvs_get_u16__nvs_handle_t.cCP.uint16_tP"></span><span class="target" id="nvs_8h_1a4b44fa374e23455a31cdc17a7fbc8207"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_u16</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_u1612nvs_handle_tPKcP8uint16_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get uint16_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_get_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_get_i3212nvs_handle_tPKcP7int32_t">
<span id="_CPPv311nvs_get_i3212nvs_handle_tPKcP7int32_t"></span><span id="_CPPv211nvs_get_i3212nvs_handle_tPKcP7int32_t"></span><span id="nvs_get_i32__nvs_handle_t.cCP.int32_tP"></span><span class="target" id="nvs_8h_1a911777e4654ca5bf1c46b1c20a8e7299"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_i32</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_i3212nvs_handle_tPKcP7int32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get int32_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_get_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_get_u3212nvs_handle_tPKcP8uint32_t">
<span id="_CPPv311nvs_get_u3212nvs_handle_tPKcP8uint32_t"></span><span id="_CPPv211nvs_get_u3212nvs_handle_tPKcP8uint32_t"></span><span id="nvs_get_u32__nvs_handle_t.cCP.uint32_tP"></span><span class="target" id="nvs_8h_1a85f3f2811ad0495884fb032406e557a6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_u32</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_u3212nvs_handle_tPKcP8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get uint32_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_get_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_get_i6412nvs_handle_tPKcP7int64_t">
<span id="_CPPv311nvs_get_i6412nvs_handle_tPKcP7int64_t"></span><span id="_CPPv211nvs_get_i6412nvs_handle_tPKcP7int64_t"></span><span id="nvs_get_i64__nvs_handle_t.cCP.int64_tP"></span><span class="target" id="nvs_8h_1a92650d8ea9025da2c00e0f6ac4d11c85"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_i64</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_i6412nvs_handle_tPKcP7int64_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get int64_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_get_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_get_u6412nvs_handle_tPKcP8uint64_t">
<span id="_CPPv311nvs_get_u6412nvs_handle_tPKcP8uint64_t"></span><span id="_CPPv211nvs_get_u6412nvs_handle_tPKcP8uint64_t"></span><span id="nvs_get_u64__nvs_handle_t.cCP.uint64_tP"></span><span class="target" id="nvs_8h_1ab9af4ab56ac2f338f3c076d35513bbd5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_u64</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_u6412nvs_handle_tPKcP8uint64_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get uint64_t value for given key </p>
<p>This function is the same as <code class="docutils literal notranslate"><span class="pre">nvs_get_i8</span></code> except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvs_get_str12nvs_handle_tPKcPcP6size_t">
<span id="_CPPv311nvs_get_str12nvs_handle_tPKcPcP6size_t"></span><span id="_CPPv211nvs_get_str12nvs_handle_tPKcPcP6size_t"></span><span id="nvs_get_str__nvs_handle_t.cCP.cP.sP"></span><span class="target" id="nvs_8h_1a9e6cf0362aba1ed1601ea2d4af427d3d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_str</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">length</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_str12nvs_handle_tPKcPcP6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get string value for given key </p>
<p>These functions retrieve the data of an entry, given its key. If key does not exist, or the requested variable type doesn't match the type which was used when setting a value, an error is returned.</p>
<p>In case of any error, out_value is not modified.</p>
<p>All functions expect out_value to be a pointer to an already allocated variable of the given type.</p>
<p>nvs_get_str and nvs_get_blob functions support WinAPI-style length queries. To get the size necessary to store the value, call nvs_get_str or nvs_get_blob with zero out_value and non-zero pointer to length. Variable pointed to by length argument will be set to the required length. For nvs_get_str, this length includes the zero terminator. When calling nvs_get_str and nvs_get_blob with non-zero out_value, length has to be non-zero and has to point to the length available in out_value. It is suggested that nvs_get/set_str is used for zero-terminated C strings, and nvs_get/set_blob used for arbitrary data structures.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example (without error checking) of using nvs_get_str to get a string into dynamic array:</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">required_size</span><span class="p">;</span>
<span class="n">nvs_get_str</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;server_name&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">required_size</span><span class="p">);</span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">server_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">required_size</span><span class="p">);</span>
<span class="n">nvs_get_str</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;server_name&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">server_name</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">required_size</span><span class="p">);</span>

<span class="c1">// Example (without error checking) of using nvs_get_blob to get a binary data</span>
<span class="n">into</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">array</span><span class="o">:</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">);</span>
<span class="n">nvs_get_blob</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dst_mac_addr&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mac_addr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> Handle obtained from nvs_open function. </p></li>
<li><p><strong>key</strong> -- <strong>[in]</strong> Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty. </p></li>
<li><p><strong>out_value</strong> -- <strong>[out]</strong> Pointer to the output value. May be NULL for nvs_get_str and nvs_get_blob, in this case required length will be returned in length argument. </p></li>
<li><p><strong>length</strong> -- <strong>[inout]</strong> A non-zero pointer to the variable holding the length of out_value. In case out_value a zero, will be set to the length required to hold the value. In case out_value is not zero, will be set to the actual length of the value written. For nvs_get_str this includes zero terminator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if the value was retrieved successfully</p></li>
<li><p>ESP_FAIL if there is an internal error; most likely due to corrupted NVS partition (only if NVS assertion checks are disabled)</p></li>
<li><p>ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</p></li>
<li><p>ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints</p></li>
<li><p>ESP_ERR_NVS_INVALID_LENGTH if <code class="docutils literal notranslate"><span class="pre">length</span></code> is not sufficient to store data </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412nvs_get_blob12nvs_handle_tPKcPvP6size_t">
<span id="_CPPv312nvs_get_blob12nvs_handle_tPKcPvP6size_t"></span><span id="_CPPv212nvs_get_blob12nvs_handle_tPKcPvP6size_t"></span><span id="nvs_get_blob__nvs_handle_t.cCP.voidP.sP"></span><span class="target" id="nvs_8h_1a407a597cf06407140d91f7898bf541f4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_blob</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_value</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">length</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412nvs_get_blob12nvs_handle_tPKcPvP6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>get blob value for given key </p>
<p>This function behaves the same as <code class="docutils literal notranslate"><span class="pre">nvs_get_str</span></code>, except for the data type. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv48nvs_openPKc15nvs_open_mode_tP12nvs_handle_t">
<span id="_CPPv38nvs_openPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="_CPPv28nvs_openPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="nvs_open__cCP.nvs_open_mode_t.nvs_handle_tP"></span><span class="target" id="nvs_8h_1a6327b443d65e4a8344a540de6c186234"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_open</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">namespace_name</span></span>, <a class="reference internal" href="#_CPPv415nvs_open_mode_t" title="nvs_open_mode_t"><span class="n"><span class="pre">nvs_open_mode_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">open_mode</span></span>, <a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48nvs_openPKc15nvs_open_mode_tP12nvs_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Open non-volatile storage with a given namespace from the default NVS partition. </p>
<p>Multiple internal ESP-IDF and third party application modules can store their key-value pairs in the NVS module. In order to reduce possible conflicts on key names, each module can use its own namespace. The default NVS partition is the one that is labelled &quot;nvs&quot; in the partition table.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>namespace_name</strong> -- <strong>[in]</strong> Namespace name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty. </p></li>
<li><p><strong>open_mode</strong> -- <strong>[in]</strong> NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will open a handle for reading only. All write requests will be rejected for this handle. </p></li>
<li><p><strong>out_handle</strong> -- <strong>[out]</strong> If successful (return code is zero), handle will be returned in this argument.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if storage handle was opened successfully</p></li>
<li><p>ESP_FAIL if there is an internal error; most likely due to corrupted NVS partition (only if NVS assertion checks are disabled)</p></li>
<li><p>ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized</p></li>
<li><p>ESP_ERR_NVS_PART_NOT_FOUND if the partition with label &quot;nvs&quot; is not found</p></li>
<li><p>ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and mode is NVS_READONLY</p></li>
<li><p>ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints</p></li>
<li><p>ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures</p></li>
<li><p>ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is no space for a new entry or there are too many different namespaces (maximum allowed different namespaces: 254)</p></li>
<li><p>ESP_ERR_NOT_ALLOWED if the NVS partition is read-only and mode is NVS_READWRITE</p></li>
<li><p>ESP_ERR_INVALID_ARG if out_handle is equal to NULL</p></li>
<li><p>other error codes from the underlying storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t">
<span id="_CPPv323nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="_CPPv223nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="nvs_open_from_partition__cCP.cCP.nvs_open_mode_t.nvs_handle_tP"></span><span class="target" id="nvs_8h_1a29f3862a459214f2a057a174ddf80698"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_open_from_partition</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">part_name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">namespace_name</span></span>, <a class="reference internal" href="#_CPPv415nvs_open_mode_t" title="nvs_open_mode_t"><span class="n"><span class="pre">nvs_open_mode_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">open_mode</span></span>, <a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Open non-volatile storage with a given namespace from specified partition. </p>
<p>The behaviour is same as nvs_open() API. However this API can operate on a specified NVS partition instead of default NVS partition. Note that the specified partition must be registered with NVS using nvs_flash_init_partition() API.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>part_name</strong> -- <strong>[in]</strong> Label (name) of the partition of interest for object read/write/erase </p></li>
<li><p><strong>namespace_name</strong> -- <strong>[in]</strong> Namespace name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty. </p></li>
<li><p><strong>open_mode</strong> -- <strong>[in]</strong> NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will open a handle for reading only. All write requests will be rejected for this handle. </p></li>
<li><p><strong>out_handle</strong> -- <strong>[out]</strong> If successful (return code is zero), handle will be returned in this argument.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if storage handle was opened successfully</p></li>
<li><p>ESP_FAIL if there is an internal error; most likely due to corrupted NVS partition (only if NVS assertion checks are disabled)</p></li>
<li><p>ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized</p></li>
<li><p>ESP_ERR_NVS_PART_NOT_FOUND if the partition with specified name is not found</p></li>
<li><p>ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and mode is NVS_READONLY</p></li>
<li><p>ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints</p></li>
<li><p>ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures</p></li>
<li><p>ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is no space for a new entry or there are too many different namespaces (maximum allowed different namespaces: 254)</p></li>
<li><p>ESP_ERR_NOT_ALLOWED if the NVS partition is read-only and mode is NVS_READWRITE</p></li>
<li><p>ESP_ERR_INVALID_ARG if out_handle is equal to NULL</p></li>
<li><p>other error codes from the underlying storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412nvs_set_blob12nvs_handle_tPKcPKv6size_t">
<span id="_CPPv312nvs_set_blob12nvs_handle_tPKcPKv6size_t"></span><span id="_CPPv212nvs_set_blob12nvs_handle_tPKcPKv6size_t"></span><span id="nvs_set_blob__nvs_handle_t.cCP.voidCP.s"></span><span class="target" id="nvs_8h_1a2a2a8a79c0df9a1682d0a1bc31f351c3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_set_blob</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">value</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">length</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412nvs_set_blob12nvs_handle_tPKcPKv6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>set variable length binary value for given key </p>
<p>Sets variable length binary value for the key. Function uses 2 overhead and 1 entry per each 32 bytes of new data from the pool of available entries. See <code class="docutils literal notranslate"><span class="pre">nvs_get_stats</span></code> . In case of value update for existing key, space occupied by the existing value and 2 overhead entries are returned to the pool of available entries. Note that the underlying storage will not be updated until <code class="docutils literal notranslate"><span class="pre">nvs_commit</span></code> is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> Handle obtained from nvs_open function. Handles that were opened read only cannot be used. </p></li>
<li><p><strong>key</strong> -- <strong>[in]</strong> Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty. </p></li>
<li><p><strong>value</strong> -- <strong>[in]</strong> The value to set. </p></li>
<li><p><strong>length</strong> -- <strong>[in]</strong> length of binary value to set, in bytes; Maximum length is 508000 bytes or (97.6% of the partition size - 4000) bytes whichever is lower.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if value was set successfully</p></li>
<li><p>ESP_FAIL if there is an internal error; most likely due to corrupted NVS partition (only if NVS assertion checks are disabled)</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</p></li>
<li><p>ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only</p></li>
<li><p>ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints</p></li>
<li><p>ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the underlying storage to save the value</p></li>
<li><p>ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash write operation has failed. The value was written however, and update will be finished after re-initialization of nvs, provided that flash operation doesn't fail again.</p></li>
<li><p>ESP_ERR_NVS_VALUE_TOO_LONG if the value is too long </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412nvs_find_key12nvs_handle_tPKcP10nvs_type_t">
<span id="_CPPv312nvs_find_key12nvs_handle_tPKcP10nvs_type_t"></span><span id="_CPPv212nvs_find_key12nvs_handle_tPKcP10nvs_type_t"></span><span id="nvs_find_key__nvs_handle_t.cCP.nvs_type_tP"></span><span class="target" id="nvs_8h_1aaf999d8687c41e203c61f36769983cdf"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_find_key</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span>, <a class="reference internal" href="#_CPPv410nvs_type_t" title="nvs_type_t"><span class="n"><span class="pre">nvs_type_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412nvs_find_key12nvs_handle_tPKcP10nvs_type_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Lookup key-value pair with given key name. </p>
<p>Note that function may indicate both existence of the key as well as the data type of NVS entry if it is found.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> Storage handle obtained with nvs_open. </p></li>
<li><p><strong>key</strong> -- <strong>[in]</strong> Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty. </p></li>
<li><p><strong>out_type</strong> -- <strong>[out]</strong> Pointer to the output variable populated with data type of NVS entry in case key was found. May be NULL, respective data type is then not provided. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if NVS entry for key provided was found</p></li>
<li><p>ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</p></li>
<li><p>ESP_FAIL if there is an internal error; most likely due to corrupted NVS partition (only if NVS assertion checks are disabled)</p></li>
<li><p>other error codes from the underlying storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413nvs_erase_key12nvs_handle_tPKc">
<span id="_CPPv313nvs_erase_key12nvs_handle_tPKc"></span><span id="_CPPv213nvs_erase_key12nvs_handle_tPKc"></span><span id="nvs_erase_key__nvs_handle_t.cCP"></span><span class="target" id="nvs_8h_1a0ba2174523872e14ef96b3add427e4dd"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_erase_key</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413nvs_erase_key12nvs_handle_tPKc" title="Permalink to this definition"></a><br /></dt>
<dd><p>Erase key-value pair with given key name. </p>
<p>Note that actual storage may not be updated until nvs_commit function is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> Storage handle obtained with nvs_open. Handles that were opened read only cannot be used.</p></li>
<li><p><strong>key</strong> -- <strong>[in]</strong> Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if erase operation was successful</p></li>
<li><p>ESP_FAIL if there is an internal error; most likely due to corrupted NVS partition (only if NVS assertion checks are disabled)</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</p></li>
<li><p>ESP_ERR_NVS_READ_ONLY if handle was opened as read only</p></li>
<li><p>ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist</p></li>
<li><p>other error codes from the underlying storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413nvs_erase_all12nvs_handle_t">
<span id="_CPPv313nvs_erase_all12nvs_handle_t"></span><span id="_CPPv213nvs_erase_all12nvs_handle_t"></span><span id="nvs_erase_all__nvs_handle_t"></span><span class="target" id="nvs_8h_1a8c72514b8e1a7c464ad0356e4927158b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_erase_all</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413nvs_erase_all12nvs_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Erase all key-value pairs in a namespace. </p>
<p>Note that actual storage may not be updated until nvs_commit function is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- <strong>[in]</strong> Storage handle obtained with nvs_open. Handles that were opened read only cannot be used.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if erase operation was successful</p></li>
<li><p>ESP_FAIL if there is an internal error; most likely due to corrupted NVS partition (only if NVS assertion checks are disabled)</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</p></li>
<li><p>ESP_ERR_NVS_READ_ONLY if handle was opened as read only</p></li>
<li><p>other error codes from the underlying storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410nvs_commit12nvs_handle_t">
<span id="_CPPv310nvs_commit12nvs_handle_t"></span><span id="_CPPv210nvs_commit12nvs_handle_t"></span><span id="nvs_commit__nvs_handle_t"></span><span class="target" id="nvs_8h_1a88e2da69bd240354fdc0be908a933ca1"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_commit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_commit12nvs_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Write any pending changes to non-volatile storage. </p>
<p>After setting any values, nvs_commit() must be called to ensure changes are written to non-volatile storage. Individual implementations may write to storage at other times, but this is not guaranteed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- <strong>[in]</strong> Storage handle obtained with nvs_open. Handles that were opened read only cannot be used.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if the changes have been written successfully</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</p></li>
<li><p>other error codes from the underlying storage driver </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv49nvs_close12nvs_handle_t">
<span id="_CPPv39nvs_close12nvs_handle_t"></span><span id="_CPPv29nvs_close12nvs_handle_t"></span><span id="nvs_close__nvs_handle_t"></span><span class="target" id="nvs_8h_1a67e6e6b8ba9a43fc08ca9a9609905c8d"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_close</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49nvs_close12nvs_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Close the storage handle and free any allocated resources. </p>
<p>This function should be called for each handle opened with nvs_open once the handle is not in use any more. Closing the handle may not automatically write the changes to nonvolatile storage. This has to be done explicitly using nvs_commit function. Once this function is called on a handle, the handle should no longer be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- <strong>[in]</strong> Storage handle to close </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413nvs_get_statsPKcP11nvs_stats_t">
<span id="_CPPv313nvs_get_statsPKcP11nvs_stats_t"></span><span id="_CPPv213nvs_get_statsPKcP11nvs_stats_t"></span><span id="nvs_get_stats__cCP.nvs_stats_tP"></span><span class="target" id="nvs_8h_1a8fed09d46b77aa6dd0e8840959fe1933"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_stats</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">part_name</span></span>, <a class="reference internal" href="#_CPPv411nvs_stats_t" title="nvs_stats_t"><span class="n"><span class="pre">nvs_stats_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">nvs_stats</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413nvs_get_statsPKcP11nvs_stats_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Fill structure <a class="reference internal" href="#structnvs__stats__t"><span class="std std-ref">nvs_stats_t</span></a>. It provides info about memory used by NVS. </p>
<p>This function calculates the number of used entries, free entries, available entries, total entries and number of namespaces in partition.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of nvs_get_stats() to get overview of actual statistics of data entries :</span>
<span class="n">nvs_stats_t</span><span class="w"> </span><span class="n">nvs_stats</span><span class="p">;</span>
<span class="n">nvs_get_stats</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nvs_stats</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Count: UsedEntries = (%lu), FreeEntries = (%lu), AvailableEntries = (%lu), AllEntries = (%lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">       </span><span class="n">nvs_stats</span><span class="p">.</span><span class="n">used_entries</span><span class="p">,</span><span class="w"> </span><span class="n">nvs_stats</span><span class="p">.</span><span class="n">free_entries</span><span class="p">,</span><span class="w"> </span><span class="n">nvs_stats</span><span class="p">.</span><span class="n">available_entries</span><span class="p">,</span><span class="w"> </span><span class="n">nvs_stats</span><span class="p">.</span><span class="n">total_entries</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>part_name</strong> -- <strong>[in]</strong> Partition name NVS in the partition table. If pass a NULL than will use NVS_DEFAULT_PART_NAME (&quot;nvs&quot;).</p></li>
<li><p><strong>nvs_stats</strong> -- <strong>[out]</strong> Returns filled structure nvs_states_t. It provides info about used memory the partition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if the changes have been written successfully. Return param nvs_stats will be filled.</p></li>
<li><p>ESP_ERR_NVS_PART_NOT_FOUND if the partition with label &quot;name&quot; is not found. Return param nvs_stats will be filled 0.</p></li>
<li><p>ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized. Return param nvs_stats will be filled 0.</p></li>
<li><p>ESP_ERR_INVALID_ARG if nvs_stats is equal to NULL.</p></li>
<li><p>ESP_ERR_INVALID_STATE if there is page with the status of INVALID. Return param nvs_stats will be filled not with correct values because not all pages will be counted. Counting will be interrupted at the first INVALID page. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424nvs_get_used_entry_count12nvs_handle_tP6size_t">
<span id="_CPPv324nvs_get_used_entry_count12nvs_handle_tP6size_t"></span><span id="_CPPv224nvs_get_used_entry_count12nvs_handle_tP6size_t"></span><span id="nvs_get_used_entry_count__nvs_handle_t.sP"></span><span class="target" id="nvs_8h_1ae6b52d96c1dcfc9d4b2ef987503955f0"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_get_used_entry_count</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">used_entries</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424nvs_get_used_entry_count12nvs_handle_tP6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Calculate all entries in a namespace. </p>
<p>An entry represents the smallest storage unit in NVS. Strings and blobs may occupy more than one entry. Note that to find out the total number of entries occupied by the namespace, add one to the returned value used_entries (if err is equal to ESP_OK). Because the name space entry takes one entry.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of nvs_get_used_entry_count() to get amount of all key-value pairs in one namespace:</span>
<span class="n">nvs_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="n">nvs_open</span><span class="p">(</span><span class="s">&quot;namespace1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NVS_READWRITE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="p">...</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">used_entries</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">total_entries_namespace</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">nvs_get_used_entry_count</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">used_entries</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ESP_OK</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// the total number of entries occupied by the namespace</span>
<span class="w">    </span><span class="n">total_entries_namespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">used_entries</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> Handle obtained from nvs_open function.</p></li>
<li><p><strong>used_entries</strong> -- <strong>[out]</strong> Returns amount of used entries from a namespace.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if the changes have been written successfully. Return param used_entries will be filled valid value.</p></li>
<li><p>ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized. Return param used_entries will be filled 0.</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL. Return param used_entries will be filled 0.</p></li>
<li><p>ESP_ERR_INVALID_ARG if used_entries is equal to NULL.</p></li>
<li><p>Other error codes from the underlying storage driver. Return param used_entries will be filled 0. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414nvs_entry_findPKcPKc10nvs_type_tP14nvs_iterator_t">
<span id="_CPPv314nvs_entry_findPKcPKc10nvs_type_tP14nvs_iterator_t"></span><span id="_CPPv214nvs_entry_findPKcPKc10nvs_type_tP14nvs_iterator_t"></span><span id="nvs_entry_find__cCP.cCP.nvs_type_t.nvs_iterator_tP"></span><span class="target" id="nvs_8h_1a29635aa4ade9944286d1fc39011969c6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_entry_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">part_name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">namespace_name</span></span>, <a class="reference internal" href="#_CPPv410nvs_type_t" title="nvs_type_t"><span class="n"><span class="pre">nvs_type_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">type</span></span>, <a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t"><span class="n"><span class="pre">nvs_iterator_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">output_iterator</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414nvs_entry_findPKcPKc10nvs_type_tP14nvs_iterator_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create an iterator to enumerate NVS entries based on one or more parameters. </p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of listing all the key-value pairs of any type under specified partition and namespace</span>
<span class="w"> </span><span class="n">nvs_iterator_t</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w"> </span><span class="n">esp_err_t</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvs_entry_find</span><span class="p">(</span><span class="o">&lt;</span><span class="n">nvs_partition_name</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">namespace</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">NVS_TYPE_ANY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>
<span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ESP_OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">nvs_entry_info_t</span><span class="w"> </span><span class="n">info</span><span class="p">;</span>
<span class="w">     </span><span class="n">nvs_entry_info</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span><span class="w"> </span><span class="c1">// Can omit error check if parameters are guaranteed to be non-NULL</span>
<span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;key &#39;%s&#39;, type &#39;%d&#39; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
<span class="w">     </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvs_entry_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>
<span class="w"> </span><span class="n">nvs_release_iterator</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>part_name</strong> -- <strong>[in]</strong> Partition name</p></li>
<li><p><strong>namespace_name</strong> -- <strong>[in]</strong> Set this value if looking for entries with a specific namespace. Pass NULL otherwise.</p></li>
<li><p><strong>type</strong> -- <strong>[in]</strong> One of nvs_type_t values.</p></li>
<li><p><strong>output_iterator</strong> -- <strong>[out]</strong> Set to a valid iterator to enumerate all the entries found. Set to NULL if no entry for specified criteria was found. If any other error except ESP_ERR_INVALID_ARG occurs, <code class="docutils literal notranslate"><span class="pre">output_iterator</span></code> is NULL, too. If ESP_ERR_INVALID_ARG occurs, <code class="docutils literal notranslate"><span class="pre">output_iterator</span></code> is not changed. If a valid iterator is obtained through this function, it has to be released using <code class="docutils literal notranslate"><span class="pre">nvs_release_iterator</span></code> when not used any more, unless ESP_ERR_INVALID_ARG is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if no internal error or programming error occurred.</p></li>
<li><p>ESP_ERR_NVS_NOT_FOUND if no element of specified criteria has been found.</p></li>
<li><p>ESP_ERR_NO_MEM if memory has been exhausted during allocation of internal structures.</p></li>
<li><p>ESP_ERR_INVALID_ARG if any of the parameters is NULL. Note: don't release <code class="docutils literal notranslate"><span class="pre">output_iterator</span></code> in case ESP_ERR_INVALID_ARG has been returned </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424nvs_entry_find_in_handle12nvs_handle_t10nvs_type_tP14nvs_iterator_t">
<span id="_CPPv324nvs_entry_find_in_handle12nvs_handle_t10nvs_type_tP14nvs_iterator_t"></span><span id="_CPPv224nvs_entry_find_in_handle12nvs_handle_t10nvs_type_tP14nvs_iterator_t"></span><span id="nvs_entry_find_in_handle__nvs_handle_t.nvs_type_t.nvs_iterator_tP"></span><span class="target" id="nvs_8h_1a5d3d87b6de9f1e94505a0038c2ca709c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_entry_find_in_handle</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">handle</span></span>, <a class="reference internal" href="#_CPPv410nvs_type_t" title="nvs_type_t"><span class="n"><span class="pre">nvs_type_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">type</span></span>, <a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t"><span class="n"><span class="pre">nvs_iterator_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">output_iterator</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424nvs_entry_find_in_handle12nvs_handle_t10nvs_type_tP14nvs_iterator_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create an iterator to enumerate NVS entries based on a handle and type. </p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of listing all the key-value pairs of any type under specified handle (which defines a partition and namespace)</span>
<span class="w"> </span><span class="n">nvs_iterator_t</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w"> </span><span class="n">esp_err_t</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvs_entry_find_in_handle</span><span class="p">(</span><span class="o">&lt;</span><span class="n">nvs_handle</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">NVS_TYPE_ANY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>
<span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ESP_OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">nvs_entry_info_t</span><span class="w"> </span><span class="n">info</span><span class="p">;</span>
<span class="w">     </span><span class="n">nvs_entry_info</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span><span class="w"> </span><span class="c1">// Can omit error check if parameters are guaranteed to be non-NULL</span>
<span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;key &#39;%s&#39;, type &#39;%d&#39; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
<span class="w">     </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvs_entry_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>
<span class="w"> </span><span class="n">nvs_release_iterator</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handle</strong> -- <strong>[in]</strong> Handle obtained from nvs_open function.</p></li>
<li><p><strong>type</strong> -- <strong>[in]</strong> One of nvs_type_t values.</p></li>
<li><p><strong>output_iterator</strong> -- <strong>[out]</strong> Set to a valid iterator to enumerate all the entries found. Set to NULL if no entry for specified criteria was found. If any other error except ESP_ERR_INVALID_ARG occurs, <code class="docutils literal notranslate"><span class="pre">output_iterator</span></code> is NULL, too. If ESP_ERR_INVALID_ARG occurs, <code class="docutils literal notranslate"><span class="pre">output_iterator</span></code> is not changed. If a valid iterator is obtained through this function, it has to be released using <code class="docutils literal notranslate"><span class="pre">nvs_release_iterator</span></code> when not used any more, unless ESP_ERR_INVALID_ARG is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if no internal error or programming error occurred.</p></li>
<li><p>ESP_ERR_NVS_NOT_FOUND if no element of specified criteria has been found.</p></li>
<li><p>ESP_ERR_NO_MEM if memory has been exhausted during allocation of internal structures.</p></li>
<li><p>ESP_ERR_NVS_INVALID_HANDLE if unknown handle was specified.</p></li>
<li><p>ESP_ERR_INVALID_ARG if output_iterator parameter is NULL. Note: don't release <code class="docutils literal notranslate"><span class="pre">output_iterator</span></code> in case ESP_ERR_INVALID_ARG has been returned </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414nvs_entry_nextP14nvs_iterator_t">
<span id="_CPPv314nvs_entry_nextP14nvs_iterator_t"></span><span id="_CPPv214nvs_entry_nextP14nvs_iterator_t"></span><span id="nvs_entry_next__nvs_iterator_tP"></span><span class="target" id="nvs_8h_1a0b947d1e0c3568a12739bd3857c950db"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_entry_next</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t"><span class="n"><span class="pre">nvs_iterator_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">iterator</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414nvs_entry_nextP14nvs_iterator_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Advances the iterator to next item matching the iterator criteria. </p>
<p>Note that any copies of the iterator will be invalid after this call.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>iterator</strong> -- <strong>[inout]</strong> Iterator obtained from nvs_entry_find or nvs_entry_find_in_handle function. Must be non-NULL. If any error except ESP_ERR_INVALID_ARG occurs, <code class="docutils literal notranslate"><span class="pre">iterator</span></code> is set to NULL. If ESP_ERR_INVALID_ARG occurs, <code class="docutils literal notranslate"><span class="pre">iterator</span></code> is not changed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if no internal error or programming error occurred.</p></li>
<li><p>ESP_ERR_NVS_NOT_FOUND if no next element matching the iterator criteria.</p></li>
<li><p>ESP_ERR_INVALID_ARG if <code class="docutils literal notranslate"><span class="pre">iterator</span></code> is NULL.</p></li>
<li><p>Possibly other errors in the future for internal programming or flash errors. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414nvs_entry_infoK14nvs_iterator_tP16nvs_entry_info_t">
<span id="_CPPv314nvs_entry_infoK14nvs_iterator_tP16nvs_entry_info_t"></span><span id="_CPPv214nvs_entry_infoK14nvs_iterator_tP16nvs_entry_info_t"></span><span id="nvs_entry_info__nvs_iterator_tC.nvs_entry_info_tP"></span><span class="target" id="nvs_8h_1afc7f4cb1e782cd65b75bf2b6c11327ea"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_entry_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t"><span class="n"><span class="pre">nvs_iterator_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">iterator</span></span>, <a class="reference internal" href="#_CPPv416nvs_entry_info_t" title="nvs_entry_info_t"><span class="n"><span class="pre">nvs_entry_info_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_info</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414nvs_entry_infoK14nvs_iterator_tP16nvs_entry_info_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Fills <a class="reference internal" href="#structnvs__entry__info__t"><span class="std std-ref">nvs_entry_info_t</span></a> structure with information about entry pointed to by the iterator. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterator</strong> -- <strong>[in]</strong> Iterator obtained from nvs_entry_find or nvs_entry_find_in_handle function. Must be non-NULL.</p></li>
<li><p><strong>out_info</strong> -- <strong>[out]</strong> Structure to which entry information is copied.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK if all parameters are valid; current iterator data has been written to out_info</p></li>
<li><p>ESP_ERR_INVALID_ARG if one of the parameters is NULL. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420nvs_release_iterator14nvs_iterator_t">
<span id="_CPPv320nvs_release_iterator14nvs_iterator_t"></span><span id="_CPPv220nvs_release_iterator14nvs_iterator_t"></span><span id="nvs_release_iterator__nvs_iterator_t"></span><span class="target" id="nvs_8h_1a33eceb70a1cc57c2fe2bae30a76f819a"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_release_iterator</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t"><span class="n"><span class="pre">nvs_iterator_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">iterator</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420nvs_release_iterator14nvs_iterator_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Release iterator. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>iterator</strong> -- <strong>[in]</strong> Release iterator obtained from nvs_entry_find or nvs_entry_find_in_handle or nvs_entry_next function. NULL argument is allowed. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id6">
<h3>Structures<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv416nvs_entry_info_t">
<span id="_CPPv316nvs_entry_info_t"></span><span id="_CPPv216nvs_entry_info_t"></span><span id="nvs_entry_info_t"></span><span class="target" id="structnvs__entry__info__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_entry_info_t</span></span></span><a class="headerlink" href="#_CPPv416nvs_entry_info_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>information about entry obtained from nvs_entry_info function </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16nvs_entry_info_t14namespace_nameE">
<span id="_CPPv3N16nvs_entry_info_t14namespace_nameE"></span><span id="_CPPv2N16nvs_entry_info_t14namespace_nameE"></span><span id="nvs_entry_info_t::namespace_name__cA"></span><span class="target" id="structnvs__entry__info__t_1aedbb175571f10416b1a242ee6b862d7d"></span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">namespace_name</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">NVS_NS_NAME_MAX_SIZE</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N16nvs_entry_info_t14namespace_nameE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Namespace to which key-value belong </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16nvs_entry_info_t3keyE">
<span id="_CPPv3N16nvs_entry_info_t3keyE"></span><span id="_CPPv2N16nvs_entry_info_t3keyE"></span><span id="nvs_entry_info_t::key__cA"></span><span class="target" id="structnvs__entry__info__t_1aa8e8a676eac22af4486c455c37974718"></span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">key</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">NVS_KEY_NAME_MAX_SIZE</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N16nvs_entry_info_t3keyE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Key of stored key-value pair </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16nvs_entry_info_t4typeE">
<span id="_CPPv3N16nvs_entry_info_t4typeE"></span><span id="_CPPv2N16nvs_entry_info_t4typeE"></span><span id="nvs_entry_info_t::type__nvs_type_t"></span><span class="target" id="structnvs__entry__info__t_1ad9cd8f3eb0f354e9f1074586bc7580dd"></span><a class="reference internal" href="#_CPPv410nvs_type_t" title="nvs_type_t"><span class="n"><span class="pre">nvs_type_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">type</span></span></span><a class="headerlink" href="#_CPPv4N16nvs_entry_info_t4typeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of stored key-value pair </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv411nvs_stats_t">
<span id="_CPPv311nvs_stats_t"></span><span id="_CPPv211nvs_stats_t"></span><span id="nvs_stats_t"></span><span class="target" id="structnvs__stats__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_stats_t</span></span></span><a class="headerlink" href="#_CPPv411nvs_stats_t" title="Permalink to this definition"></a><br /></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Info about storage space NVS. </p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11nvs_stats_t12used_entriesE">
<span id="_CPPv3N11nvs_stats_t12used_entriesE"></span><span id="_CPPv2N11nvs_stats_t12used_entriesE"></span><span id="nvs_stats_t::used_entries__s"></span><span class="target" id="structnvs__stats__t_1a984ca538c8d5ed3657e79a61ae32290d"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">used_entries</span></span></span><a class="headerlink" href="#_CPPv4N11nvs_stats_t12used_entriesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of used entries. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11nvs_stats_t12free_entriesE">
<span id="_CPPv3N11nvs_stats_t12free_entriesE"></span><span id="_CPPv2N11nvs_stats_t12free_entriesE"></span><span id="nvs_stats_t::free_entries__s"></span><span class="target" id="structnvs__stats__t_1aabe96c61ba4d7e45986ade7662dd2976"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">free_entries</span></span></span><a class="headerlink" href="#_CPPv4N11nvs_stats_t12free_entriesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of free entries. It includes also reserved entries. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11nvs_stats_t17available_entriesE">
<span id="_CPPv3N11nvs_stats_t17available_entriesE"></span><span id="_CPPv2N11nvs_stats_t17available_entriesE"></span><span id="nvs_stats_t::available_entries__s"></span><span class="target" id="structnvs__stats__t_1a7d9dbd0119726c4facc3a6722163c06d"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">available_entries</span></span></span><a class="headerlink" href="#_CPPv4N11nvs_stats_t17available_entriesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of entries available for data storage. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11nvs_stats_t13total_entriesE">
<span id="_CPPv3N11nvs_stats_t13total_entriesE"></span><span id="_CPPv2N11nvs_stats_t13total_entriesE"></span><span id="nvs_stats_t::total_entries__s"></span><span class="target" id="structnvs__stats__t_1aefc55846fa9a1c4b66002dc2064cb6f8"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">total_entries</span></span></span><a class="headerlink" href="#_CPPv4N11nvs_stats_t13total_entriesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of all entries. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11nvs_stats_t15namespace_countE">
<span id="_CPPv3N11nvs_stats_t15namespace_countE"></span><span id="_CPPv2N11nvs_stats_t15namespace_countE"></span><span id="nvs_stats_t::namespace_count__s"></span><span class="target" id="structnvs__stats__t_1ada57627fb643fd0ca4bda5110f47faa6"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">namespace_count</span></span></span><a class="headerlink" href="#_CPPv4N11nvs_stats_t15namespace_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of namespaces. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id7">
<h3>Macros<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_BASE">
<span class="target" id="nvs_8h_1a6ebf3d06cf50a876d6702b293e909d8b"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_BASE</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_BASE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Starting number of error codes </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_NOT_INITIALIZED">
<span class="target" id="nvs_8h_1ad943a82bd363a027c66c0a96be0d18c1"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_NOT_INITIALIZED</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_NOT_INITIALIZED" title="Permalink to this definition"></a><br /></dt>
<dd><p>The storage driver is not initialized </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_NOT_FOUND">
<span class="target" id="nvs_8h_1a082e1ba076150e1c74f78bedf51f33d3"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_NOT_FOUND</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_NOT_FOUND" title="Permalink to this definition"></a><br /></dt>
<dd><p>A requested entry couldn't be found or namespace doesn’t exist yet and mode is NVS_READONLY </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_TYPE_MISMATCH">
<span class="target" id="nvs_8h_1a879189233ef6af91693744b61315b8b0"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_TYPE_MISMATCH</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_TYPE_MISMATCH" title="Permalink to this definition"></a><br /></dt>
<dd><p>The type of set or get operation doesn't match the type of value stored in NVS </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_READ_ONLY">
<span class="target" id="nvs_8h_1a0375ec3f706dae978eec4e5ea4b63595"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_READ_ONLY</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_READ_ONLY" title="Permalink to this definition"></a><br /></dt>
<dd><p>Storage handle was opened as read only </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_NOT_ENOUGH_SPACE">
<span class="target" id="nvs_8h_1a749dd12cecf7a713767e02d82a691438"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_NOT_ENOUGH_SPACE</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_NOT_ENOUGH_SPACE" title="Permalink to this definition"></a><br /></dt>
<dd><p>There is not enough space in the underlying storage to save the value </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_INVALID_NAME">
<span class="target" id="nvs_8h_1a1bd03eb2ed14371d21bad10191296603"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_INVALID_NAME</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_INVALID_NAME" title="Permalink to this definition"></a><br /></dt>
<dd><p>Namespace name doesn’t satisfy constraints </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_INVALID_HANDLE">
<span class="target" id="nvs_8h_1a5f8311ac86b9c5148a5a462ed807bb9c"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_INVALID_HANDLE</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_INVALID_HANDLE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Handle has been closed or is NULL </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_REMOVE_FAILED">
<span class="target" id="nvs_8h_1a6e2dd398a871449dacf60f7291f23033"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_REMOVE_FAILED</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_REMOVE_FAILED" title="Permalink to this definition"></a><br /></dt>
<dd><p>The value wasn’t updated because flash write operation has failed. The value was written however, and update will be finished after re-initialization of nvs, provided that flash operation doesn’t fail again. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_KEY_TOO_LONG">
<span class="target" id="nvs_8h_1a43e34b6c49c7aa954db4f04fc41e3296"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_KEY_TOO_LONG</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_KEY_TOO_LONG" title="Permalink to this definition"></a><br /></dt>
<dd><p>Key name is too long </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_PAGE_FULL">
<span class="target" id="nvs_8h_1a48b4105cbb5e8ddde83619b4ab88daa5"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_PAGE_FULL</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_PAGE_FULL" title="Permalink to this definition"></a><br /></dt>
<dd><p>Internal error; never returned by nvs API functions </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_INVALID_STATE">
<span class="target" id="nvs_8h_1a0a66474f77e59dd4e9d0f92402c71a08"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_INVALID_STATE</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_INVALID_STATE" title="Permalink to this definition"></a><br /></dt>
<dd><p>NVS is in an inconsistent state due to a previous error. Call nvs_flash_init and nvs_open again, then retry. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_INVALID_LENGTH">
<span class="target" id="nvs_8h_1a8fe5478e998fcb6ba2504fad13563695"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_INVALID_LENGTH</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_INVALID_LENGTH" title="Permalink to this definition"></a><br /></dt>
<dd><p>String or blob length is not sufficient to store data </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_NO_FREE_PAGES">
<span class="target" id="nvs_8h_1a0db9bc5030273dc8443de06de2bdf166"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_NO_FREE_PAGES</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_NO_FREE_PAGES" title="Permalink to this definition"></a><br /></dt>
<dd><p>NVS partition doesn't contain any empty pages. This may happen if NVS partition was truncated. Erase the whole partition and call nvs_flash_init again. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_VALUE_TOO_LONG">
<span class="target" id="nvs_8h_1a069270375766125d42cd881d17e0caac"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_VALUE_TOO_LONG</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_VALUE_TOO_LONG" title="Permalink to this definition"></a><br /></dt>
<dd><p>Value doesn't fit into the entry or string or blob length is longer than supported by the implementation </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_PART_NOT_FOUND">
<span class="target" id="nvs_8h_1ab5c583c77736f31153212fc24e9ad428"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_PART_NOT_FOUND</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_PART_NOT_FOUND" title="Permalink to this definition"></a><br /></dt>
<dd><p>Partition with specified name is not found in the partition table </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_NEW_VERSION_FOUND">
<span class="target" id="nvs_8h_1a719036fc53adfba75a722bc3b2c8088d"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_NEW_VERSION_FOUND</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_NEW_VERSION_FOUND" title="Permalink to this definition"></a><br /></dt>
<dd><p>NVS partition contains data in new format and cannot be recognized by this version of code </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_XTS_ENCR_FAILED">
<span class="target" id="nvs_8h_1a8d6a9ee18ef709bfb31b5b0876fdb4e2"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_XTS_ENCR_FAILED</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_XTS_ENCR_FAILED" title="Permalink to this definition"></a><br /></dt>
<dd><p>XTS encryption failed while writing NVS entry </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_XTS_DECR_FAILED">
<span class="target" id="nvs_8h_1a3b7991e1ece6f0a068188ff0e6446646"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_XTS_DECR_FAILED</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_XTS_DECR_FAILED" title="Permalink to this definition"></a><br /></dt>
<dd><p>XTS decryption failed while reading NVS entry </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_XTS_CFG_FAILED">
<span class="target" id="nvs_8h_1a4304c1cc1a58723ba7e8cd52a3240fad"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_XTS_CFG_FAILED</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_XTS_CFG_FAILED" title="Permalink to this definition"></a><br /></dt>
<dd><p>XTS configuration setting failed </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_XTS_CFG_NOT_FOUND">
<span class="target" id="nvs_8h_1a5ed7fdfd6c8d769f7148d7553b97f004"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_XTS_CFG_NOT_FOUND</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_XTS_CFG_NOT_FOUND" title="Permalink to this definition"></a><br /></dt>
<dd><p>XTS configuration not found </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_ENCR_NOT_SUPPORTED">
<span class="target" id="nvs_8h_1a680919934f73044eef6d5a7d235d6bc5"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_ENCR_NOT_SUPPORTED</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_ENCR_NOT_SUPPORTED" title="Permalink to this definition"></a><br /></dt>
<dd><p>NVS encryption is not supported in this version </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_KEYS_NOT_INITIALIZED">
<span class="target" id="nvs_8h_1a222febdb2697ebcd48f673582de503f7"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_KEYS_NOT_INITIALIZED</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_KEYS_NOT_INITIALIZED" title="Permalink to this definition"></a><br /></dt>
<dd><p>NVS key partition is uninitialized </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_CORRUPT_KEY_PART">
<span class="target" id="nvs_8h_1ae0a1f13593d08f82d3e36f34838cb003"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_CORRUPT_KEY_PART</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_CORRUPT_KEY_PART" title="Permalink to this definition"></a><br /></dt>
<dd><p>NVS key partition is corrupt </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_WRONG_ENCRYPTION">
<span class="target" id="nvs_8h_1ab0f92c442fade1420558297b185e7929"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_WRONG_ENCRYPTION</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_WRONG_ENCRYPTION" title="Permalink to this definition"></a><br /></dt>
<dd><p>NVS partition is marked as encrypted with generic flash encryption. This is forbidden since the NVS encryption works differently. </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.ESP_ERR_NVS_CONTENT_DIFFERS">
<span class="target" id="nvs_8h_1ada3575eb4ea5831fbb35ac564f0d49e6"></span><span class="sig-name descname"><span class="n"><span class="pre">ESP_ERR_NVS_CONTENT_DIFFERS</span></span></span><a class="headerlink" href="#c.ESP_ERR_NVS_CONTENT_DIFFERS" title="Permalink to this definition"></a><br /></dt>
<dd><p>Internal error; never returned by nvs API functions. NVS key is different in comparison </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.NVS_DEFAULT_PART_NAME">
<span class="target" id="nvs_8h_1a4e567a079a04ef71a18d21de58bd9b5a"></span><span class="sig-name descname"><span class="n"><span class="pre">NVS_DEFAULT_PART_NAME</span></span></span><a class="headerlink" href="#c.NVS_DEFAULT_PART_NAME" title="Permalink to this definition"></a><br /></dt>
<dd><p>Default partition name of the NVS partition in the partition table </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.NVS_PART_NAME_MAX_SIZE">
<span class="target" id="nvs_8h_1a1db8c93ce4ae61d2900cd70ebb021e1d"></span><span class="sig-name descname"><span class="n"><span class="pre">NVS_PART_NAME_MAX_SIZE</span></span></span><a class="headerlink" href="#c.NVS_PART_NAME_MAX_SIZE" title="Permalink to this definition"></a><br /></dt>
<dd><p>maximum length of partition name (excluding null terminator) </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.NVS_KEY_NAME_MAX_SIZE">
<span class="target" id="nvs_8h_1a6a9257025e312bd177991833ff92f27a"></span><span class="sig-name descname"><span class="n"><span class="pre">NVS_KEY_NAME_MAX_SIZE</span></span></span><a class="headerlink" href="#c.NVS_KEY_NAME_MAX_SIZE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Maximum length of NVS key name (including null terminator) </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.NVS_NS_NAME_MAX_SIZE">
<span class="target" id="nvs_8h_1a2dace11d6eac99e2a1140bda1fdb5de6"></span><span class="sig-name descname"><span class="n"><span class="pre">NVS_NS_NAME_MAX_SIZE</span></span></span><a class="headerlink" href="#c.NVS_NS_NAME_MAX_SIZE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Maximum length of NVS namespace name (including null terminator) </p>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.NVS_GUARD_SYSVIEW_MACRO_EXPANSION_PUSH">
<span class="target" id="nvs_8h_1ae567262dce4f6f1bf71390cd9bb6831a"></span><span class="sig-name descname"><span class="n"><span class="pre">NVS_GUARD_SYSVIEW_MACRO_EXPANSION_PUSH</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.NVS_GUARD_SYSVIEW_MACRO_EXPANSION_PUSH" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.NVS_GUARD_SYSVIEW_MACRO_EXPANSION_POP">
<span class="target" id="nvs_8h_1a9cb8776a4a5c7dabe10dcb1afdf7a928"></span><span class="sig-name descname"><span class="n"><span class="pre">NVS_GUARD_SYSVIEW_MACRO_EXPANSION_POP</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.NVS_GUARD_SYSVIEW_MACRO_EXPANSION_POP" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
<section id="id8">
<h3>Type Definitions<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv412nvs_handle_t">
<span id="_CPPv312nvs_handle_t"></span><span id="_CPPv212nvs_handle_t"></span><span id="nvs_handle_t"></span><span class="target" id="nvs_8h_1a1d7beddf57b3313de191f91ba639f9aa"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_handle_t</span></span></span><a class="headerlink" href="#_CPPv412nvs_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Opaque pointer type representing non-volatile storage handle </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv410nvs_handle">
<span id="_CPPv310nvs_handle"></span><span id="_CPPv210nvs_handle"></span><span id="nvs_handle"></span><span class="target" id="nvs_8h_1a2f2c716f08f30da049ffd5f8e10c40ea"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t"><span class="n"><span class="pre">nvs_handle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_handle</span></span></span><a class="headerlink" href="#_CPPv410nvs_handle" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv413nvs_open_mode">
<span id="_CPPv313nvs_open_mode"></span><span id="_CPPv213nvs_open_mode"></span><span id="nvs_open_mode"></span><span class="target" id="nvs_8h_1a58b11f9db94a9699f095102b1361e53f"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv415nvs_open_mode_t" title="nvs_open_mode_t"><span class="n"><span class="pre">nvs_open_mode_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_open_mode</span></span></span><a class="headerlink" href="#_CPPv413nvs_open_mode" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv414nvs_iterator_t">
<span id="_CPPv314nvs_iterator_t"></span><span id="_CPPv214nvs_iterator_t"></span><span id="nvs_iterator_t"></span><span class="target" id="nvs_8h_1addeca2dd4bededba2c1c5aac2dfd5cbf"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">nvs_opaque_iterator_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">nvs_iterator_t</span></span></span><a class="headerlink" href="#_CPPv414nvs_iterator_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Opaque pointer type representing iterator to nvs entries </p>
</dd></dl>

</section>
<section id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv415nvs_open_mode_t">
<span id="_CPPv315nvs_open_mode_t"></span><span id="_CPPv215nvs_open_mode_t"></span><span class="target" id="nvs_8h_1a017e1932838b044b88f875edf56e3793"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_open_mode_t</span></span></span><a class="headerlink" href="#_CPPv415nvs_open_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Mode of opening the non-volatile storage. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15nvs_open_mode_t12NVS_READONLYE">
<span id="_CPPv3N15nvs_open_mode_t12NVS_READONLYE"></span><span id="_CPPv2N15nvs_open_mode_t12NVS_READONLYE"></span><span class="target" id="nvs_8h_1a017e1932838b044b88f875edf56e3793adcb7dd95b10700e8855315dd2a88c02d"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_READONLY</span></span></span><a class="headerlink" href="#_CPPv4N15nvs_open_mode_t12NVS_READONLYE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Read only </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15nvs_open_mode_t13NVS_READWRITEE">
<span id="_CPPv3N15nvs_open_mode_t13NVS_READWRITEE"></span><span id="_CPPv2N15nvs_open_mode_t13NVS_READWRITEE"></span><span class="target" id="nvs_8h_1a017e1932838b044b88f875edf56e3793afd73ea5fe0b78c36af2a47b3bb788d7b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_READWRITE</span></span></span><a class="headerlink" href="#_CPPv4N15nvs_open_mode_t13NVS_READWRITEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Read and write </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv410nvs_type_t">
<span id="_CPPv310nvs_type_t"></span><span id="_CPPv210nvs_type_t"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvs_type_t</span></span></span><a class="headerlink" href="#_CPPv410nvs_type_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Types of variables. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t11NVS_TYPE_U8E">
<span id="_CPPv3N10nvs_type_t11NVS_TYPE_U8E"></span><span id="_CPPv2N10nvs_type_t11NVS_TYPE_U8E"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a0bf45d256ba3969cfa47d938da79a610"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_U8</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t11NVS_TYPE_U8E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type uint8_t </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t11NVS_TYPE_I8E">
<span id="_CPPv3N10nvs_type_t11NVS_TYPE_I8E"></span><span id="_CPPv2N10nvs_type_t11NVS_TYPE_I8E"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a5b774222e037fe8762a52c10165b0cf7"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_I8</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t11NVS_TYPE_I8E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type int8_t </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t12NVS_TYPE_U16E">
<span id="_CPPv3N10nvs_type_t12NVS_TYPE_U16E"></span><span id="_CPPv2N10nvs_type_t12NVS_TYPE_U16E"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19af57a753522c97be5ca3dbfd4d90ee0a2"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_U16</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t12NVS_TYPE_U16E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type uint16_t </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t12NVS_TYPE_I16E">
<span id="_CPPv3N10nvs_type_t12NVS_TYPE_I16E"></span><span id="_CPPv2N10nvs_type_t12NVS_TYPE_I16E"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19acbb42175aac1f46510597c52f7eadf67"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_I16</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t12NVS_TYPE_I16E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type int16_t </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t12NVS_TYPE_U32E">
<span id="_CPPv3N10nvs_type_t12NVS_TYPE_U32E"></span><span id="_CPPv2N10nvs_type_t12NVS_TYPE_U32E"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19ae3f5df4fc9c206ab0a4311c40bcb07fd"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_U32</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t12NVS_TYPE_U32E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type uint32_t </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t12NVS_TYPE_I32E">
<span id="_CPPv3N10nvs_type_t12NVS_TYPE_I32E"></span><span id="_CPPv2N10nvs_type_t12NVS_TYPE_I32E"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a03285d076b980e0a1d125ea9150ed552"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_I32</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t12NVS_TYPE_I32E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type int32_t </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t12NVS_TYPE_U64E">
<span id="_CPPv3N10nvs_type_t12NVS_TYPE_U64E"></span><span id="_CPPv2N10nvs_type_t12NVS_TYPE_U64E"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a0b95e503d55dbf29342ac491d7e66956"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_U64</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t12NVS_TYPE_U64E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type uint64_t </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t12NVS_TYPE_I64E">
<span id="_CPPv3N10nvs_type_t12NVS_TYPE_I64E"></span><span id="_CPPv2N10nvs_type_t12NVS_TYPE_I64E"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19ad2a38ac131962fdb89d8407795ee44aa"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_I64</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t12NVS_TYPE_I64E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type int64_t </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t12NVS_TYPE_STRE">
<span id="_CPPv3N10nvs_type_t12NVS_TYPE_STRE"></span><span id="_CPPv2N10nvs_type_t12NVS_TYPE_STRE"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a2d4edb61489d985af5b358634e81dacc"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_STR</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t12NVS_TYPE_STRE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type string </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t13NVS_TYPE_BLOBE">
<span id="_CPPv3N10nvs_type_t13NVS_TYPE_BLOBE"></span><span id="_CPPv2N10nvs_type_t13NVS_TYPE_BLOBE"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19ada2916eec53ebf6fd7b00de6b9037c16"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_BLOB</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t13NVS_TYPE_BLOBE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type blob </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10nvs_type_t12NVS_TYPE_ANYE">
<span id="_CPPv3N10nvs_type_t12NVS_TYPE_ANYE"></span><span id="_CPPv2N10nvs_type_t12NVS_TYPE_ANYE"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a3cec9452563a30fb500a17e77c3dc257"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVS_TYPE_ANY</span></span></span><a class="headerlink" href="#_CPPv4N10nvs_type_t12NVS_TYPE_ANYE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Must be last </p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Non-Volatile Storage Library (api-reference/storage/nvs_flash)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Non-Volatile Storage Library (api-reference/storage/nvs_flash)&version=esp32 v5.4.2 (v5.4.2)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mass_mfg.html" class="btn btn-neutral float-left" title="Manufacturing Utility" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="nvs_bootloader.html" class="btn btn-neutral float-right" title="NVS Bootloader" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-v5.4.2.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>